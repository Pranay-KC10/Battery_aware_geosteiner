 % ./bb
 % Args:
DEBUG P1READ: Terminal 0 battery=100.00
DEBUG P1READ: Terminal 1 battery=80.00
DEBUG P1READ: Terminal 2 battery=96.00
DEBUG P1READ: Terminal 3 battery=100.00
DEBUG P1READ: Terminal 4 battery=94.00
DEBUG P1READ: Terminal 5 battery=85.50
DEBUG P1READ: Terminal 6 battery=100.00
DEBUG P1READ: Terminal 7 battery=100.00
DEBUG P1READ: Terminal 8 battery=100.00
DEBUG P1READ: Terminal 9 battery=100.00
DEBUG P1READ: Terminal 10 battery=88.20
DEBUG P1READ: Terminal 11 battery=44.70
DEBUG P1READ: Terminal 12 battery=100.00
DEBUG P1READ: Terminal 13 battery=97.90
DEBUG P1READ: Terminal 14 battery=58.30
DEBUG P1READ: Terminal 15 battery=100.00
DEBUG P1READ: Terminal 16 battery=66.00
DEBUG P1READ: Terminal 17 battery=100.00
DEBUG P1READ: Terminal 18 battery=100.00
DEBUG P1READ: Terminal 19 battery=100.00
DEBUG HG: num_verts=20, num_edges=40
 % Phase 1: 0.00 seconds

%%BeginSetup

0 1 0 1 SetAxes

20 DefineTerminals
	.4588350000000000	.2373240000000000	DT
	.1270640000000000	.3509960000000000	DT
	.1544540000000000	.4808220000000000	DT
	.9474030000000000	.1441120000000000	DT
	.2867390000000000	.0565890000000000	DT
	.1326890000000000	.1166050000000000	DT
	.6273950000000000	.2122140000000000	DT
	.0794880000000000	.7970990000000000	DT
	.0327480000000000	.8803250000000000	DT
	.3110550000000000	.8689670000000000	DT
	.0916180000000000	.0221720000000000	DT
	.3600710000000000	.6382240000000000	DT
	.7197120000000000	.7181670000000000	DT
	.4424420000000000	.1450340000000000	DT
	.9983770000000000	.5729870000000000	DT
	.9654920000000000	.1935700000000000	DT
	.1600100000000000	.4187950000000000	DT
	.2909450000000000	.9620800000000000	DT
	.3330000000000000	.9414120000000000	DT
	.9512590000000000	.5074670000000000	DT

%%EndSetup

DEBUG ALGO: num_verts=20 <= 8? NO, num_edges=40 <= 12? NO
DEBUG ALGO: Forcing BRANCH-AND-CUT for multi-objective optimization (vertices=20 > 1)
DEBUG SPANNING: Adding modified spanning constraint for budget mode
DEBUG SPANNING: Added modified spanning constraint: Σ(|FST|-1)*x + Σnot_covered = 19
DEBUG CONSTRAINT: Adding soft cutset constraints with not_covered variables
DEBUG CONSTRAINT: Added constraint x[2] + not_covered[0] ≤ 1 for terminal 0
DEBUG CONSTRAINT: Added constraint x[27] + not_covered[0] ≤ 1 for terminal 0
DEBUG CONSTRAINT: Added constraint x[31] + not_covered[0] ≤ 1 for terminal 0
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 3·not_covered[0] ≤ 3 for terminal 0
DEBUG CONSTRAINT: Added constraint x[0] + not_covered[1] ≤ 1 for terminal 1
DEBUG CONSTRAINT: Added constraint x[24] + not_covered[1] ≤ 1 for terminal 1
DEBUG CONSTRAINT: Added constraint x[33] + not_covered[1] ≤ 1 for terminal 1
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 3·not_covered[1] ≤ 3 for terminal 1
DEBUG CONSTRAINT: Added constraint x[5] + not_covered[2] ≤ 1 for terminal 2
DEBUG CONSTRAINT: Added constraint x[7] + not_covered[2] ≤ 1 for terminal 2
DEBUG CONSTRAINT: Added constraint x[16] + not_covered[2] ≤ 1 for terminal 2
DEBUG CONSTRAINT: Added constraint x[23] + not_covered[2] ≤ 1 for terminal 2
DEBUG CONSTRAINT: Added constraint x[36] + not_covered[2] ≤ 1 for terminal 2
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 5·not_covered[2] ≤ 5 for terminal 2
DEBUG CONSTRAINT: Added constraint x[3] + not_covered[3] ≤ 1 for terminal 3
DEBUG CONSTRAINT: Added constraint x[4] + not_covered[3] ≤ 1 for terminal 3
DEBUG CONSTRAINT: Added constraint x[17] + not_covered[3] ≤ 1 for terminal 3
DEBUG CONSTRAINT: Added constraint x[20] + not_covered[3] ≤ 1 for terminal 3
DEBUG CONSTRAINT: Added constraint x[22] + not_covered[3] ≤ 1 for terminal 3
DEBUG CONSTRAINT: Added constraint x[39] + not_covered[3] ≤ 1 for terminal 3
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 6·not_covered[3] ≤ 6 for terminal 3
DEBUG CONSTRAINT: Added constraint x[0] + not_covered[4] ≤ 1 for terminal 4
DEBUG CONSTRAINT: Added constraint x[1] + not_covered[4] ≤ 1 for terminal 4
DEBUG CONSTRAINT: Added constraint x[30] + not_covered[4] ≤ 1 for terminal 4
DEBUG CONSTRAINT: Added constraint x[32] + not_covered[4] ≤ 1 for terminal 4
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 4·not_covered[4] ≤ 4 for terminal 4
DEBUG CONSTRAINT: Added constraint x[0] + not_covered[5] ≤ 1 for terminal 5
DEBUG CONSTRAINT: Added constraint x[1] + not_covered[5] ≤ 1 for terminal 5
DEBUG CONSTRAINT: Added constraint x[29] + not_covered[5] ≤ 1 for terminal 5
DEBUG CONSTRAINT: Added constraint x[30] + not_covered[5] ≤ 1 for terminal 5
DEBUG CONSTRAINT: Added constraint x[33] + not_covered[5] ≤ 1 for terminal 5
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 5·not_covered[5] ≤ 5 for terminal 5
DEBUG CONSTRAINT: Added constraint x[2] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[3] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[4] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[11] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[17] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[18] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[20] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[31] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[39] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 9·not_covered[6] ≤ 9 for terminal 6
DEBUG CONSTRAINT: Added constraint x[5] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[6] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[8] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[13] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[14] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[15] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[16] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[19] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[28] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[35] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 10·not_covered[7] ≤ 10 for terminal 7
DEBUG CONSTRAINT: Added constraint x[6] + not_covered[8] ≤ 1 for terminal 8
DEBUG CONSTRAINT: Added constraint x[13] + not_covered[8] ≤ 1 for terminal 8
DEBUG CONSTRAINT: Added constraint x[14] + not_covered[8] ≤ 1 for terminal 8
DEBUG CONSTRAINT: Added constraint x[19] + not_covered[8] ≤ 1 for terminal 8
DEBUG CONSTRAINT: Added constraint x[28] + not_covered[8] ≤ 1 for terminal 8
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 5·not_covered[8] ≤ 5 for terminal 8
DEBUG CONSTRAINT: Added constraint x[6] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[7] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[8] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[9] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[12] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[13] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[14] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[15] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[16] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[19] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[25] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[34] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[35] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 13·not_covered[9] ≤ 13 for terminal 9
DEBUG CONSTRAINT: Added constraint x[1] + not_covered[10] ≤ 1 for terminal 10
DEBUG CONSTRAINT: Added constraint x[29] + not_covered[10] ≤ 1 for terminal 10
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 2·not_covered[10] ≤ 2 for terminal 10
DEBUG CONSTRAINT: Added constraint x[5] + not_covered[11] ≤ 1 for terminal 11
DEBUG CONSTRAINT: Added constraint x[7] + not_covered[11] ≤ 1 for terminal 11
DEBUG CONSTRAINT: Added constraint x[8] + not_covered[11] ≤ 1 for terminal 11
DEBUG CONSTRAINT: Added constraint x[9] + not_covered[11] ≤ 1 for terminal 11
DEBUG CONSTRAINT: Added constraint x[13] + not_covered[11] ≤ 1 for terminal 11
DEBUG CONSTRAINT: Added constraint x[16] + not_covered[11] ≤ 1 for terminal 11
DEBUG CONSTRAINT: Added constraint x[34] + not_covered[11] ≤ 1 for terminal 11
DEBUG CONSTRAINT: Added constraint x[36] + not_covered[11] ≤ 1 for terminal 11
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 8·not_covered[11] ≤ 8 for terminal 11
DEBUG CONSTRAINT: Added constraint x[9] + not_covered[12] ≤ 1 for terminal 12
DEBUG CONSTRAINT: Added constraint x[10] + not_covered[12] ≤ 1 for terminal 12
DEBUG CONSTRAINT: Added constraint x[18] + not_covered[12] ≤ 1 for terminal 12
DEBUG CONSTRAINT: Added constraint x[20] + not_covered[12] ≤ 1 for terminal 12
DEBUG CONSTRAINT: Added constraint x[37] + not_covered[12] ≤ 1 for terminal 12
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 5·not_covered[12] ≤ 5 for terminal 12
DEBUG CONSTRAINT: Added constraint x[2] + not_covered[13] ≤ 1 for terminal 13
DEBUG CONSTRAINT: Added constraint x[27] + not_covered[13] ≤ 1 for terminal 13
DEBUG CONSTRAINT: Added constraint x[32] + not_covered[13] ≤ 1 for terminal 13
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 3·not_covered[13] ≤ 3 for terminal 13
DEBUG CONSTRAINT: Added constraint x[10] + not_covered[14] ≤ 1 for terminal 14
DEBUG CONSTRAINT: Added constraint x[26] + not_covered[14] ≤ 1 for terminal 14
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 2·not_covered[14] ≤ 2 for terminal 14
DEBUG CONSTRAINT: Added constraint x[3] + not_covered[15] ≤ 1 for terminal 15
DEBUG CONSTRAINT: Added constraint x[11] + not_covered[15] ≤ 1 for terminal 15
DEBUG CONSTRAINT: Added constraint x[17] + not_covered[15] ≤ 1 for terminal 15
DEBUG CONSTRAINT: Added constraint x[18] + not_covered[15] ≤ 1 for terminal 15
DEBUG CONSTRAINT: Added constraint x[20] + not_covered[15] ≤ 1 for terminal 15
DEBUG CONSTRAINT: Added constraint x[22] + not_covered[15] ≤ 1 for terminal 15
DEBUG CONSTRAINT: Added constraint x[38] + not_covered[15] ≤ 1 for terminal 15
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 7·not_covered[15] ≤ 7 for terminal 15
DEBUG CONSTRAINT: Added constraint x[23] + not_covered[16] ≤ 1 for terminal 16
DEBUG CONSTRAINT: Added constraint x[24] + not_covered[16] ≤ 1 for terminal 16
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 2·not_covered[16] ≤ 2 for terminal 16
DEBUG CONSTRAINT: Added constraint x[12] + not_covered[17] ≤ 1 for terminal 17
DEBUG CONSTRAINT: Added constraint x[15] + not_covered[17] ≤ 1 for terminal 17
DEBUG CONSTRAINT: Added constraint x[19] + not_covered[17] ≤ 1 for terminal 17
DEBUG CONSTRAINT: Added constraint x[21] + not_covered[17] ≤ 1 for terminal 17
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 4·not_covered[17] ≤ 4 for terminal 17
DEBUG CONSTRAINT: Added constraint x[12] + not_covered[18] ≤ 1 for terminal 18
DEBUG CONSTRAINT: Added constraint x[14] + not_covered[18] ≤ 1 for terminal 18
DEBUG CONSTRAINT: Added constraint x[15] + not_covered[18] ≤ 1 for terminal 18
DEBUG CONSTRAINT: Added constraint x[19] + not_covered[18] ≤ 1 for terminal 18
DEBUG CONSTRAINT: Added constraint x[21] + not_covered[18] ≤ 1 for terminal 18
DEBUG CONSTRAINT: Added constraint x[25] + not_covered[18] ≤ 1 for terminal 18
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 6·not_covered[18] ≤ 6 for terminal 18
DEBUG CONSTRAINT: Added constraint x[4] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint x[10] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint x[11] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint x[17] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint x[18] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint x[20] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint x[26] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint x[37] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint x[38] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 9·not_covered[19] ≤ 9 for terminal 19
DEBUG CONSTRAINT: Added source terminal constraint: not_covered[0] = 0
DEBUG BUDGET: Adding budget constraint ≤ 1800000.000 to constraint pool
DEBUG BUDGET: Using raw tree costs directly
DEBUG BUDGET: Budget limit: 1800000.000
DEBUG BUDGET: Building raw cost constraint coefficients:
DEBUG BUDGET:   x[0] coefficient = 398991 (raw=398991.100)
DEBUG BUDGET:   x[1] coefficient = 260889 (raw=260889.712)
DEBUG BUDGET:   x[2] coefficient = 256773 (raw=256773.057)
DEBUG BUDGET:   x[3] coefficient = 376541 (raw=376541.557)
DEBUG BUDGET:   x[4] coefficient = 646084 (raw=646084.462)
DEBUG BUDGET:   x[5] coefficient = 520973 (raw=520973.020)
DEBUG BUDGET:   x[6] coefficient = 334575 (raw=334575.182)
DEBUG BUDGET:   x[7] coefficient = 494448 (raw=494448.457)
DEBUG BUDGET:   x[8] coefficient = 455905 (raw=455905.519)
DEBUG BUDGET:   x[9] coefficient = 584020 (raw=584020.499)
DEBUG BUDGET:   x[10] coefficient = 380918 (raw=380918.244)
DEBUG BUDGET:   x[11] coefficient = 621357 (raw=621357.781)
DEBUG BUDGET:   x[12] coefficient = 120675 (raw=120675.719)
DEBUG BUDGET:   x[13] coefficient = 551354 (raw=551354.477)
DEBUG BUDGET:   x[14] coefficient = 410262 (raw=410262.679)
DEBUG BUDGET:   x[15] coefficient = 362962 (raw=362962.653)
DEBUG BUDGET:   x[16] coefficient = 702244 (raw=702244.403)
DEBUG BUDGET:   x[17] coefficient = 673894 (raw=673894.542)
DEBUG BUDGET:   x[18] coefficient = 933994 (raw=933994.022)
DEBUG BUDGET:   x[19] coefficient = 454199 (raw=454199.906)
DEBUG BUDGET:   x[20] coefficient = 986439 (raw=986439.144)
DEBUG BUDGET:   x[21] coefficient = 46859 (raw=46859.249)
DEBUG BUDGET:   x[22] coefficient = 52662 (raw=52662.185)
DEBUG BUDGET:   x[23] coefficient = 62275 (raw=62275.339)
DEBUG BUDGET:   x[24] coefficient = 75379 (raw=75379.993)
DEBUG BUDGET:   x[25] coefficient = 75695 (raw=75695.846)
DEBUG BUDGET:   x[26] coefficient = 80703 (raw=80703.013)
DEBUG BUDGET:   x[27] coefficient = 93734 (raw=93734.596)
DEBUG BUDGET:   x[28] coefficient = 95452 (raw=95452.578)
DEBUG BUDGET:   x[29] coefficient = 102977 (raw=102977.757)
DEBUG BUDGET:   x[30] coefficient = 165327 (raw=165327.925)
DEBUG BUDGET:   x[31] coefficient = 170420 (raw=170420.027)
DEBUG BUDGET:   x[32] coefficient = 179069 (raw=179069.657)
DEBUG BUDGET:   x[33] coefficient = 234458 (raw=234458.486)
DEBUG BUDGET:   x[34] coefficient = 235891 (raw=235891.713)
DEBUG BUDGET:   x[35] coefficient = 242462 (raw=242462.956)
DEBUG BUDGET:   x[36] coefficient = 258947 (raw=258947.370)
DEBUG BUDGET:   x[37] coefficient = 313063 (raw=313063.098)
DEBUG BUDGET:   x[38] coefficient = 314219 (raw=314219.517)
DEBUG BUDGET:   x[39] coefficient = 327174 (raw=327174.269)
DEBUG BUDGET: Constraint: Σ tree_cost[i] * x[i] ≤ 1800000
DEBUG BUDGET: Budget constraint added to pool with 40 FSTs
DEBUG CONSTRAINT: Adding 'at least one FST' constraint: Σ x[i] ≥ 1
DEBUG CONSTRAINT: Added 'at least one FST' constraint: Σ x[i] ≥ 1
 % _gst_initialize_constraint_pool: 0.00 seconds.
 % Constraint pool initialized with:
 % 	1	Total degree rows	40	coeffs.
 % 	20	Cutset rows		111	coeffs.
 % 	0	Incompatibility rows	0	coeffs.
 % 	29	2-terminal SEC rows	102	coeffs.
 % 	1	At least one FST rows	40	coeffs.
 % 	163	Total rows in pool	135	in LP
 % @PMEM 163 rows, 1 blocks, 415 nzfree, 0 nzwasted, 1172 nztotal
DEBUG SOFT: Found 20 terminals, 40 FSTs
DEBUG SOFT: Adding space for 20 not_covered variables in soft constraints, total ncoeff=514
DEBUG LP_SETUP: Created LP with 0 rows, 60 columns (nedges=40 + nterms=20)
DEBUG SOFT: Set bounds for 40 FST vars [1-40] and 20 coverage vars [41-60]
DEBUG OBJ: Using raw costs - alpha=10000.0 (battery weight), beta=1500000 (coverage penalty)
DEBUG OBJ: Allocated rowvec[0-60] for ncols=60 LP variables
DEBUG OBJ: Full_trees battery_score=0.000 for FST 0
DEBUG OBJ: Recalculating for FST 0 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 5): battery=85.50, running_total=85.50
DEBUG OBJ: Terminal 1 (idx 1): battery=80.00, running_total=165.50
DEBUG OBJ: Terminal 2 (idx 4): battery=94.00, running_total=259.50
DEBUG OBJ: Recalculated battery_score=259.500 for FST 0
DEBUG OBJ: FST 0: tree_cost=398991.100, battery_cost=259.500 (weighted=2595000.0), combined=2993991.1
DEBUG OBJ: Full_trees battery_score=0.000 for FST 1
DEBUG OBJ: Recalculating for FST 1 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 10): battery=88.20, running_total=88.20
DEBUG OBJ: Terminal 1 (idx 5): battery=85.50, running_total=173.70
DEBUG OBJ: Terminal 2 (idx 4): battery=94.00, running_total=267.70
DEBUG OBJ: Recalculated battery_score=267.700 for FST 1
DEBUG OBJ: FST 1: tree_cost=260889.712, battery_cost=267.700 (weighted=2677000.0), combined=2937889.7
DEBUG OBJ: Full_trees battery_score=0.000 for FST 2
DEBUG OBJ: Recalculating for FST 2 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 13): battery=97.90, running_total=97.90
DEBUG OBJ: Terminal 1 (idx 0): battery=100.00, running_total=197.90
DEBUG OBJ: Terminal 2 (idx 6): battery=100.00, running_total=297.90
DEBUG OBJ: Recalculated battery_score=297.900 for FST 2
DEBUG OBJ: FST 2: tree_cost=256773.057, battery_cost=297.900 (weighted=2979000.0), combined=3235773.1
DEBUG OBJ: Full_trees battery_score=0.000 for FST 3
DEBUG OBJ: Recalculating for FST 3 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 15): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 3): battery=100.00, running_total=200.00
DEBUG OBJ: Terminal 2 (idx 6): battery=100.00, running_total=300.00
DEBUG OBJ: Recalculated battery_score=300.000 for FST 3
DEBUG OBJ: FST 3: tree_cost=376541.557, battery_cost=300.000 (weighted=3000000.0), combined=3376541.6
DEBUG OBJ: Full_trees battery_score=0.000 for FST 4
DEBUG OBJ: Recalculating for FST 4 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 19): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 3): battery=100.00, running_total=200.00
DEBUG OBJ: Terminal 2 (idx 6): battery=100.00, running_total=300.00
DEBUG OBJ: Recalculated battery_score=300.000 for FST 4
DEBUG OBJ: FST 4: tree_cost=646084.462, battery_cost=300.000 (weighted=3000000.0), combined=3646084.5
DEBUG OBJ: Full_trees battery_score=0.000 for FST 5
DEBUG OBJ: Recalculating for FST 5 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 11): battery=44.70, running_total=44.70
DEBUG OBJ: Terminal 1 (idx 2): battery=96.00, running_total=140.70
DEBUG OBJ: Terminal 2 (idx 7): battery=100.00, running_total=240.70
DEBUG OBJ: Recalculated battery_score=240.700 for FST 5
DEBUG OBJ: FST 5: tree_cost=520973.020, battery_cost=240.700 (weighted=2407000.0), combined=2927973.0
DEBUG OBJ: Full_trees battery_score=0.000 for FST 6
DEBUG OBJ: Recalculating for FST 6 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 9): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 7): battery=100.00, running_total=200.00
DEBUG OBJ: Terminal 2 (idx 8): battery=100.00, running_total=300.00
DEBUG OBJ: Recalculated battery_score=300.000 for FST 6
DEBUG OBJ: FST 6: tree_cost=334575.182, battery_cost=300.000 (weighted=3000000.0), combined=3334575.2
DEBUG OBJ: Full_trees battery_score=0.000 for FST 7
DEBUG OBJ: Recalculating for FST 7 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 11): battery=44.70, running_total=44.70
DEBUG OBJ: Terminal 1 (idx 2): battery=96.00, running_total=140.70
DEBUG OBJ: Terminal 2 (idx 9): battery=100.00, running_total=240.70
DEBUG OBJ: Recalculated battery_score=240.700 for FST 7
DEBUG OBJ: FST 7: tree_cost=494448.457, battery_cost=240.700 (weighted=2407000.0), combined=2901448.5
DEBUG OBJ: Full_trees battery_score=0.000 for FST 8
DEBUG OBJ: Recalculating for FST 8 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 11): battery=44.70, running_total=44.70
DEBUG OBJ: Terminal 1 (idx 7): battery=100.00, running_total=144.70
DEBUG OBJ: Terminal 2 (idx 9): battery=100.00, running_total=244.70
DEBUG OBJ: Recalculated battery_score=244.700 for FST 8
DEBUG OBJ: FST 8: tree_cost=455905.519, battery_cost=244.700 (weighted=2447000.0), combined=2902905.5
DEBUG OBJ: Full_trees battery_score=0.000 for FST 9
DEBUG OBJ: Recalculating for FST 9 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 12): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 11): battery=44.70, running_total=144.70
DEBUG OBJ: Terminal 2 (idx 9): battery=100.00, running_total=244.70
DEBUG OBJ: Recalculated battery_score=244.700 for FST 9
DEBUG OBJ: FST 9: tree_cost=584020.499, battery_cost=244.700 (weighted=2447000.0), combined=3031020.5
DEBUG OBJ: Full_trees battery_score=0.000 for FST 10
DEBUG OBJ: Recalculating for FST 10 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 19): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 12): battery=100.00, running_total=200.00
DEBUG OBJ: Terminal 2 (idx 14): battery=58.30, running_total=258.30
DEBUG OBJ: Recalculated battery_score=258.300 for FST 10
DEBUG OBJ: FST 10: tree_cost=380918.244, battery_cost=258.300 (weighted=2583000.0), combined=2963918.2
DEBUG OBJ: Full_trees battery_score=0.000 for FST 11
DEBUG OBJ: Recalculating for FST 11 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 19): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 15): battery=100.00, running_total=200.00
DEBUG OBJ: Terminal 2 (idx 6): battery=100.00, running_total=300.00
DEBUG OBJ: Recalculated battery_score=300.000 for FST 11
DEBUG OBJ: FST 11: tree_cost=621357.781, battery_cost=300.000 (weighted=3000000.0), combined=3621357.8
DEBUG OBJ: Full_trees battery_score=0.000 for FST 12
DEBUG OBJ: Recalculating for FST 12 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 18): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 9): battery=100.00, running_total=200.00
DEBUG OBJ: Terminal 2 (idx 17): battery=100.00, running_total=300.00
DEBUG OBJ: Recalculated battery_score=300.000 for FST 12
DEBUG OBJ: FST 12: tree_cost=120675.719, battery_cost=300.000 (weighted=3000000.0), combined=3120675.7
DEBUG OBJ: Full_trees battery_score=0.000 for FST 13
DEBUG OBJ: Recalculating for FST 13 with 4 terminals
DEBUG OBJ: Terminal 0 (idx 11): battery=44.70, running_total=44.70
DEBUG OBJ: Terminal 1 (idx 7): battery=100.00, running_total=144.70
DEBUG OBJ: Terminal 2 (idx 8): battery=100.00, running_total=244.70
DEBUG OBJ: Terminal 3 (idx 9): battery=100.00, running_total=344.70
DEBUG OBJ: Recalculated battery_score=344.700 for FST 13
DEBUG OBJ: FST 13: tree_cost=551354.477, battery_cost=344.700 (weighted=3447000.0), combined=3998354.5
DEBUG OBJ: Full_trees battery_score=0.000 for FST 14
DEBUG OBJ: Recalculating for FST 14 with 4 terminals
DEBUG OBJ: Terminal 0 (idx 18): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 9): battery=100.00, running_total=200.00
DEBUG OBJ: Terminal 2 (idx 7): battery=100.00, running_total=300.00
DEBUG OBJ: Terminal 3 (idx 8): battery=100.00, running_total=400.00
DEBUG OBJ: Recalculated battery_score=400.000 for FST 14
DEBUG OBJ: FST 14: tree_cost=410262.679, battery_cost=400.000 (weighted=4000000.0), combined=4410262.7
DEBUG OBJ: Full_trees battery_score=0.000 for FST 15
DEBUG OBJ: Recalculating for FST 15 with 4 terminals
DEBUG OBJ: Terminal 0 (idx 18): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 9): battery=100.00, running_total=200.00
DEBUG OBJ: Terminal 2 (idx 7): battery=100.00, running_total=300.00
DEBUG OBJ: Terminal 3 (idx 17): battery=100.00, running_total=400.00
DEBUG OBJ: Recalculated battery_score=400.000 for FST 15
DEBUG OBJ: FST 15: tree_cost=362962.653, battery_cost=400.000 (weighted=4000000.0), combined=4362962.7
DEBUG OBJ: Full_trees battery_score=0.000 for FST 16
DEBUG OBJ: Recalculating for FST 16 with 4 terminals
DEBUG OBJ: Terminal 0 (idx 11): battery=44.70, running_total=44.70
DEBUG OBJ: Terminal 1 (idx 2): battery=96.00, running_total=140.70
DEBUG OBJ: Terminal 2 (idx 7): battery=100.00, running_total=240.70
DEBUG OBJ: Terminal 3 (idx 9): battery=100.00, running_total=340.70
DEBUG OBJ: Recalculated battery_score=340.700 for FST 16
DEBUG OBJ: FST 16: tree_cost=702244.403, battery_cost=340.700 (weighted=3407000.0), combined=4109244.4
DEBUG OBJ: Full_trees battery_score=0.000 for FST 17
DEBUG OBJ: Recalculating for FST 17 with 4 terminals
DEBUG OBJ: Terminal 0 (idx 19): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 15): battery=100.00, running_total=200.00
DEBUG OBJ: Terminal 2 (idx 3): battery=100.00, running_total=300.00
DEBUG OBJ: Terminal 3 (idx 6): battery=100.00, running_total=400.00
DEBUG OBJ: Recalculated battery_score=400.000 for FST 17
DEBUG OBJ: FST 17: tree_cost=673894.542, battery_cost=400.000 (weighted=4000000.0), combined=4673894.5
DEBUG OBJ: Full_trees battery_score=0.000 for FST 18
DEBUG OBJ: Recalculating for FST 18 with 4 terminals
DEBUG OBJ: Terminal 0 (idx 19): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 15): battery=100.00, running_total=200.00
DEBUG OBJ: Terminal 2 (idx 6): battery=100.00, running_total=300.00
DEBUG OBJ: Terminal 3 (idx 12): battery=100.00, running_total=400.00
DEBUG OBJ: Recalculated battery_score=400.000 for FST 18
DEBUG OBJ: FST 18: tree_cost=933994.022, battery_cost=400.000 (weighted=4000000.0), combined=4933994.0
DEBUG OBJ: Full_trees battery_score=0.000 for FST 19
DEBUG OBJ: Recalculating for FST 19 with 5 terminals
DEBUG OBJ: Terminal 0 (idx 18): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 9): battery=100.00, running_total=200.00
DEBUG OBJ: Terminal 2 (idx 7): battery=100.00, running_total=300.00
DEBUG OBJ: Terminal 3 (idx 8): battery=100.00, running_total=400.00
DEBUG OBJ: Terminal 4 (idx 17): battery=100.00, running_total=500.00
DEBUG OBJ: Recalculated battery_score=500.000 for FST 19
DEBUG OBJ: FST 19: tree_cost=454199.906, battery_cost=500.000 (weighted=5000000.0), combined=5454199.9
DEBUG OBJ: Full_trees battery_score=0.000 for FST 20
DEBUG OBJ: Recalculating for FST 20 with 5 terminals
DEBUG OBJ: Terminal 0 (idx 19): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 15): battery=100.00, running_total=200.00
DEBUG OBJ: Terminal 2 (idx 3): battery=100.00, running_total=300.00
DEBUG OBJ: Terminal 3 (idx 6): battery=100.00, running_total=400.00
DEBUG OBJ: Terminal 4 (idx 12): battery=100.00, running_total=500.00
DEBUG OBJ: Recalculated battery_score=500.000 for FST 20
DEBUG OBJ: FST 20: tree_cost=986439.144, battery_cost=500.000 (weighted=5000000.0), combined=5986439.1
DEBUG OBJ: Full_trees battery_score=0.000 for FST 21
DEBUG OBJ: Recalculating for FST 21 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 18): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 17): battery=100.00, running_total=200.00
DEBUG OBJ: Recalculated battery_score=200.000 for FST 21
DEBUG OBJ: FST 21: tree_cost=46859.249, battery_cost=200.000 (weighted=2000000.0), combined=2046859.2
DEBUG OBJ: Full_trees battery_score=0.000 for FST 22
DEBUG OBJ: Recalculating for FST 22 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 15): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 3): battery=100.00, running_total=200.00
DEBUG OBJ: Recalculated battery_score=200.000 for FST 22
DEBUG OBJ: FST 22: tree_cost=52662.185, battery_cost=200.000 (weighted=2000000.0), combined=2052662.2
DEBUG OBJ: Full_trees battery_score=0.000 for FST 23
DEBUG OBJ: Recalculating for FST 23 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 16): battery=66.00, running_total=66.00
DEBUG OBJ: Terminal 1 (idx 2): battery=96.00, running_total=162.00
DEBUG OBJ: Recalculated battery_score=162.000 for FST 23
DEBUG OBJ: FST 23: tree_cost=62275.339, battery_cost=162.000 (weighted=1620000.0), combined=1682275.3
DEBUG OBJ: Full_trees battery_score=0.000 for FST 24
DEBUG OBJ: Recalculating for FST 24 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 16): battery=66.00, running_total=66.00
DEBUG OBJ: Terminal 1 (idx 1): battery=80.00, running_total=146.00
DEBUG OBJ: Recalculated battery_score=146.000 for FST 24
DEBUG OBJ: FST 24: tree_cost=75379.993, battery_cost=146.000 (weighted=1460000.0), combined=1535380.0
DEBUG OBJ: Full_trees battery_score=0.000 for FST 25
DEBUG OBJ: Recalculating for FST 25 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 18): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 9): battery=100.00, running_total=200.00
DEBUG OBJ: Recalculated battery_score=200.000 for FST 25
DEBUG OBJ: FST 25: tree_cost=75695.846, battery_cost=200.000 (weighted=2000000.0), combined=2075695.8
DEBUG OBJ: Full_trees battery_score=0.000 for FST 26
DEBUG OBJ: Recalculating for FST 26 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 14): battery=58.30, running_total=58.30
DEBUG OBJ: Terminal 1 (idx 19): battery=100.00, running_total=158.30
DEBUG OBJ: Recalculated battery_score=158.300 for FST 26
DEBUG OBJ: FST 26: tree_cost=80703.013, battery_cost=158.300 (weighted=1583000.0), combined=1663703.0
DEBUG OBJ: Full_trees battery_score=0.000 for FST 27
DEBUG OBJ: Recalculating for FST 27 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 0): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 13): battery=97.90, running_total=197.90
DEBUG OBJ: Recalculated battery_score=197.900 for FST 27
DEBUG OBJ: FST 27: tree_cost=93734.596, battery_cost=197.900 (weighted=1979000.0), combined=2072734.6
DEBUG OBJ: Full_trees battery_score=0.000 for FST 28
DEBUG OBJ: Recalculating for FST 28 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 8): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 7): battery=100.00, running_total=200.00
DEBUG OBJ: Recalculated battery_score=200.000 for FST 28
DEBUG OBJ: FST 28: tree_cost=95452.578, battery_cost=200.000 (weighted=2000000.0), combined=2095452.6
DEBUG OBJ: Full_trees battery_score=0.000 for FST 29
DEBUG OBJ: Recalculating for FST 29 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 5): battery=85.50, running_total=85.50
DEBUG OBJ: Terminal 1 (idx 10): battery=88.20, running_total=173.70
DEBUG OBJ: Recalculated battery_score=173.700 for FST 29
DEBUG OBJ: FST 29: tree_cost=102977.757, battery_cost=173.700 (weighted=1737000.0), combined=1839977.8
DEBUG OBJ: Full_trees battery_score=0.000 for FST 30
DEBUG OBJ: Recalculating for FST 30 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 4): battery=94.00, running_total=94.00
DEBUG OBJ: Terminal 1 (idx 5): battery=85.50, running_total=179.50
DEBUG OBJ: Recalculated battery_score=179.500 for FST 30
DEBUG OBJ: FST 30: tree_cost=165327.925, battery_cost=179.500 (weighted=1795000.0), combined=1960327.9
DEBUG OBJ: Full_trees battery_score=0.000 for FST 31
DEBUG OBJ: Recalculating for FST 31 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 6): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 0): battery=100.00, running_total=200.00
DEBUG OBJ: Recalculated battery_score=200.000 for FST 31
DEBUG OBJ: FST 31: tree_cost=170420.027, battery_cost=200.000 (weighted=2000000.0), combined=2170420.0
DEBUG OBJ: Full_trees battery_score=0.000 for FST 32
DEBUG OBJ: Recalculating for FST 32 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 13): battery=97.90, running_total=97.90
DEBUG OBJ: Terminal 1 (idx 4): battery=94.00, running_total=191.90
DEBUG OBJ: Recalculated battery_score=191.900 for FST 32
DEBUG OBJ: FST 32: tree_cost=179069.657, battery_cost=191.900 (weighted=1919000.0), combined=2098069.7
DEBUG OBJ: Full_trees battery_score=0.000 for FST 33
DEBUG OBJ: Recalculating for FST 33 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 5): battery=85.50, running_total=85.50
DEBUG OBJ: Terminal 1 (idx 1): battery=80.00, running_total=165.50
DEBUG OBJ: Recalculated battery_score=165.500 for FST 33
DEBUG OBJ: FST 33: tree_cost=234458.486, battery_cost=165.500 (weighted=1655000.0), combined=1889458.5
DEBUG OBJ: Full_trees battery_score=0.000 for FST 34
DEBUG OBJ: Recalculating for FST 34 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 11): battery=44.70, running_total=44.70
DEBUG OBJ: Terminal 1 (idx 9): battery=100.00, running_total=144.70
DEBUG OBJ: Recalculated battery_score=144.700 for FST 34
DEBUG OBJ: FST 34: tree_cost=235891.713, battery_cost=144.700 (weighted=1447000.0), combined=1682891.7
DEBUG OBJ: Full_trees battery_score=0.000 for FST 35
DEBUG OBJ: Recalculating for FST 35 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 9): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 7): battery=100.00, running_total=200.00
DEBUG OBJ: Recalculated battery_score=200.000 for FST 35
DEBUG OBJ: FST 35: tree_cost=242462.956, battery_cost=200.000 (weighted=2000000.0), combined=2242463.0
DEBUG OBJ: Full_trees battery_score=0.000 for FST 36
DEBUG OBJ: Recalculating for FST 36 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 2): battery=96.00, running_total=96.00
DEBUG OBJ: Terminal 1 (idx 11): battery=44.70, running_total=140.70
DEBUG OBJ: Recalculated battery_score=140.700 for FST 36
DEBUG OBJ: FST 36: tree_cost=258947.370, battery_cost=140.700 (weighted=1407000.0), combined=1665947.4
DEBUG OBJ: Full_trees battery_score=0.000 for FST 37
DEBUG OBJ: Recalculating for FST 37 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 19): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 12): battery=100.00, running_total=200.00
DEBUG OBJ: Recalculated battery_score=200.000 for FST 37
DEBUG OBJ: FST 37: tree_cost=313063.098, battery_cost=200.000 (weighted=2000000.0), combined=2313063.1
DEBUG OBJ: Full_trees battery_score=0.000 for FST 38
DEBUG OBJ: Recalculating for FST 38 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 15): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 19): battery=100.00, running_total=200.00
DEBUG OBJ: Recalculated battery_score=200.000 for FST 38
DEBUG OBJ: FST 38: tree_cost=314219.517, battery_cost=200.000 (weighted=2000000.0), combined=2314219.5
DEBUG OBJ: Full_trees battery_score=0.000 for FST 39
DEBUG OBJ: Recalculating for FST 39 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 3): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 6): battery=100.00, running_total=200.00
DEBUG OBJ: Recalculated battery_score=200.000 for FST 39
DEBUG OBJ: FST 39: tree_cost=327174.269, battery_cost=200.000 (weighted=2000000.0), combined=2327174.3
DEBUG OBJ: Added penalty terms beta=1500000 for 20 not_covered variables [41-60]
DEBUG LP_MATRIX: LP has 0 rows, 60 columns after setup
DEBUG EXTRA_COEFF: Calculated extra_coeff=1 for 135 rows
DEBUG SOFT: Added not_covered_0 (RC_var 43 -> matrix_idx 40) to soft constraint 134
DEBUG MATRIX_CHECK: nzi=495, ncoeff=514, extra_coeff=1, expected=515
ERROR: Matrix coefficient count mismatch! nzi=495 != ncoeff=514 + extra_coeff=1
WARNING: Allowing discrepancy in budget mode (nzi=495 vs expected=515)
DEBUG MATRIX: Total matrix has 495 entries (nzi=495)
DEBUG MATRIX: matbeg[135] = 495 (should equal nzi)
DEBUG LP: Calling add_rows with 135 rows
DEBUG LP: Before add_rows: LP has 0 rows, 60 cols, 60 nonzeros
DEBUG LP: After add_rows: LP has 135 rows, 60 cols, 555 nonzeros
DEBUG NLPROWS: nrows=135, extra_rows=0, setting nlprows=135
 % _gst_build_initial_formulation: 0.00 seconds.
DEBUG BB: Expected nlprows=135, total rows=163
DEBUG BB: Row 0 (uid=0) has lprow=0 (included, j=0)
DEBUG BB: Row 1 (uid=1) has lprow=1 (included, j=1)
DEBUG BB: Row 2 (uid=2) has lprow=2 (included, j=2)
DEBUG BB: Row 3 (uid=3) has lprow=3 (included, j=3)
DEBUG BB: Row 4 (uid=4) has lprow=4 (included, j=4)
DEBUG BB: Row 5 (uid=5) has lprow=5 (included, j=5)
DEBUG BB: Row 6 (uid=6) has lprow=6 (included, j=6)
DEBUG BB: Row 7 (uid=7) has lprow=7 (included, j=7)
DEBUG BB: Row 8 (uid=8) has lprow=8 (included, j=8)
DEBUG BB: Row 9 (uid=9) has lprow=9 (included, j=9)
DEBUG BB: Row 10 (uid=10) has lprow=10 (included, j=10)
DEBUG BB: Row 11 (uid=11) has lprow=11 (included, j=11)
DEBUG BB: Row 12 (uid=12) has lprow=12 (included, j=12)
DEBUG BB: Row 13 (uid=13) has lprow=13 (included, j=13)
DEBUG BB: Row 14 (uid=14) has lprow=14 (included, j=14)
DEBUG BB: Row 15 (uid=15) has lprow=15 (included, j=15)
DEBUG BB: Row 16 (uid=16) has lprow=16 (included, j=16)
DEBUG BB: Row 17 (uid=17) has lprow=17 (included, j=17)
DEBUG BB: Row 18 (uid=18) has lprow=18 (included, j=18)
DEBUG BB: Row 19 (uid=19) has lprow=19 (included, j=19)
DEBUG BB: Row 20 (uid=20) has lprow=20 (included, j=20)
DEBUG BB: Row 21 (uid=21) has lprow=21 (included, j=21)
DEBUG BB: Row 22 (uid=22) has lprow=22 (included, j=22)
DEBUG BB: Row 23 (uid=23) has lprow=23 (included, j=23)
DEBUG BB: Row 24 (uid=24) has lprow=24 (included, j=24)
DEBUG BB: Row 25 (uid=25) has lprow=25 (included, j=25)
DEBUG BB: Row 26 (uid=26) has lprow=26 (included, j=26)
DEBUG BB: Row 27 (uid=27) has lprow=27 (included, j=27)
DEBUG BB: Row 28 (uid=28) has lprow=28 (included, j=28)
DEBUG BB: Row 29 (uid=29) has lprow=29 (included, j=29)
DEBUG BB: Row 30 (uid=30) has lprow=30 (included, j=30)
DEBUG BB: Row 31 (uid=31) has lprow=31 (included, j=31)
DEBUG BB: Row 32 (uid=32) has lprow=32 (included, j=32)
DEBUG BB: Row 33 (uid=33) has lprow=33 (included, j=33)
DEBUG BB: Row 34 (uid=34) has lprow=34 (included, j=34)
DEBUG BB: Row 35 (uid=35) has lprow=35 (included, j=35)
DEBUG BB: Row 36 (uid=36) has lprow=36 (included, j=36)
DEBUG BB: Row 37 (uid=37) has lprow=37 (included, j=37)
DEBUG BB: Row 38 (uid=38) has lprow=38 (included, j=38)
DEBUG BB: Row 39 (uid=39) has lprow=39 (included, j=39)
DEBUG BB: Row 40 (uid=40) has lprow=40 (included, j=40)
DEBUG BB: Row 41 (uid=41) has lprow=41 (included, j=41)
DEBUG BB: Row 42 (uid=42) has lprow=42 (included, j=42)
DEBUG BB: Row 43 (uid=43) has lprow=43 (included, j=43)
DEBUG BB: Row 44 (uid=44) has lprow=44 (included, j=44)
DEBUG BB: Row 45 (uid=45) has lprow=45 (included, j=45)
DEBUG BB: Row 46 (uid=46) has lprow=46 (included, j=46)
DEBUG BB: Row 47 (uid=47) has lprow=47 (included, j=47)
DEBUG BB: Row 48 (uid=48) has lprow=48 (included, j=48)
DEBUG BB: Row 49 (uid=49) has lprow=49 (included, j=49)
DEBUG BB: Row 50 (uid=50) has lprow=50 (included, j=50)
DEBUG BB: Row 51 (uid=51) has lprow=51 (included, j=51)
DEBUG BB: Row 52 (uid=52) has lprow=52 (included, j=52)
DEBUG BB: Row 53 (uid=53) has lprow=53 (included, j=53)
DEBUG BB: Row 54 (uid=54) has lprow=54 (included, j=54)
DEBUG BB: Row 55 (uid=55) has lprow=55 (included, j=55)
DEBUG BB: Row 56 (uid=56) has lprow=56 (included, j=56)
DEBUG BB: Row 57 (uid=57) has lprow=57 (included, j=57)
DEBUG BB: Row 58 (uid=58) has lprow=58 (included, j=58)
DEBUG BB: Row 59 (uid=59) has lprow=59 (included, j=59)
DEBUG BB: Row 60 (uid=60) has lprow=60 (included, j=60)
DEBUG BB: Row 61 (uid=61) has lprow=61 (included, j=61)
DEBUG BB: Row 62 (uid=62) has lprow=62 (included, j=62)
DEBUG BB: Row 63 (uid=63) has lprow=63 (included, j=63)
DEBUG BB: Row 64 (uid=64) has lprow=64 (included, j=64)
DEBUG BB: Row 65 (uid=65) has lprow=65 (included, j=65)
DEBUG BB: Row 66 (uid=66) has lprow=66 (included, j=66)
DEBUG BB: Row 67 (uid=67) has lprow=67 (included, j=67)
DEBUG BB: Row 68 (uid=68) has lprow=68 (included, j=68)
DEBUG BB: Row 69 (uid=69) has lprow=69 (included, j=69)
DEBUG BB: Row 70 (uid=70) has lprow=70 (included, j=70)
DEBUG BB: Row 71 (uid=71) has lprow=71 (included, j=71)
DEBUG BB: Row 72 (uid=72) has lprow=72 (included, j=72)
DEBUG BB: Row 73 (uid=73) has lprow=73 (included, j=73)
DEBUG BB: Row 74 (uid=74) has lprow=74 (included, j=74)
DEBUG BB: Row 75 (uid=75) has lprow=75 (included, j=75)
DEBUG BB: Row 76 (uid=76) has lprow=76 (included, j=76)
DEBUG BB: Row 77 (uid=77) has lprow=77 (included, j=77)
DEBUG BB: Row 78 (uid=78) has lprow=78 (included, j=78)
DEBUG BB: Row 79 (uid=79) has lprow=79 (included, j=79)
DEBUG BB: Row 80 (uid=80) has lprow=80 (included, j=80)
DEBUG BB: Row 81 (uid=81) has lprow=81 (included, j=81)
DEBUG BB: Row 82 (uid=82) has lprow=82 (included, j=82)
DEBUG BB: Row 83 (uid=83) has lprow=83 (included, j=83)
DEBUG BB: Row 84 (uid=84) has lprow=84 (included, j=84)
DEBUG BB: Row 85 (uid=85) has lprow=85 (included, j=85)
DEBUG BB: Row 86 (uid=86) has lprow=86 (included, j=86)
DEBUG BB: Row 87 (uid=87) has lprow=87 (included, j=87)
DEBUG BB: Row 88 (uid=88) has lprow=88 (included, j=88)
DEBUG BB: Row 89 (uid=89) has lprow=89 (included, j=89)
DEBUG BB: Row 90 (uid=90) has lprow=90 (included, j=90)
DEBUG BB: Row 91 (uid=91) has lprow=91 (included, j=91)
DEBUG BB: Row 92 (uid=92) has lprow=92 (included, j=92)
DEBUG BB: Row 93 (uid=93) has lprow=93 (included, j=93)
DEBUG BB: Row 94 (uid=94) has lprow=94 (included, j=94)
DEBUG BB: Row 95 (uid=95) has lprow=95 (included, j=95)
DEBUG BB: Row 96 (uid=96) has lprow=96 (included, j=96)
DEBUG BB: Row 97 (uid=97) has lprow=97 (included, j=97)
DEBUG BB: Row 98 (uid=98) has lprow=98 (included, j=98)
DEBUG BB: Row 99 (uid=99) has lprow=99 (included, j=99)
DEBUG BB: Row 100 (uid=100) has lprow=100 (included, j=100)
DEBUG BB: Row 101 (uid=101) has lprow=101 (included, j=101)
DEBUG BB: Row 102 (uid=102) has lprow=102 (included, j=102)
DEBUG BB: Row 103 (uid=103) has lprow=103 (included, j=103)
DEBUG BB: Row 104 (uid=104) has lprow=104 (included, j=104)
DEBUG BB: Row 105 (uid=105) has lprow=105 (included, j=105)
DEBUG BB: Row 106 (uid=106) has lprow=106 (included, j=106)
DEBUG BB: Row 107 (uid=107) has lprow=107 (included, j=107)
DEBUG BB: Row 108 (uid=108) has lprow=108 (included, j=108)
DEBUG BB: Row 109 (uid=109) has lprow=109 (included, j=109)
DEBUG BB: Row 110 (uid=110) has lprow=110 (included, j=110)
DEBUG BB: Row 111 (uid=111) has lprow=111 (included, j=111)
DEBUG BB: Row 112 (uid=112) has lprow=112 (included, j=112)
DEBUG BB: Row 113 (uid=113) has lprow=113 (included, j=113)
DEBUG BB: Row 114 (uid=114) has lprow=114 (included, j=114)
DEBUG BB: Row 115 (uid=115) has lprow=115 (included, j=115)
DEBUG BB: Row 116 (uid=116) has lprow=116 (included, j=116)
DEBUG BB: Row 117 (uid=117) has lprow=117 (included, j=117)
DEBUG BB: Row 118 (uid=118) has lprow=118 (included, j=118)
DEBUG BB: Row 119 (uid=119) has lprow=119 (included, j=119)
DEBUG BB: Row 120 (uid=120) has lprow=120 (included, j=120)
DEBUG BB: Row 121 (uid=121) has lprow=121 (included, j=121)
DEBUG BB: Row 122 (uid=122) has lprow=122 (included, j=122)
DEBUG BB: Row 123 (uid=123) has lprow=123 (included, j=123)
DEBUG BB: Row 124 (uid=124) has lprow=124 (included, j=124)
DEBUG BB: Row 125 (uid=125) has lprow=125 (included, j=125)
DEBUG BB: Row 126 (uid=126) has lprow=126 (included, j=126)
DEBUG BB: Row 127 (uid=127) has lprow=127 (included, j=127)
DEBUG BB: Row 128 (uid=128) has lprow=128 (included, j=128)
DEBUG BB: Row 129 (uid=129) has lprow=129 (included, j=129)
DEBUG BB: Row 130 (uid=130) has lprow=130 (included, j=130)
DEBUG BB: Row 131 (uid=131) has lprow=131 (included, j=131)
DEBUG BB: Row 132 (uid=132) has lprow=132 (included, j=132)
DEBUG BB: Row 133 (uid=133) has lprow=-1 (skipped)
DEBUG BB: Row 134 (uid=134) has lprow=-1 (skipped)
DEBUG BB: Row 135 (uid=135) has lprow=-1 (skipped)
DEBUG BB: Row 136 (uid=136) has lprow=-1 (skipped)
DEBUG BB: Row 137 (uid=137) has lprow=-1 (skipped)
DEBUG BB: Row 138 (uid=138) has lprow=-1 (skipped)
DEBUG BB: Row 139 (uid=139) has lprow=-1 (skipped)
DEBUG BB: Row 140 (uid=140) has lprow=-1 (skipped)
DEBUG BB: Row 141 (uid=141) has lprow=-1 (skipped)
DEBUG BB: Row 142 (uid=142) has lprow=-1 (skipped)
DEBUG BB: Row 143 (uid=143) has lprow=-1 (skipped)
DEBUG BB: Row 144 (uid=144) has lprow=-1 (skipped)
DEBUG BB: Row 145 (uid=145) has lprow=-1 (skipped)
DEBUG BB: Row 146 (uid=146) has lprow=-1 (skipped)
DEBUG BB: Row 147 (uid=147) has lprow=-1 (skipped)
DEBUG BB: Row 148 (uid=148) has lprow=-1 (skipped)
DEBUG BB: Row 149 (uid=149) has lprow=-1 (skipped)
DEBUG BB: Row 150 (uid=150) has lprow=-1 (skipped)
DEBUG BB: Row 151 (uid=151) has lprow=-1 (skipped)
DEBUG BB: Row 152 (uid=152) has lprow=-1 (skipped)
DEBUG BB: Row 153 (uid=153) has lprow=-1 (skipped)
DEBUG BB: Row 154 (uid=154) has lprow=-1 (skipped)
DEBUG BB: Row 155 (uid=155) has lprow=-1 (skipped)
DEBUG BB: Row 156 (uid=156) has lprow=-1 (skipped)
DEBUG BB: Row 157 (uid=157) has lprow=-1 (skipped)
DEBUG BB: Row 158 (uid=158) has lprow=-1 (skipped)
DEBUG BB: Row 159 (uid=159) has lprow=-1 (skipped)
DEBUG BB: Row 160 (uid=160) has lprow=-1 (skipped)
DEBUG BB: Row 161 (uid=161) has lprow=133 (included, j=133)
DEBUG BB: Row 162 (uid=162) has lprow=134 (included, j=134)
DEBUG BB: Found 135 actual LP rows, expected 135
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x555cc0985600
% Resuming node 0
DEBUG CONSTRNT: LP rows=135, pool->nlprows=135, pool->npend=0
DEBUG CONSTRNT: Checking 135 LP rows (pool tracks 135, total LP rows 135)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 1
DEBUG CONSTRNT: Pool row 1 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 2
DEBUG CONSTRNT: Pool row 2 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 3
DEBUG CONSTRNT: Pool row 3 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 4
DEBUG CONSTRNT: Pool row 4 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=56, expected 56
DEBUG CONSTRNT: Checking LP row 57 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=57, expected 57
DEBUG CONSTRNT: Checking LP row 58 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=58, expected 58
DEBUG CONSTRNT: Checking LP row 59 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=59, expected 59
DEBUG CONSTRNT: Checking LP row 60 -> pool row 60
DEBUG CONSTRNT: Pool row 60 has lprow=60, expected 60
DEBUG CONSTRNT: Checking LP row 61 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=61, expected 61
DEBUG CONSTRNT: Checking LP row 62 -> pool row 62
DEBUG CONSTRNT: Pool row 62 has lprow=62, expected 62
DEBUG CONSTRNT: Checking LP row 63 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=63, expected 63
DEBUG CONSTRNT: Checking LP row 64 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=64, expected 64
DEBUG CONSTRNT: Checking LP row 65 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=65, expected 65
DEBUG CONSTRNT: Checking LP row 66 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=66, expected 66
DEBUG CONSTRNT: Checking LP row 67 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=67, expected 67
DEBUG CONSTRNT: Checking LP row 68 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=68, expected 68
DEBUG CONSTRNT: Checking LP row 69 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=69, expected 69
DEBUG CONSTRNT: Checking LP row 70 -> pool row 70
DEBUG CONSTRNT: Pool row 70 has lprow=70, expected 70
DEBUG CONSTRNT: Checking LP row 71 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=71, expected 71
DEBUG CONSTRNT: Checking LP row 72 -> pool row 72
DEBUG CONSTRNT: Pool row 72 has lprow=72, expected 72
DEBUG CONSTRNT: Checking LP row 73 -> pool row 73
DEBUG CONSTRNT: Pool row 73 has lprow=73, expected 73
DEBUG CONSTRNT: Checking LP row 74 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=74, expected 74
DEBUG CONSTRNT: Checking LP row 75 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=75, expected 75
DEBUG CONSTRNT: Checking LP row 76 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=76, expected 76
DEBUG CONSTRNT: Checking LP row 77 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=77, expected 77
DEBUG CONSTRNT: Checking LP row 78 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=78, expected 78
DEBUG CONSTRNT: Checking LP row 79 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=79, expected 79
DEBUG CONSTRNT: Checking LP row 80 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=80, expected 80
DEBUG CONSTRNT: Checking LP row 81 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=81, expected 81
DEBUG CONSTRNT: Checking LP row 82 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=82, expected 82
DEBUG CONSTRNT: Checking LP row 83 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=83, expected 83
DEBUG CONSTRNT: Checking LP row 84 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=84, expected 84
DEBUG CONSTRNT: Checking LP row 85 -> pool row 85
DEBUG CONSTRNT: Pool row 85 has lprow=85, expected 85
DEBUG CONSTRNT: Checking LP row 86 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=86, expected 86
DEBUG CONSTRNT: Checking LP row 87 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=87, expected 87
DEBUG CONSTRNT: Checking LP row 88 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=88, expected 88
DEBUG CONSTRNT: Checking LP row 89 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=89, expected 89
DEBUG CONSTRNT: Checking LP row 90 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=90, expected 90
DEBUG CONSTRNT: Checking LP row 91 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=91, expected 91
DEBUG CONSTRNT: Checking LP row 92 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=92, expected 92
DEBUG CONSTRNT: Checking LP row 93 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=93, expected 93
DEBUG CONSTRNT: Checking LP row 94 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=94, expected 94
DEBUG CONSTRNT: Checking LP row 95 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=95, expected 95
DEBUG CONSTRNT: Checking LP row 96 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=96, expected 96
DEBUG CONSTRNT: Checking LP row 97 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=97, expected 97
DEBUG CONSTRNT: Checking LP row 98 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=98, expected 98
DEBUG CONSTRNT: Checking LP row 99 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=99, expected 99
DEBUG CONSTRNT: Checking LP row 100 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=100, expected 100
DEBUG CONSTRNT: Checking LP row 101 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=101, expected 101
DEBUG CONSTRNT: Checking LP row 102 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=102, expected 102
DEBUG CONSTRNT: Checking LP row 103 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=103, expected 103
DEBUG CONSTRNT: Checking LP row 104 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=104, expected 104
DEBUG CONSTRNT: Checking LP row 105 -> pool row 105
DEBUG CONSTRNT: Pool row 105 has lprow=105, expected 105
DEBUG CONSTRNT: Checking LP row 106 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=106, expected 106
DEBUG CONSTRNT: Checking LP row 107 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=107, expected 107
DEBUG CONSTRNT: Checking LP row 108 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=108, expected 108
DEBUG CONSTRNT: Checking LP row 109 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=109, expected 109
DEBUG CONSTRNT: Checking LP row 110 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=110, expected 110
DEBUG CONSTRNT: Checking LP row 111 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=111, expected 111
DEBUG CONSTRNT: Checking LP row 112 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=112, expected 112
DEBUG CONSTRNT: Checking LP row 113 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=113, expected 113
DEBUG CONSTRNT: Checking LP row 114 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=114, expected 114
DEBUG CONSTRNT: Checking LP row 115 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=115, expected 115
DEBUG CONSTRNT: Checking LP row 116 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=116, expected 116
DEBUG CONSTRNT: Checking LP row 117 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=117, expected 117
DEBUG CONSTRNT: Checking LP row 118 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=118, expected 118
DEBUG CONSTRNT: Checking LP row 119 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=119, expected 119
DEBUG CONSTRNT: Checking LP row 120 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=120, expected 120
DEBUG CONSTRNT: Checking LP row 121 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=121, expected 121
DEBUG CONSTRNT: Checking LP row 122 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=122, expected 122
DEBUG CONSTRNT: Checking LP row 123 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=123, expected 123
DEBUG CONSTRNT: Checking LP row 124 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=124, expected 124
DEBUG CONSTRNT: Checking LP row 125 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=125, expected 125
DEBUG CONSTRNT: Checking LP row 126 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=126, expected 126
DEBUG CONSTRNT: Checking LP row 127 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=127, expected 127
DEBUG CONSTRNT: Checking LP row 128 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=128, expected 128
DEBUG CONSTRNT: Checking LP row 129 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=129, expected 129
DEBUG CONSTRNT: Checking LP row 130 -> pool row 130
DEBUG CONSTRNT: Pool row 130 has lprow=130, expected 130
DEBUG CONSTRNT: Checking LP row 131 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=131, expected 131
DEBUG CONSTRNT: Checking LP row 132 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=132, expected 132
DEBUG CONSTRNT: Checking LP row 133 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=133, expected 133
DEBUG CONSTRNT: Checking LP row 134 -> pool row 162
DEBUG CONSTRNT: Pool row 162 has lprow=134, expected 134
 % @PAP adding 135 rows, 494 nz to LP
DEBUG BB: Processing node 0, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=149, theta=6.333333, up=1.000000
ITER 2: row=1, varin=155, theta=4.000000, up=1.000000
ITER 3: row=1, varin=152, theta=4.000000, up=1.000000
ITER 4: row=1, varin=143, theta=4.500000, up=1.000000
ITER 5: row=1, varin=144, theta=3.500000, up=1.000000
ITER 6: row=1, varin=151, theta=1.666667, up=1.000000
ITER 7: row=1, varin=141, theta=1.000000, up=1.000000
ITER 8: row=134, varin=137, theta=6.698163, up=1.000000
ITER 9: row=134, varin=150, theta=3.992486, up=1.000000
ITER 10: row=134, varin=176, theta=4.264342, up=1.000000
LP PHASE: Switching to primal (iter=37)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=135)
DEBUG SOLUTION: LP solution array indices: FST[136-175], not_covered[176-195]
DEBUG SOLUTION: lp->best_solution[0] = 27026987.278019
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 0.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 3.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 135 rows, 60 cols, 554 nonzeros, 74 slack, 61 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 74 slack rows
  % @PAP adding 10 rows, 44 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=63, varin=73, theta=3.135920, up=1.000000
ITER 2: row=63, varin=79, theta=1.126990, up=1.000000
ITER 3: row=63, varin=77, theta=0.120524, up=1.000000
ITER 4: row=1, varin=127, theta=2.508951, up=1.000000
ITER 5: row=1, varin=128, theta=1.508951, up=1.000000
ITER 6: row=1, varin=129, theta=0.508951, up=1.000000
ITER 7: row=68, varin=79, theta=2.000000, up=1.000000
ITER 8: row=68, varin=88, theta=1.000000, up=1.000000
ITER 9: row=62, varin=82, theta=2.353577, up=1.000000
ITER 10: row=62, varin=72, theta=1.292265, up=1.000000
LP PHASE: Switching to primal (iter=29)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=71)
DEBUG SOLUTION: LP solution array indices: FST[72-111], not_covered[112-131]
DEBUG SOLUTION: lp->best_solution[0] = 27714928.687550
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 0.817570
DEBUG SOLUTION: lp->best_solution[3] = 0.817570
DEBUG SOLUTION: lp->best_solution[4] = 0.817570
DEBUG SOLUTION: lp->best_solution[5] = 2.452709
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 6.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 71 rows, 60 cols, 350 nonzeros, 26 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 26 slack rows
  % @PAP adding 6 rows, 22 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=26, theta=0.250000, up=999999999999999983222784.000000
ITER 2: row=51, varin=36, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=49, varin=106, theta=1.550108, up=1.000000
ITER 4: row=49, varin=52, theta=0.525190, up=1.000000
ITER 5: row=1, varin=94, theta=1.074620, up=1.000000
ITER 6: row=1, varin=99, theta=0.074620, up=1.000000
ITER 7: row=47, varin=48, theta=7.000000, up=999999999999999983222784.000000
ITER 8: row=21, varin=100, theta=0.949620, up=1.000000
ITER 9: row=22, varin=101, theta=0.949620, up=1.000000
ITER 10: row=23, varin=109, theta=0.949620, up=1.000000
LP PHASE: Switching to primal (iter=12)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 27754300.506309
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 6.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 306 nonzeros, 6 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 7 rows, 29 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=95, theta=1.000000, up=1.000000
ITER 2: row=51, varin=72, theta=0.197161, up=1.000000
ITER 3: row=50, varin=107, theta=1.000000, up=1.000000
ITER 4: row=46, varin=73, theta=0.575614, up=1.000000
ITER 5: row=5, varin=51, theta=10.942854, up=999999999999999983222784.000000
ITER 6: row=44, varin=96, theta=0.159751, up=1.000000
ITER 7: row=17, varin=94, theta=0.390367, up=1.000000
ITER 8: row=52, varin=99, theta=0.156268, up=1.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 27786995.146589
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 0.843732
DEBUG SOLUTION: lp->best_solution[3] = 0.843732
DEBUG SOLUTION: lp->best_solution[4] = 0.843732
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.843732
DEBUG SOLUTION: lp->best_solution[7] = 0.843732
DEBUG SOLUTION: lp->best_solution[8] = 5.218662
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.843732
DEBUG SOLUTION: lp->best_solution[12] = 0.843732
DEBUG SOLUTION: lp->best_solution[13] = 0.843732
DEBUG SOLUTION: lp->best_solution[14] = 0.843732
  % @PL 52 rows, 60 cols, 313 nonzeros, 22 slack, 30 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 22 slack rows
  % @PAP adding 3 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=31, varin=89, theta=0.152932, up=1.000000
ITER 2: row=33, varin=44, theta=0.261753, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=33)
DEBUG SOLUTION: LP solution array indices: FST[34-73], not_covered[74-93]
DEBUG SOLUTION: lp->best_solution[0] = 27792523.973561
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 3.000000
  % @PL 33 rows, 60 cols, 251 nonzeros, 1 slack, 32 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 0 LP 1 Solution, length = 27792523.973561, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 1.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.412749 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.587251 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.738247 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.412749 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.587251 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.261753 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.412749 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.738247 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.738247 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.412749 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.412749 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.412749 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.412749 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.261753 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.261753 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.738247 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.412749 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.412749 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.261753 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=27792523.973561, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.00  27.79252397356127346484 99.9000000000
 % @LN 0.00  27.79252397356127346484 99.9000000000
DEBUG CG: Second cutoff check: z=27792523.973561, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 3 connected components.
 % initially 3 congested vertices:
 % _gst_find_congested_components found 1 components:
 % 	component 0:	3 verts,	4 edges
 % @PAP adding 1 rows, 12 nz to LP
 % @PMEM 164 rows, 1 blocks, 402 nzfree, 0 nzwasted, 1172 nztotal
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=33, varin=22, theta=1.206805, up=999999999999999983222784.000000
ITER 2: row=18, varin=32, theta=0.175140, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=33)
DEBUG SOLUTION: LP solution array indices: FST[34-73], not_covered[74-93]
DEBUG SOLUTION: lp->best_solution[0] = 27799588.537100
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 3.000000
  % @PL 33 rows, 60 cols, 255 nonzeros, 2 slack, 31 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 4 rows, 19 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=32, varin=43, theta=0.500000, up=1.000000
ITER 2: row=23, varin=37, theta=0.223045, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=35)
DEBUG SOLUTION: LP solution array indices: FST[36-75], not_covered[76-95]
DEBUG SOLUTION: lp->best_solution[0] = 27811801.991597
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 3.000000
  % @PL 35 rows, 60 cols, 264 nonzeros, 3 slack, 32 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 4 rows, 20 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=33, varin=89, theta=0.371630, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=36)
DEBUG SOLUTION: LP solution array indices: FST[37-76], not_covered[77-96]
DEBUG SOLUTION: lp->best_solution[0] = 27816402.380510
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 3.000000
  % @PL 36 rows, 60 cols, 265 nonzeros, 2 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 0 LP 2 Solution, length = 27816402.380510, 0.00/0.00/0.00/0.00/0.00/0.00/0.00 1
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.500000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.500000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.500000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.371630 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.371630 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.500000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.628370 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.628370 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.628370 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.628370 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.628370 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.628370 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=27816402.380510, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.00  27.79252397356127346484 99.9000000000
 % @LN 0.00  27.81640238050955460380 99.9000000000
DEBUG CG: Second cutoff check: z=27816402.380510, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 3 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 0 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 0
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.500000
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.500000
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.500000
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.500000
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.371630
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.371630)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.371630
DEBUG CAREFUL: Adding var 20 to fractional list (xi=0.371630)
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 0
DEBUG CAREFUL: New best var: 0
DEBUG CAREFUL: Testing fvar[1] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 1
DEBUG CAREFUL: New best var: 1
DEBUG CAREFUL: Testing fvar[2] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
DEBUG CAREFUL: Testing fvar[3] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 5
DEBUG CAREFUL: Testing fvar[4] = var 20
DEBUG CAREFUL: Calling compare_branch_vars for var 20
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 20
DEBUG CAREFUL: Testing fvar[5] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x1, Z0 = 27825243.9886882        , Z1 = 27816402.3805096        

DEBUG EVAL: Testing var 0 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=59, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 0 = 0 gives z=27823961.420511
  % 	x0 = 0,	Z0 = 27823961.4205109        
DEBUG EVAL: First branch cutoff check: z=27823961.420511, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 0 = 1
ITER 1: row=1, varin=33, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=10, varin=31, theta=0.059785, up=999999999999999983222784.000000
  % 	x0 = 1,	Z1 = 27825216.3636144        
DEBUG EVAL: Second branch cutoff check: z=27825216.363614, best_z=INF, threshold=INF
  %   New best:  x0, Z = 27823961.4205109        
DEBUG EVAL: Testing var 1 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=59, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 1 = 1 gives z=27823961.420511
  % 	x1 = 1,	Z1 = 27823961.4205109        
DEBUG EVAL: First branch cutoff check: z=27823961.420511, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 0
ITER 1: row=3, varin=33, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=10, varin=31, theta=0.059785, up=999999999999999983222784.000000
  % 	x1 = 0,	Z0 = 27825243.9886882        
DEBUG EVAL: Second branch cutoff check: z=27825243.988688, best_z=INF, threshold=INF
  %   New best:  x1, Z = 27823961.4205109        
DEBUG EVAL: Testing var 7 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=22, varin=31, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 7 = 1 gives z=27833216.223919
  % 	x7 = 1,	Z1 = 27833216.2239189        
DEBUG EVAL: First branch cutoff check: z=27833216.223919, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 7 = 0
ITER 1: row=22, varin=26, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=32, varin=24, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=1, varin=22, theta=0.500000, up=999999999999999983222784.000000
  % 	x7 = 0,	Z0 = 27849985.8456519        
DEBUG EVAL: Second branch cutoff check: z=27849985.845652, best_z=INF, threshold=INF
  %   New best:  x7, Z = 27833216.2239189        
DEBUG EVAL: Testing var 5 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=18, varin=31, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 5 = 0 gives z=27833216.223919
  % 	x5 = 0,	Z0 = 27833216.2239189        
DEBUG EVAL: First branch cutoff check: z=27833216.223919, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 5 = 1
ITER 1: row=18, varin=26, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=32, varin=22, theta=1.000000, up=999999999999999983222784.000000
  % 	x5 = 1,	Z1 = 27860703.7908104        
DEBUG EVAL: Second branch cutoff check: z=27860703.790810, best_z=INF, threshold=INF
  %   New best:  x5, Z = 27833216.2239189        
DEBUG EVAL: Testing var 20 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=33, theta=1.129301, up=999999999999999983222784.000000
ITER 2: row=10, varin=18, theta=58181.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 20 = 0 gives z=27826819.988810
  % 	x20 = 0,	Z0 = 27826819.9888103        
DEBUG EVAL: First branch cutoff check: z=27826819.988810, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=10, varin=10, theta=0.515136, up=999999999999999983222784.000000
ITER 2: row=34, varin=18, theta=508150.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 0 gives z=27834851.050322
  % 	x10 = 0,	Z0 = 27834851.0503219        
DEBUG EVAL: First branch cutoff check: z=27834851.050322, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 1
ITER 1: row=10, varin=33, theta=0.936579, up=999999999999999983222784.000000
  % 	x10 = 1,	Z1 = 27824180.9501589        
DEBUG EVAL: Second branch cutoff check: z=27824180.950159, best_z=INF, threshold=INF
  % Best branch is x5, Z0 = 27833216.2239189        , Z1 = 27860703.7908104        

DEBUG CAREFUL: Final result - returning best.var = 5
DEBUG BB: Branching variable chosen: j=5
 % @NC    1    0	x5 = 0	27833216.223919
 % @NC    2    0	x5 = 1	27860703.790810
 %       0     2 27816402.3805               27833216.2239
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x555cc098d550
% @LO 0.00  27.81640238050955460380 99.9000000000
% @LN 0.00  27.83321622391894578641 99.9000000000
% Resuming node 1 at  27.83321622391894578641
DEBUG CONSTRNT: LP rows=34, pool->nlprows=34, pool->npend=0
DEBUG CONSTRNT: Checking 34 LP rows (pool tracks 34, total LP rows 34)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=33, expected 33
 % @PAP adding 34 rows, 189 nz to LP
DEBUG BB: Processing node 1, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=18, varin=31, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=34)
DEBUG SOLUTION: LP solution array indices: FST[35-74], not_covered[75-94]
DEBUG SOLUTION: lp->best_solution[0] = 27833216.223919
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 3.000000
  % @PL 34 rows, 60 cols, 249 nonzeros, 2 slack, 32 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 15 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=35, varin=24, theta=0.250000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 27834729.143063
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 3.000000
  % @PL 38 rows, 60 cols, 264 nonzeros, 5 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % Node 1 LP 1 Solution, length = 27834729.143063, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.500000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.750000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.453968 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.250000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.750000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.453968 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.500000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.250000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.546032 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.546032 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.250000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.250000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.250000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.250000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.546032 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.546032 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.546032 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.250000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.250000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.546032 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=27834729.143063, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.00  27.83321622391894578641 99.9000000000
 % @LN 0.00  27.83472914306252476990 99.9000000000
DEBUG CG: Second cutoff check: z=27834729.143063, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 3 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 1 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 1
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.500000
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.500000
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.750000
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.750000)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.453968
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.453968)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.250000
DEBUG CAREFUL: Adding var 13 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.750000
DEBUG CAREFUL: Adding var 19 to fractional list (xi=0.750000)
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.453968
DEBUG CAREFUL: Adding var 20 to fractional list (xi=0.453968)
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 7 fractional variables

  %  Carefully choosing branching variable, nfrac = 7
DEBUG CAREFUL: Testing fvar[0] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 0
DEBUG CAREFUL: New best var: 0
DEBUG CAREFUL: Testing fvar[1] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[2] = var 19
DEBUG CAREFUL: Calling compare_branch_vars for var 19
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 19
DEBUG CAREFUL: New best var: 19
DEBUG CAREFUL: Testing fvar[3] = var 13
DEBUG CAREFUL: Calling compare_branch_vars for var 13
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 13
DEBUG CAREFUL: Testing fvar[4] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 7
DEBUG CAREFUL: New best var: 7
DEBUG CAREFUL: Testing fvar[5] = var 20
DEBUG CAREFUL: Calling compare_branch_vars for var 20
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 20
DEBUG CAREFUL: Testing fvar[6] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x7, Z0 = 27849985.8456519        , Z1 = 27834729.1430625        

DEBUG EVAL: Testing var 0 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=32, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 0 = 0 gives z=27836242.062206
  % 	x0 = 0,	Z0 = 27836242.0622061        
DEBUG EVAL: First branch cutoff check: z=27836242.062206, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 0 = 1
ITER 1: row=1, varin=3, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=33, varin=4, theta=1.000000, up=999999999999999983222784.000000
  % 	x0 = 1,	Z1 = 27897357.3159164        
DEBUG EVAL: Second branch cutoff check: z=27897357.315916, best_z=INF, threshold=INF
  %   New best:  x0, Z = 27836242.0622061        
DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=27, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 0 gives z=27856810.092472
  % 	x1 = 0,	Z0 = 27856810.0924718        
DEBUG EVAL: First branch cutoff check: z=27856810.092472, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 1
ITER 1: row=3, varin=32, theta=1.000000, up=999999999999999983222784.000000
  % 	x1 = 1,	Z1 = 27836242.0622061        
DEBUG EVAL: Second branch cutoff check: z=27836242.062206, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 19 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=58, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 19 = 1 gives z=27840775.263920
  % 	x19 = 1,	Z1 = 27840775.2639202        
DEBUG EVAL: First branch cutoff check: z=27840775.263920, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 19 = 0
ITER 1: row=6, varin=32, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=30, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=10, varin=2, theta=1.615181, up=999999999999999983222784.000000
ITER 4: row=5, varin=15, theta=1.230363, up=999999999999999983222784.000000
ITER 5: row=16, varin=22, theta=0.230363, up=999999999999999983222784.000000
  % 	x19 = 0,	Z0 = 27891820.0460492        
DEBUG EVAL: Second branch cutoff check: z=27891820.046049, best_z=INF, threshold=INF
  %   New best:  x19, Z = 27840775.2639202        
DEBUG EVAL: Testing var 13 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=19, varin=58, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 13 = 0 gives z=27840775.263920
  % 	x13 = 0,	Z0 = 27840775.2639202        
DEBUG EVAL: First branch cutoff check: z=27840775.263920, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 13 = 1
ITER 1: row=19, varin=32, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=30, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=10, varin=2, theta=1.615181, up=999999999999999983222784.000000
ITER 4: row=5, varin=15, theta=1.230363, up=999999999999999983222784.000000
ITER 5: row=16, varin=7, theta=0.230363, up=999999999999999983222784.000000
  % 	x13 = 1,	Z1 = 27891820.0460492        
DEBUG EVAL: Second branch cutoff check: z=27891820.046049, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 7 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=18, varin=58, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 7 = 1 gives z=27840775.263920
  % 	x7 = 1,	Z1 = 27840775.2639202        
DEBUG EVAL: First branch cutoff check: z=27840775.263920, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 7 = 0
ITER 1: row=18, varin=32, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=30, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=10, varin=29, theta=0.413989, up=999999999999999983222784.000000
  % 	x7 = 0,	Z0 = 27872987.6141153        
DEBUG EVAL: Second branch cutoff check: z=27872987.614115, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 20 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=58, theta=3.553110, up=1.000000
ITER 2: row=2, varin=30, theta=1.583957, up=999999999999999983222784.000000
ITER 3: row=23, varin=18, theta=164439.250000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 20 = 0 gives z=28753332.727189
  % 	x20 = 0,	Z0 = 28753332.7271887        
DEBUG EVAL: First branch cutoff check: z=28753332.727189, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 20 = 1
ITER 1: row=2, varin=32, theta=4.434293, up=999999999999999983222784.000000
ITER 2: row=1, varin=10, theta=1.518034, up=999999999999999983222784.000000
ITER 3: row=31, varin=26, theta=1.204075, up=999999999999999983222784.000000
ITER 4: row=10, varin=27, theta=0.606597, up=999999999999999983222784.000000
  % 	x20 = 1,	Z1 = 27903041.4357474        
DEBUG EVAL: Second branch cutoff check: z=27903041.435747, best_z=INF, threshold=INF
  %   New best:  x20, Z = 27903041.4357474        
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=10, varin=32, theta=4.434293, up=999999999999999983222784.000000
ITER 2: row=1, varin=30, theta=0.532572, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=27841470.969351
  % 	x10 = 1,	Z1 = 27841470.9693514        
DEBUG EVAL: First branch cutoff check: z=27841470.969351, best_z=INF, threshold=INF
  % Best branch is x20, Z0 = 28753332.7271887        , Z1 = 27903041.4357474        

DEBUG CAREFUL: Final result - returning best.var = 20
DEBUG BB: Branching variable chosen: j=20
 % @NC    3    1	x20 = 1	27903041.435747
 % @NC    4    1	x20 = 0	28753332.727189
 %       1     3 27834729.1431               27860703.7908    x5 D     0     1
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x555cc09962c0
% @LO 0.00  27.83472914306252476990 99.9000000000
% @LN 0.00  27.86070379081042247549 99.9000000000
% Resuming node 2 at  27.86070379081042247549
DEBUG CONSTRNT: LP rows=33, pool->nlprows=33, pool->npend=0
DEBUG CONSTRNT: Checking 33 LP rows (pool tracks 33, total LP rows 33)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=32, expected 32
 % @PAP adding 34 rows, 189 nz to LP
DEBUG BB: Processing node 2, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=18, varin=26, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=32, varin=22, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=34)
DEBUG SOLUTION: LP solution array indices: FST[35-74], not_covered[75-94]
DEBUG SOLUTION: lp->best_solution[0] = 27860703.790810
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 3.000000
  % @PL 34 rows, 60 cols, 249 nonzeros, 2 slack, 32 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 15 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=35, varin=63, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 27868262.830812
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 3.000000
  % @PL 38 rows, 60 cols, 264 nonzeros, 4 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 3 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=50, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 27892674.608164
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 3.000000
  % @PL 37 rows, 60 cols, 256 nonzeros, 1 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 3 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=37, varin=23, theta=0.250000, up=999999999999999983222784.000000
ITER 2: row=18, varin=57, theta=0.333333, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 27896266.369231
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 3.000000
  % @PL 39 rows, 60 cols, 266 nonzeros, 0 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=59, theta=0.062598, up=1.000000
ITER 2: row=20, varin=19, theta=0.054145, up=999999999999999983222784.000000
ITER 3: row=40, varin=20, theta=0.029735, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 27903165.565084
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 3.000000
  % @PL 43 rows, 60 cols, 274 nonzeros, 3 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=10, theta=0.487058, up=999999999999999983222784.000000
ITER 2: row=29, varin=23, theta=0.562311, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 27908682.737246
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 3.000000
  % @PL 42 rows, 60 cols, 263 nonzeros, 1 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 2 LP 1 Solution, length = 27908682.737246, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.218844 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.218844 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.333333 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.333333 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.333333 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.781156 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.666667 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.781156 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.781156 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.666667 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.781156 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.666667 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.666667 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.666667 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.666667 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=27908682.737246, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 2 at  27.90868273724631976052
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x555cc0985600
% @LO 0.00  27.86070379081042247549 99.9000000000
% @LN 0.00  27.90304143574741502221 99.9000000000
% Resuming node 3 at  27.90304143574741502221
DEBUG CONSTRNT: LP rows=41, pool->nlprows=41, pool->npend=0
DEBUG CONSTRNT: Checking 41 LP rows (pool tracks 41, total LP rows 41)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=40, expected 40
 % @PAP adding 33 rows, 185 nz to LP
DEBUG BB: Processing node 3, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=2, varin=32, theta=4.434293, up=999999999999999983222784.000000
ITER 2: row=1, varin=10, theta=1.518034, up=999999999999999983222784.000000
ITER 3: row=31, varin=26, theta=1.204075, up=999999999999999983222784.000000
ITER 4: row=26, varin=27, theta=0.606597, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=33)
DEBUG SOLUTION: LP solution array indices: FST[34-73], not_covered[74-93]
DEBUG SOLUTION: lp->best_solution[0] = 27903041.435747
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 3.000000
  % @PL 33 rows, 60 cols, 245 nonzeros, 5 slack, 28 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 4 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=32, varin=87, theta=0.099034, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=32)
DEBUG SOLUTION: LP solution array indices: FST[33-72], not_covered[73-92]
DEBUG SOLUTION: lp->best_solution[0] = 27903716.246002
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 32 rows, 60 cols, 242 nonzeros, 0 slack, 32 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=33, varin=34, theta=0.096321, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=33)
DEBUG SOLUTION: LP solution array indices: FST[34-73], not_covered[74-93]
DEBUG SOLUTION: lp->best_solution[0] = 27906879.235286
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 33 rows, 60 cols, 246 nonzeros, 0 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 3 LP 1 Solution, length = 27906879.235286, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.096321 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.096321 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.500000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.500000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.500000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.903679 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.903679 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.903679 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.903679 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=27906879.235286, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.00  27.90304143574741502221 99.9000000000
 % @LN 0.00  27.90687923528630065562 99.9000000000
DEBUG CG: Second cutoff check: z=27906879.235286, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 3 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 3 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 3
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.096321
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.096321)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.096321
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.096321)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.500000
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.500000
DEBUG CAREFUL: Adding var 13 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.500000
DEBUG CAREFUL: Adding var 19 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=1.000000
DEBUG CAREFUL: Skipping var 20: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 19
DEBUG CAREFUL: Calling compare_branch_vars for var 19
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 19
DEBUG CAREFUL: New best var: 19
DEBUG CAREFUL: Testing fvar[1] = var 13
DEBUG CAREFUL: Calling compare_branch_vars for var 13
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 13
DEBUG CAREFUL: Testing fvar[2] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
DEBUG CAREFUL: Testing fvar[3] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[4] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 0
DEBUG CAREFUL: New best var: 0
  % Initial guess is x0, Z0 = 27906879.2352863        , Z1 = 27942885.1619561        

DEBUG EVAL: Testing var 19 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=21, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=29, varin=6, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=30, varin=7, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=31, varin=19, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=21, varin=8, theta=0.343641, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 19 = 0 gives z=28018731.256185
  % 	x19 = 0,	Z0 = 28018731.2561852        
DEBUG EVAL: First branch cutoff check: z=28018731.256185, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 19 = 1
ITER 1: row=6, varin=32, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=3, varin=58, theta=2.883292, up=1.000000
ITER 3: row=3, varin=46, theta=0.899822, up=1.000000
ITER 4: row=21, varin=26, theta=0.547687, up=999999999999999983222784.000000
  % 	x19 = 1,	Z1 = 27991780.7102299        
DEBUG EVAL: Second branch cutoff check: z=27991780.710230, best_z=INF, threshold=INF
  %   New best:  x19, Z = 27991780.7102299        
DEBUG EVAL: Testing var 13 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=18, varin=32, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=3, varin=58, theta=2.883292, up=1.000000
ITER 3: row=3, varin=19, theta=0.330801, up=999999999999999983222784.000000
ITER 4: row=21, varin=26, theta=0.301072, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 13 = 0 gives z=27970537.580509
  % 	x13 = 0,	Z0 = 27970537.5805092        
DEBUG EVAL: First branch cutoff check: z=27970537.580509, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 7 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=17, varin=21, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=29, varin=26, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 7 = 0 gives z=27948223.560256
  % 	x7 = 0,	Z0 = 27948223.5602556        
DEBUG EVAL: First branch cutoff check: z=27948223.560256, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=32, theta=0.063776, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 0 gives z=27908123.544396
  % 	x1 = 0,	Z0 = 27908123.5443961        
DEBUG EVAL: First branch cutoff check: z=27908123.544396, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 0 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=33, theta=0.929126, up=999999999999999983222784.000000
ITER 2: row=33, varin=32, theta=1.845439, up=999999999999999983222784.000000
ITER 3: row=3, varin=26, theta=0.879271, up=999999999999999983222784.000000
ITER 4: row=33, varin=21, theta=0.541138, up=999999999999999983222784.000000
ITER 5: row=23, varin=24, theta=0.167600, up=999999999999999983222784.000000
ITER 6: row=17, varin=18, theta=0.119014, up=999999999999999983222784.000000
ITER 7: row=19, varin=19, theta=0.147999, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 0 = 1 gives z=28027947.991077
  % 	x0 = 1,	Z1 = 28027947.9910768        
DEBUG EVAL: First branch cutoff check: z=28027947.991077, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 0 = 0
ITER 1: row=1, varin=58, theta=0.189017, up=1.000000
  % 	x0 = 0,	Z0 = 27908388.0734011        
DEBUG EVAL: Second branch cutoff check: z=27908388.073401, best_z=INF, threshold=INF
  % Best branch is x19, Z0 = 28018731.2561852        , Z1 = 27991780.7102299        

DEBUG CAREFUL: Final result - returning best.var = 19
DEBUG BB: Branching variable chosen: j=19
 % @NC    5    3	x19 = 1	27991780.710230
 % @NC    6    3	x19 = 0	28018731.256185
 %       3     4 27906879.2353               27908682.7372   x20 U     1     2
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x555cc09962c0
% @LO 0.00  27.90687923528630065562 99.9000000000
% @LN 0.00  27.90868273724631976052 99.9000000000
% Resuming node 2 at  27.90868273724631976052
DEBUG CONSTRNT: LP rows=33, pool->nlprows=33, pool->npend=0
DEBUG CONSTRNT: Checking 33 LP rows (pool tracks 33, total LP rows 33)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=32, expected 32
 % @PAP adding 41 rows, 200 nz to LP
DEBUG BB: Processing node 2, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 2 LP 2 Solution, length = 27908682.737246, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.218844 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.218844 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.333333 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.333333 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.333333 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.781156 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.666667 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.781156 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.781156 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.666667 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.781156 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.666667 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.666667 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.666667 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.666667 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=27908682.737246, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27908682.737246, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 3 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 2 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 2
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.218844
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.218844)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.218844
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.218844)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.333333
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.333333
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.333333
DEBUG CAREFUL: Adding var 20 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 20
DEBUG CAREFUL: Calling compare_branch_vars for var 20
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 20
DEBUG CAREFUL: New best var: 20
DEBUG CAREFUL: Testing fvar[1] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
DEBUG CAREFUL: Testing fvar[2] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[3] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
DEBUG CAREFUL: Testing fvar[4] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
  % Initial guess is x17, Z0 = 27908682.7372463        , Z1 = 27967391.5260721        

DEBUG EVAL: Testing var 20 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=6, theta=0.285714, up=999999999999999983222784.000000
ITER 2: row=1, varin=28, theta=0.476417, up=999999999999999983222784.000000
ITER 3: row=10, varin=2, theta=0.256703, up=999999999999999983222784.000000
ITER 4: row=39, varin=18, theta=181475.714286, up=999999999999999983222784.000000
ITER 5: row=41, varin=57, theta=0.156068, up=1.000000
DEBUG EVAL: Branch var 20 = 0 gives z=27080154.035660
  % 	x20 = 0,	Z0 = 27908682.7372463        
DEBUG EVAL: First branch cutoff check: z=27908682.737246, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 20 = 1
ITER 1: row=2, varin=40, theta=0.444444, up=999999999999999983222784.000000
ITER 2: row=21, varin=36, theta=1.743445, up=999999999999999983222784.000000
ITER 3: row=19, varin=3, theta=2.030266, up=999999999999999983222784.000000
ITER 4: row=3, varin=21, theta=1.286098, up=999999999999999983222784.000000
ITER 5: row=1, varin=22, theta=1.345126, up=999999999999999983222784.000000
ITER 6: row=2, varin=6, theta=0.663844, up=999999999999999983222784.000000
ITER 7: row=41, varin=57, theta=0.748342, up=1.000000
ITER 8: row=18, varin=33, theta=0.555298, up=999999999999999983222784.000000
ITER 9: row=33, varin=31, theta=0.952690, up=999999999999999983222784.000000
ITER 10: row=31, varin=24, theta=0.221899, up=999999999999999983222784.000000
  % 	x20 = 1,	Z1 = 28262233.098748         
DEBUG EVAL: Second branch cutoff check: z=28262233.098748, best_z=INF, threshold=INF
  %   New best:  x20, Z = 27908682.7372463        
DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=19, varin=2, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=39, varin=40, theta=0.444444, up=999999999999999983222784.000000
ITER 3: row=21, varin=28, theta=1.243010, up=999999999999999983222784.000000
ITER 4: row=10, varin=22, theta=0.891653, up=999999999999999983222784.000000
ITER 5: row=37, varin=3, theta=4.761154, up=999999999999999983222784.000000
ITER 6: row=3, varin=5, theta=0.883501, up=999999999999999983222784.000000
ITER 7: row=38, varin=21, theta=3.016014, up=999999999999999983222784.000000
ITER 8: row=37, varin=23, theta=0.875496, up=999999999999999983222784.000000
ITER 9: row=39, varin=6, theta=0.424740, up=999999999999999983222784.000000
ITER 10: row=41, varin=57, theta=0.477047, up=1.000000
DEBUG EVAL: Branch var 17 = 1 gives z=28244006.596690
  % 	x17 = 1,	Z1 = 28244006.5966901        
DEBUG EVAL: First branch cutoff check: z=28244006.596690, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 0
ITER 1: row=19, varin=6, theta=0.285714, up=999999999999999983222784.000000
ITER 2: row=1, varin=28, theta=0.476417, up=999999999999999983222784.000000
ITER 3: row=10, varin=36, theta=0.132720, up=999999999999999983222784.000000
ITER 4: row=41, varin=57, theta=0.333333, up=1.000000
  % 	x17 = 0,	Z0 = 27943215.3281048        
DEBUG EVAL: Second branch cutoff check: z=27943215.328105, best_z=INF, threshold=INF
  %   New best:  x17, Z = 27943215.3281048        
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=18, varin=6, theta=0.285714, up=999999999999999983222784.000000
ITER 2: row=1, varin=2, theta=0.256703, up=999999999999999983222784.000000
ITER 3: row=39, varin=22, theta=0.107167, up=999999999999999983222784.000000
ITER 4: row=41, varin=57, theta=0.257663, up=1.000000
DEBUG EVAL: Branch var 10 = 0 gives z=27937575.563460
  % 	x10 = 0,	Z0 = 27937575.5634602        
DEBUG EVAL: First branch cutoff check: z=27937575.563460, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 0 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=28, theta=0.379113, up=999999999999999983222784.000000
ITER 2: row=10, varin=40, theta=0.046290, up=999999999999999983222784.000000
ITER 3: row=7, varin=36, theta=0.105613, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 0 = 0 gives z=27918347.318640
  % 	x0 = 0,	Z0 = 27918347.3186403        
DEBUG EVAL: First branch cutoff check: z=27918347.318640, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=28, theta=0.379113, up=999999999999999983222784.000000
ITER 2: row=10, varin=40, theta=0.046290, up=999999999999999983222784.000000
ITER 3: row=6, varin=36, theta=0.105613, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 0 gives z=27918347.318640
  % 	x1 = 0,	Z0 = 27918347.3186404        
DEBUG EVAL: First branch cutoff check: z=27918347.318640, best_z=INF, threshold=INF
  % Best branch is x17, Z0 = 27943215.3281048        , Z1 = 28244006.5966901        

DEBUG CAREFUL: Final result - returning best.var = 17
DEBUG BB: Branching variable chosen: j=17
 % @NC    7    2	x17 = 0	27943215.328105
 % @NC    8    2	x17 = 1	28244006.596690
 %       2     5 27908682.7372               27943215.3281    x5 U     0     1
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x555cc0985600
% @LO 0.00  27.90868273724631976052 99.9000000000
% @LN 0.00  27.94321532810483077469 99.9000000000
% Resuming node 7 at  27.94321532810483077469
DEBUG CONSTRNT: LP rows=41, pool->nlprows=41, pool->npend=0
DEBUG CONSTRNT: Checking 41 LP rows (pool tracks 41, total LP rows 41)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=40, expected 40
 % @PAP adding 41 rows, 200 nz to LP
DEBUG BB: Processing node 7, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=19, varin=6, theta=0.285714, up=999999999999999983222784.000000
ITER 2: row=1, varin=28, theta=0.476417, up=999999999999999983222784.000000
ITER 3: row=10, varin=36, theta=0.132720, up=999999999999999983222784.000000
ITER 4: row=41, varin=57, theta=0.333333, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 27943215.328105
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.666667
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 3.000000
  % @PL 41 rows, 60 cols, 260 nonzeros, 5 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 3 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=43, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 27965296.277514
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.666667
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 3.000000
  % @PL 42 rows, 60 cols, 263 nonzeros, 5 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % Node 7 LP 1 Solution, length = 27965296.277514, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.500000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.384172 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.333333 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.666667 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.384172 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.500000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.615828 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.615828 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.333333 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.333333 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.615828 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.615828 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.615828 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.333333 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.333333 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.615828 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=27965296.277514, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.00  27.94321532810483077469 99.9000000000
 % @LN 0.00  27.96529627751406010816 99.9000000000
DEBUG CG: Second cutoff check: z=27965296.277514, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 3 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 7 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 7
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.500000
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.500000
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.384172
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.384172)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.333333
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.666667
DEBUG CAREFUL: Adding var 19 to fractional list (xi=0.666667)
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.384172
DEBUG CAREFUL: Adding var 20 to fractional list (xi=0.384172)
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 15
DEBUG CAREFUL: New best var: 15
DEBUG CAREFUL: Testing fvar[1] = var 19
DEBUG CAREFUL: Calling compare_branch_vars for var 19
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 19
DEBUG CAREFUL: Testing fvar[2] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 0
DEBUG CAREFUL: New best var: 0
DEBUG CAREFUL: Testing fvar[3] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[4] = var 20
DEBUG CAREFUL: Calling compare_branch_vars for var 20
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 20
DEBUG CAREFUL: New best var: 20
DEBUG CAREFUL: Testing fvar[5] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x20, Z0 = 27965296.2775141        , Z1 = 28262233.098748         

DEBUG EVAL: Testing var 15 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=20, varin=45, theta=0.250000, up=1.000000
ITER 2: row=19, varin=40, theta=0.600000, up=1.000000
ITER 3: row=10, varin=52, theta=0.333333, up=1.000000
DEBUG EVAL: Branch var 15 = 0 gives z=27981635.369657
  % 	x15 = 0,	Z0 = 27981635.3696573        
DEBUG EVAL: First branch cutoff check: z=27981635.369657, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 15 = 1
ITER 1: row=20, varin=36, theta=0.285714, up=999999999999999983222784.000000
ITER 2: row=17, varin=30, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=30, varin=28, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=1, varin=26, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=9, varin=2, theta=0.278028, up=999999999999999983222784.000000
  % 	x15 = 1,	Z1 = 28188973.3273856        
DEBUG EVAL: Second branch cutoff check: z=28188973.327386, best_z=INF, threshold=INF
  %   New best:  x15, Z = 27981635.3696573        
DEBUG EVAL: Testing var 19 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=40, theta=0.600000, up=1.000000
ITER 2: row=10, varin=56, theta=0.333333, up=1.000000
DEBUG EVAL: Branch var 19 = 1 gives z=27986113.884852
  % 	x19 = 1,	Z1 = 27986113.8848523        
DEBUG EVAL: First branch cutoff check: z=27986113.884852, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 19 = 0
ITER 1: row=6, varin=32, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=17, varin=30, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=30, varin=28, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=1, varin=26, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=9, varin=2, theta=0.278028, up=999999999999999983222784.000000
  % 	x19 = 0,	Z0 = 28188973.3273856        
DEBUG EVAL: Second branch cutoff check: z=28188973.327386, best_z=INF, threshold=INF
  %   New best:  x19, Z = 27986113.8848523        
DEBUG EVAL: Testing var 0 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=3, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=29, varin=4, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 0 = 1 gives z=28131004.017928
  % 	x0 = 1,	Z1 = 28131004.017928         
DEBUG EVAL: First branch cutoff check: z=28131004.017928, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 0 = 0
ITER 1: row=1, varin=37, theta=1.000000, up=999999999999999983222784.000000
  % 	x0 = 0,	Z0 = 27987377.2269234        
DEBUG EVAL: Second branch cutoff check: z=27987377.226923, best_z=INF, threshold=INF
  %   New best:  x0, Z = 27987377.2269234        
DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=37, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 0 gives z=27987377.226923
  % 	x1 = 0,	Z0 = 27987377.2269234        
DEBUG EVAL: First branch cutoff check: z=27987377.226923, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 1
ITER 1: row=3, varin=28, theta=1.000000, up=999999999999999983222784.000000
  % 	x1 = 1,	Z1 = 28069888.7642177        
DEBUG EVAL: Second branch cutoff check: z=28069888.764218, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 20 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=9, theta=2.210598, up=999999999999999983222784.000000
ITER 2: row=27, varin=37, theta=2.552151, up=999999999999999983222784.000000
ITER 3: row=1, varin=3, theta=1.962968, up=999999999999999983222784.000000
ITER 4: row=3, varin=21, theta=1.245025, up=999999999999999983222784.000000
ITER 5: row=9, varin=32, theta=0.555298, up=999999999999999983222784.000000
ITER 6: row=17, varin=30, theta=0.952690, up=999999999999999983222784.000000
ITER 7: row=30, varin=23, theta=0.221899, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 20 = 1 gives z=28262233.098748
  % 	x20 = 1,	Z1 = 28262233.098748         
DEBUG EVAL: First branch cutoff check: z=28262233.098748, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 20 = 0
ITER 1: row=2, varin=40, theta=1.708515, up=1.000000
ITER 2: row=2, varin=56, theta=0.212479, up=1.000000
ITER 3: row=10, varin=40, theta=1.000000, up=1.000000
ITER 4: row=20, varin=10, theta=0.466865, up=999999999999999983222784.000000
ITER 5: row=10, varin=17, theta=183556.666667, up=999999999999999983222784.000000
  % 	x20 = 0,	Z0 = 27992778.0056889        
DEBUG EVAL: Second branch cutoff check: z=27992778.005689, best_z=INF, threshold=INF
  %   New best:  x20, Z = 27992778.0056889        
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=9, varin=9, theta=0.532522, up=999999999999999983222784.000000
ITER 2: row=27, varin=17, theta=525300.333333, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 0 gives z=27984367.581000
  % 	x10 = 0,	Z0 = 27984367.5809999        
DEBUG EVAL: First branch cutoff check: z=27984367.581000, best_z=INF, threshold=INF
  % Best branch is x20, Z0 = 27992778.0056889        , Z1 = 28262233.098748         

DEBUG CAREFUL: Final result - returning best.var = 20
DEBUG BB: Branching variable chosen: j=20
 % @NC    9    7	x20 = 0	27992778.005689
 % @NC   10    7	x20 = 1	28262233.098748
 %       7     6 27965296.2775               27991780.7102   x17 D     2     2
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x555cc098d550
% @LO 0.00  27.96529627751406010816 99.9000000000
% @LN 0.00  27.99178071022993208317 99.9000000000
% Resuming node 5 at  27.99178071022993208317
DEBUG CONSTRNT: LP rows=37, pool->nlprows=37, pool->npend=0
DEBUG CONSTRNT: Checking 37 LP rows (pool tracks 37, total LP rows 37)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=36, expected 36
 % @PAP adding 33 rows, 186 nz to LP
DEBUG BB: Processing node 5, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=6, varin=32, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=3, varin=58, theta=2.883292, up=1.000000
ITER 3: row=3, varin=46, theta=0.899822, up=1.000000
ITER 4: row=21, varin=26, theta=0.547687, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=33)
DEBUG SOLUTION: LP solution array indices: FST[34-73], not_covered[74-93]
DEBUG SOLUTION: lp->best_solution[0] = 27991780.710230
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 33 rows, 60 cols, 246 nonzeros, 5 slack, 28 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 7 rows, 23 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=29, varin=77, theta=1.000000, up=1.000000
ITER 2: row=31, varin=60, theta=1.000000, up=1.000000
ITER 3: row=33, varin=29, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=23, varin=45, theta=0.500000, up=1.000000
ITER 5: row=21, varin=36, theta=3.099980, up=1.000000
ITER 6: row=21, varin=24, theta=1.109762, up=999999999999999983222784.000000
ITER 7: row=24, varin=28, theta=2.526859, up=999999999999999983222784.000000
ITER 8: row=22, varin=53, theta=1.111420, up=1.000000
ITER 9: row=22, varin=62, theta=0.106584, up=1.000000
ITER 10: row=23, varin=53, theta=0.541540, up=1.000000
LP PHASE: Switching to primal (iter=10)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=35)
DEBUG SOLUTION: LP solution array indices: FST[36-75], not_covered[76-95]
DEBUG SOLUTION: lp->best_solution[0] = 28122615.028582
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 35 rows, 60 cols, 249 nonzeros, 0 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 8 rows, 32 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=67, theta=0.553724, up=1.000000
ITER 2: row=32, varin=46, theta=0.764380, up=1.000000
ITER 3: row=10, varin=100, theta=1.033610, up=1.000000
ITER 4: row=10, varin=73, theta=0.024030, up=1.000000
ITER 5: row=29, varin=100, theta=1.000000, up=1.000000
ITER 6: row=38, varin=98, theta=0.600031, up=1.000000
ITER 7: row=28, varin=53, theta=0.405770, up=1.000000
ITER 8: row=10, varin=31, theta=0.212737, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28370380.999919
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 281 nonzeros, 1 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 9 rows, 34 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=81, theta=1.000000, up=1.000000
ITER 2: row=43, varin=73, theta=0.916407, up=1.000000
ITER 3: row=34, varin=86, theta=4.003243, up=1.000000
ITER 4: row=34, varin=79, theta=0.780654, up=1.000000
ITER 5: row=50, varin=86, theta=1.315930, up=1.000000
ITER 6: row=50, varin=103, theta=0.026765, up=1.000000
ITER 7: row=11, varin=13, theta=0.966008, up=999999999999999983222784.000000
ITER 8: row=49, varin=86, theta=0.057968, up=1.000000
ITER 9: row=24, varin=52, theta=0.041870, up=1.000000
ITER 10: row=46, varin=21, theta=0.010627, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=10)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28728712.810918
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.042509
DEBUG SOLUTION: lp->best_solution[13] = 2.042509
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 313 nonzeros, 3 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=81, theta=0.562767, up=1.000000
ITER 2: row=49, varin=87, theta=1.012746, up=1.000000
ITER 3: row=49, varin=4, theta=0.003198, up=999999999999999983222784.000000
ITER 4: row=41, varin=87, theta=1.000000, up=1.000000
ITER 5: row=44, varin=93, theta=0.251533, up=1.000000
ITER 6: row=20, varin=83, theta=0.964819, up=1.000000
ITER 7: row=48, varin=92, theta=0.004776, up=1.000000
ITER 8: row=50, varin=42, theta=0.000936, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28926528.757129
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.999064
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 50 rows, 60 cols, 309 nonzeros, 3 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 9 rows, 23 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=88, theta=0.925718, up=1.000000
ITER 2: row=54, varin=45, theta=0.028030, up=999999999999999983222784.000000
ITER 3: row=49, varin=39, theta=0.092442, up=999999999999999983222784.000000
ITER 4: row=53, varin=44, theta=0.063030, up=999999999999999983222784.000000
ITER 5: row=54, varin=53, theta=0.024117, up=999999999999999983222784.000000
ITER 6: row=49, varin=38, theta=0.005276, up=999999999999999983222784.000000
ITER 7: row=48, varin=39, theta=0.046057, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 28978461.698309
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1800000.000000
  % @PL 56 rows, 60 cols, 324 nonzeros, 5 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=64, theta=0.591453, up=1.000000
ITER 2: row=35, varin=54, theta=0.207134, up=1.000000
ITER 3: row=47, varin=83, theta=0.240170, up=1.000000
ITER 4: row=41, varin=35, theta=1.727315, up=999999999999999983222784.000000
ITER 5: row=52, varin=51, theta=0.307037, up=999999999999999983222784.000000
ITER 6: row=9, varin=81, theta=0.984825, up=1.000000
ITER 7: row=16, varin=46, theta=0.658172, up=999999999999999983222784.000000
ITER 8: row=19, varin=75, theta=0.499739, up=1.000000
ITER 9: row=32, varin=41, theta=0.988769, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1800000.000000
  % @PL 52 rows, 60 cols, 303 nonzeros, 3 slack, 49 tight.
  % Node 5 LP 1 Solution, length = 999999999999999983222784.000000, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.015352 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.015352 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.500000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.938591 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.015352 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.015352 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.984648 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.984648 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 5 is INFEASIBLE
 %       5     5    infeasible               27992778.0057   x19 U     3     3
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x555cc09962c0
% @LO 0.00  27.99178071022993208317 99.9000000000
% @LN 0.00  27.99277800568886931387 99.9000000000
% Resuming node 9 at  27.99277800568886931387
DEBUG CONSTRNT: LP rows=52, pool->nlprows=52, pool->npend=0
DEBUG CONSTRNT: Checking 52 LP rows (pool tracks 52, total LP rows 52)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 141
DEBUG CONSTRNT: Pool row 141 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 134
DEBUG CONSTRNT: Pool row 134 has lprow=51, expected 51
 % @PAP adding 37 rows, 193 nz to LP
DEBUG BB: Processing node 9, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=2, varin=40, theta=1.708515, up=1.000000
ITER 2: row=2, varin=56, theta=0.212479, up=1.000000
ITER 3: row=10, varin=40, theta=1.000000, up=1.000000
ITER 4: row=20, varin=10, theta=0.466865, up=999999999999999983222784.000000
ITER 5: row=10, varin=17, theta=183556.666667, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
ITER 6: row=1, varin=53, theta=0.333333, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 27984367.581000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 37 rows, 60 cols, 253 nonzeros, 1 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 9 LP 1 Solution, length = 27984367.581000, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.500000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.333333 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.666667 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.500000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.333333 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.333333 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.333333 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.333333 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=27984367.581000, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27984367.581000, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 9 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 9
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.500000
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.500000
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.333333
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.666667
DEBUG CAREFUL: Adding var 19 to fractional list (xi=0.666667)
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 15
DEBUG CAREFUL: New best var: 15
DEBUG CAREFUL: Testing fvar[1] = var 19
DEBUG CAREFUL: Calling compare_branch_vars for var 19
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 19
DEBUG CAREFUL: New best var: 19
DEBUG CAREFUL: Testing fvar[2] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 0
DEBUG CAREFUL: New best var: 0
DEBUG CAREFUL: Testing fvar[3] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
  % Initial guess is x0, Z0 = 27987377.2269234        , Z1 = 28131004.017928         

DEBUG EVAL: Testing var 15 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=23, varin=36, theta=0.285714, up=999999999999999983222784.000000
ITER 2: row=20, varin=26, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=17, varin=30, theta=0.385080, up=999999999999999983222784.000000
ITER 4: row=9, varin=17, theta=280586.000000, up=999999999999999983222784.000000
ITER 5: row=30, varin=28, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 15 = 1 gives z=28192743.629625
  % 	x15 = 1,	Z1 = 28192743.6296252        
DEBUG EVAL: First branch cutoff check: z=28192743.629625, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 15 = 0
ITER 1: row=23, varin=40, theta=0.600000, up=1.000000
ITER 2: row=10, varin=45, theta=0.250000, up=1.000000
ITER 3: row=19, varin=56, theta=0.333333, up=1.000000
  % 	x15 = 0,	Z0 = 27992778.0056889        
DEBUG EVAL: Second branch cutoff check: z=27992778.005689, best_z=INF, threshold=INF
  %   New best:  x15, Z = 27992778.0056889        
DEBUG EVAL: Testing var 19 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=40, theta=0.600000, up=1.000000
ITER 2: row=10, varin=56, theta=0.333333, up=1.000000
DEBUG EVAL: Branch var 19 = 1 gives z=27992778.005689
  % 	x19 = 1,	Z1 = 27992778.0056889        
DEBUG EVAL: First branch cutoff check: z=27992778.005689, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 19 = 0
ITER 1: row=6, varin=32, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=20, varin=26, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=17, varin=30, theta=0.385080, up=999999999999999983222784.000000
ITER 4: row=9, varin=17, theta=280586.000000, up=999999999999999983222784.000000
ITER 5: row=30, varin=28, theta=1.000000, up=999999999999999983222784.000000
  % 	x19 = 0,	Z0 = 28192743.6296252        
DEBUG EVAL: Second branch cutoff check: z=28192743.629625, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 0 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=37, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 0 = 0 gives z=28018427.174763
  % 	x0 = 0,	Z0 = 28018427.1747634        
DEBUG EVAL: First branch cutoff check: z=28018427.174763, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 0 = 1
ITER 1: row=1, varin=3, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=29, varin=4, theta=1.000000, up=999999999999999983222784.000000
  % 	x0 = 1,	Z1 = 28148672.5244013        
DEBUG EVAL: Second branch cutoff check: z=28148672.524401, best_z=INF, threshold=INF
  %   New best:  x0, Z = 28018427.1747634        
DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=3, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=29, varin=37, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 0 gives z=28018427.174763
  % 	x1 = 0,	Z0 = 28018427.1747634        
DEBUG EVAL: First branch cutoff check: z=28018427.174763, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 1
ITER 1: row=3, varin=28, theta=1.000000, up=999999999999999983222784.000000
  % 	x1 = 1,	Z1 = 28092571.1360684        
DEBUG EVAL: Second branch cutoff check: z=28092571.136068, best_z=INF, threshold=INF
  % Best branch is x0, Z0 = 28018427.1747634        , Z1 = 28148672.5244013        

DEBUG CAREFUL: Final result - returning best.var = 0
DEBUG BB: Branching variable chosen: j=0
 % @NC   11    9	x0 = 0	28018427.174763
 % @NC   12    9	x0 = 1	28148672.524401
 %       9     6 27984367.5810               28018427.1748   x20 D     7     3
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x555cc098d550
% @LO 0.00  27.99277800568886931387 99.9000000000
% @LN 0.00  28.01842717476336730442 99.9000000000
% Resuming node 11 at  28.01842717476336730442
DEBUG CONSTRNT: LP rows=37, pool->nlprows=37, pool->npend=0
DEBUG CONSTRNT: Checking 37 LP rows (pool tracks 37, total LP rows 37)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=36, expected 36
 % @PAP adding 37 rows, 193 nz to LP
DEBUG BB: Processing node 11, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=37, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 28018427.174763
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 37 rows, 60 cols, 253 nonzeros, 2 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 11 LP 1 Solution, length = 28018427.174763, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.333333 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.666667 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.333333 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.333333 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.333333 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.333333 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 2 fractional variables
DEBUG CG: LP optimal, z=28018427.174763, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28018427.174763, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 11 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 11
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.333333
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.666667
DEBUG CAREFUL: Adding var 19 to fractional list (xi=0.666667)
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 2 fractional variables

  %  Carefully choosing branching variable, nfrac = 2
DEBUG CAREFUL: Testing fvar[0] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 15
DEBUG CAREFUL: New best var: 15
DEBUG CAREFUL: Testing fvar[1] = var 19
DEBUG CAREFUL: Calling compare_branch_vars for var 19
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 19
  % Initial guess is x15, Z0 = 28018427.1747634        , Z1 = 28192743.6296252        

DEBUG EVAL: Testing var 15 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=23, varin=36, theta=0.285714, up=999999999999999983222784.000000
ITER 2: row=1, varin=28, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=3, varin=26, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 15 = 1 gives z=28192743.629625
  % 	x15 = 1,	Z1 = 28192743.6296252        
DEBUG EVAL: First branch cutoff check: z=28192743.629625, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 15 = 0
ITER 1: row=23, varin=40, theta=0.600000, up=1.000000
ITER 2: row=10, varin=45, theta=0.250000, up=1.000000
ITER 3: row=19, varin=56, theta=0.333333, up=1.000000
  % 	x15 = 0,	Z0 = 28026837.5994523        
DEBUG EVAL: Second branch cutoff check: z=28026837.599452, best_z=INF, threshold=INF
  %   New best:  x15, Z = 28026837.5994523        
DEBUG EVAL: Testing var 19 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=40, theta=0.600000, up=1.000000
ITER 2: row=10, varin=56, theta=0.333333, up=1.000000
DEBUG EVAL: Branch var 19 = 1 gives z=28026837.599452
  % 	x19 = 1,	Z1 = 28026837.5994523        
DEBUG EVAL: First branch cutoff check: z=28026837.599452, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 19 = 0
ITER 1: row=6, varin=28, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=3, varin=32, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=1, varin=26, theta=1.000000, up=999999999999999983222784.000000
  % 	x19 = 0,	Z0 = 28192743.6296252        
DEBUG EVAL: Second branch cutoff check: z=28192743.629625, best_z=INF, threshold=INF
  % Best branch is x15, Z0 = 28026837.5994523        , Z1 = 28192743.6296252        

DEBUG CAREFUL: Final result - returning best.var = 15
DEBUG BB: Branching variable chosen: j=15
 % @NC   13   11	x15 = 0	28026837.599452
 % @NC   14   11	x15 = 1	28192743.629625
 %      11     7 28018427.1748               28018731.2562    x0 D     9     4
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x555cc099b340
% @LO 0.00  28.01842717476336730442 99.9000000000
% @LN 0.00  28.01873125618523374669 99.9000000000
% Resuming node 6 at  28.01873125618523374669
DEBUG CONSTRNT: LP rows=37, pool->nlprows=37, pool->npend=0
DEBUG CONSTRNT: Checking 37 LP rows (pool tracks 37, total LP rows 37)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=36, expected 36
 % @PAP adding 33 rows, 186 nz to LP
DEBUG BB: Processing node 6, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=6, varin=21, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=29, varin=6, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=30, varin=7, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=31, varin=19, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=21, varin=8, theta=0.343641, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=33)
DEBUG SOLUTION: LP solution array indices: FST[34-73], not_covered[74-93]
DEBUG SOLUTION: lp->best_solution[0] = 28018731.256185
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.656359
DEBUG SOLUTION: lp->best_solution[7] = 0.656359
DEBUG SOLUTION: lp->best_solution[8] = 0.656359
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 33 rows, 60 cols, 246 nonzeros, 6 slack, 27 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 5 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=34, varin=80, theta=1.188072, up=1.000000
ITER 2: row=34, varin=63, theta=0.369066, up=1.000000
ITER 3: row=1, varin=24, theta=2.819554, up=999999999999999983222784.000000
ITER 4: row=34, varin=80, theta=0.536518, up=1.000000
ITER 5: row=37, varin=63, theta=0.039348, up=1.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 28038862.706518
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.500000
DEBUG SOLUTION: lp->best_solution[7] = 0.500000
DEBUG SOLUTION: lp->best_solution[8] = 0.500000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 38 rows, 60 cols, 260 nonzeros, 8 slack, 30 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 8 slack rows
  % @PAP adding 6 rows, 20 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=31, varin=38, theta=0.225908, up=1.000000
ITER 2: row=35, varin=52, theta=0.111111, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=36)
DEBUG SOLUTION: LP solution array indices: FST[37-76], not_covered[77-96]
DEBUG SOLUTION: lp->best_solution[0] = 28047005.602786
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1800000.000000
  % @PL 36 rows, 60 cols, 255 nonzeros, 2 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 4 rows, 16 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=35, varin=53, theta=0.111111, up=1.000000
ITER 2: row=38, varin=12, theta=0.019231, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 28054028.478183
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.980769
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1800000.000000
  % @PL 38 rows, 60 cols, 260 nonzeros, 2 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=37, varin=11, theta=0.119048, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 28055689.877591
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.880952
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 37 rows, 60 cols, 258 nonzeros, 2 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=49, theta=0.133333, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=36)
DEBUG SOLUTION: LP solution array indices: FST[37-76], not_covered[77-96]
DEBUG SOLUTION: lp->best_solution[0] = 28056077.531733
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 36 rows, 60 cols, 253 nonzeros, 0 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 9 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=34, theta=0.166667, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 28057300.922040
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 39 rows, 60 cols, 262 nonzeros, 2 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 6 LP 1 Solution, length = 28057300.922040, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.230052 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.230052 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.111111 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.055556 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.444444 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.055556 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.055556 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.444444 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.769948 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.555556 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.769948 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.769948 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.555556 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.555556 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.555556 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.769948 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.555556 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.944444 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.944444 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 8 fractional variables
DEBUG CG: LP optimal, z=28057300.922040, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 6 at  28.05730092204044723303
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x555cc09962c0
% @LO 0.00  28.01873125618523374669 99.9000000000
% @LN 0.00  28.02683759945233532562 99.9000000000
% Resuming node 13 at  28.02683759945233532562
DEBUG CONSTRNT: LP rows=37, pool->nlprows=37, pool->npend=0
DEBUG CONSTRNT: Checking 37 LP rows (pool tracks 37, total LP rows 37)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=36, expected 36
 % @PAP adding 37 rows, 193 nz to LP
DEBUG BB: Processing node 13, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=23, varin=40, theta=0.600000, up=1.000000
ITER 2: row=10, varin=45, theta=0.250000, up=1.000000
ITER 3: row=19, varin=56, theta=0.333333, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 28026837.599452
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 37 rows, 60 cols, 253 nonzeros, 2 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 8 rows, 42 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=60, theta=0.333333, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28034193.849823
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 295 nonzeros, 4 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % Node 13 LP 1 Solution, length = 28034193.849823, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.333333 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.666667 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.333333 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.333333 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.333333 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.333333 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 2 fractional variables
DEBUG CG: LP optimal, z=28034193.849823, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.00  28.02683759945233532562 99.9000000000
 % @LN 0.00  28.03419384982273143692 99.9000000000
DEBUG CG: Second cutoff check: z=28034193.849823, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 13 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 13
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.333333
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.666667
DEBUG CAREFUL: Adding var 19 to fractional list (xi=0.666667)
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 2 fractional variables

  %  Carefully choosing branching variable, nfrac = 2
DEBUG CAREFUL: Testing fvar[0] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 14
DEBUG CAREFUL: New best var: 14
DEBUG CAREFUL: Testing fvar[1] = var 19
DEBUG CAREFUL: Calling compare_branch_vars for var 19
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 19
  % Initial guess is x14, Z0 = 28034193.8498227        , Z1 = 28201234.6513547        

DEBUG EVAL: Testing var 14 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=22, varin=34, theta=0.666667, up=999999999999999983222784.000000
ITER 2: row=34, varin=18, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=10, varin=10, theta=0.800000, up=999999999999999983222784.000000
ITER 4: row=1, varin=27, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=3, varin=25, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 14 = 1 gives z=28240043.654803
  % 	x14 = 1,	Z1 = 28240043.6548033        
DEBUG EVAL: First branch cutoff check: z=28240043.654803, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 14 = 0
ITER 1: row=22, varin=68, theta=1.000000, up=1.000000
ITER 2: row=41, varin=51, theta=0.250000, up=1.000000
ITER 3: row=37, varin=25, theta=0.043478, up=999999999999999983222784.000000
  % 	x14 = 0,	Z0 = 28058848.0385829        
DEBUG EVAL: Second branch cutoff check: z=28058848.038583, best_z=INF, threshold=INF
  %   New best:  x14, Z = 28058848.0385829        
DEBUG EVAL: Testing var 19 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=68, theta=1.000000, up=1.000000
ITER 2: row=41, varin=25, theta=0.142857, up=999999999999999983222784.000000
ITER 3: row=6, varin=65, theta=0.125000, up=1.000000
ITER 4: row=30, varin=45, theta=0.062500, up=1.000000
ITER 5: row=35, varin=5, theta=0.006993, up=999999999999999983222784.000000
ITER 6: row=39, varin=21, theta=0.009688, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 19 = 1 gives z=28067299.749079
  % 	x19 = 1,	Z1 = 28067299.7490793        
DEBUG EVAL: First branch cutoff check: z=28067299.749079, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 19 = 0
ITER 1: row=6, varin=34, theta=0.666667, up=999999999999999983222784.000000
ITER 2: row=34, varin=10, theta=0.800000, up=999999999999999983222784.000000
ITER 3: row=1, varin=18, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=10, varin=27, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=3, varin=25, theta=1.000000, up=999999999999999983222784.000000
  % 	x19 = 0,	Z0 = 28240043.6548033        
DEBUG EVAL: Second branch cutoff check: z=28240043.654803, best_z=INF, threshold=INF
  %   New best:  x19, Z = 28067299.7490793        
  % Best branch is x19, Z0 = 28240043.6548033        , Z1 = 28067299.7490793        

DEBUG CAREFUL: Final result - returning best.var = 19
DEBUG BB: Branching variable chosen: j=19
 % @NC   15   13	x19 = 1	28067299.749079
 % @NC   16   13	x19 = 0	28240043.654803
 %      13     8 28034193.8498               28057300.9220   x15 D    11     5
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x555cc099b340
% @LO 0.00  28.03419384982273143692 99.9000000000
% @LN 0.00  28.05730092204044723303 99.9000000000
% Resuming node 6 at  28.05730092204044723303
DEBUG CONSTRNT: LP rows=41, pool->nlprows=41, pool->npend=0
DEBUG CONSTRNT: Checking 41 LP rows (pool tracks 41, total LP rows 41)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=40, expected 40
 % @PAP adding 37 rows, 190 nz to LP
DEBUG BB: Processing node 6, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 6 LP 2 Solution, length = 28057300.922040, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.230052 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.230052 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.111111 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.055556 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.444444 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.055556 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.055556 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.444444 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.769948 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.555556 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.769948 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.769948 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.555556 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.555556 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.555556 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.769948 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.555556 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.944444 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.944444 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 8 fractional variables
DEBUG CG: LP optimal, z=28057300.922040, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28057300.922040, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 3 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 6 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 6
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.230052
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.230052)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.230052
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.230052)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.111111
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.111111)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.055556
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.055556)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.444444
DEBUG CAREFUL: Adding var 13 to fractional list (xi=0.444444)
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.055556
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.055556)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.055556
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.055556)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.444444
DEBUG CAREFUL: Adding var 16 to fractional list (xi=0.444444)
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=1.000000
DEBUG CAREFUL: Skipping var 20: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 8 fractional variables

  %  Carefully choosing branching variable, nfrac = 8
DEBUG CAREFUL: Testing fvar[0] = var 13
DEBUG CAREFUL: Calling compare_branch_vars for var 13
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 13
DEBUG CAREFUL: New best var: 13
DEBUG CAREFUL: Testing fvar[1] = var 16
DEBUG CAREFUL: Calling compare_branch_vars for var 16
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 16
DEBUG CAREFUL: Testing fvar[2] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 14
DEBUG CAREFUL: New best var: 14
DEBUG CAREFUL: Testing fvar[3] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
DEBUG CAREFUL: Testing fvar[4] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
DEBUG CAREFUL: Testing fvar[5] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 15
DEBUG CAREFUL: Testing fvar[6] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
DEBUG CAREFUL: Testing fvar[7] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
  % Initial guess is x14, Z0 = 28057300.9220404        , Z1 = 28274210.6411159        

DEBUG EVAL: Testing var 13 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=13, varin=37, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=15, varin=22, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=26, varin=20, theta=0.750000, up=999999999999999983222784.000000
ITER 4: row=28, varin=31, theta=3.000000, up=999999999999999983222784.000000
ITER 5: row=31, varin=23, theta=0.600000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 13 = 0 gives z=28163102.665210
  % 	x13 = 0,	Z0 = 28163102.6652096        
DEBUG EVAL: First branch cutoff check: z=28163102.665210, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 13 = 1
ITER 1: row=13, varin=55, theta=1.666667, up=1.000000
ITER 2: row=13, varin=27, theta=0.666667, up=999999999999999983222784.000000
ITER 3: row=1, varin=55, theta=0.763603, up=1.000000
ITER 4: row=27, varin=35, theta=1.329996, up=999999999999999983222784.000000
ITER 5: row=36, varin=3, theta=0.716993, up=999999999999999983222784.000000
ITER 6: row=3, varin=25, theta=0.890278, up=999999999999999983222784.000000
ITER 7: row=25, varin=24, theta=1.196875, up=999999999999999983222784.000000
ITER 8: row=14, varin=64, theta=1.299644, up=1.000000
ITER 9: row=14, varin=61, theta=0.265634, up=1.000000
ITER 10: row=32, varin=40, theta=0.366690, up=1.000000
  % 	x13 = 1,	Z1 = 28285643.3154198        
DEBUG EVAL: Second branch cutoff check: z=28285643.315420, best_z=INF, threshold=INF
  %   New best:  x13, Z = 28163102.6652096        
DEBUG EVAL: Testing var 16 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=25, varin=37, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=15, varin=27, theta=0.600000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 16 = 0 gives z=28087222.915538
  % 	x16 = 0,	Z0 = 28087222.9155385        
DEBUG EVAL: First branch cutoff check: z=28087222.915538, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 14 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=17, varin=35, theta=2.428571, up=999999999999999983222784.000000
ITER 2: row=36, varin=37, theta=1.545455, up=999999999999999983222784.000000
ITER 3: row=20, varin=36, theta=1.500000, up=999999999999999983222784.000000
ITER 4: row=15, varin=31, theta=3.000000, up=999999999999999983222784.000000
ITER 5: row=31, varin=27, theta=2.000000, up=999999999999999983222784.000000
ITER 6: row=25, varin=29, theta=3.000000, up=999999999999999983222784.000000
ITER 7: row=1, varin=24, theta=1.361493, up=999999999999999983222784.000000
ITER 8: row=14, varin=14, theta=0.968007, up=999999999999999983222784.000000
ITER 9: row=24, varin=17, theta=0.859864, up=999999999999999983222784.000000
ITER 10: row=3, varin=3, theta=0.576036, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 14 = 1 gives z=28306206.901500
  % 	x14 = 1,	Z1 = 28306206.9015           
DEBUG EVAL: First branch cutoff check: z=28306206.901500, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 14 = 0
ITER 1: row=17, varin=55, theta=0.166667, up=1.000000
  % 	x14 = 0,	Z0 = 28061535.9382224        
DEBUG EVAL: Second branch cutoff check: z=28061535.938222, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 7 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=12, varin=55, theta=0.166667, up=1.000000
DEBUG EVAL: Branch var 7 = 0 gives z=28061535.938222
  % 	x7 = 0,	Z0 = 28061535.9382224        
DEBUG EVAL: First branch cutoff check: z=28061535.938222, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 12 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=15, varin=35, theta=2.428571, up=999999999999999983222784.000000
ITER 2: row=36, varin=34, theta=1.888889, up=999999999999999983222784.000000
ITER 3: row=17, varin=33, theta=0.888889, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 12 = 1 gives z=28180138.561307
  % 	x12 = 1,	Z1 = 28180138.561307         
DEBUG EVAL: First branch cutoff check: z=28180138.561307, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 0
ITER 1: row=15, varin=37, theta=0.071429, up=999999999999999983222784.000000
  % 	x12 = 0,	Z0 = 28058174.7722601        
DEBUG EVAL: Second branch cutoff check: z=28058174.772260, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 15 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=20, varin=37, theta=4.250000, up=999999999999999983222784.000000
ITER 2: row=15, varin=34, theta=1.444444, up=999999999999999983222784.000000
ITER 3: row=17, varin=31, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=31, varin=27, theta=1.333333, up=999999999999999983222784.000000
ITER 5: row=25, varin=29, theta=2.000000, up=999999999999999983222784.000000
ITER 6: row=1, varin=24, theta=0.881304, up=999999999999999983222784.000000
ITER 7: row=14, varin=14, theta=0.626597, up=999999999999999983222784.000000
ITER 8: row=24, varin=17, theta=0.556596, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 15 = 1 gives z=28250623.677473
  % 	x15 = 1,	Z1 = 28250623.6774732        
DEBUG EVAL: First branch cutoff check: z=28250623.677473, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 15 = 0
ITER 1: row=20, varin=35, theta=0.090909, up=999999999999999983222784.000000
ITER 2: row=36, varin=55, theta=0.166667, up=1.000000
  % 	x15 = 0,	Z0 = 28061535.9382224        
DEBUG EVAL: Second branch cutoff check: z=28061535.938222, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 0 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=55, theta=0.327055, up=1.000000
ITER 2: row=12, varin=13, theta=0.076878, up=999999999999999983222784.000000
ITER 3: row=17, varin=37, theta=0.226565, up=999999999999999983222784.000000
ITER 4: row=15, varin=29, theta=0.153333, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 0 = 0 gives z=28068585.374599
  % 	x0 = 0,	Z0 = 28068585.3745987        
DEBUG EVAL: First branch cutoff check: z=28068585.374599, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=55, theta=0.327055, up=1.000000
ITER 2: row=12, varin=13, theta=0.076878, up=999999999999999983222784.000000
ITER 3: row=17, varin=3, theta=0.186586, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 0 gives z=28068099.828311
  % 	x1 = 0,	Z0 = 28068099.8283114        
DEBUG EVAL: First branch cutoff check: z=28068099.828311, best_z=INF, threshold=INF
  % Best branch is x13, Z0 = 28163102.6652096        , Z1 = 28285643.3154198        

DEBUG CAREFUL: Final result - returning best.var = 13
DEBUG BB: Branching variable chosen: j=13
 % @NC   17    6	x13 = 0	28163102.665210
 % @NC   18    6	x13 = 1	28285643.315420
 %       6     9 28057300.9220               28067299.7491   x19 D     3     3
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x555cc098d550
% @LO 0.00  28.05730092204044723303 99.9000000000
% @LN 0.00  28.06729974907928237826 99.9000000000
% Resuming node 15 at  28.06729974907928237826
DEBUG CONSTRNT: LP rows=37, pool->nlprows=37, pool->npend=0
DEBUG CONSTRNT: Checking 37 LP rows (pool tracks 37, total LP rows 37)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=36, expected 36
 % @PAP adding 41 rows, 185 nz to LP
DEBUG BB: Processing node 15, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=6, varin=68, theta=1.000000, up=1.000000
ITER 2: row=41, varin=25, theta=0.142857, up=999999999999999983222784.000000
ITER 3: row=6, varin=65, theta=0.125000, up=1.000000
ITER 4: row=30, varin=45, theta=0.062500, up=1.000000
ITER 5: row=35, varin=5, theta=0.006993, up=999999999999999983222784.000000
ITER 6: row=39, varin=21, theta=0.009688, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28067299.749079
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.992465
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 41 rows, 60 cols, 245 nonzeros, 8 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 8 rows, 22 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=76, theta=0.991453, up=1.000000
ITER 2: row=42, varin=106, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28099828.257485
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 267 nonzeros, 1 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=13, theta=1.623188, up=999999999999999983222784.000000
ITER 2: row=36, varin=60, theta=1.000000, up=1.000000
ITER 3: row=22, varin=41, theta=0.608696, up=999999999999999983222784.000000
ITER 4: row=38, varin=34, theta=0.125000, up=999999999999999983222784.000000
ITER 5: row=13, varin=87, theta=0.111111, up=1.000000
ITER 6: row=18, varin=39, theta=0.352941, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28150982.175375
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.882353
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 271 nonzeros, 13 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 13 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=92, theta=0.937500, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 28177716.381187
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 38 rows, 60 cols, 227 nonzeros, 0 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=51, theta=0.437500, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 28203853.725677
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 39 rows, 60 cols, 229 nonzeros, 0 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 5 rows, 24 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=49, theta=0.375000, up=1.000000
ITER 2: row=32, varin=2, theta=0.066667, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28217220.257824
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 0.933333
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 253 nonzeros, 2 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=75, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28222150.682981
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 249 nonzeros, 0 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=31, theta=0.923077, up=999999999999999983222784.000000
ITER 2: row=45, varin=26, theta=0.571429, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28230940.373495
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 262 nonzeros, 3 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % Node 15 LP 1 Solution, length = 28230940.373495, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.142857 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.142857 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.142857 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.142857 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.142857 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.142857 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.142857 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.857143 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.857143 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.857143 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.857143 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.857143 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.857143 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.857143 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=28230940.373495, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 15 at  28.23094037349540741388
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x555cc0985600
% @LO 0.00  28.06729974907928237826 99.9000000000
% @LN 0.00  28.14867252440126321744 99.9000000000
% Resuming node 12 at  28.14867252440126321744
DEBUG CONSTRNT: LP rows=46, pool->nlprows=46, pool->npend=0
DEBUG CONSTRNT: Checking 46 LP rows (pool tracks 46, total LP rows 46)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=45, expected 45
 % @PAP adding 37 rows, 193 nz to LP
DEBUG BB: Processing node 12, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=3, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=29, varin=4, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 28148672.524401
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 37 rows, 60 cols, 253 nonzeros, 3 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=43, theta=0.300000, up=1.000000
ITER 2: row=10, varin=59, theta=0.166667, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28152877.736746
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 259 nonzeros, 3 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 8 rows, 42 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=53, theta=0.200000, up=1.000000
ITER 2: row=16, varin=72, theta=0.500000, up=1.000000
ITER 3: row=45, varin=60, theta=0.333333, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28164439.199461
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 3.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 45 rows, 60 cols, 257 nonzeros, 2 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 12 LP 1 Solution, length = 28164439.199461, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 1.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.333333 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.333333 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.333333 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.666667 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.666667 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.666667 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.666667 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28164439.199461, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 12 at  28.16443919946062024451
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x555cc09962c0
% @LO 0.00  28.14867252440126321744 99.9000000000
% @LN 0.00  28.16310266520961747005 99.9000000000
% Resuming node 17 at  28.16310266520961747005
DEBUG CONSTRNT: LP rows=43, pool->nlprows=43, pool->npend=0
DEBUG CONSTRNT: Checking 43 LP rows (pool tracks 43, total LP rows 43)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=42, expected 42
 % @PAP adding 37 rows, 190 nz to LP
DEBUG BB: Processing node 17, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=13, varin=37, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=15, varin=22, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=26, varin=20, theta=0.750000, up=999999999999999983222784.000000
ITER 4: row=28, varin=31, theta=3.000000, up=999999999999999983222784.000000
ITER 5: row=31, varin=23, theta=0.600000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 28163102.665210
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 37 rows, 60 cols, 250 nonzeros, 5 slack, 32 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=34, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 28169784.551655
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 39 rows, 60 cols, 258 nonzeros, 6 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % Node 17 LP 1 Solution, length = 28169784.551655, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.051121 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.051121 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.500000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.500000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.500000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.948879 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.948879 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.948879 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.948879 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28169784.551655, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 17 at  28.16978455165538264282
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x555cc0985600
% @LO 0.00  28.16310266520961747005 99.9000000000
% @LN 0.00  28.16443919946062024451 99.9000000000
% Resuming node 12 at  28.16443919946062024451
DEBUG CONSTRNT: LP rows=33, pool->nlprows=33, pool->npend=0
DEBUG CONSTRNT: Checking 33 LP rows (pool tracks 33, total LP rows 33)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=32, expected 32
 % @PAP adding 43 rows, 190 nz to LP
DEBUG BB: Processing node 12, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 12 LP 2 Solution, length = 28164439.199461, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 1.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.333333 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.333333 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.333333 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.666667 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.666667 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.666667 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.666667 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28164439.199461, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28164439.199461, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 12 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 12
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=1.000000
DEBUG CAREFUL: Skipping var 0: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.333333
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.333333
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.333333
DEBUG CAREFUL: Adding var 19 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 3 fractional variables

  %  Carefully choosing branching variable, nfrac = 3
DEBUG CAREFUL: Testing fvar[0] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 14
DEBUG CAREFUL: New best var: 14
DEBUG CAREFUL: Testing fvar[1] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 15
DEBUG CAREFUL: Testing fvar[2] = var 19
DEBUG CAREFUL: Calling compare_branch_vars for var 19
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 19
  % Initial guess is x14, Z0 = 28164439.1994606        , Z1 = 28201234.6513547        

DEBUG EVAL: Testing var 14 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=20, varin=43, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=43, varin=16, theta=0.400000, up=999999999999999983222784.000000
ITER 3: row=8, varin=36, theta=0.333333, up=999999999999999983222784.000000
ITER 4: row=36, varin=8, theta=0.400000, up=999999999999999983222784.000000
ITER 5: row=1, varin=33, theta=0.666667, up=999999999999999983222784.000000
ITER 6: row=33, varin=23, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 14 = 1 gives z=28296145.043136
  % 	x14 = 1,	Z1 = 28296145.0431362        
DEBUG EVAL: First branch cutoff check: z=28296145.043136, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 14 = 0
ITER 1: row=20, varin=23, theta=0.071429, up=999999999999999983222784.000000
  % 	x14 = 0,	Z0 = 28171512.7104374        
DEBUG EVAL: Second branch cutoff check: z=28171512.710437, best_z=INF, threshold=INF
  %   New best:  x14, Z = 28171512.7104374        
DEBUG EVAL: Testing var 15 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=33, varin=23, theta=0.285714, up=999999999999999983222784.000000
ITER 2: row=43, varin=67, theta=1.125000, up=1.000000
ITER 3: row=43, varin=47, theta=0.062500, up=1.000000
ITER 4: row=20, varin=80, theta=1.000000, up=1.000000
ITER 5: row=8, varin=5, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=28, varin=67, theta=1.000000, up=1.000000
ITER 7: row=34, varin=12, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=35, varin=13, theta=1.000000, up=999999999999999983222784.000000
ITER 9: row=37, varin=3, theta=0.062937, up=999999999999999983222784.000000
ITER 10: row=41, varin=19, theta=0.087191, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 15 = 1 gives z=28677525.836443
  % 	x15 = 1,	Z1 = 28677525.8364427        
DEBUG EVAL: First branch cutoff check: z=28677525.836443, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 15 = 0
ITER 1: row=33, varin=43, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=43, varin=33, theta=0.333333, up=999999999999999983222784.000000
  % 	x15 = 0,	Z0 = 28180205.87452          
DEBUG EVAL: Second branch cutoff check: z=28180205.874520, best_z=INF, threshold=INF
  %   New best:  x15, Z = 28180205.87452          
DEBUG EVAL: Testing var 19 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=4, varin=23, theta=0.285714, up=999999999999999983222784.000000
ITER 2: row=43, varin=67, theta=1.125000, up=1.000000
ITER 3: row=43, varin=47, theta=0.062500, up=1.000000
ITER 4: row=20, varin=33, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=28, varin=67, theta=1.000000, up=1.000000
ITER 6: row=37, varin=3, theta=0.062937, up=999999999999999983222784.000000
ITER 7: row=41, varin=19, theta=0.087191, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 19 = 1 gives z=28268763.088738
  % 	x19 = 1,	Z1 = 28268763.088738         
DEBUG EVAL: First branch cutoff check: z=28268763.088738, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 19 = 0
ITER 1: row=4, varin=43, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=43, varin=36, theta=0.333333, up=999999999999999983222784.000000
ITER 3: row=36, varin=8, theta=0.400000, up=999999999999999983222784.000000
ITER 4: row=1, varin=16, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=8, varin=5, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=34, varin=23, theta=1.000000, up=999999999999999983222784.000000
  % 	x19 = 0,	Z0 = 28296145.0431362        
DEBUG EVAL: Second branch cutoff check: z=28296145.043136, best_z=INF, threshold=INF
  %   New best:  x19, Z = 28268763.088738         
  % Best branch is x19, Z0 = 28296145.0431362        , Z1 = 28268763.088738         

DEBUG CAREFUL: Final result - returning best.var = 19
DEBUG BB: Branching variable chosen: j=19
 % @NC   19   12	x19 = 1	28268763.088738
 % @NC   20   12	x19 = 0	28296145.043136
 %      12    10 28164439.1995               28169784.5517    x0 U     9     4
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x555cc09962c0
% @LO 0.00  28.16443919946062024451 99.9000000000
% @LN 0.00  28.16978455165538264282 99.9000000000
% Resuming node 17 at  28.16978455165538264282
DEBUG CONSTRNT: LP rows=43, pool->nlprows=43, pool->npend=0
DEBUG CONSTRNT: Checking 43 LP rows (pool tracks 43, total LP rows 43)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=42, expected 42
 % @PAP adding 33 rows, 186 nz to LP
DEBUG BB: Processing node 17, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 17 LP 2 Solution, length = 28169784.551655, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.051121 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.051121 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.500000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.500000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.500000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.948879 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.948879 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.948879 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.948879 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28169784.551655, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28169784.551655, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 3 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 17 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 17
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.051121
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.051121)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.051121
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.051121)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.500000
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.500000
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.500000
DEBUG CAREFUL: Adding var 16 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=1.000000
DEBUG CAREFUL: Skipping var 20: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 16
DEBUG CAREFUL: Calling compare_branch_vars for var 16
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 16
DEBUG CAREFUL: New best var: 16
DEBUG CAREFUL: Testing fvar[1] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
DEBUG CAREFUL: Testing fvar[2] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 15
DEBUG CAREFUL: New best var: 15
DEBUG CAREFUL: Testing fvar[3] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
DEBUG CAREFUL: Testing fvar[4] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
  % Initial guess is x15, Z0 = 28169784.5516554        , Z1 = 28250623.6774732        

DEBUG EVAL: Testing var 16 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=15, varin=58, theta=2.000000, up=1.000000
ITER 2: row=15, varin=13, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=28, varin=58, theta=1.000000, up=1.000000
ITER 4: row=13, varin=46, theta=1.000000, up=1.000000
ITER 5: row=1, varin=20, theta=0.111159, up=999999999999999983222784.000000
ITER 6: row=15, varin=3, theta=0.035870, up=999999999999999983222784.000000
ITER 7: row=3, varin=21, theta=0.029191, up=999999999999999983222784.000000
ITER 8: row=21, varin=17, theta=0.025037, up=999999999999999983222784.000000
ITER 9: row=12, varin=13, theta=0.032315, up=999999999999999983222784.000000
ITER 10: row=33, varin=32, theta=0.031023, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 16 = 1 gives z=28554146.643990
  % 	x16 = 1,	Z1 = 28554146.6439904        
DEBUG EVAL: First branch cutoff check: z=28554146.643990, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 16 = 0
ITER 1: row=15, varin=26, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=32, theta=0.993936, up=999999999999999983222784.000000
ITER 3: row=32, varin=21, theta=0.881304, up=999999999999999983222784.000000
ITER 4: row=14, varin=14, theta=0.626597, up=999999999999999983222784.000000
ITER 5: row=21, varin=17, theta=0.556596, up=999999999999999983222784.000000
  % 	x16 = 0,	Z0 = 28250623.6774732        
DEBUG EVAL: Second branch cutoff check: z=28250623.677473, best_z=INF, threshold=INF
  %   New best:  x16, Z = 28250623.6774732        
DEBUG EVAL: Testing var 7 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=12, varin=58, theta=2.000000, up=1.000000
ITER 2: row=12, varin=20, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=28, varin=58, theta=1.000000, up=1.000000
ITER 4: row=13, varin=46, theta=1.000000, up=1.000000
ITER 5: row=1, varin=3, theta=0.035870, up=999999999999999983222784.000000
ITER 6: row=27, varin=17, theta=0.019785, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 7 = 0 gives z=28218733.509883
  % 	x7 = 0,	Z0 = 28218733.5098831        
DEBUG EVAL: First branch cutoff check: z=28218733.509883, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 15 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=13, varin=32, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=32, varin=26, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=1, varin=21, theta=0.881304, up=999999999999999983222784.000000
ITER 4: row=21, varin=17, theta=0.556596, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 15 = 1 gives z=28250623.677473
  % 	x15 = 1,	Z1 = 28250623.6774732        
DEBUG EVAL: First branch cutoff check: z=28250623.677473, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 15 = 0
ITER 1: row=13, varin=58, theta=2.000000, up=1.000000
ITER 2: row=13, varin=13, theta=0.200000, up=999999999999999983222784.000000
ITER 3: row=28, varin=58, theta=1.000000, up=1.000000
ITER 4: row=1, varin=20, theta=0.039719, up=999999999999999983222784.000000
  % 	x15 = 0,	Z0 = 28173494.6453977        
DEBUG EVAL: Second branch cutoff check: z=28173494.645398, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 0 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=58, theta=0.922009, up=1.000000
ITER 2: row=28, varin=26, theta=0.112567, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 0 = 0 gives z=28170642.005375
  % 	x0 = 0,	Z0 = 28170642.005375         
DEBUG EVAL: First branch cutoff check: z=28170642.005375, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=58, theta=0.922009, up=1.000000
ITER 2: row=28, varin=3, theta=0.084548, up=999999999999999983222784.000000
ITER 3: row=27, varin=13, theta=0.363927, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 0 gives z=28173155.585495
  % 	x1 = 0,	Z0 = 28173155.5854951        
DEBUG EVAL: First branch cutoff check: z=28173155.585495, best_z=INF, threshold=INF
  % Best branch is x16, Z0 = 28250623.6774732        , Z1 = 28554146.6439904        

DEBUG CAREFUL: Final result - returning best.var = 16
DEBUG BB: Branching variable chosen: j=16
 % @NC   21   17	x16 = 0	28250623.677473
 % @NC   22   17	x16 = 1	28554146.643990
 %      17    11 28169784.5517               28192743.6296   x13 D     6     4
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x555cc09a0290
% @LO 0.00  28.16978455165538264282 99.9000000000
% @LN 0.00  28.19274362962521252030 99.9000000000
% Resuming node 14 at  28.19274362962521252030
DEBUG CONSTRNT: LP rows=33, pool->nlprows=33, pool->npend=0
DEBUG CONSTRNT: Checking 33 LP rows (pool tracks 33, total LP rows 33)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=32, expected 32
 % @PAP adding 37 rows, 193 nz to LP
DEBUG BB: Processing node 14, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=23, varin=36, theta=0.285714, up=999999999999999983222784.000000
ITER 2: row=1, varin=28, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=3, varin=26, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 28192743.629625
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 37 rows, 60 cols, 253 nonzeros, 5 slack, 32 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 32 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=7, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=40, varin=14, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=1, varin=45, theta=1.000000, up=1.000000
ITER 4: row=42, varin=15, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=1, varin=46, theta=0.600000, up=1.000000
ITER 6: row=10, varin=62, theta=0.333333, up=1.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28435600.347157
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 43 rows, 60 cols, 285 nonzeros, 8 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 8 slack rows
  % @PAP adding 8 rows, 42 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=70, theta=1.000000, up=1.000000
ITER 2: row=43, varin=80, theta=1.000000, up=1.000000
ITER 3: row=15, varin=54, theta=0.142857, up=1.000000
ITER 4: row=36, varin=67, theta=0.125000, up=1.000000
ITER 5: row=27, varin=47, theta=0.062500, up=1.000000
ITER 6: row=37, varin=5, theta=0.006993, up=999999999999999983222784.000000
ITER 7: row=41, varin=18, theta=0.009688, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28476062.496784
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.992465
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 3.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 252 nonzeros, 8 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 8 slack rows
  % @PAP adding 8 rows, 22 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=70, theta=0.991453, up=1.000000
ITER 2: row=36, varin=100, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28508591.005190
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 3.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 254 nonzeros, 1 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=11, theta=1.623188, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28528165.681917
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.188406
DEBUG SOLUTION: lp->best_solution[10] = 0.188406
DEBUG SOLUTION: lp->best_solution[11] = 1.376812
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 258 nonzeros, 5 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 5 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=30, theta=2.450000, up=999999999999999983222784.000000
ITER 2: row=43, varin=56, theta=0.428571, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28614188.174768
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 44 rows, 60 cols, 260 nonzeros, 2 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=30, theta=1.250000, up=999999999999999983222784.000000
ITER 2: row=45, varin=50, theta=0.357143, up=1.000000
ITER 3: row=33, varin=2, theta=0.066667, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28625983.005529
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 0.933333
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 45 rows, 60 cols, 250 nonzeros, 2 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=76, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28630913.430686
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 246 nonzeros, 0 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=41, theta=0.357143, up=999999999999999983222784.000000
ITER 2: row=38, varin=31, theta=1.052632, up=999999999999999983222784.000000
ITER 3: row=45, varin=29, theta=0.571429, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28639703.121200
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 259 nonzeros, 2 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 14 LP 1 Solution, length = 28639703.121200, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.142857 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.142857 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.142857 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.142857 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.142857 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.142857 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.142857 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.857143 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.857143 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.857143 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.857143 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.857143 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.857143 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.857143 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=28639703.121200, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 14 at  28.63970312120009609202
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x555cc098d550
% @LO 0.00  28.19274362962521252030 99.9000000000
% @LN 0.00  28.23094037349540741388 99.9000000000
% Resuming node 15 at  28.23094037349540741388
DEBUG CONSTRNT: LP rows=48, pool->nlprows=48, pool->npend=0
DEBUG CONSTRNT: Checking 48 LP rows (pool tracks 48, total LP rows 48)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=47, expected 47
 % @PAP adding 46 rows, 175 nz to LP
DEBUG BB: Processing node 15, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 15 LP 2 Solution, length = 28230940.373495, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.142857 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.142857 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.142857 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.142857 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.142857 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.142857 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.142857 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.857143 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.857143 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.857143 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.857143 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.857143 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.857143 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.857143 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=28230940.373495, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28230940.373495, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 15 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 15
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.142857
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.142857)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.142857
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.142857)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.142857
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.142857)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.142857
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.142857)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.142857
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.142857)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.142857
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.142857)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.142857
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.142857)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 7 fractional variables

  %  Carefully choosing branching variable, nfrac = 7
DEBUG CAREFUL: Testing fvar[0] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[1] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 4
DEBUG CAREFUL: New best var: 4
DEBUG CAREFUL: Testing fvar[2] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 11
DEBUG CAREFUL: Testing fvar[3] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 18
DEBUG CAREFUL: Testing fvar[4] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[5] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[6] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
  % Initial guess is x4, Z0 = 28230940.3734954        , Z1 = 28469129.4169772        

DEBUG EVAL: Testing var 3 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=8, varin=42, theta=0.250000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 0 gives z=28236859.454788
  % 	x3 = 0,	Z0 = 28236859.4547885        
DEBUG EVAL: First branch cutoff check: z=28236859.454788, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 1
ITER 1: row=8, varin=40, theta=1.000000, up=999999999999999983222784.000000
  % 	x3 = 1,	Z1 = 28258714.4820889        
DEBUG EVAL: Second branch cutoff check: z=28258714.482089, best_z=INF, threshold=INF
  %   New best:  x3, Z = 28236859.4547885        
DEBUG EVAL: Testing var 4 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=29, varin=43, theta=6.000000, up=999999999999999983222784.000000
ITER 2: row=43, varin=26, theta=1.500000, up=999999999999999983222784.000000
ITER 3: row=41, varin=37, theta=3.000000, up=999999999999999983222784.000000
ITER 4: row=37, varin=54, theta=4.000000, up=1.000000
ITER 5: row=37, varin=61, theta=3.000000, up=1.000000
ITER 6: row=37, varin=35, theta=2.000000, up=999999999999999983222784.000000
ITER 7: row=16, varin=61, theta=2.000000, up=1.000000
ITER 8: row=16, varin=54, theta=1.000000, up=1.000000
ITER 9: row=1, varin=33, theta=3.000000, up=999999999999999983222784.000000
ITER 10: row=21, varin=36, theta=1.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 4 = 1 gives z=28844149.423402
  % 	x4 = 1,	Z1 = 28844149.4234024        
DEBUG EVAL: First branch cutoff check: z=28844149.423402, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 4 = 0
ITER 1: row=29, varin=42, theta=0.250000, up=999999999999999983222784.000000
  % 	x4 = 0,	Z0 = 28236859.4547885        
DEBUG EVAL: Second branch cutoff check: z=28236859.454788, best_z=INF, threshold=INF
  %   New best:  x4, Z = 28236859.4547885        
DEBUG EVAL: Testing var 11 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=37, varin=42, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=8, varin=43, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=43, varin=40, theta=1.500000, up=999999999999999983222784.000000
ITER 4: row=29, varin=54, theta=3.000000, up=1.000000
ITER 5: row=29, varin=36, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=38, varin=61, theta=2.000000, up=1.000000
ITER 7: row=38, varin=35, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=16, varin=61, theta=2.000000, up=1.000000
ITER 9: row=16, varin=54, theta=1.000000, up=1.000000
ITER 10: row=36, varin=33, theta=2.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 11 = 1 gives z=28756778.298588
  % 	x11 = 1,	Z1 = 28756778.298588         
DEBUG EVAL: First branch cutoff check: z=28756778.298588, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 11 = 0
ITER 1: row=37, varin=37, theta=0.200000, up=999999999999999983222784.000000
  % 	x11 = 0,	Z0 = 28246175.7965042        
DEBUG EVAL: Second branch cutoff check: z=28246175.796504, best_z=INF, threshold=INF
  %   New best:  x11, Z = 28246175.7965042        
DEBUG EVAL: Testing var 18 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=26, varin=42, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=8, varin=43, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=43, varin=40, theta=1.500000, up=999999999999999983222784.000000
ITER 4: row=29, varin=37, theta=1.500000, up=999999999999999983222784.000000
ITER 5: row=37, varin=54, theta=1.000000, up=1.000000
ITER 6: row=13, varin=61, theta=1.000000, up=1.000000
ITER 7: row=16, varin=35, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 18 = 1 gives z=28443788.204726
  % 	x18 = 1,	Z1 = 28443788.2047256        
DEBUG EVAL: First branch cutoff check: z=28443788.204726, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 18 = 0
ITER 1: row=26, varin=21, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=22, varin=40, theta=0.500000, up=999999999999999983222784.000000
  % 	x18 = 0,	Z0 = 28252719.0429487        
DEBUG EVAL: Second branch cutoff check: z=28252719.042949, best_z=INF, threshold=INF
  %   New best:  x18, Z = 28252719.0429487        
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=21, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=22, varin=40, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28252719.042949
  % 	x10 = 0,	Z0 = 28252719.0429487        
DEBUG EVAL: First branch cutoff check: z=28252719.042949, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 1
ITER 1: row=7, varin=42, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=8, varin=43, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=43, varin=40, theta=1.500000, up=999999999999999983222784.000000
ITER 4: row=29, varin=26, theta=0.750000, up=999999999999999983222784.000000
  % 	x10 = 1,	Z1 = 28332575.3978576        
DEBUG EVAL: Second branch cutoff check: z=28332575.397858, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=21, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=22, varin=35, theta=0.083333, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28248248.187903
  % 	x2 = 0,	Z0 = 28248248.1879031        
DEBUG EVAL: First branch cutoff check: z=28248248.187903, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 26 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=30, varin=21, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=22, varin=40, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 0 gives z=28252719.042949
  % 	x26 = 0,	Z0 = 28252719.0429487        
DEBUG EVAL: First branch cutoff check: z=28252719.042949, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 1
ITER 1: row=30, varin=42, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=8, varin=43, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=43, varin=40, theta=1.500000, up=999999999999999983222784.000000
ITER 4: row=29, varin=26, theta=0.750000, up=999999999999999983222784.000000
  % 	x26 = 1,	Z1 = 28332575.3978576        
DEBUG EVAL: Second branch cutoff check: z=28332575.397858, best_z=INF, threshold=INF
  % Best branch is x18, Z0 = 28252719.0429487        , Z1 = 28443788.2047256        

DEBUG CAREFUL: Final result - returning best.var = 18
DEBUG BB: Branching variable chosen: j=18
 % @NC   23   15	x18 = 0	28252719.042949
 % @NC   24   15	x18 = 1	28443788.204726
 %      15    12 28230940.3735               28240043.6548   x19 U    13     6
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x555cc099a900
% @LO 0.00  28.23094037349540741388 99.9000000000
% @LN 0.00  28.24004365480329781235 99.9000000000
% Resuming node 16 at  28.24004365480329781235
DEBUG CONSTRNT: LP rows=46, pool->nlprows=46, pool->npend=0
DEBUG CONSTRNT: Checking 46 LP rows (pool tracks 46, total LP rows 46)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=45, expected 45
 % @PAP adding 41 rows, 185 nz to LP
DEBUG BB: Processing node 16, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=6, varin=34, theta=0.666667, up=999999999999999983222784.000000
ITER 2: row=34, varin=10, theta=0.800000, up=999999999999999983222784.000000
ITER 3: row=1, varin=18, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=10, varin=27, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=3, varin=25, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28240043.654803
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 41 rows, 60 cols, 245 nonzeros, 8 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 33 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=31, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=18, varin=6, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=44, varin=7, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=41, varin=60, theta=0.500000, up=1.000000
ITER 5: row=47, varin=49, theta=3.000000, up=1.000000
ITER 6: row=47, varin=15, theta=0.181818, up=999999999999999983222784.000000
ITER 7: row=46, varin=49, theta=9.000000, up=1.000000
ITER 8: row=46, varin=47, theta=4.000000, up=999999999999999983222784.000000
ITER 9: row=42, varin=57, theta=0.500000, up=1.000000
ITER 10: row=37, varin=41, theta=1.066667, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=10)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28400079.064334
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.533333
DEBUG SOLUTION: lp->best_solution[7] = 0.533333
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 278 nonzeros, 13 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 13 slack rows
  % @PAP adding 6 rows, 15 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=42, theta=2.000000, up=1.000000
ITER 2: row=38, varin=24, theta=0.571429, up=999999999999999983222784.000000
ITER 3: row=37, varin=29, theta=3.000000, up=999999999999999983222784.000000
ITER 4: row=35, varin=12, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28440911.590519
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 3.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.500000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 238 nonzeros, 3 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % Node 16 LP 1 Solution, length = 28440911.590519, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.500000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.500000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28440911.590519, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 16 at  28.44091159051858497264
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x555cc099b4c0
% @LO 0.00  28.24004365480329781235 99.9000000000
% @LN 0.00  28.24400659669010948960 99.9000000000
% Resuming node 8 at  28.24400659669010948960
DEBUG CONSTRNT: LP rows=37, pool->nlprows=37, pool->npend=0
DEBUG CONSTRNT: Checking 37 LP rows (pool tracks 37, total LP rows 37)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=36, expected 36
 % @PAP adding 41 rows, 200 nz to LP
DEBUG BB: Processing node 8, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=19, varin=2, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=39, varin=40, theta=0.444444, up=999999999999999983222784.000000
ITER 3: row=21, varin=28, theta=1.243010, up=999999999999999983222784.000000
ITER 4: row=10, varin=22, theta=0.891653, up=999999999999999983222784.000000
ITER 5: row=37, varin=3, theta=4.761154, up=999999999999999983222784.000000
ITER 6: row=3, varin=5, theta=0.883501, up=999999999999999983222784.000000
ITER 7: row=38, varin=21, theta=3.016014, up=999999999999999983222784.000000
ITER 8: row=37, varin=23, theta=0.875496, up=999999999999999983222784.000000
ITER 9: row=39, varin=6, theta=0.424740, up=999999999999999983222784.000000
ITER 10: row=41, varin=57, theta=0.477047, up=1.000000
LP PHASE: Switching to primal (iter=10)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28244006.596690
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 0.142215
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.142215
DEBUG SOLUTION: lp->best_solution[6] = 0.522953
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 3.000000
  % @PL 41 rows, 60 cols, 260 nonzeros, 6 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 27 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=27, theta=0.555917, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
ITER 2: row=21, varin=49, theta=0.000000, up=1.000000
ITER 3: row=1, varin=89, theta=0.320905, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28306716.190517
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 0.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.333333
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 3.000000
  % @PL 47 rows, 60 cols, 287 nonzeros, 6 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=52, theta=0.200000, up=1.000000
ITER 2: row=17, varin=47, theta=0.300000, up=1.000000
ITER 3: row=8, varin=59, theta=0.333333, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28324110.453203
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 3.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 44 rows, 60 cols, 281 nonzeros, 2 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 8 LP 1 Solution, length = 28324110.453203, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.297012 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.297012 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.333333 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.333333 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.333333 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.702988 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.702988 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.702988 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.666667 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.666667 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.702988 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.666667 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.666667 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28324110.453203, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 8 at  28.32411045320295528427
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x555cc0985600
% @LO 0.00  28.24400659669010948960 99.9000000000
% @LN 0.00  28.25062367747321445677 99.9000000000
% Resuming node 21 at  28.25062367747321445677
DEBUG CONSTRNT: LP rows=42, pool->nlprows=42, pool->npend=0
DEBUG CONSTRNT: Checking 42 LP rows (pool tracks 42, total LP rows 42)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 141
DEBUG CONSTRNT: Pool row 141 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=41, expected 41
 % @PAP adding 33 rows, 186 nz to LP
DEBUG BB: Processing node 21, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=15, varin=26, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=32, theta=0.993936, up=999999999999999983222784.000000
ITER 3: row=32, varin=21, theta=0.881304, up=999999999999999983222784.000000
ITER 4: row=14, varin=14, theta=0.626597, up=999999999999999983222784.000000
ITER 5: row=21, varin=17, theta=0.556596, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=33)
DEBUG SOLUTION: LP solution array indices: FST[34-73], not_covered[74-93]
DEBUG SOLUTION: lp->best_solution[0] = 28250623.677473
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 33 rows, 60 cols, 246 nonzeros, 3 slack, 30 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 9 rows, 50 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=37, varin=23, theta=0.113268, up=999999999999999983222784.000000
ITER 2: row=33, varin=22, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=36, varin=37, theta=11.043149, up=999999999999999983222784.000000
ITER 4: row=31, varin=21, theta=1.287342, up=999999999999999983222784.000000
ITER 5: row=38, varin=24, theta=1.966591, up=999999999999999983222784.000000
ITER 6: row=1, varin=54, theta=0.500000, up=1.000000
ITER 7: row=29, varin=19, theta=0.666667, up=999999999999999983222784.000000
ITER 8: row=35, varin=50, theta=0.374438, up=1.000000
ITER 9: row=14, varin=48, theta=5.570398, up=1.000000
ITER 10: row=14, varin=94, theta=0.393622, up=1.000000
LP PHASE: Switching to primal (iter=12)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 28310665.079788
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 39 rows, 60 cols, 280 nonzeros, 9 slack, 30 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 9 slack rows
  % @PAP adding 5 rows, 24 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=31, varin=26, theta=3.263854, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=35)
DEBUG SOLUTION: LP solution array indices: FST[36-75], not_covered[76-95]
DEBUG SOLUTION: lp->best_solution[0] = 28311257.909039
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 35 rows, 60 cols, 254 nonzeros, 6 slack, 29 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 4 rows, 22 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=30, varin=34, theta=0.267545, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=33)
DEBUG SOLUTION: LP solution array indices: FST[34-73], not_covered[74-93]
DEBUG SOLUTION: lp->best_solution[0] = 28317657.600350
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 33 rows, 60 cols, 246 nonzeros, 2 slack, 31 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 4 rows, 15 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=32, varin=60, theta=0.419488, up=1.000000
ITER 2: row=20, varin=45, theta=0.151970, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=35)
DEBUG SOLUTION: LP solution array indices: FST[36-75], not_covered[76-95]
DEBUG SOLUTION: lp->best_solution[0] = 28320392.751275
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 35 rows, 60 cols, 243 nonzeros, 0 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 18 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=39, theta=0.097392, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 28320544.377115
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 37 rows, 60 cols, 261 nonzeros, 2 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 21 LP 1 Solution, length = 28320544.377115, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.097392 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.097392 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.555556 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.333333 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.111111 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.333333 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.333333 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.902608 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.444444 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.902608 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.902608 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.666667 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.666667 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.444444 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.902608 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.444444 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.666667 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.666667 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=28320544.377115, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 21 at  28.32054437711519767618
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x555cc09962c0
% @LO 0.00  28.25062367747321445677 99.9000000000
% @LN 0.00  28.25271904294868718921 99.9000000000
% Resuming node 23 at  28.25271904294868718921
DEBUG CONSTRNT: LP rows=35, pool->nlprows=35, pool->npend=0
DEBUG CONSTRNT: Checking 35 LP rows (pool tracks 35, total LP rows 35)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=34, expected 34
 % @PAP adding 46 rows, 175 nz to LP
DEBUG BB: Processing node 23, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=26, varin=21, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=22, varin=40, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28252719.042949
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 235 nonzeros, 2 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 5 rows, 24 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=26, theta=0.250000, up=999999999999999983222784.000000
ITER 2: row=51, varin=75, theta=1.000000, up=1.000000
ITER 3: row=40, varin=85, theta=1.000000, up=1.000000
ITER 4: row=34, varin=36, theta=0.200000, up=999999999999999983222784.000000
ITER 5: row=50, varin=27, theta=0.060606, up=999999999999999983222784.000000
ITER 6: row=38, varin=82, theta=1.000000, up=1.000000
ITER 7: row=44, varin=37, theta=0.263158, up=999999999999999983222784.000000
ITER 8: row=49, varin=50, theta=1.250000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28384017.454028
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 259 nonzeros, 6 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % Node 23 LP 1 Solution, length = 28384017.454028, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.250000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.250000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.250000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.250000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.250000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.250000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.750000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.750000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.750000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.750000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.750000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.750000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.750000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28384017.454028, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 23 at  28.38401745402768838744
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x555cc099b400
% @LO 0.00  28.25271904294868718921 99.9000000000
% @LN 0.00  28.26223309874798772512 99.9000000000
% Resuming node 10 at  28.26223309874798772512
DEBUG CONSTRNT: LP rows=45, pool->nlprows=45, pool->npend=0
DEBUG CONSTRNT: Checking 45 LP rows (pool tracks 45, total LP rows 45)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=44, expected 44
 % @PAP adding 37 rows, 193 nz to LP
DEBUG BB: Processing node 10, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=2, varin=9, theta=2.210598, up=999999999999999983222784.000000
ITER 2: row=27, varin=37, theta=2.552151, up=999999999999999983222784.000000
ITER 3: row=1, varin=3, theta=1.962968, up=999999999999999983222784.000000
ITER 4: row=3, varin=21, theta=1.245025, up=999999999999999983222784.000000
ITER 5: row=9, varin=32, theta=0.555298, up=999999999999999983222784.000000
ITER 6: row=17, varin=30, theta=0.952690, up=999999999999999983222784.000000
ITER 7: row=30, varin=23, theta=0.221899, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 28262233.098748
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 37 rows, 60 cols, 253 nonzeros, 7 slack, 30 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 5 rows, 18 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=67, theta=1.280080, up=1.000000
ITER 2: row=38, varin=55, theta=0.130106, up=1.000000
ITER 3: row=30, varin=67, theta=1.000000, up=1.000000
ITER 4: row=32, varin=57, theta=0.198652, up=1.000000
ITER 5: row=40, varin=14, theta=0.002026, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28310039.917137
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.997974
  % @PL 42 rows, 60 cols, 271 nonzeros, 9 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 9 slack rows
  % @PAP adding 6 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=35, varin=28, theta=0.224864, up=999999999999999983222784.000000
ITER 2: row=34, varin=63, theta=0.338410, up=1.000000
ITER 3: row=27, varin=66, theta=0.413815, up=1.000000
ITER 4: row=37, varin=35, theta=0.063451, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 28371165.849348
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 3.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 39 rows, 60 cols, 246 nonzeros, 3 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 4 rows, 9 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=37, varin=31, theta=2.920616, up=999999999999999983222784.000000
ITER 2: row=33, varin=62, theta=0.026720, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28442280.995781
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 3.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 40 rows, 60 cols, 246 nonzeros, 3 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 6 rows, 23 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=101, theta=0.795659, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28480954.699522
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 3.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 43 rows, 60 cols, 260 nonzeros, 4 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 3 rows, 9 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=29, theta=0.201491, up=999999999999999983222784.000000
ITER 2: row=29, varin=65, theta=0.170057, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28487038.610759
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 3.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 42 rows, 60 cols, 250 nonzeros, 0 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=73, theta=0.334545, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28508712.406831
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 3.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 43 rows, 60 cols, 254 nonzeros, 0 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=73, theta=0.219450, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28519967.740443
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 3.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 47 rows, 60 cols, 267 nonzeros, 0 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 16 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=80, theta=0.029884, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28524931.276560
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 3.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 51 rows, 60 cols, 283 nonzeros, 1 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 10 LP 1 Solution, length = 28524931.276560, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.197012 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.197012 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.197012 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.197012 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.197012 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.197012 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.029884 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.802988 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.802988 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.802988 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.802988 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=28524931.276560, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 10 at  28.52493127655993987446
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x555cc099b340
% @LO 0.00  28.26223309874798772512 99.9000000000
% @LN 0.00  28.26876308873798038235 99.9000000000
% Resuming node 19 at  28.26876308873798038235
DEBUG CONSTRNT: LP rows=50, pool->nlprows=50, pool->npend=0
DEBUG CONSTRNT: Checking 50 LP rows (pool tracks 50, total LP rows 50)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 70
DEBUG CONSTRNT: Pool row 70 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=49, expected 49
 % @PAP adding 43 rows, 190 nz to LP
DEBUG BB: Processing node 19, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=4, varin=23, theta=0.285714, up=999999999999999983222784.000000
ITER 2: row=43, varin=67, theta=1.125000, up=1.000000
ITER 3: row=43, varin=47, theta=0.062500, up=1.000000
ITER 4: row=20, varin=33, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=28, varin=67, theta=1.000000, up=1.000000
ITER 6: row=37, varin=3, theta=0.062937, up=999999999999999983222784.000000
ITER 7: row=41, varin=19, theta=0.087191, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28268763.088738
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.932185
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 3.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 43 rows, 60 cols, 250 nonzeros, 11 slack, 32 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 8 rows, 22 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=78, theta=0.982906, up=1.000000
ITER 2: row=44, varin=108, theta=2.000000, up=1.000000
ITER 3: row=44, varin=11, theta=1.623188, up=999999999999999983222784.000000
ITER 4: row=38, varin=43, theta=0.608696, up=999999999999999983222784.000000
ITER 5: row=40, varin=36, theta=0.125000, up=999999999999999983222784.000000
ITER 6: row=11, varin=61, theta=0.111111, up=1.000000
ITER 7: row=20, varin=88, theta=0.111111, up=1.000000
ITER 8: row=16, varin=41, theta=0.352941, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28362628.607735
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.882353
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 51 rows, 60 cols, 272 nonzeros, 17 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 17 slack rows
  % @PAP adding 2 rows, 42 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=66, theta=0.079709, up=1.000000
ITER 2: row=35, varin=90, theta=0.981051, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=36)
DEBUG SOLUTION: LP solution array indices: FST[37-76], not_covered[77-96]
DEBUG SOLUTION: lp->best_solution[0] = 28420325.541061
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 36 rows, 60 cols, 260 nonzeros, 0 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=51, theta=0.549782, up=1.000000
ITER 2: row=6, varin=27, theta=0.123286, up=999999999999999983222784.000000
ITER 3: row=28, varin=73, theta=0.417734, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 28445987.323152
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 39 rows, 60 cols, 267 nonzeros, 1 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 6 rows, 26 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=66, theta=0.137721, up=1.000000
ITER 2: row=40, varin=100, theta=0.168510, up=1.000000
ITER 3: row=43, varin=55, theta=0.044085, up=1.000000
ITER 4: row=39, varin=40, theta=0.201274, up=999999999999999983222784.000000
ITER 5: row=27, varin=49, theta=0.256641, up=1.000000
ITER 6: row=31, varin=2, theta=0.046607, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28492599.041320
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 0.953393
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 291 nonzeros, 2 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 4 rows, 10 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=69, theta=0.308430, up=1.000000
ITER 2: row=45, varin=41, theta=0.419415, up=999999999999999983222784.000000
ITER 3: row=44, varin=30, theta=0.951869, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28527599.015080
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 46 rows, 60 cols, 291 nonzeros, 3 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 5 rows, 16 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=25, theta=0.458230, up=999999999999999983222784.000000
ITER 2: row=44, varin=76, theta=0.277815, up=1.000000
ITER 3: row=47, varin=44, theta=0.169205, up=999999999999999983222784.000000
ITER 4: row=45, varin=48, theta=0.224437, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28547763.892576
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 48 rows, 60 cols, 288 nonzeros, 2 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=77, theta=0.328645, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28555574.964692
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 48 rows, 60 cols, 276 nonzeros, 1 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 1 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=81, theta=0.463709, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28583685.934851
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 48 rows, 60 cols, 277 nonzeros, 0 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=40, theta=0.261077, up=999999999999999983222784.000000
ITER 2: row=37, varin=82, theta=0.385895, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28608295.813158
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 50 rows, 60 cols, 283 nonzeros, 0 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=44, theta=1.779380, up=999999999999999983222784.000000
ITER 2: row=43, varin=36, theta=0.169234, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28661717.033909
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 52 rows, 60 cols, 295 nonzeros, 4 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % Node 19 LP 1 Solution, length = 28661717.033909, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 1.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.213989 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.044754 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.044754 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.044754 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.044754 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.044754 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.044754 (FST 22)
  % DEBUG LP_VARS: x[23] = 1.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 1.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.044754 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.213989 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.213989 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.213989 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.955246 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.786011 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.955246 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.786011 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.955246 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.955246 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.955246 (terminal 19)
 % 11 fractional variables
DEBUG CG: LP optimal, z=28661717.033909, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 19 at  28.66171703390897462782
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x555cc09949e0
% @LO 0.00  28.26876308873798038235 99.9000000000
% @LN 0.00  28.28564331541977239226 99.9000000000
% Resuming node 18 at  28.28564331541977239226
DEBUG CONSTRNT: LP rows=48, pool->nlprows=48, pool->npend=0
DEBUG CONSTRNT: Checking 48 LP rows (pool tracks 48, total LP rows 48)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 135
DEBUG CONSTRNT: Pool row 135 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=47, expected 47
 % @PAP adding 37 rows, 190 nz to LP
DEBUG BB: Processing node 18, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=13, varin=55, theta=1.666667, up=1.000000
ITER 2: row=13, varin=27, theta=0.666667, up=999999999999999983222784.000000
ITER 3: row=1, varin=55, theta=0.763603, up=1.000000
ITER 4: row=27, varin=35, theta=1.329996, up=999999999999999983222784.000000
ITER 5: row=36, varin=3, theta=0.716993, up=999999999999999983222784.000000
ITER 6: row=3, varin=25, theta=0.890278, up=999999999999999983222784.000000
ITER 7: row=25, varin=24, theta=1.196875, up=999999999999999983222784.000000
ITER 8: row=24, varin=64, theta=1.299644, up=1.000000
ITER 9: row=24, varin=61, theta=0.265634, up=1.000000
ITER 10: row=32, varin=40, theta=0.366690, up=1.000000
LP PHASE: Switching to primal (iter=11)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 28285643.315420
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 37 rows, 60 cols, 250 nonzeros, 3 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 12 rows, 46 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=73, theta=1.000000, up=1.000000
ITER 2: row=35, varin=76, theta=1.537600, up=1.000000
ITER 3: row=35, varin=68, theta=0.367894, up=1.000000
ITER 4: row=41, varin=57, theta=0.305436, up=1.000000
ITER 5: row=24, varin=28, theta=1.446384, up=999999999999999983222784.000000
ITER 6: row=37, varin=83, theta=0.529832, up=1.000000
ITER 7: row=38, varin=37, theta=0.648634, up=999999999999999983222784.000000
ITER 8: row=29, varin=10, theta=1.070638, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28705100.208247
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.464681
DEBUG SOLUTION: lp->best_solution[9] = 0.464681
DEBUG SOLUTION: lp->best_solution[10] = 1.929362
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 290 nonzeros, 3 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 8 rows, 29 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=81, theta=1.000000, up=1.000000
ITER 2: row=51, varin=28, theta=0.514936, up=999999999999999983222784.000000
ITER 3: row=48, varin=75, theta=3.680708, up=1.000000
ITER 4: row=48, varin=77, theta=0.850570, up=1.000000
ITER 5: row=34, varin=75, theta=1.000000, up=1.000000
ITER 6: row=10, varin=79, theta=1.541588, up=1.000000
ITER 7: row=10, varin=27, theta=0.108537, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28987739.368416
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 51 rows, 60 cols, 311 nonzeros, 4 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 4 rows, 10 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=79, theta=0.543781, up=1.000000
ITER 2: row=50, varin=80, theta=1.106495, up=1.000000
ITER 3: row=50, varin=32, theta=0.101543, up=999999999999999983222784.000000
ITER 4: row=51, varin=82, theta=0.090777, up=1.000000
ITER 5: row=42, varin=47, theta=0.092824, up=999999999999999983222784.000000
ITER 6: row=32, varin=42, theta=0.194418, up=999999999999999983222784.000000
ITER 7: row=51, varin=51, theta=0.158439, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 29018938.538844
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 51 rows, 60 cols, 310 nonzeros, 3 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 1 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=78, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 29151119.793873
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 49 rows, 60 cols, 302 nonzeros, 0 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 9 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=74, theta=0.128030, up=1.000000
ITER 2: row=35, varin=82, theta=3.491764, up=1.000000
ITER 3: row=35, varin=21, theta=0.222605, up=999999999999999983222784.000000
ITER 4: row=42, varin=82, theta=1.000000, up=1.000000
ITER 5: row=11, varin=14, theta=0.240800, up=999999999999999983222784.000000
ITER 6: row=14, varin=11, theta=1.139752, up=999999999999999983222784.000000
ITER 7: row=21, varin=83, theta=7.170994, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 51 rows, 60 cols, 311 nonzeros, 3 slack, 48 tight.
  % Node 18 LP 1 Solution, length = 999999999999999983222784.000000, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.176905 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.823095 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.823095 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.823095 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.176905 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.823095 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.176905 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.176905 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 18 is INFEASIBLE
 %      18    11    infeasible               28296145.0431   x13 U     6     4
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x555cc09ab280
% @LO 0.02  28.28564331541977239226 99.9000000000
% @LN 0.02  28.29614504313620670928 99.9000000000
% Resuming node 20 at  28.29614504313620670928
DEBUG CONSTRNT: LP rows=51, pool->nlprows=51, pool->npend=0
DEBUG CONSTRNT: Checking 51 LP rows (pool tracks 51, total LP rows 51)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 141
DEBUG CONSTRNT: Pool row 141 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=50, expected 50
 % @PAP adding 43 rows, 190 nz to LP
DEBUG BB: Processing node 20, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=4, varin=43, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=43, varin=36, theta=0.333333, up=999999999999999983222784.000000
ITER 3: row=36, varin=8, theta=0.400000, up=999999999999999983222784.000000
ITER 4: row=1, varin=16, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=8, varin=5, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=34, varin=23, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28296145.043136
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 3.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 43 rows, 60 cols, 250 nonzeros, 6 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 33 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=12, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=43, varin=29, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=16, varin=4, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=46, varin=62, theta=0.250000, up=1.000000
ITER 5: row=49, varin=13, theta=0.227273, up=999999999999999983222784.000000
ITER 6: row=43, varin=59, theta=0.266667, up=1.000000
ITER 7: row=39, varin=43, theta=0.592593, up=999999999999999983222784.000000
ITER 8: row=35, varin=49, theta=0.909091, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28401690.645702
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.681818
DEBUG SOLUTION: lp->best_solution[5] = 0.681818
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 3.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.681818
DEBUG SOLUTION: lp->best_solution[13] = 0.681818
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 49 rows, 60 cols, 283 nonzeros, 12 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 12 slack rows
  % @PAP adding 5 rows, 10 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=32, theta=1.500000, up=999999999999999983222784.000000
ITER 2: row=38, varin=45, theta=0.200000, up=1.000000
ITER 3: row=31, varin=61, theta=0.250000, up=1.000000
ITER 4: row=30, varin=27, theta=0.500000, up=999999999999999983222784.000000
ITER 5: row=37, varin=3, theta=0.021739, up=999999999999999983222784.000000
ITER 6: row=6, varin=69, theta=0.333333, up=1.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28439478.389528
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 3.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 240 nonzeros, 1 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 20 LP 1 Solution, length = 28439478.389528, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 1.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.333333 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.333333 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.333333 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.333333 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.333333 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.333333 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.666667 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.666667 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.666667 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.666667 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.666667 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.666667 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.666667 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28439478.389528, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 20 at  28.43947838952763973452
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x555cc0985600
% @LO 0.02  28.29614504313620670928 99.9000000000
% @LN 0.02  28.32054437711519767618 99.9000000000
% Resuming node 21 at  28.32054437711519767618
DEBUG CONSTRNT: LP rows=41, pool->nlprows=41, pool->npend=0
DEBUG CONSTRNT: Checking 41 LP rows (pool tracks 41, total LP rows 41)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=40, expected 40
 % @PAP adding 35 rows, 190 nz to LP
DEBUG BB: Processing node 21, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 21 LP 2 Solution, length = 28320544.377115, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.097392 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.097392 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.555556 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.333333 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.111111 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.333333 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.333333 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.902608 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.444444 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.902608 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.902608 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.666667 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.666667 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.444444 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.902608 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.444444 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.666667 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.666667 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=28320544.377115, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28320544.377115, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 21 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 21
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.097392
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.097392)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.097392
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.097392)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.555556
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.555556)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.333333
DEBUG CAREFUL: Adding var 8 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.111111
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.111111)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.333333
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.333333
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=1.000000
DEBUG CAREFUL: Skipping var 20: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 7 fractional variables

  %  Carefully choosing branching variable, nfrac = 7
DEBUG CAREFUL: Testing fvar[0] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 15
DEBUG CAREFUL: New best var: 15
DEBUG CAREFUL: Testing fvar[1] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 14
DEBUG CAREFUL: Testing fvar[2] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 9
DEBUG CAREFUL: New best var: 9
DEBUG CAREFUL: Testing fvar[3] = var 8
DEBUG CAREFUL: Calling compare_branch_vars for var 8
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 8
DEBUG CAREFUL: Testing fvar[4] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
DEBUG CAREFUL: Testing fvar[5] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
DEBUG CAREFUL: Testing fvar[6] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
  % Initial guess is x9, Z0 = 28320544.3771152        , Z1 = 28399831.2577294        

DEBUG EVAL: Testing var 15 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=22, varin=26, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=31, varin=30, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 15 = 0 gives z=28352423.956302
  % 	x15 = 0,	Z0 = 28352423.9563023        
DEBUG EVAL: First branch cutoff check: z=28352423.956302, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 15 = 1
ITER 1: row=22, varin=30, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=24, varin=29, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=3, varin=34, theta=0.197525, up=999999999999999983222784.000000
  % 	x15 = 1,	Z1 = 28348166.7974572        
DEBUG EVAL: Second branch cutoff check: z=28348166.797457, best_z=INF, threshold=INF
  %   New best:  x15, Z = 28348166.7974572        
DEBUG EVAL: Testing var 14 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=24, varin=30, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 14 = 0 gives z=28327036.785671
  % 	x14 = 0,	Z0 = 28327036.7856714        
DEBUG EVAL: First branch cutoff check: z=28327036.785671, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 9 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=15, varin=20, theta=2.666667, up=999999999999999983222784.000000
ITER 2: row=20, varin=29, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=13, varin=32, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=1, varin=30, theta=2.385785, up=999999999999999983222784.000000
ITER 5: row=29, varin=19, theta=0.614375, up=999999999999999983222784.000000
ITER 6: row=14, varin=34, theta=1.688267, up=999999999999999983222784.000000
ITER 7: row=3, varin=24, theta=0.257611, up=999999999999999983222784.000000
ITER 8: row=27, varin=37, theta=1.425274, up=1.000000
ITER 9: row=27, varin=14, theta=0.336747, up=999999999999999983222784.000000
ITER 10: row=19, varin=25, theta=0.237951, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 9 = 1 gives z=28430795.778978
  % 	x9 = 1,	Z1 = 28430795.7789778        
DEBUG EVAL: First branch cutoff check: z=28430795.778978, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 0
ITER 1: row=15, varin=34, theta=0.333333, up=999999999999999983222784.000000
  % 	x9 = 0,	Z0 = 28320956.7109406        
DEBUG EVAL: Second branch cutoff check: z=28320956.710941, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 8 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=13, varin=29, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=4, varin=34, theta=0.185686, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 8 = 0 gives z=28327970.703335
  % 	x8 = 0,	Z0 = 28327970.7033349        
DEBUG EVAL: First branch cutoff check: z=28327970.703335, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 7 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=12, varin=48, theta=0.666667, up=1.000000
ITER 2: row=15, varin=29, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=3, varin=32, theta=0.377485, up=999999999999999983222784.000000
ITER 4: row=1, varin=19, theta=0.398766, up=999999999999999983222784.000000
ITER 5: row=14, varin=13, theta=0.391807, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 7 = 1 gives z=28402904.803022
  % 	x7 = 1,	Z1 = 28402904.8030219        
DEBUG EVAL: First branch cutoff check: z=28402904.803022, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 7 = 0
ITER 1: row=12, varin=34, theta=0.833333, up=999999999999999983222784.000000
ITER 2: row=15, varin=20, theta=0.333333, up=999999999999999983222784.000000
ITER 3: row=20, varin=32, theta=0.333333, up=999999999999999983222784.000000
  % 	x7 = 0,	Z0 = 28325067.0573433        
DEBUG EVAL: Second branch cutoff check: z=28325067.057343, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 0 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=34, theta=1.136004, up=999999999999999983222784.000000
ITER 2: row=15, varin=20, theta=0.738548, up=999999999999999983222784.000000
ITER 3: row=20, varin=30, theta=1.274575, up=999999999999999983222784.000000
ITER 4: row=29, varin=29, theta=0.472811, up=999999999999999983222784.000000
ITER 5: row=12, varin=84, theta=5.603324, up=1.000000
ITER 6: row=12, varin=19, theta=0.628231, up=999999999999999983222784.000000
ITER 7: row=20, varin=84, theta=0.873736, up=1.000000
ITER 8: row=19, varin=3, theta=0.892836, up=999999999999999983222784.000000
ITER 9: row=33, varin=13, theta=0.734059, up=999999999999999983222784.000000
ITER 10: row=29, varin=60, theta=0.662351, up=1.000000
DEBUG EVAL: Branch var 0 = 1 gives z=28425245.395318
  % 	x0 = 1,	Z1 = 28425245.3953175        
DEBUG EVAL: First branch cutoff check: z=28425245.395318, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 0 = 0
ITER 1: row=1, varin=32, theta=0.221041, up=999999999999999983222784.000000
  % 	x0 = 0,	Z0 = 28322996.6154016        
DEBUG EVAL: Second branch cutoff check: z=28322996.615402, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 1 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=34, theta=1.136004, up=999999999999999983222784.000000
ITER 2: row=15, varin=20, theta=0.738548, up=999999999999999983222784.000000
ITER 3: row=20, varin=32, theta=0.471039, up=999999999999999983222784.000000
ITER 4: row=27, varin=60, theta=0.380183, up=1.000000
ITER 5: row=15, varin=48, theta=0.181648, up=1.000000
DEBUG EVAL: Branch var 1 = 1 gives z=28336470.092694
  % 	x1 = 1,	Z1 = 28336470.0926939        
DEBUG EVAL: First branch cutoff check: z=28336470.092694, best_z=INF, threshold=INF
  % Best branch is x15, Z0 = 28352423.9563023        , Z1 = 28348166.7974572        

DEBUG CAREFUL: Final result - returning best.var = 15
DEBUG BB: Branching variable chosen: j=15
 % @NC   25   21	x15 = 1	28348166.797457
 % @NC   26   21	x15 = 0	28352423.956302
 %      21    12 28320544.3771               28324110.4532   x16 D    17     5
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x555cc099b4c0
% @LO 0.02  28.32054437711519767618 99.9000000000
% @LN 0.02  28.32411045320295528427 99.9000000000
% Resuming node 8 at  28.32411045320295528427
DEBUG CONSTRNT: LP rows=35, pool->nlprows=35, pool->npend=0
DEBUG CONSTRNT: Checking 35 LP rows (pool tracks 35, total LP rows 35)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=34, expected 34
 % @PAP adding 42 rows, 214 nz to LP
DEBUG BB: Processing node 8, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 8 LP 2 Solution, length = 28324110.453203, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.297012 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.297012 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.333333 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.333333 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.333333 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.702988 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.702988 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.702988 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.666667 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.666667 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.702988 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.666667 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.666667 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28324110.453203, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28324110.453203, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 3 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 8 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 8
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.297012
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.297012)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.297012
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.297012)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.333333
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.333333
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=1.000000
DEBUG CAREFUL: Skipping var 17: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.333333
DEBUG CAREFUL: Adding var 19 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 14
DEBUG CAREFUL: New best var: 14
DEBUG CAREFUL: Testing fvar[1] = var 19
DEBUG CAREFUL: Calling compare_branch_vars for var 19
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 19
DEBUG CAREFUL: Testing fvar[2] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 15
DEBUG CAREFUL: Testing fvar[3] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
DEBUG CAREFUL: Testing fvar[4] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
  % Initial guess is x14, Z0 = 28324110.453203         , Z1 = 28358898.9785758        

DEBUG EVAL: Testing var 14 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=18, varin=8, theta=0.400000, up=999999999999999983222784.000000
ITER 2: row=8, varin=17, theta=0.400000, up=999999999999999983222784.000000
ITER 3: row=17, varin=40, theta=0.666667, up=999999999999999983222784.000000
ITER 4: row=19, varin=33, theta=0.142857, up=999999999999999983222784.000000
ITER 5: row=15, varin=25, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=25, varin=23, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=1, varin=34, theta=0.032521, up=999999999999999983222784.000000
ITER 8: row=34, varin=7, theta=0.253050, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 14 = 1 gives z=28465736.969535
  % 	x14 = 1,	Z1 = 28465736.9695351        
DEBUG EVAL: First branch cutoff check: z=28465736.969535, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 14 = 0
ITER 1: row=18, varin=69, theta=0.500000, up=1.000000
  % 	x14 = 0,	Z0 = 28326175.771448         
DEBUG EVAL: Second branch cutoff check: z=28326175.771448, best_z=INF, threshold=INF
  %   New best:  x14, Z = 28326175.771448         
DEBUG EVAL: Testing var 19 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=4, varin=8, theta=0.400000, up=999999999999999983222784.000000
ITER 2: row=8, varin=17, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=18, varin=5, theta=0.500000, up=999999999999999983222784.000000
ITER 4: row=17, varin=27, theta=0.500000, up=999999999999999983222784.000000
ITER 5: row=15, varin=57, theta=1.000000, up=1.000000
ITER 6: row=41, varin=25, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=25, varin=23, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=1, varin=34, theta=0.032521, up=999999999999999983222784.000000
ITER 9: row=34, varin=12, theta=0.116009, up=999999999999999983222784.000000
ITER 10: row=42, varin=13, theta=0.079543, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 19 = 0 gives z=28461078.871090
  % 	x19 = 0,	Z0 = 28461078.8710905        
DEBUG EVAL: First branch cutoff check: z=28461078.871090, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 19 = 1
ITER 1: row=4, varin=69, theta=2.000000, up=1.000000
ITER 2: row=4, varin=61, theta=0.333333, up=1.000000
ITER 3: row=18, varin=17, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=17, varin=40, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=1, varin=66, theta=0.968055, up=1.000000
ITER 6: row=26, varin=2, theta=0.924149, up=999999999999999983222784.000000
ITER 7: row=2, varin=50, theta=4.074683, up=1.000000
ITER 8: row=2, varin=79, theta=3.472985, up=1.000000
ITER 9: row=2, varin=99, theta=0.745899, up=1.000000
ITER 10: row=18, varin=79, theta=2.000000, up=1.000000
  % 	x19 = 1,	Z1 = 28680467.8165846        
DEBUG EVAL: Second branch cutoff check: z=28680467.816585, best_z=INF, threshold=INF
  %   New best:  x19, Z = 28461078.8710905        
DEBUG EVAL: Testing var 15 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=19, varin=8, theta=0.400000, up=999999999999999983222784.000000
ITER 2: row=8, varin=40, theta=0.333333, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 15 = 0 gives z=28341504.715889
  % 	x15 = 0,	Z0 = 28341504.7158894        
DEBUG EVAL: First branch cutoff check: z=28341504.715889, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 0 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=53, theta=0.514525, up=1.000000
DEBUG EVAL: Branch var 0 = 0 gives z=28325777.659504
  % 	x0 = 0,	Z0 = 28325777.659504         
DEBUG EVAL: First branch cutoff check: z=28325777.659504, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=53, theta=0.514525, up=1.000000
DEBUG EVAL: Branch var 1 = 0 gives z=28325777.659504
  % 	x1 = 0,	Z0 = 28325777.659504         
DEBUG EVAL: First branch cutoff check: z=28325777.659504, best_z=INF, threshold=INF
  % Best branch is x19, Z0 = 28461078.8710905        , Z1 = 28680467.8165846        

DEBUG CAREFUL: Final result - returning best.var = 19
DEBUG BB: Branching variable chosen: j=19
 % @NC   27    8	x19 = 0	28461078.871090
 % @NC   28    8	x19 = 1	28680467.816585
 %       8    13 28324110.4532               28348166.7975   x17 U     2     2
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x555cc09949e0
% @LO 0.02  28.32411045320295528427 99.9000000000
% @LN 0.02  28.34816679745724599115 99.9000000000
% Resuming node 25 at  28.34816679745724599115
DEBUG CONSTRNT: LP rows=42, pool->nlprows=42, pool->npend=0
DEBUG CONSTRNT: Checking 42 LP rows (pool tracks 42, total LP rows 42)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 141
DEBUG CONSTRNT: Pool row 141 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=41, expected 41
 % @PAP adding 35 rows, 190 nz to LP
DEBUG BB: Processing node 25, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=22, varin=30, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=24, varin=29, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=1, varin=34, theta=0.197525, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=35)
DEBUG SOLUTION: LP solution array indices: FST[36-75], not_covered[76-95]
DEBUG SOLUTION: lp->best_solution[0] = 28348166.797457
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 35 rows, 60 cols, 250 nonzeros, 5 slack, 30 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=32, varin=48, theta=13.756085, up=1.000000
ITER 2: row=32, varin=46, theta=1.256571, up=1.000000
ITER 3: row=32, varin=27, theta=0.240432, up=999999999999999983222784.000000
ITER 4: row=13, varin=48, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=33)
DEBUG SOLUTION: LP solution array indices: FST[34-73], not_covered[74-93]
DEBUG SOLUTION: lp->best_solution[0] = 28404318.288025
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 33 rows, 60 cols, 232 nonzeros, 3 slack, 30 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 3 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=31, varin=42, theta=1.000000, up=1.000000
ITER 2: row=13, varin=46, theta=1.000000, up=1.000000
ITER 3: row=25, varin=3, theta=0.511409, up=999999999999999983222784.000000
ITER 4: row=3, varin=25, theta=0.659071, up=999999999999999983222784.000000
ITER 5: row=1, varin=19, theta=1.500664, up=999999999999999983222784.000000
ITER 6: row=19, varin=51, theta=0.660056, up=1.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=33)
DEBUG SOLUTION: LP solution array indices: FST[34-73], not_covered[74-93]
DEBUG SOLUTION: lp->best_solution[0] = 28464489.482331
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 33 rows, 60 cols, 238 nonzeros, 0 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 8 rows, 38 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=68, theta=0.631408, up=1.000000
ITER 2: row=34, varin=49, theta=0.345776, up=1.000000
ITER 3: row=25, varin=52, theta=0.963286, up=1.000000
ITER 4: row=19, varin=84, theta=0.315347, up=1.000000
ITER 5: row=36, varin=65, theta=0.355037, up=1.000000
ITER 6: row=21, varin=44, theta=0.263787, up=1.000000
ITER 7: row=7, varin=98, theta=0.421679, up=1.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28585358.275264
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 41 rows, 60 cols, 276 nonzeros, 1 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 5 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=72, theta=1.000000, up=1.000000
ITER 2: row=41, varin=82, theta=2.240093, up=1.000000
ITER 3: row=41, varin=80, theta=1.145838, up=1.000000
ITER 4: row=41, varin=75, theta=0.101406, up=1.000000
ITER 5: row=12, varin=82, theta=0.283638, up=1.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28747602.490626
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 280 nonzeros, 0 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 9 rows, 34 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=54, varin=64, theta=0.148037, up=1.000000
ITER 2: row=52, varin=89, theta=0.862965, up=1.000000
ITER 3: row=48, varin=27, theta=0.856364, up=999999999999999983222784.000000
ITER 4: row=47, varin=20, theta=1.884367, up=999999999999999983222784.000000
ITER 5: row=43, varin=76, theta=0.704400, up=1.000000
ITER 6: row=33, varin=10, theta=5.920812, up=999999999999999983222784.000000
ITER 7: row=1, varin=82, theta=0.562116, up=1.000000
ITER 8: row=53, varin=47, theta=0.486851, up=999999999999999983222784.000000
ITER 9: row=48, varin=54, theta=0.329853, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=9)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 28983605.177085
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.628916
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.628916
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 54 rows, 60 cols, 314 nonzeros, 6 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=81, theta=0.856164, up=1.000000
ITER 2: row=44, varin=79, theta=0.632947, up=1.000000
ITER 3: row=49, varin=23, theta=0.124131, up=999999999999999983222784.000000
ITER 4: row=42, varin=39, theta=0.082563, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 29007203.045488
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 293 nonzeros, 1 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=53, theta=0.279624, up=1.000000
ITER 2: row=3, varin=54, theta=1.223637, up=1.000000
ITER 3: row=3, varin=4, theta=0.045069, up=999999999999999983222784.000000
ITER 4: row=44, varin=84, theta=0.170176, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 29082272.575224
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 299 nonzeros, 0 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 5 rows, 15 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=56, varin=59, theta=0.522621, up=1.000000
ITER 2: row=52, varin=88, theta=0.407381, up=1.000000
ITER 3: row=54, varin=56, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 29141602.686916
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 56 rows, 60 cols, 314 nonzeros, 2 slack, 54 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=55, varin=42, theta=0.008742, up=999999999999999983222784.000000
ITER 2: row=53, varin=67, theta=0.039491, up=1.000000
ITER 3: row=34, varin=56, theta=0.016036, up=1.000000
ITER 4: row=4, varin=89, theta=0.013397, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 29145272.671598
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 55 rows, 60 cols, 310 nonzeros, 0 slack, 55 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 25 LP 1 Solution, length = 29145272.671598, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.013397 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.013397 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.108254 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.108254 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.013397 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.013397 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.500000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.013397 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.013397 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.500000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.013397 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.013397 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.108254 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.108254 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.986603 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.891746 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.986603 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.986603 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.986603 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.891746 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.986603 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 15 fractional variables
DEBUG CG: LP optimal, z=29145272.671598, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 25 at  29.14527267159779100325
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x555cc098d550
% @LO 0.02  28.34816679745724599115 99.9000000000
% @LN 0.02  28.35242395630229950143 99.9000000000
% Resuming node 26 at  28.35242395630229950143
DEBUG CONSTRNT: LP rows=55, pool->nlprows=55, pool->npend=0
DEBUG CONSTRNT: Checking 55 LP rows (pool tracks 55, total LP rows 55)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 141
DEBUG CONSTRNT: Pool row 141 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 134
DEBUG CONSTRNT: Pool row 134 has lprow=54, expected 54
 % @PAP adding 35 rows, 190 nz to LP
DEBUG BB: Processing node 26, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=22, varin=26, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=31, varin=30, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=35)
DEBUG SOLUTION: LP solution array indices: FST[36-75], not_covered[76-95]
DEBUG SOLUTION: lp->best_solution[0] = 28352423.956302
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 35 rows, 60 cols, 250 nonzeros, 2 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 5 rows, 30 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=23, theta=0.600000, up=999999999999999983222784.000000
ITER 2: row=30, varin=53, theta=0.250000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28363274.997783
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 280 nonzeros, 5 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 2 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=25, theta=0.250000, up=999999999999999983222784.000000
ITER 2: row=35, varin=27, theta=0.333333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 28368787.201866
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 37 rows, 60 cols, 257 nonzeros, 1 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=37, varin=55, theta=0.166667, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 28370568.489734
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 37 rows, 60 cols, 257 nonzeros, 0 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 27 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=13, theta=0.333333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28384582.573502
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.666667
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 284 nonzeros, 2 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 26 LP 1 Solution, length = 28384582.573502, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.250575 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.250575 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.333333 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.333333 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.333333 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.333333 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.749425 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.666667 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.749425 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.749425 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.666667 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.666667 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.666667 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.749425 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.666667 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.666667 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28384582.573502, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 26 at  28.38458257350209379410
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x555cc09962c0
% @LO 0.02  28.35242395630229950143 99.9000000000
% @LN 0.02  28.38401745402768838744 99.9000000000
% Resuming node 23 at  28.38401745402768838744
DEBUG CONSTRNT: LP rows=41, pool->nlprows=41, pool->npend=0
DEBUG CONSTRNT: Checking 41 LP rows (pool tracks 41, total LP rows 41)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 62
DEBUG CONSTRNT: Pool row 62 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 141
DEBUG CONSTRNT: Pool row 141 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=40, expected 40
 % @PAP adding 45 rows, 173 nz to LP
DEBUG BB: Processing node 23, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 23 LP 2 Solution, length = 28384017.454028, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.250000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.250000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.250000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.250000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.250000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.250000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.750000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.750000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.750000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.750000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.750000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.750000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.750000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28384017.454028, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28384017.454028, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 23 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 23
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.250000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.250000
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.250000
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.250000
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.250000
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.250000
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[1] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 4
DEBUG CAREFUL: New best var: 4
DEBUG CAREFUL: Testing fvar[2] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 11
DEBUG CAREFUL: Testing fvar[3] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[4] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[5] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
  % Initial guess is x4, Z0 = 28384017.4540277        , Z1 = 28844149.4234024        

DEBUG EVAL: Testing var 3 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=8, varin=3, theta=0.250000, up=999999999999999983222784.000000
ITER 2: row=41, varin=67, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 3 = 0 gives z=28429032.174872
  % 	x3 = 0,	Z0 = 28429032.1748716        
DEBUG EVAL: First branch cutoff check: z=28429032.174872, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 1
ITER 1: row=8, varin=40, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=40, varin=31, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=31, varin=36, theta=1.500000, up=999999999999999983222784.000000
ITER 4: row=35, varin=45, theta=3.000000, up=999999999999999983222784.000000
ITER 5: row=22, varin=34, theta=0.750000, up=999999999999999983222784.000000
  % 	x3 = 1,	Z1 = 28843253.4141628        
DEBUG EVAL: Second branch cutoff check: z=28843253.414163, best_z=INF, threshold=INF
  %   New best:  x3, Z = 28429032.1748716        
DEBUG EVAL: Testing var 4 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=26, varin=40, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=40, varin=26, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=37, varin=31, theta=3.000000, up=999999999999999983222784.000000
ITER 4: row=31, varin=45, theta=3.000000, up=999999999999999983222784.000000
ITER 5: row=22, varin=39, theta=3.000000, up=999999999999999983222784.000000
ITER 6: row=39, varin=43, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 4 = 1 gives z=28891651.702075
  % 	x4 = 1,	Z1 = 28891651.7020751        
DEBUG EVAL: First branch cutoff check: z=28891651.702075, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 4 = 0
ITER 1: row=26, varin=3, theta=0.250000, up=999999999999999983222784.000000
ITER 2: row=41, varin=67, theta=1.000000, up=1.000000
  % 	x4 = 0,	Z0 = 28429032.1748716        
DEBUG EVAL: Second branch cutoff check: z=28429032.174872, best_z=INF, threshold=INF
  %   New best:  x4, Z = 28429032.1748716        
DEBUG EVAL: Testing var 11 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=34, varin=44, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=33, varin=40, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=40, varin=31, theta=3.000000, up=999999999999999983222784.000000
ITER 4: row=31, varin=36, theta=1.500000, up=999999999999999983222784.000000
ITER 5: row=35, varin=43, theta=3.000000, up=999999999999999983222784.000000
ITER 6: row=31, varin=45, theta=3.000000, up=999999999999999983222784.000000
ITER 7: row=22, varin=38, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 11 = 1 gives z=28866925.020797
  % 	x11 = 1,	Z1 = 28866925.0207968        
DEBUG EVAL: First branch cutoff check: z=28866925.020797, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 11 = 0
ITER 1: row=34, varin=3, theta=0.250000, up=999999999999999983222784.000000
ITER 2: row=41, varin=67, theta=1.000000, up=1.000000
  % 	x11 = 0,	Z0 = 28429032.1748716        
DEBUG EVAL: Second branch cutoff check: z=28429032.174872, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=3, theta=0.250000, up=999999999999999983222784.000000
ITER 2: row=41, varin=67, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28429032.174872
  % 	x10 = 0,	Z0 = 28429032.1748716        
DEBUG EVAL: First branch cutoff check: z=28429032.174872, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 1
ITER 1: row=7, varin=38, theta=0.750000, up=999999999999999983222784.000000
  % 	x10 = 1,	Z1 = 28479733.3970969        
DEBUG EVAL: Second branch cutoff check: z=28479733.397097, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=3, theta=0.250000, up=999999999999999983222784.000000
ITER 2: row=41, varin=67, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28429032.174872
  % 	x2 = 0,	Z0 = 28429032.1748716        
DEBUG EVAL: First branch cutoff check: z=28429032.174872, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 1
ITER 1: row=1, varin=40, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=40, varin=43, theta=0.750000, up=999999999999999983222784.000000
  % 	x2 = 1,	Z1 = 28560847.2467424        
DEBUG EVAL: Second branch cutoff check: z=28560847.246742, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 26 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=27, varin=3, theta=0.250000, up=999999999999999983222784.000000
ITER 2: row=41, varin=67, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 26 = 0 gives z=28429032.174872
  % 	x26 = 0,	Z0 = 28429032.1748716        
DEBUG EVAL: First branch cutoff check: z=28429032.174872, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 1
ITER 1: row=27, varin=38, theta=0.750000, up=999999999999999983222784.000000
  % 	x26 = 1,	Z1 = 28479733.3970969        
DEBUG EVAL: Second branch cutoff check: z=28479733.397097, best_z=INF, threshold=INF
  % Best branch is x4, Z0 = 28429032.1748716        , Z1 = 28891651.7020751        

DEBUG CAREFUL: Final result - returning best.var = 4
DEBUG BB: Branching variable chosen: j=4
 % @NC   29   23	x4 = 0	28429032.174872
 % @NC   30   23	x4 = 1	28891651.702075
 %      23    14 28384017.4540               28384582.5735   x18 D    15     7
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x555cc098d550
% @LO 0.02  28.38401745402768838744 99.9000000000
% @LN 0.02  28.38458257350209379410 99.9000000000
% Resuming node 26 at  28.38458257350209379410
DEBUG CONSTRNT: LP rows=45, pool->nlprows=45, pool->npend=0
DEBUG CONSTRNT: Checking 45 LP rows (pool tracks 45, total LP rows 45)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=44, expected 44
 % @PAP adding 41 rows, 204 nz to LP
DEBUG BB: Processing node 26, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 26 LP 2 Solution, length = 28384582.573502, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.250575 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.250575 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.333333 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.333333 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.333333 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.333333 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.749425 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.666667 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.749425 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.749425 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.666667 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.666667 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.666667 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.749425 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.666667 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.666667 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28384582.573502, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28384582.573502, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 26 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 26
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.250575
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.250575)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.250575
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.250575)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.333333
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.333333
DEBUG CAREFUL: Adding var 8 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.333333
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.333333
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=1.000000
DEBUG CAREFUL: Skipping var 20: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 9
DEBUG CAREFUL: New best var: 9
DEBUG CAREFUL: Testing fvar[1] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 14
DEBUG CAREFUL: Testing fvar[2] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
DEBUG CAREFUL: Testing fvar[3] = var 8
DEBUG CAREFUL: Calling compare_branch_vars for var 8
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 8
DEBUG CAREFUL: Testing fvar[4] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
DEBUG CAREFUL: Testing fvar[5] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
  % Initial guess is x9, Z0 = 28384582.5735021        , Z1 = 28430795.7789778        

DEBUG EVAL: Testing var 9 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=23, varin=36, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=36, varin=33, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=33, varin=25, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=25, varin=31, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=1, varin=19, theta=0.372129, up=999999999999999983222784.000000
ITER 6: row=19, varin=18, theta=0.228420, up=999999999999999983222784.000000
ITER 7: row=18, varin=28, theta=1.209864, up=999999999999999983222784.000000
ITER 8: row=26, varin=23, theta=0.104692, up=999999999999999983222784.000000
ITER 9: row=12, varin=26, theta=0.076410, up=999999999999999983222784.000000
ITER 10: row=27, varin=30, theta=0.043734, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 9 = 1 gives z=28462812.427153
  % 	x9 = 1,	Z1 = 28462812.4271528        
DEBUG EVAL: First branch cutoff check: z=28462812.427153, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 0
ITER 1: row=23, varin=21, theta=0.500000, up=999999999999999983222784.000000
  % 	x9 = 0,	Z0 = 28396558.2374131        
DEBUG EVAL: Second branch cutoff check: z=28396558.237413, best_z=INF, threshold=INF
  %   New best:  x9, Z = 28396558.2374131        
DEBUG EVAL: Testing var 14 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=22, varin=35, theta=0.333333, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 14 = 0 gives z=28400377.945138
  % 	x14 = 0,	Z0 = 28400377.945138         
DEBUG EVAL: First branch cutoff check: z=28400377.945138, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 14 = 1
ITER 1: row=22, varin=21, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=23, varin=25, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=1, varin=3, theta=0.664194, up=999999999999999983222784.000000
ITER 4: row=3, varin=51, theta=5.571199, up=1.000000
ITER 5: row=3, varin=30, theta=0.380386, up=999999999999999983222784.000000
ITER 6: row=12, varin=18, theta=1.982574, up=999999999999999983222784.000000
ITER 7: row=18, varin=36, theta=1.654384, up=999999999999999983222784.000000
ITER 8: row=21, varin=51, theta=2.285874, up=1.000000
ITER 9: row=21, varin=31, theta=0.749247, up=999999999999999983222784.000000
ITER 10: row=18, varin=51, theta=0.528634, up=1.000000
  % 	x14 = 1,	Z1 = 28539470.3342347        
DEBUG EVAL: Second branch cutoff check: z=28539470.334235, best_z=INF, threshold=INF
  %   New best:  x14, Z = 28400377.945138         
DEBUG EVAL: Testing var 7 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=12, varin=21, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=23, varin=32, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=24, varin=31, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=21, varin=44, theta=0.600000, up=1.000000
ITER 5: row=4, varin=35, theta=0.891839, up=999999999999999983222784.000000
ITER 6: row=7, varin=68, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 7 = 1 gives z=28646513.952173
  % 	x7 = 1,	Z1 = 28646513.952173         
DEBUG EVAL: First branch cutoff check: z=28646513.952173, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 7 = 0
ITER 1: row=12, varin=25, theta=0.500000, up=999999999999999983222784.000000
  % 	x7 = 0,	Z0 = 28399401.0227979        
DEBUG EVAL: Second branch cutoff check: z=28399401.022798, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 8 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=14, varin=36, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=36, varin=32, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=24, varin=33, theta=0.500000, up=999999999999999983222784.000000
ITER 4: row=33, varin=31, theta=0.333333, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 8 = 0 gives z=28431695.989468
  % 	x8 = 0,	Z0 = 28431695.9894684        
DEBUG EVAL: First branch cutoff check: z=28431695.989468, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 8 = 1
ITER 1: row=14, varin=21, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=23, varin=25, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=1, varin=35, theta=0.422367, up=999999999999999983222784.000000
  % 	x8 = 1,	Z1 = 28458185.1160778        
DEBUG EVAL: Second branch cutoff check: z=28458185.116078, best_z=INF, threshold=INF
  %   New best:  x8, Z = 28431695.9894684        
DEBUG EVAL: Testing var 0 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=36, theta=0.570742, up=999999999999999983222784.000000
ITER 2: row=36, varin=35, theta=1.205402, up=999999999999999983222784.000000
ITER 3: row=22, varin=3, theta=1.371375, up=999999999999999983222784.000000
ITER 4: row=29, varin=30, theta=0.815175, up=999999999999999983222784.000000
ITER 5: row=36, varin=25, theta=0.683315, up=999999999999999983222784.000000
ITER 6: row=12, varin=18, theta=1.555867, up=999999999999999983222784.000000
ITER 7: row=13, varin=21, theta=0.807360, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 0 = 1 gives z=28518736.584317
  % 	x0 = 1,	Z1 = 28518736.5843166        
DEBUG EVAL: First branch cutoff check: z=28518736.584317, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 0 = 0
ITER 1: row=1, varin=12, theta=165349.333333, up=999999999999999983222784.000000
  % 	x0 = 0,	Z0 = 28401651.5288346        
DEBUG EVAL: Second branch cutoff check: z=28401651.528835, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=3, theta=0.414419, up=999999999999999983222784.000000
ITER 2: row=29, varin=12, theta=165349.333333, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 0 gives z=28401651.528835
  % 	x1 = 0,	Z0 = 28401651.5288346        
DEBUG EVAL: First branch cutoff check: z=28401651.528835, best_z=INF, threshold=INF
  % Best branch is x8, Z0 = 28431695.9894684        , Z1 = 28458185.1160778        

DEBUG CAREFUL: Final result - returning best.var = 8
DEBUG BB: Branching variable chosen: j=8
 % @NC   31   26	x8 = 0	28431695.989468
 % @NC   32   26	x8 = 1	28458185.116078
 %      26    15 28384582.5735               28429032.1749   x15 D    21     6
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x555cc099b4c0
% @LO 0.02  28.38458257350209379410 99.9000000000
% @LN 0.02  28.42903217487157974119 99.9000000000
% Resuming node 29 at  28.42903217487157974119
DEBUG CONSTRNT: LP rows=41, pool->nlprows=41, pool->npend=0
DEBUG CONSTRNT: Checking 41 LP rows (pool tracks 41, total LP rows 41)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 62
DEBUG CONSTRNT: Pool row 62 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 141
DEBUG CONSTRNT: Pool row 141 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=40, expected 40
 % @PAP adding 45 rows, 173 nz to LP
DEBUG BB: Processing node 29, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=26, varin=3, theta=0.250000, up=999999999999999983222784.000000
ITER 2: row=41, varin=67, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28429032.174872
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 233 nonzeros, 0 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=69, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28434835.110111
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 237 nonzeros, 0 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 19 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=19, theta=0.333333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28435123.340282
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 256 nonzeros, 2 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 3 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=23, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=16, varin=39, theta=0.250000, up=999999999999999983222784.000000
ITER 3: row=23, varin=61, theta=1.000000, up=1.000000
ITER 4: row=51, varin=79, theta=0.500000, up=1.000000
ITER 5: row=3, varin=51, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28454907.521858
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 259 nonzeros, 1 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=14, theta=0.333333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28460428.824777
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.666667
  % @PL 52 rows, 60 cols, 262 nonzeros, 1 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=53, varin=33, theta=0.250000, up=999999999999999983222784.000000
ITER 2: row=32, varin=82, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28477625.503681
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 53 rows, 60 cols, 264 nonzeros, 0 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=54, varin=87, theta=1.000000, up=1.000000
ITER 2: row=51, varin=35, theta=0.200000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 28499124.943575
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 54 rows, 60 cols, 269 nonzeros, 5 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 2 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=34, theta=0.083333, up=999999999999999983222784.000000
ITER 2: row=50, varin=51, theta=0.142857, up=999999999999999983222784.000000
ITER 3: row=47, varin=46, theta=0.250000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28503845.533714
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 255 nonzeros, 1 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 29 LP 1 Solution, length = 28503845.533714, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.250000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.250000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.250000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.250000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.250000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.250000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.250000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.750000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.750000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.750000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.750000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.750000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.750000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.750000 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=28503845.533714, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 29 at  28.50384553371359785956
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x555cc09962c0
% @LO 0.02  28.42903217487157974119 99.9000000000
% @LN 0.02  28.43169598946838760867 99.9000000000
% Resuming node 31 at  28.43169598946838760867
DEBUG CONSTRNT: LP rows=50, pool->nlprows=50, pool->npend=0
DEBUG CONSTRNT: Checking 50 LP rows (pool tracks 50, total LP rows 50)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=49, expected 49
 % @PAP adding 41 rows, 204 nz to LP
DEBUG BB: Processing node 31, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=14, varin=36, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=36, varin=32, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=24, varin=33, theta=0.500000, up=999999999999999983222784.000000
ITER 4: row=33, varin=31, theta=0.333333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28431695.989468
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 41 rows, 60 cols, 264 nonzeros, 2 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=54, theta=0.250000, up=1.000000
ITER 2: row=31, varin=59, theta=0.166667, up=1.000000
ITER 3: row=34, varin=24, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=41, varin=21, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28467228.361363
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 41 rows, 60 cols, 264 nonzeros, 2 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 31 LP 1 Solution, length = 28467228.361363, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.013424 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.013424 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.500000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.500000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.500000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.986576 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.986576 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.986576 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.986576 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28467228.361363, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 31 at  28.46722836136250833761
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x555cc09ab280
% @LO 0.02  28.43169598946838760867 99.9000000000
% @LN 0.02  28.43947838952763973452 99.9000000000
% Resuming node 20 at  28.43947838952763973452
DEBUG CONSTRNT: LP rows=39, pool->nlprows=39, pool->npend=0
DEBUG CONSTRNT: Checking 39 LP rows (pool tracks 39, total LP rows 39)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 141
DEBUG CONSTRNT: Pool row 141 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=38, expected 38
 % @PAP adding 41 rows, 174 nz to LP
DEBUG BB: Processing node 20, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 20 LP 2 Solution, length = 28439478.389528, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 1.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.333333 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.333333 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.333333 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.333333 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.333333 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.333333 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.666667 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.666667 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.666667 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.666667 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.666667 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.666667 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.666667 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28439478.389528, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28439478.389528, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 20 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 20
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=1.000000
DEBUG CAREFUL: Skipping var 0: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.333333
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.333333
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.333333
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.333333
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.333333
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.333333
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 9
DEBUG CAREFUL: New best var: 9
DEBUG CAREFUL: Testing fvar[1] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 26
DEBUG CAREFUL: New best var: 26
DEBUG CAREFUL: Testing fvar[2] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
DEBUG CAREFUL: Testing fvar[3] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 15
DEBUG CAREFUL: New best var: 15
DEBUG CAREFUL: Testing fvar[4] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 14
DEBUG CAREFUL: Testing fvar[5] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x15, Z0 = 28439478.3895276        , Z1 = 28677525.8364427        

DEBUG EVAL: Testing var 9 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=16, varin=36, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=27, varin=37, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 9 = 0 gives z=28472279.799329
  % 	x9 = 0,	Z0 = 28472279.7993288        
DEBUG EVAL: First branch cutoff check: z=28472279.799329, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 1
ITER 1: row=16, varin=35, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=40, varin=36, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=35, varin=28, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=41, varin=12, theta=0.500000, up=999999999999999983222784.000000
ITER 5: row=12, varin=25, theta=0.250000, up=999999999999999983222784.000000
ITER 6: row=1, varin=78, theta=0.250000, up=1.000000
ITER 7: row=41, varin=65, theta=0.250000, up=1.000000
ITER 8: row=22, varin=45, theta=0.111111, up=1.000000
ITER 9: row=25, varin=23, theta=1.000000, up=999999999999999983222784.000000
ITER 10: row=33, varin=15, theta=0.076923, up=999999999999999983222784.000000
  % 	x9 = 1,	Z1 = 28786796.3495567        
DEBUG EVAL: Second branch cutoff check: z=28786796.349557, best_z=INF, threshold=INF
  %   New best:  x9, Z = 28472279.7993288        
DEBUG EVAL: Testing var 26 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=6, theta=0.231884, up=999999999999999983222784.000000
ITER 2: row=6, varin=30, theta=0.205128, up=999999999999999983222784.000000
ITER 3: row=30, varin=36, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=27, varin=37, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 1 gives z=28472279.799329
  % 	x26 = 1,	Z1 = 28472279.7993288        
DEBUG EVAL: First branch cutoff check: z=28472279.799329, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 0
ITER 1: row=1, varin=65, theta=0.333333, up=1.000000
ITER 2: row=22, varin=45, theta=0.148148, up=1.000000
ITER 3: row=33, varin=15, theta=0.025641, up=999999999999999983222784.000000
  % 	x26 = 0,	Z0 = 28453640.8760993        
DEBUG EVAL: Second branch cutoff check: z=28453640.876099, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 12 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=23, varin=36, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=27, varin=37, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 12 = 0 gives z=28472279.799329
  % 	x12 = 0,	Z0 = 28472279.7993288        
DEBUG EVAL: First branch cutoff check: z=28472279.799329, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 1
ITER 1: row=23, varin=35, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=40, varin=36, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=35, varin=28, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=41, varin=29, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=1, varin=48, theta=0.500000, up=1.000000
ITER 6: row=38, varin=65, theta=1.000000, up=1.000000
ITER 7: row=22, varin=45, theta=0.444444, up=1.000000
ITER 8: row=33, varin=15, theta=0.076923, up=999999999999999983222784.000000
  % 	x12 = 1,	Z1 = 28907472.0689512        
DEBUG EVAL: Second branch cutoff check: z=28907472.068951, best_z=INF, threshold=INF
  %   New best:  x12, Z = 28472279.7993288        
DEBUG EVAL: Testing var 15 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=29, varin=36, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=27, varin=37, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=1, varin=65, theta=2.000000, up=1.000000
ITER 4: row=1, varin=45, theta=0.444444, up=1.000000
ITER 5: row=5, varin=35, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=22, varin=65, theta=1.000000, up=1.000000
ITER 7: row=33, varin=52, theta=1.000000, up=1.000000
ITER 8: row=34, varin=15, theta=0.076923, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 15 = 1 gives z=28654820.259558
  % 	x15 = 1,	Z1 = 28677525.8364427        
DEBUG EVAL: First branch cutoff check: z=28677525.836443, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 15 = 0
ITER 1: row=29, varin=29, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=40, varin=28, theta=0.500000, up=999999999999999983222784.000000
  % 	x15 = 0,	Z0 = 28598605.7040252        
DEBUG EVAL: Second branch cutoff check: z=28598605.704025, best_z=INF, threshold=INF
  %   New best:  x15, Z = 28598605.7040252        
DEBUG EVAL: Testing var 14 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=35, varin=36, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=27, varin=35, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 14 = 0 gives z=28493104.184884
  % 	x14 = 0,	Z0 = 28493104.1848843        
DEBUG EVAL: First branch cutoff check: z=28493104.184884, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=5, varin=36, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=27, varin=5, theta=0.333333, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28451505.641420
  % 	x10 = 0,	Z0 = 28451505.6414203        
DEBUG EVAL: First branch cutoff check: z=28451505.641420, best_z=INF, threshold=INF
  % Best branch is x15, Z0 = 28598605.7040252        , Z1 = 28677525.8364427        

DEBUG CAREFUL: Final result - returning best.var = 15
DEBUG BB: Branching variable chosen: j=15
 % @NC   33   20	x15 = 0	28598605.704025
 % @NC   34   20	x15 = 1	28677525.836443
 %      20    16 28439478.3895               28440911.5905   x19 D    12     5
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x555cc099a900
% @LO 0.02  28.43947838952763973452 99.9000000000
% @LN 0.02  28.44091159051858497264 99.9000000000
% Resuming node 16 at  28.44091159051858497264
DEBUG CONSTRNT: LP rows=41, pool->nlprows=41, pool->npend=0
DEBUG CONSTRNT: Checking 41 LP rows (pool tracks 41, total LP rows 41)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=40, expected 40
 % @PAP adding 37 rows, 165 nz to LP
DEBUG BB: Processing node 16, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 16 LP 2 Solution, length = 28440911.590519, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.500000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.500000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28440911.590519, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28440911.590519, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 16 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 16
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.500000
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.500000
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.500000
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.500000
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 9
DEBUG CAREFUL: New best var: 9
DEBUG CAREFUL: Testing fvar[1] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
DEBUG CAREFUL: Testing fvar[2] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 14
DEBUG CAREFUL: Testing fvar[3] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x9, Z0 = 28440911.5905186        , Z1 = 28440911.5905186        

DEBUG EVAL: Testing var 9 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=33, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=23, varin=40, theta=0.600000, up=1.000000
ITER 3: row=27, varin=56, theta=0.750000, up=1.000000
ITER 4: row=23, varin=5, theta=0.038462, up=999999999999999983222784.000000
ITER 5: row=28, varin=40, theta=0.642857, up=1.000000
ITER 6: row=8, varin=64, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 9 = 0 gives z=28501938.711515
  % 	x9 = 0,	Z0 = 28501938.7115148        
DEBUG EVAL: First branch cutoff check: z=28501938.711515, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 1
ITER 1: row=1, varin=31, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=37, varin=40, theta=0.600000, up=1.000000
ITER 3: row=27, varin=56, theta=0.750000, up=1.000000
ITER 4: row=26, varin=5, theta=0.065217, up=999999999999999983222784.000000
ITER 5: row=8, varin=64, theta=1.000000, up=1.000000
  % 	x9 = 1,	Z1 = 28586614.776335         
DEBUG EVAL: Second branch cutoff check: z=28586614.776335, best_z=INF, threshold=INF
  %   New best:  x9, Z = 28501938.7115148        
DEBUG EVAL: Testing var 12 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=18, varin=40, theta=0.300000, up=1.000000
ITER 2: row=27, varin=56, theta=0.375000, up=1.000000
ITER 3: row=18, varin=5, theta=0.019231, up=999999999999999983222784.000000
ITER 4: row=28, varin=40, theta=0.321429, up=1.000000
ITER 5: row=8, varin=64, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 12 = 0 gives z=28462425.237373
  % 	x12 = 0,	Z0 = 28462425.2373731        
DEBUG EVAL: First branch cutoff check: z=28462425.237373, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 14 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=30, varin=31, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=37, varin=40, theta=0.600000, up=1.000000
ITER 3: row=27, varin=56, theta=0.750000, up=1.000000
ITER 4: row=26, varin=5, theta=0.065217, up=999999999999999983222784.000000
ITER 5: row=8, varin=64, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 14 = 0 gives z=28586614.776335
  % 	x14 = 0,	Z0 = 28586614.776335         
DEBUG EVAL: First branch cutoff check: z=28586614.776335, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 14 = 1
ITER 1: row=30, varin=33, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=23, varin=40, theta=0.600000, up=1.000000
ITER 3: row=27, varin=56, theta=0.750000, up=1.000000
ITER 4: row=23, varin=5, theta=0.038462, up=999999999999999983222784.000000
ITER 5: row=28, varin=40, theta=0.642857, up=1.000000
ITER 6: row=8, varin=64, theta=1.000000, up=1.000000
  % 	x14 = 1,	Z1 = 28501938.7115148        
DEBUG EVAL: Second branch cutoff check: z=28501938.711515, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=33, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=23, varin=7, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28458952.468358
  % 	x10 = 0,	Z0 = 28458952.4683576        
DEBUG EVAL: First branch cutoff check: z=28458952.468358, best_z=INF, threshold=INF
  % Best branch is x9, Z0 = 28501938.7115148        , Z1 = 28586614.776335         

DEBUG CAREFUL: Final result - returning best.var = 9
DEBUG BB: Branching variable chosen: j=9
 % @NC   35   16	x9 = 0	28501938.711515
 % @NC   36   16	x9 = 1	28586614.776335
 %      16    17 28440911.5905               28443788.2047   x19 D    13     6
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x555cc09abe60
% @LO 0.02  28.44091159051858497264 99.9000000000
% @LN 0.02  28.44378820472563518251 99.9000000000
% Resuming node 24 at  28.44378820472563518251
DEBUG CONSTRNT: LP rows=37, pool->nlprows=37, pool->npend=0
DEBUG CONSTRNT: Checking 37 LP rows (pool tracks 37, total LP rows 37)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=36, expected 36
 % @PAP adding 46 rows, 175 nz to LP
DEBUG BB: Processing node 24, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=26, varin=42, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=8, varin=43, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=43, varin=40, theta=1.500000, up=999999999999999983222784.000000
ITER 4: row=29, varin=37, theta=1.500000, up=999999999999999983222784.000000
ITER 5: row=37, varin=54, theta=1.000000, up=1.000000
ITER 6: row=13, varin=61, theta=1.000000, up=1.000000
ITER 7: row=16, varin=35, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28443788.204726
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 235 nonzeros, 6 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 46 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=2, theta=2.187854, up=999999999999999983222784.000000
ITER 2: row=44, varin=7, theta=2.786393, up=999999999999999983222784.000000
ITER 3: row=28, varin=21, theta=4.316851, up=999999999999999983222784.000000
ITER 4: row=22, varin=79, theta=5.697800, up=1.000000
ITER 5: row=22, varin=56, theta=1.964737, up=1.000000
ITER 6: row=22, varin=71, theta=0.973336, up=1.000000
ITER 7: row=1, varin=79, theta=6.008738, up=1.000000
ITER 8: row=1, varin=3, theta=2.176389, up=999999999999999983222784.000000
ITER 9: row=2, varin=73, theta=15.645609, up=1.000000
ITER 10: row=2, varin=15, theta=1.546375, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 281 nonzeros, 15 slack, 34 tight.
  % Node 24 LP 1 Solution, length = 999999999999999983222784.000000, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 1.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 1.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 1.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 24 is INFEASIBLE
 %      24    16    infeasible               28458185.1161   x18 U    15     7
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x555cc0998840
% @LO 0.02  28.44378820472563518251 99.9000000000
% @LN 0.02  28.45818511607782497208 99.9000000000
% Resuming node 32 at  28.45818511607782497208
DEBUG CONSTRNT: LP rows=49, pool->nlprows=49, pool->npend=0
DEBUG CONSTRNT: Checking 49 LP rows (pool tracks 49, total LP rows 49)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 158
DEBUG CONSTRNT: Pool row 158 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=48, expected 48
 % @PAP adding 41 rows, 204 nz to LP
DEBUG BB: Processing node 32, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=14, varin=21, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=23, varin=25, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=1, varin=35, theta=0.422367, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28458185.116078
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 41 rows, 60 cols, 264 nonzeros, 5 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 5 rows, 29 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=42, theta=0.359127, up=1.000000
ITER 2: row=38, varin=51, theta=1.000000, up=1.000000
ITER 3: row=27, varin=44, theta=0.600000, up=1.000000
ITER 4: row=37, varin=23, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=7, varin=68, theta=2.000000, up=1.000000
ITER 6: row=7, varin=65, theta=1.000000, up=1.000000
ITER 7: row=20, varin=78, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28717136.292896
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 41 rows, 60 cols, 280 nonzeros, 2 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 4 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=70, theta=1.000000, up=1.000000
ITER 2: row=40, varin=100, theta=2.000000, up=1.000000
ITER 3: row=40, varin=10, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=41, varin=51, theta=0.333333, up=1.000000
ITER 5: row=26, varin=100, theta=1.000000, up=1.000000
ITER 6: row=7, varin=22, theta=0.250000, up=999999999999999983222784.000000
ITER 7: row=14, varin=3, theta=0.389084, up=999999999999999983222784.000000
ITER 8: row=25, varin=40, theta=0.836881, up=999999999999999983222784.000000
ITER 9: row=19, varin=73, theta=0.459921, up=1.000000
ITER 10: row=12, varin=46, theta=0.373003, up=1.000000
LP PHASE: Switching to primal (iter=10)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28949637.290342
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.373003
DEBUG SOLUTION: lp->best_solution[9] = 0.373003
DEBUG SOLUTION: lp->best_solution[10] = 1.746006
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 286 nonzeros, 5 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 7 rows, 21 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=70, theta=1.000000, up=1.000000
ITER 2: row=42, varin=11, theta=0.625283, up=999999999999999983222784.000000
ITER 3: row=1, varin=67, theta=0.838527, up=1.000000
ITER 4: row=40, varin=82, theta=0.243945, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 29105736.150421
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 295 nonzeros, 1 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 5 rows, 18 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=40, theta=1.929186, up=999999999999999983222784.000000
ITER 2: row=9, varin=75, theta=0.766516, up=1.000000
ITER 3: row=45, varin=86, theta=1.000000, up=1.000000
ITER 4: row=49, varin=80, theta=1.298212, up=1.000000
ITER 5: row=49, varin=77, theta=0.224002, up=1.000000
ITER 6: row=42, varin=80, theta=0.980102, up=1.000000
ITER 7: row=11, varin=21, theta=0.014743, up=999999999999999983222784.000000
ITER 8: row=3, varin=61, theta=0.016477, up=1.000000
ITER 9: row=29, varin=54, theta=0.015588, up=1.000000
ITER 10: row=27, varin=83, theta=0.103412, up=1.000000
LP PHASE: Switching to primal (iter=11)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 29191280.563725
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 311 nonzeros, 0 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=19, theta=0.194482, up=999999999999999983222784.000000
ITER 2: row=50, varin=80, theta=4.909444, up=1.000000
ITER 3: row=50, varin=39, theta=0.005719, up=999999999999999983222784.000000
ITER 4: row=49, varin=80, theta=0.017234, up=1.000000
LP PHASE: Switching to primal (iter=4)
ITER 5: row=25, varin=77, theta=0.782762, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 29213928.146336
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 315 nonzeros, 3 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=80, theta=0.982766, up=1.000000
ITER 2: row=49, varin=38, theta=0.006198, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 29216450.576116
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 312 nonzeros, 1 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=4, theta=0.364757, up=999999999999999983222784.000000
ITER 2: row=40, varin=45, theta=1.616936, up=999999999999999983222784.000000
ITER 3: row=45, varin=40, theta=0.074620, up=999999999999999983222784.000000
ITER 4: row=39, varin=26, theta=0.051461, up=999999999999999983222784.000000
ITER 5: row=26, varin=28, theta=0.054827, up=999999999999999983222784.000000
ITER 6: row=28, varin=55, theta=0.127157, up=1.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 29289580.042322
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 316 nonzeros, 1 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 32 LP 1 Solution, length = 29289580.042322, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.872843 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.500000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.500000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.127157 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.127157 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=29289580.042322, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 32 at  29.28958004232247347431
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x555cc0985600
% @LO 0.02  28.45818511607782497208 99.9000000000
% @LN 0.02  28.46107887109048206753 99.9000000000
% Resuming node 27 at  28.46107887109048206753
DEBUG CONSTRNT: LP rows=51, pool->nlprows=51, pool->npend=0
DEBUG CONSTRNT: Checking 51 LP rows (pool tracks 51, total LP rows 51)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 62
DEBUG CONSTRNT: Pool row 62 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 141
DEBUG CONSTRNT: Pool row 141 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=50, expected 50
 % @PAP adding 42 rows, 214 nz to LP
DEBUG BB: Processing node 27, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=4, varin=8, theta=0.400000, up=999999999999999983222784.000000
ITER 2: row=8, varin=17, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=18, varin=5, theta=0.500000, up=999999999999999983222784.000000
ITER 4: row=17, varin=27, theta=0.500000, up=999999999999999983222784.000000
ITER 5: row=15, varin=57, theta=1.000000, up=1.000000
ITER 6: row=41, varin=25, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=25, varin=23, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=1, varin=34, theta=0.032521, up=999999999999999983222784.000000
ITER 9: row=34, varin=12, theta=0.116009, up=999999999999999983222784.000000
ITER 10: row=42, varin=13, theta=0.079543, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=10)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28461078.871090
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.920457
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 3.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.920457
DEBUG SOLUTION: lp->best_solution[13] = 0.920457
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 42 rows, 60 cols, 274 nonzeros, 5 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 5 rows, 19 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=4, theta=1.342433, up=999999999999999983222784.000000
ITER 2: row=47, varin=68, theta=0.142718, up=1.000000
ITER 3: row=46, varin=47, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=22, varin=55, theta=1.300183, up=1.000000
ITER 5: row=22, varin=58, theta=0.045910, up=1.000000
ITER 6: row=17, varin=55, theta=1.000000, up=1.000000
ITER 7: row=1, varin=72, theta=0.462802, up=1.000000
ITER 8: row=25, varin=60, theta=0.219036, up=1.000000
ITER 9: row=27, varin=19, theta=0.202901, up=999999999999999983222784.000000
ITER 10: row=34, varin=57, theta=0.434143, up=1.000000
LP PHASE: Switching to primal (iter=12)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28565228.763034
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.666667
DEBUG SOLUTION: lp->best_solution[5] = 0.666667
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 3.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.666667
DEBUG SOLUTION: lp->best_solution[13] = 0.666667
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 47 rows, 60 cols, 293 nonzeros, 6 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=18, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=1, varin=2, theta=0.055500, up=999999999999999983222784.000000
ITER 3: row=2, varin=15, theta=0.029020, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28569391.513048
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 3.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 280 nonzeros, 3 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=70, theta=0.036039, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28570805.090408
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 3.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 266 nonzeros, 0 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 27 LP 1 Solution, length = 28570805.090408, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.315314 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.315314 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.333333 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.333333 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.333333 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.036039 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.666667 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.666667 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.684686 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.684686 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.666667 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.666667 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28570805.090408, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 27 at  28.57080509040773819152
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x555cc09962c0
% @LO 0.02  28.46107887109048206753 99.9000000000
% @LN 0.02  28.46722836136250833761 99.9000000000
% Resuming node 31 at  28.46722836136250833761
DEBUG CONSTRNT: LP rows=43, pool->nlprows=43, pool->npend=0
DEBUG CONSTRNT: Checking 43 LP rows (pool tracks 43, total LP rows 43)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 141
DEBUG CONSTRNT: Pool row 141 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=42, expected 42
 % @PAP adding 39 rows, 197 nz to LP
DEBUG BB: Processing node 31, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 31 LP 2 Solution, length = 28467228.361363, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.013424 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.013424 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.500000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.500000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.500000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.986576 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.986576 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.986576 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.986576 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28467228.361363, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28467228.361363, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 31 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 31
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.013424
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.013424)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.013424
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.013424)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.500000
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.500000
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.500000
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.500000
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=1.000000
DEBUG CAREFUL: Skipping var 20: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 12
DEBUG CAREFUL: New best var: 12
DEBUG CAREFUL: Testing fvar[1] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 14
DEBUG CAREFUL: New best var: 14
DEBUG CAREFUL: Testing fvar[2] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 7
DEBUG CAREFUL: New best var: 7
DEBUG CAREFUL: Testing fvar[3] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[4] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
DEBUG CAREFUL: Testing fvar[5] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
  % Initial guess is x7, Z0 = 28467228.3613625        , Z1 = 28646513.952173         

DEBUG EVAL: Testing var 12 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=22, varin=42, theta=0.300000, up=1.000000
ITER 2: row=7, varin=66, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 12 = 0 gives z=28486678.860248
  % 	x12 = 0,	Z0 = 28486678.8602478        
DEBUG EVAL: First branch cutoff check: z=28486678.860248, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 1
ITER 1: row=22, varin=39, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=23, varin=32, theta=0.166667, up=999999999999999983222784.000000
ITER 3: row=32, varin=38, theta=0.333333, up=999999999999999983222784.000000
ITER 4: row=1, varin=29, theta=0.131519, up=999999999999999983222784.000000
  % 	x12 = 1,	Z1 = 28507078.1939606        
DEBUG EVAL: Second branch cutoff check: z=28507078.193961, best_z=INF, threshold=INF
  %   New best:  x12, Z = 28486678.8602478        
DEBUG EVAL: Testing var 14 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=21, varin=38, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=1, varin=3, theta=0.983598, up=999999999999999983222784.000000
ITER 3: row=3, varin=29, theta=0.613080, up=999999999999999983222784.000000
ITER 4: row=38, varin=66, theta=0.559635, up=1.000000
DEBUG EVAL: Branch var 14 = 1 gives z=28594122.325596
  % 	x14 = 1,	Z1 = 28594122.3255956        
DEBUG EVAL: First branch cutoff check: z=28594122.325596, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 14 = 0
ITER 1: row=21, varin=39, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=23, varin=31, theta=0.500000, up=999999999999999983222784.000000
  % 	x14 = 0,	Z0 = 28490921.4188164        
DEBUG EVAL: Second branch cutoff check: z=28490921.418816, best_z=INF, threshold=INF
  %   New best:  x14, Z = 28490921.4188164        
DEBUG EVAL: Testing var 7 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=12, varin=39, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=23, varin=38, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=22, varin=42, theta=0.600000, up=1.000000
ITER 4: row=1, varin=31, theta=0.891839, up=999999999999999983222784.000000
ITER 5: row=7, varin=66, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 7 = 1 gives z=28646513.952173
  % 	x7 = 1,	Z1 = 28646513.952173         
DEBUG EVAL: First branch cutoff check: z=28646513.952173, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 7 = 0
ITER 1: row=12, varin=29, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=4, varin=24, theta=0.033196, up=999999999999999983222784.000000
  % 	x7 = 0,	Z0 = 28537046.5234476        
DEBUG EVAL: Second branch cutoff check: z=28537046.523448, best_z=INF, threshold=INF
  %   New best:  x7, Z = 28537046.5234476        
DEBUG EVAL: Testing var 9 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=14, varin=39, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=23, varin=29, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=4, varin=38, theta=0.032189, up=999999999999999983222784.000000
ITER 4: row=38, varin=42, theta=0.018704, up=1.000000
ITER 5: row=7, varin=66, theta=0.033495, up=1.000000
DEBUG EVAL: Branch var 9 = 0 gives z=28538172.183236
  % 	x9 = 0,	Z0 = 28538172.1832356        
DEBUG EVAL: First branch cutoff check: z=28538172.183236, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 1
ITER 1: row=14, varin=24, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=31, theta=0.734643, up=999999999999999983222784.000000
  % 	x9 = 1,	Z1 = 28614322.9131316        
DEBUG EVAL: Second branch cutoff check: z=28614322.913132, best_z=INF, threshold=INF
  %   New best:  x9, Z = 28538172.1832356        
DEBUG EVAL: Testing var 0 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=29, theta=0.951748, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 0 = 1 gives z=28532289.935169
  % 	x0 = 1,	Z1 = 28532289.9351685        
DEBUG EVAL: First branch cutoff check: z=28532289.935169, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=3, theta=0.022202, up=999999999999999983222784.000000
ITER 2: row=28, varin=12, theta=8858.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 0 gives z=28468142.821299
  % 	x1 = 0,	Z0 = 28468142.8212987        
DEBUG EVAL: First branch cutoff check: z=28468142.821299, best_z=INF, threshold=INF
  % Best branch is x9, Z0 = 28538172.1832356        , Z1 = 28614322.9131316        

DEBUG CAREFUL: Final result - returning best.var = 9
DEBUG BB: Branching variable chosen: j=9
 % @NC   37   31	x9 = 0	28538172.183236
 % @NC   38   31	x9 = 1	28614322.913132
 %      31    17 28467228.3614               28501938.7115    x8 D    26     7
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x555cc09ab280
% @LO 0.02  28.46722836136250833761 99.9000000000
% @LN 0.02  28.50193871151484614757 99.9000000000
% Resuming node 35 at  28.50193871151484614757
DEBUG CONSTRNT: LP rows=39, pool->nlprows=39, pool->npend=0
DEBUG CONSTRNT: Checking 39 LP rows (pool tracks 39, total LP rows 39)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 141
DEBUG CONSTRNT: Pool row 141 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=38, expected 38
 % @PAP adding 37 rows, 165 nz to LP
DEBUG BB: Processing node 35, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=33, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=23, varin=40, theta=0.600000, up=1.000000
ITER 3: row=27, varin=56, theta=0.750000, up=1.000000
ITER 4: row=23, varin=5, theta=0.038462, up=999999999999999983222784.000000
ITER 5: row=28, varin=40, theta=0.642857, up=1.000000
ITER 6: row=8, varin=64, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 28501938.711515
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 3.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 37 rows, 60 cols, 225 nonzeros, 3 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 17 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=48, theta=0.333333, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28519898.439281
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 3.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 41 rows, 60 cols, 242 nonzeros, 3 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % Node 35 LP 1 Solution, length = 28519898.439281, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.333333 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.333333 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.666667 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.333333 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.333333 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.666667 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.333333 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28519898.439281, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 35 at  28.51989843928061318934
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x555cc099b4c0
% @LO 0.02  28.50193871151484614757 99.9000000000
% @LN 0.02  28.50384553371359785956 99.9000000000
% Resuming node 29 at  28.50384553371359785956
DEBUG CONSTRNT: LP rows=38, pool->nlprows=38, pool->npend=0
DEBUG CONSTRNT: Checking 38 LP rows (pool tracks 38, total LP rows 38)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=37, expected 37
 % @PAP adding 50 rows, 191 nz to LP
DEBUG BB: Processing node 29, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 29 LP 2 Solution, length = 28503845.533714, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.250000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.250000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.250000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.250000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.250000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.250000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.250000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.750000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.750000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.750000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.750000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.750000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.750000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.750000 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=28503845.533714, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28503845.533714, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 29 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 29
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.250000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.250000
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.250000
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.250000
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.250000
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.250000
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.250000
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 7 fractional variables

  %  Carefully choosing branching variable, nfrac = 7
DEBUG CAREFUL: Testing fvar[0] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[1] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 11
DEBUG CAREFUL: New best var: 11
DEBUG CAREFUL: Testing fvar[2] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[3] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[4] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[5] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 22
DEBUG CAREFUL: Testing fvar[6] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 27
  % Initial guess is x11, Z0 = 28503845.5337136        , Z1 = 28866925.0207968        

DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=8, varin=46, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=1, varin=49, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=45, varin=48, theta=3.000000, up=999999999999999983222784.000000
ITER 4: row=48, varin=45, theta=3.000000, up=999999999999999983222784.000000
ITER 5: row=41, varin=64, theta=2.000000, up=1.000000
ITER 6: row=41, varin=41, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=15, varin=64, theta=1.000000, up=1.000000
ITER 8: row=31, varin=40, theta=1.000000, up=999999999999999983222784.000000
ITER 9: row=40, varin=47, theta=1.000000, up=999999999999999983222784.000000
ITER 10: row=28, varin=43, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 1 gives z=28868977.058200
  % 	x3 = 1,	Z1 = 28868977.0581996        
DEBUG EVAL: First branch cutoff check: z=28868977.058200, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=8, varin=28, theta=0.333333, up=999999999999999983222784.000000
  % 	x3 = 0,	Z0 = 28529965.8820486        
DEBUG EVAL: Second branch cutoff check: z=28529965.882049, best_z=INF, threshold=INF
  %   New best:  x3, Z = 28529965.8820486        
DEBUG EVAL: Testing var 11 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=23, varin=46, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=1, varin=49, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=45, varin=48, theta=3.000000, up=999999999999999983222784.000000
ITER 4: row=48, varin=38, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=30, varin=45, theta=3.000000, up=999999999999999983222784.000000
ITER 6: row=41, varin=64, theta=2.000000, up=1.000000
ITER 7: row=41, varin=41, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=15, varin=64, theta=1.000000, up=1.000000
ITER 9: row=31, varin=40, theta=1.000000, up=999999999999999983222784.000000
ITER 10: row=40, varin=47, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 11 = 1 gives z=28866925.020797
  % 	x11 = 1,	Z1 = 28866925.0207968        
DEBUG EVAL: First branch cutoff check: z=28866925.020797, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 11 = 0
ITER 1: row=23, varin=28, theta=0.333333, up=999999999999999983222784.000000
  % 	x11 = 0,	Z0 = 28529965.8820486        
DEBUG EVAL: Second branch cutoff check: z=28529965.882049, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=28, theta=0.333333, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28529965.882049
  % 	x10 = 0,	Z0 = 28529965.8820486        
DEBUG EVAL: First branch cutoff check: z=28529965.882049, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 1
ITER 1: row=7, varin=46, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=1, varin=49, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=45, varin=48, theta=3.000000, up=999999999999999983222784.000000
ITER 4: row=48, varin=32, theta=0.750000, up=999999999999999983222784.000000
  % 	x10 = 1,	Z1 = 28599561.4767828        
DEBUG EVAL: Second branch cutoff check: z=28599561.476783, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 2 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=46, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=1, varin=49, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=45, varin=48, theta=3.000000, up=999999999999999983222784.000000
ITER 4: row=48, varin=45, theta=3.000000, up=999999999999999983222784.000000
ITER 5: row=41, varin=64, theta=2.000000, up=1.000000
ITER 6: row=41, varin=37, theta=0.333333, up=999999999999999983222784.000000
ITER 7: row=15, varin=64, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 2 = 1 gives z=28677340.242301
  % 	x2 = 1,	Z1 = 28677340.2423009        
DEBUG EVAL: First branch cutoff check: z=28677340.242301, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 0
ITER 1: row=2, varin=28, theta=0.333333, up=999999999999999983222784.000000
  % 	x2 = 0,	Z0 = 28529965.8820486        
DEBUG EVAL: Second branch cutoff check: z=28529965.882049, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 26 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=24, varin=28, theta=0.333333, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 0 gives z=28529965.882049
  % 	x26 = 0,	Z0 = 28529965.8820486        
DEBUG EVAL: First branch cutoff check: z=28529965.882049, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 1
ITER 1: row=24, varin=46, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=1, varin=49, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=45, varin=48, theta=3.000000, up=999999999999999983222784.000000
ITER 4: row=48, varin=32, theta=0.750000, up=999999999999999983222784.000000
  % 	x26 = 1,	Z1 = 28599561.4767828        
DEBUG EVAL: Second branch cutoff check: z=28599561.476783, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 22 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=31, varin=41, theta=0.333333, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 22 = 0 gives z=28526849.008248
  % 	x22 = 0,	Z0 = 28526849.0082478        
DEBUG EVAL: First branch cutoff check: z=28526849.008248, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 27 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=41, varin=45, theta=0.333333, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 27 = 0 gives z=28520158.204332
  % 	x27 = 0,	Z0 = 28520158.2043322        
DEBUG EVAL: First branch cutoff check: z=28520158.204332, best_z=INF, threshold=INF
  % Best branch is x3, Z0 = 28529965.8820486        , Z1 = 28868977.0581996        

DEBUG CAREFUL: Final result - returning best.var = 3
DEBUG BB: Branching variable chosen: j=3
 % @NC   39   29	x3 = 0	28529965.882049
 % @NC   40   29	x3 = 1	28868977.058200
 %      29    18 28503845.5337               28519898.4393    x4 D    23     8
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x555cc09ab280
% @LO 0.03  28.50384553371359785956 99.9000000000
% @LN 0.03  28.51989843928061318934 99.9000000000
% Resuming node 35 at  28.51989843928061318934
DEBUG CONSTRNT: LP rows=50, pool->nlprows=50, pool->npend=0
DEBUG CONSTRNT: Checking 50 LP rows (pool tracks 50, total LP rows 50)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=49, expected 49
 % @PAP adding 38 rows, 176 nz to LP
DEBUG BB: Processing node 35, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 35 LP 2 Solution, length = 28519898.439281, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.333333 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.333333 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.666667 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.333333 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.333333 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.666667 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.333333 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28519898.439281, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28519898.439281, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 35 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 35
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.333333
DEBUG CAREFUL: Adding var 6 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.333333
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.666667
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.666667)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 3 fractional variables

  %  Carefully choosing branching variable, nfrac = 3
DEBUG CAREFUL: Testing fvar[0] = var 6
DEBUG CAREFUL: Calling compare_branch_vars for var 6
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 6
DEBUG CAREFUL: New best var: 6
DEBUG CAREFUL: Testing fvar[1] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
DEBUG CAREFUL: Testing fvar[2] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 14
  % Initial guess is x6, Z0 = 28519898.4392806        , Z1 = 28697159.9792371        

DEBUG EVAL: Testing var 6 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=8, varin=35, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=35, varin=8, theta=0.857143, up=999999999999999983222784.000000
ITER 3: row=1, varin=28, theta=0.692308, up=999999999999999983222784.000000
ITER 4: row=28, varin=23, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=18, varin=40, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 6 = 1 gives z=28700437.913695
  % 	x6 = 1,	Z1 = 28700437.9136949        
DEBUG EVAL: First branch cutoff check: z=28700437.913695, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 6 = 0
ITER 1: row=8, varin=62, theta=1.000000, up=1.000000
ITER 2: row=22, varin=73, theta=0.500000, up=1.000000
  % 	x6 = 0,	Z0 = 28534888.0753336        
DEBUG EVAL: Second branch cutoff check: z=28534888.075334, best_z=INF, threshold=INF
  %   New best:  x6, Z = 28534888.0753336        
DEBUG EVAL: Testing var 12 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=18, varin=62, theta=1.000000, up=1.000000
ITER 2: row=22, varin=42, theta=0.529412, up=1.000000
ITER 3: row=29, varin=17, theta=0.075630, up=999999999999999983222784.000000
ITER 4: row=38, varin=33, theta=0.010804, up=999999999999999983222784.000000
ITER 5: row=26, varin=28, theta=0.017094, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 12 = 0 gives z=28545516.951208
  % 	x12 = 0,	Z0 = 28545516.9512079        
DEBUG EVAL: First branch cutoff check: z=28545516.951208, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 1
ITER 1: row=18, varin=18, theta=1.000000, up=999999999999999983222784.000000
  % 	x12 = 1,	Z1 = 28548648.7391649        
DEBUG EVAL: Second branch cutoff check: z=28548648.739165, best_z=INF, threshold=INF
  %   New best:  x12, Z = 28545516.9512079        
DEBUG EVAL: Testing var 14 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=23, varin=62, theta=1.000000, up=1.000000
ITER 2: row=22, varin=42, theta=0.529412, up=1.000000
ITER 3: row=29, varin=17, theta=0.075630, up=999999999999999983222784.000000
ITER 4: row=38, varin=33, theta=0.010804, up=999999999999999983222784.000000
ITER 5: row=26, varin=28, theta=0.017094, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 14 = 1 gives z=28545516.951208
  % 	x14 = 1,	Z1 = 28545516.9512079        
DEBUG EVAL: First branch cutoff check: z=28545516.951208, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 14 = 0
ITER 1: row=23, varin=18, theta=1.000000, up=999999999999999983222784.000000
  % 	x14 = 0,	Z0 = 28586614.776335         
DEBUG EVAL: Second branch cutoff check: z=28586614.776335, best_z=INF, threshold=INF
  %   New best:  x14, Z = 28545516.9512079        
  % Best branch is x14, Z0 = 28586614.776335         , Z1 = 28545516.9512079        

DEBUG CAREFUL: Final result - returning best.var = 14
DEBUG BB: Branching variable chosen: j=14
 % @NC   41   35	x14 = 1	28545516.951208
 % @NC   42   35	x14 = 0	28586614.776335
 %      35    19 28519898.4393               28524931.2766    x9 D    16     7
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x555cc099b400
% @LO 0.03  28.51989843928061318934 99.9000000000
% @LN 0.03  28.52493127655993987446 99.9000000000
% Resuming node 10 at  28.52493127655993987446
DEBUG CONSTRNT: LP rows=38, pool->nlprows=38, pool->npend=0
DEBUG CONSTRNT: Checking 38 LP rows (pool tracks 38, total LP rows 38)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=37, expected 37
 % @PAP adding 50 rows, 218 nz to LP
DEBUG BB: Processing node 10, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 10 LP 2 Solution, length = 28524931.276560, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.197012 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.197012 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.197012 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.197012 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.197012 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.197012 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.029884 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.802988 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.802988 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.802988 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.802988 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=28524931.276560, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28524931.276560, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 10 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 10
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.197012
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.197012)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.197012
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.197012)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.197012
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.197012)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.197012
DEBUG CAREFUL: Adding var 19 to fractional list (xi=0.197012)
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=1.000000
DEBUG CAREFUL: Skipping var 20: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.197012
DEBUG CAREFUL: Adding var 21 to fractional list (xi=0.197012)
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.197012
DEBUG CAREFUL: Adding var 25 to fractional list (xi=0.197012)
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.029884
DEBUG CAREFUL: Adding var 28 to fractional list (xi=0.029884)
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 7 fractional variables

  %  Carefully choosing branching variable, nfrac = 7
DEBUG CAREFUL: Testing fvar[0] = var 28
DEBUG CAREFUL: Calling compare_branch_vars for var 28
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 28
DEBUG CAREFUL: New best var: 28
DEBUG CAREFUL: Testing fvar[1] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 14
DEBUG CAREFUL: Testing fvar[2] = var 19
DEBUG CAREFUL: Calling compare_branch_vars for var 19
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 19
DEBUG CAREFUL: Testing fvar[3] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 15
DEBUG CAREFUL: Testing fvar[4] = var 25
DEBUG CAREFUL: Calling compare_branch_vars for var 25
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 25
DEBUG CAREFUL: Testing fvar[5] = var 21
DEBUG CAREFUL: Calling compare_branch_vars for var 21
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 21
DEBUG CAREFUL: Testing fvar[6] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
  % Initial guess is x28, Z0 = 28524931.2765599        , Z1 = 28872679.5920057        

DEBUG EVAL: Testing var 28 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=42, varin=48, theta=0.701565, up=999999999999999983222784.000000
ITER 2: row=34, varin=44, theta=0.810116, up=999999999999999983222784.000000
ITER 3: row=44, varin=43, theta=0.411800, up=999999999999999983222784.000000
ITER 4: row=43, varin=64, theta=0.487919, up=1.000000
ITER 5: row=29, varin=42, theta=0.389701, up=999999999999999983222784.000000
ITER 6: row=32, varin=38, theta=0.598357, up=999999999999999983222784.000000
ITER 7: row=41, varin=36, theta=0.295296, up=999999999999999983222784.000000
ITER 8: row=36, varin=27, theta=0.245057, up=999999999999999983222784.000000
ITER 9: row=27, varin=32, theta=0.261479, up=999999999999999983222784.000000
ITER 10: row=15, varin=34, theta=0.016640, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 28 = 1 gives z=28873092.509158
  % 	x28 = 1,	Z1 = 28873092.5091584        
DEBUG EVAL: First branch cutoff check: z=28873092.509158, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 28 = 0
ITER 1: row=42, varin=26, theta=0.117705, up=999999999999999983222784.000000
ITER 2: row=26, varin=7, theta=0.053317, up=999999999999999983222784.000000
ITER 3: row=50, varin=107, theta=0.068505, up=1.000000
  % 	x28 = 0,	Z0 = 28530292.6361759        
DEBUG EVAL: Second branch cutoff check: z=28530292.636176, best_z=INF, threshold=INF
  %   New best:  x28, Z = 28530292.6361759        
DEBUG EVAL: Testing var 14 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=15, varin=7, theta=0.572790, up=999999999999999983222784.000000
ITER 2: row=50, varin=32, theta=0.225263, up=999999999999999983222784.000000
ITER 3: row=31, varin=50, theta=0.259248, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 14 = 0 gives z=28670007.167792
  % 	x14 = 0,	Z0 = 28670007.1677922        
DEBUG EVAL: First branch cutoff check: z=28670007.167792, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 14 = 1
ITER 1: row=15, varin=26, theta=31.627595, up=999999999999999983222784.000000
ITER 2: row=26, varin=6, theta=1.396510, up=999999999999999983222784.000000
ITER 3: row=42, varin=107, theta=10.073730, up=1.000000
  % 	x14 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: Second branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=15, varin=7, theta=0.572790, up=999999999999999983222784.000000
ITER 2: row=50, varin=32, theta=0.225263, up=999999999999999983222784.000000
ITER 3: row=31, varin=50, theta=0.259248, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28670007.167792
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 3.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
   % @PL 50 rows, 60 cols, 278 nonzeros, 4 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 4 slack rows
   % @PAP adding 2 rows, 9 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=105, theta=0.085956, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28670899.847173
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 3.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
   % @PL 48 rows, 60 cols, 274 nonzeros, 0 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=64, theta=0.013689, up=1.000000
ITER 2: row=29, varin=26, theta=0.124665, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28674588.283854
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 3.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
   % @PL 50 rows, 60 cols, 280 nonzeros, 1 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=53, theta=0.037134, up=1.000000
ITER 2: row=9, varin=57, theta=0.025249, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28681752.468986
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 3.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
   % @PL 50 rows, 60 cols, 280 nonzeros, 0 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 10 at  28.68175246898556451924
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x555cc09962c0
% @LO 0.03  28.52493127655993987446 99.9000000000
% @LN 0.03  28.52996588204859662596 99.9000000000
% Resuming node 39 at  28.52996588204859662596
DEBUG CONSTRNT: LP rows=50, pool->nlprows=50, pool->npend=0
DEBUG CONSTRNT: Checking 50 LP rows (pool tracks 50, total LP rows 50)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 70
DEBUG CONSTRNT: Pool row 70 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=49, expected 49
 % @PAP adding 50 rows, 191 nz to LP
DEBUG BB: Processing node 39, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=8, varin=28, theta=0.333333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28529965.882049
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 251 nonzeros, 3 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=84, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28552592.952814
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 257 nonzeros, 0 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=53, varin=49, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 28554827.531563
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 54 rows, 60 cols, 269 nonzeros, 4 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % Node 39 LP 1 Solution, length = 28554827.531563, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.500000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.500000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.500000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.500000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.500000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.500000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.500000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28554827.531563, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 39 at  28.55482753156307751397
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x555cc09abe60
% @LO 0.03  28.52996588204859662596 99.9000000000
% @LN 0.03  28.53817218323561277771 99.9000000000
% Resuming node 37 at  28.53817218323561277771
DEBUG CONSTRNT: LP rows=50, pool->nlprows=50, pool->npend=0
DEBUG CONSTRNT: Checking 50 LP rows (pool tracks 50, total LP rows 50)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=49, expected 49
 % @PAP adding 39 rows, 197 nz to LP
DEBUG BB: Processing node 37, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=14, varin=39, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=23, varin=29, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=4, varin=38, theta=0.032189, up=999999999999999983222784.000000
ITER 4: row=38, varin=42, theta=0.018704, up=1.000000
ITER 5: row=7, varin=66, theta=0.033495, up=1.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 28538172.183236
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 39 rows, 60 cols, 257 nonzeros, 3 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 8 rows, 38 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=89, theta=0.500000, up=1.000000
ITER 2: row=41, varin=102, theta=0.607057, up=1.000000
ITER 3: row=39, varin=51, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28598808.339296
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 285 nonzeros, 3 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=81, theta=0.466374, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28601002.043040
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 265 nonzeros, 0 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=70, theta=0.117342, up=1.000000
ITER 2: row=20, varin=41, theta=0.169772, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28602465.060961
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 269 nonzeros, 1 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 37 LP 1 Solution, length = 28602465.060961, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.415114 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.415114 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.333333 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.333333 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.333333 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.333333 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.333333 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.584886 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.666667 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.584886 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.584886 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.666667 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.666667 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.666667 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.584886 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.666667 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.666667 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.666667 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=28602465.060961, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 37 at  28.60246506096057572677
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x555cc099b4c0
% @LO 0.03  28.53817218323561277771 99.9000000000
% @LN 0.03  28.54551695120794008176 99.9000000000
% Resuming node 41 at  28.54551695120794008176
DEBUG CONSTRNT: LP rows=45, pool->nlprows=45, pool->npend=0
DEBUG CONSTRNT: Checking 45 LP rows (pool tracks 45, total LP rows 45)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 141
DEBUG CONSTRNT: Pool row 141 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 60
DEBUG CONSTRNT: Pool row 60 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=44, expected 44
 % @PAP adding 38 rows, 176 nz to LP
DEBUG BB: Processing node 41, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=23, varin=62, theta=1.000000, up=1.000000
ITER 2: row=22, varin=42, theta=0.529412, up=1.000000
ITER 3: row=29, varin=17, theta=0.075630, up=999999999999999983222784.000000
ITER 4: row=38, varin=33, theta=0.010804, up=999999999999999983222784.000000
ITER 5: row=26, varin=28, theta=0.017094, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 28545516.951208
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.940171
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 3.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 38 rows, 60 cols, 236 nonzeros, 4 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 7 rows, 23 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=102, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28555891.030368
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 3.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 259 nonzeros, 0 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=11, theta=1.623188, up=999999999999999983222784.000000
ITER 2: row=28, varin=29, theta=0.666667, up=999999999999999983222784.000000
ITER 3: row=42, varin=26, theta=0.125000, up=999999999999999983222784.000000
ITER 4: row=1, varin=38, theta=0.352941, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28607044.948258
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.882353
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 265 nonzeros, 12 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 12 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=39, theta=0.937500, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=36)
DEBUG SOLUTION: LP solution array indices: FST[37-76], not_covered[77-96]
DEBUG SOLUTION: lp->best_solution[0] = 28633779.154069
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 36 rows, 60 cols, 223 nonzeros, 0 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=37, varin=49, theta=0.437500, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 28659916.498560
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 37 rows, 60 cols, 225 nonzeros, 0 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 5 rows, 24 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=47, theta=0.375000, up=1.000000
ITER 2: row=31, varin=2, theta=0.066667, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28673283.030707
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 0.933333
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 249 nonzeros, 2 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=73, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28678213.455864
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 245 nonzeros, 0 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=30, theta=0.923077, up=999999999999999983222784.000000
ITER 2: row=43, varin=20, theta=0.571429, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28687003.146378
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 258 nonzeros, 3 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % Node 41 LP 1 Solution, length = 28687003.146378, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.142857 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.142857 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.142857 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.142857 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.142857 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 1.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.142857 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.142857 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.857143 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.857143 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.857143 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.857143 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.857143 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.857143 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.857143 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=28687003.146378, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 41 at  28.68700314637818138408
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x555cc09a22d0
% @LO 0.03  28.54551695120794008176 99.9000000000
% @LN 0.03  28.55414664399043900289 99.9000000000
% Resuming node 22 at  28.55414664399043900289
DEBUG CONSTRNT: LP rows=44, pool->nlprows=44, pool->npend=0
DEBUG CONSTRNT: Checking 44 LP rows (pool tracks 44, total LP rows 44)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=43, expected 43
 % @PAP adding 33 rows, 186 nz to LP
DEBUG BB: Processing node 22, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=15, varin=58, theta=2.000000, up=1.000000
ITER 2: row=15, varin=13, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=13, varin=46, theta=0.500000, up=1.000000
ITER 4: row=28, varin=58, theta=1.000000, up=1.000000
ITER 5: row=17, varin=20, theta=0.111159, up=999999999999999983222784.000000
ITER 6: row=15, varin=15, theta=0.015609, up=999999999999999983222784.000000
ITER 7: row=1, varin=3, theta=0.035870, up=999999999999999983222784.000000
ITER 8: row=3, varin=21, theta=0.029191, up=999999999999999983222784.000000
ITER 9: row=14, varin=17, theta=0.025037, up=999999999999999983222784.000000
ITER 10: row=13, varin=57, theta=0.050598, up=1.000000
LP PHASE: Switching to primal (iter=18)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=33)
DEBUG SOLUTION: LP solution array indices: FST[34-73], not_covered[74-93]
DEBUG SOLUTION: lp->best_solution[0] = 28554146.643990
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 33 rows, 60 cols, 246 nonzeros, 0 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 7 rows, 24 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=63, theta=1.716697, up=1.000000
ITER 2: row=36, varin=64, theta=1.313664, up=1.000000
ITER 3: row=36, varin=30, theta=0.106433, up=999999999999999983222784.000000
ITER 4: row=29, varin=64, theta=1.000000, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 270 nonzeros, 3 slack, 37 tight.
  % Node 22 LP 1 Solution, length = 999999999999999983222784.000000, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.652855 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 1.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.694291 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 22 is INFEASIBLE
 %      22    18    infeasible               28554827.5316   x16 U    17     5
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x555cc09962c0
% @LO 0.03  28.55414664399043900289 99.9000000000
% @LN 0.03  28.55482753156307751397 99.9000000000
% Resuming node 39 at  28.55482753156307751397
DEBUG CONSTRNT: LP rows=40, pool->nlprows=40, pool->npend=0
DEBUG CONSTRNT: Checking 40 LP rows (pool tracks 40, total LP rows 40)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=39, expected 39
 % @PAP adding 50 rows, 192 nz to LP
DEBUG BB: Processing node 39, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 39 LP 2 Solution, length = 28554827.531563, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.500000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.500000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.500000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.500000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.500000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.500000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.500000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28554827.531563, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28554827.531563, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 39 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 39
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.500000
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.500000
DEBUG CAREFUL: Adding var 23 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.500000
DEBUG CAREFUL: Adding var 24 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.500000
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.500000
DEBUG CAREFUL: Adding var 30 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.500000
DEBUG CAREFUL: Adding var 33 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 24
DEBUG CAREFUL: Calling compare_branch_vars for var 24
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 24
DEBUG CAREFUL: New best var: 24
DEBUG CAREFUL: Testing fvar[1] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[2] = var 23
DEBUG CAREFUL: Calling compare_branch_vars for var 23
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 23
DEBUG CAREFUL: Testing fvar[3] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 29
DEBUG CAREFUL: Testing fvar[4] = var 33
DEBUG CAREFUL: Calling compare_branch_vars for var 33
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 33
DEBUG CAREFUL: Testing fvar[5] = var 30
DEBUG CAREFUL: Calling compare_branch_vars for var 30
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 30
  % Initial guess is x24, Z0 = 28554827.5315631        , Z1 = 28554827.5315631        

DEBUG EVAL: Testing var 24 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=27, varin=35, theta=0.333333, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 24 = 0 gives z=28574505.371548
  % 	x24 = 0,	Z0 = 28574505.3715481        
DEBUG EVAL: First branch cutoff check: z=28574505.371548, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 24 = 1
ITER 1: row=27, varin=49, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=49, varin=47, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=47, varin=46, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=46, varin=43, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=43, varin=44, theta=0.500000, up=999999999999999983222784.000000
  % 	x24 = 1,	Z1 = 28663655.1975413        
DEBUG EVAL: Second branch cutoff check: z=28663655.197541, best_z=INF, threshold=INF
  %   New best:  x24, Z = 28574505.3715481        
DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=35, theta=0.333333, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 0 gives z=28574505.371548
  % 	x1 = 0,	Z0 = 28574505.3715481        
DEBUG EVAL: First branch cutoff check: z=28574505.371548, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 1
ITER 1: row=1, varin=49, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=49, varin=45, theta=1.000000, up=999999999999999983222784.000000
  % 	x1 = 1,	Z1 = 28620368.3199642        
DEBUG EVAL: Second branch cutoff check: z=28620368.319964, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 23 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=35, theta=0.333333, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 23 = 0 gives z=28574505.371548
  % 	x23 = 0,	Z0 = 28574505.3715481        
DEBUG EVAL: First branch cutoff check: z=28574505.371548, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 23 = 1
ITER 1: row=2, varin=49, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=49, varin=47, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=47, varin=46, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=46, varin=19, theta=0.500000, up=999999999999999983222784.000000
  % 	x23 = 1,	Z1 = 28645965.2011331        
DEBUG EVAL: Second branch cutoff check: z=28645965.201133, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 29 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=19, varin=35, theta=0.333333, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 29 = 0 gives z=28574505.371548
  % 	x29 = 0,	Z0 = 28574505.3715481        
DEBUG EVAL: First branch cutoff check: z=28574505.371548, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 29 = 1
ITER 1: row=19, varin=49, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=49, varin=45, theta=1.000000, up=999999999999999983222784.000000
  % 	x29 = 1,	Z1 = 28620368.3199642        
DEBUG EVAL: Second branch cutoff check: z=28620368.319964, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 33 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=41, varin=35, theta=0.333333, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 33 = 0 gives z=28574505.371548
  % 	x33 = 0,	Z0 = 28574505.3715481        
DEBUG EVAL: First branch cutoff check: z=28574505.371548, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 33 = 1
ITER 1: row=41, varin=49, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=49, varin=47, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=47, varin=46, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=46, varin=43, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=43, varin=64, theta=1.000000, up=1.000000
ITER 6: row=15, varin=39, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=39, varin=38, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=38, varin=41, theta=1.000000, up=999999999999999983222784.000000
  % 	x33 = 1,	Z1 = 28767154.2126848        
DEBUG EVAL: Second branch cutoff check: z=28767154.212685, best_z=INF, threshold=INF
  %   New best:  x33, Z = 28574505.3715481        
DEBUG EVAL: Testing var 30 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=32, varin=35, theta=0.333333, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 30 = 0 gives z=28574505.371548
  % 	x30 = 0,	Z0 = 28574505.3715481        
DEBUG EVAL: First branch cutoff check: z=28574505.371548, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 30 = 1
ITER 1: row=32, varin=49, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=49, varin=45, theta=1.000000, up=999999999999999983222784.000000
  % 	x30 = 1,	Z1 = 28620368.3199642        
DEBUG EVAL: Second branch cutoff check: z=28620368.319964, best_z=INF, threshold=INF
  % Best branch is x33, Z0 = 28574505.3715481        , Z1 = 28767154.2126848        

DEBUG CAREFUL: Final result - returning best.var = 33
DEBUG BB: Branching variable chosen: j=33
 % @NC   43   39	x33 = 0	28574505.371548
 % @NC   44   39	x33 = 1	28767154.212685
 %      39    19 28554827.5316               28570805.0904    x3 D    29     9
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x555cc0985600
% @LO 0.03  28.55482753156307751397 99.9000000000
% @LN 0.03  28.57080509040773819152 99.9000000000
% Resuming node 27 at  28.57080509040773819152
DEBUG CONSTRNT: LP rows=50, pool->nlprows=50, pool->npend=0
DEBUG CONSTRNT: Checking 50 LP rows (pool tracks 50, total LP rows 50)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=49, expected 49
 % @PAP adding 43 rows, 206 nz to LP
DEBUG BB: Processing node 27, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 27 LP 2 Solution, length = 28570805.090408, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.315314 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.315314 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.333333 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.333333 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.333333 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.036039 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.666667 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.666667 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.684686 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.684686 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.666667 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.666667 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28570805.090408, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28570805.090408, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 27 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 27
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.315314
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.315314)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.315314
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.315314)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.333333
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.333333
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.333333
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=1.000000
DEBUG CAREFUL: Skipping var 17: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.036039
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.036039)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 12
DEBUG CAREFUL: New best var: 12
DEBUG CAREFUL: Testing fvar[1] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 15
DEBUG CAREFUL: Testing fvar[2] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 14
DEBUG CAREFUL: Testing fvar[3] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 26
DEBUG CAREFUL: New best var: 26
DEBUG CAREFUL: Testing fvar[4] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[5] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x26, Z0 = 28570805.0904077        , Z1 = 28637956.3352667        

DEBUG EVAL: Testing var 12 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=11, varin=41, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 12 = 0 gives z=28595160.027958
  % 	x12 = 0,	Z0 = 28595160.0279575        
DEBUG EVAL: First branch cutoff check: z=28595160.027958, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 1
ITER 1: row=11, varin=34, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=42, varin=39, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=39, varin=35, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=43, varin=37, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=37, varin=46, theta=0.938870, up=1.000000
ITER 6: row=21, varin=36, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=6, varin=67, theta=1.335533, up=1.000000
ITER 8: row=6, varin=50, theta=0.223663, up=1.000000
ITER 9: row=20, varin=67, theta=1.000000, up=1.000000
  % 	x12 = 1,	Z1 = 29183547.636901         
DEBUG EVAL: Second branch cutoff check: z=29183547.636901, best_z=INF, threshold=INF
  %   New best:  x12, Z = 28595160.0279575        
DEBUG EVAL: Testing var 15 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=34, varin=36, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=38, varin=34, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=42, varin=21, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 15 = 0 gives z=28745678.273341
  % 	x15 = 0,	Z0 = 28745678.2733407        
DEBUG EVAL: First branch cutoff check: z=28745678.273341, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 15 = 1
ITER 1: row=34, varin=41, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=37, varin=46, theta=1.115551, up=1.000000
ITER 3: row=37, varin=67, theta=0.150516, up=1.000000
ITER 4: row=11, varin=39, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=6, varin=46, theta=1.000000, up=1.000000
ITER 6: row=20, varin=50, theta=0.509232, up=1.000000
ITER 7: row=1, varin=56, theta=0.020096, up=1.000000
ITER 8: row=39, varin=5, theta=0.027241, up=999999999999999983222784.000000
ITER 9: row=5, varin=100, theta=0.196382, up=1.000000
  % 	x15 = 1,	Z1 = 28805712.1602989        
DEBUG EVAL: Second branch cutoff check: z=28805712.160299, best_z=INF, threshold=INF
  %   New best:  x15, Z = 28745678.2733407        
DEBUG EVAL: Testing var 14 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=21, varin=39, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 14 = 0 gives z=28640457.171353
  % 	x14 = 0,	Z0 = 28640457.1713533        
DEBUG EVAL: First branch cutoff check: z=28640457.171353, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 26 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=37, varin=41, theta=0.776223, up=999999999999999983222784.000000
ITER 2: row=11, varin=45, theta=0.528263, up=1.000000
ITER 3: row=2, varin=44, theta=0.208853, up=1.000000
DEBUG EVAL: Branch var 26 = 1 gives z=28637956.335267
  % 	x26 = 1,	Z1 = 28637956.3352669        
DEBUG EVAL: First branch cutoff check: z=28637956.335267, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 9 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=5, theta=1.832578, up=999999999999999983222784.000000
ITER 2: row=5, varin=28, theta=0.376646, up=999999999999999983222784.000000
ITER 3: row=28, varin=67, theta=13.563725, up=1.000000
ITER 4: row=28, varin=13, theta=0.695181, up=999999999999999983222784.000000
ITER 5: row=20, varin=67, theta=1.000000, up=1.000000
ITER 6: row=13, varin=21, theta=1.313035, up=999999999999999983222784.000000
ITER 7: row=37, varin=34, theta=0.579671, up=999999999999999983222784.000000
ITER 8: row=42, varin=46, theta=0.515106, up=1.000000
ITER 9: row=6, varin=100, theta=0.694354, up=1.000000
ITER 10: row=11, varin=73, theta=1.718430, up=1.000000
DEBUG EVAL: Branch var 9 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x9 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=46, theta=2.072208, up=1.000000
ITER 2: row=1, varin=45, theta=0.502500, up=1.000000
ITER 3: row=37, varin=46, theta=0.600000, up=1.000000
ITER 4: row=2, varin=41, theta=0.730204, up=999999999999999983222784.000000
ITER 5: row=6, varin=70, theta=1.397583, up=1.000000
ITER 6: row=6, varin=67, theta=0.419905, up=1.000000
ITER 7: row=11, varin=62, theta=0.184454, up=1.000000
ITER 8: row=6, varin=44, theta=0.208853, up=1.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28637956.335267
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 3.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 43 rows, 60 cols, 266 nonzeros, 3 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 3 slack rows
   % @PAP adding 2 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=40, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=69, theta=1.617543, up=1.000000
ITER 3: row=1, varin=66, theta=0.372648, up=1.000000
ITER 4: row=20, varin=55, theta=0.160775, up=1.000000
ITER 5: row=31, varin=49, theta=0.559130, up=1.000000
ITER 6: row=20, varin=20, theta=0.487880, up=999999999999999983222784.000000
ITER 7: row=1, varin=69, theta=0.174066, up=1.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28648863.252195
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 3.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 42 rows, 60 cols, 265 nonzeros, 1 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 2 rows, 20 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=67, theta=0.608745, up=1.000000
ITER 2: row=20, varin=56, theta=0.184695, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28650413.074298
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 3.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 43 rows, 60 cols, 283 nonzeros, 0 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 27 at  28.65041307429839534393
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x555cc09a22d0
% @LO 0.03  28.57080509040773819152 99.9000000000
% @LN 0.03  28.57450537154809211415 99.9000000000
% Resuming node 43 at  28.57450537154809211415
DEBUG CONSTRNT: LP rows=43, pool->nlprows=43, pool->npend=0
DEBUG CONSTRNT: Checking 43 LP rows (pool tracks 43, total LP rows 43)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 141
DEBUG CONSTRNT: Pool row 141 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=42, expected 42
 % @PAP adding 50 rows, 192 nz to LP
DEBUG BB: Processing node 43, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=35, theta=0.333333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28574505.371548
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 252 nonzeros, 3 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=45, theta=0.250000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28585971.108652
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 259 nonzeros, 5 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % Node 43 LP 1 Solution, length = 28585971.108652, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.250000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.250000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.250000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.250000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.250000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.250000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.250000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.750000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.750000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.750000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.750000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.750000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=28585971.108652, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.03  28.57450537154809211415 99.9000000000
 % @LN 0.03  28.58597110865212087560 99.9000000000
DEBUG CG: Second cutoff check: z=28585971.108652, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 43 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 43
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.250000
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.250000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.250000
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.250000
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.250000
DEBUG CAREFUL: Adding var 30 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.250000
DEBUG CAREFUL: Adding var 31 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.250000
DEBUG CAREFUL: Adding var 32 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 7 fractional variables

  %  Carefully choosing branching variable, nfrac = 7
DEBUG CAREFUL: Testing fvar[0] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 2
DEBUG CAREFUL: New best var: 2
DEBUG CAREFUL: Testing fvar[1] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 27
DEBUG CAREFUL: Testing fvar[2] = var 32
DEBUG CAREFUL: Calling compare_branch_vars for var 32
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 32
DEBUG CAREFUL: Testing fvar[3] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[4] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 29
DEBUG CAREFUL: Testing fvar[5] = var 31
DEBUG CAREFUL: Calling compare_branch_vars for var 31
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 31
DEBUG CAREFUL: Testing fvar[6] = var 30
DEBUG CAREFUL: Calling compare_branch_vars for var 30
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 30
  % Initial guess is x2, Z0 = 28585971.1086521        , Z1 = 28677340.2423009        

DEBUG EVAL: Testing var 2 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=46, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=41, varin=44, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 1 gives z=28690680.578811
  % 	x2 = 1,	Z1 = 28690680.5788107        
DEBUG EVAL: First branch cutoff check: z=28690680.578811, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 0
ITER 1: row=2, varin=47, theta=1.000000, up=999999999999999983222784.000000
  % 	x2 = 0,	Z0 = 28620368.3199642        
DEBUG EVAL: Second branch cutoff check: z=28620368.319964, best_z=INF, threshold=INF
  %   New best:  x2, Z = 28620368.3199642        
DEBUG EVAL: Testing var 27 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=19, varin=47, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 27 = 0 gives z=28620368.319964
  % 	x27 = 0,	Z0 = 28620368.3199642        
DEBUG EVAL: First branch cutoff check: z=28620368.319964, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 27 = 1
ITER 1: row=19, varin=46, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=41, varin=44, theta=1.000000, up=999999999999999983222784.000000
  % 	x27 = 1,	Z1 = 28690680.5788107        
DEBUG EVAL: Second branch cutoff check: z=28690680.578811, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 32 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=44, varin=47, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 32 = 0 gives z=28620368.319964
  % 	x32 = 0,	Z0 = 28620368.3199642        
DEBUG EVAL: First branch cutoff check: z=28620368.319964, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 32 = 1
ITER 1: row=44, varin=46, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=41, varin=43, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=43, varin=41, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=19, varin=61, theta=1.000000, up=1.000000
ITER 5: row=15, varin=37, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=37, varin=36, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=36, varin=39, theta=1.000000, up=999999999999999983222784.000000
  % 	x32 = 1,	Z1 = 28993883.1094954        
DEBUG EVAL: Second branch cutoff check: z=28993883.109495, best_z=INF, threshold=INF
  %   New best:  x32, Z = 28620368.3199642        
DEBUG EVAL: Testing var 1 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=47, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 1 gives z=28620368.319964
  % 	x1 = 1,	Z1 = 28620368.3199642        
DEBUG EVAL: First branch cutoff check: z=28620368.319964, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 0
ITER 1: row=1, varin=44, theta=0.500000, up=999999999999999983222784.000000
  % 	x1 = 0,	Z0 = 28621636.7658123        
DEBUG EVAL: Second branch cutoff check: z=28621636.765812, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 29 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=31, varin=47, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 29 = 1 gives z=28620368.319964
  % 	x29 = 1,	Z1 = 28620368.3199642        
DEBUG EVAL: First branch cutoff check: z=28620368.319964, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 29 = 0
ITER 1: row=31, varin=44, theta=0.500000, up=999999999999999983222784.000000
  % 	x29 = 0,	Z0 = 28621636.7658123        
DEBUG EVAL: Second branch cutoff check: z=28621636.765812, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 31 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=41, varin=46, theta=0.333333, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 31 = 0 gives z=28597097.160598
  % 	x31 = 0,	Z0 = 28597097.1605982        
DEBUG EVAL: First branch cutoff check: z=28597097.160598, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 30 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=39, varin=47, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 30 = 1 gives z=28620368.319964
  % 	x30 = 1,	Z1 = 28620368.3199642        
DEBUG EVAL: First branch cutoff check: z=28620368.319964, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 30 = 0
ITER 1: row=39, varin=44, theta=0.500000, up=999999999999999983222784.000000
  % 	x30 = 0,	Z0 = 28621636.7658123        
DEBUG EVAL: Second branch cutoff check: z=28621636.765812, best_z=INF, threshold=INF
  % Best branch is x32, Z0 = 28620368.3199642        , Z1 = 28993883.1094954        

DEBUG CAREFUL: Final result - returning best.var = 32
DEBUG BB: Branching variable chosen: j=32
 % @NC   45   43	x32 = 0	28620368.319964
 % @NC   46   43	x32 = 1	28993883.109495
 %      43    20 28585971.1087               28586614.7763   x33 D    39    10
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x555cc09a6580
% @LO 0.03  28.58597110865212087560 99.9000000000
% @LN 0.03  28.58661477633499359285 99.9000000000
% Resuming node 42 at  28.58661477633499359285
DEBUG CONSTRNT: LP rows=47, pool->nlprows=47, pool->npend=0
DEBUG CONSTRNT: Checking 47 LP rows (pool tracks 47, total LP rows 47)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=46, expected 46
 % @PAP adding 38 rows, 176 nz to LP
DEBUG BB: Processing node 42, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=23, varin=18, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 28548648.739165
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 3.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 38 rows, 60 cols, 236 nonzeros, 1 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 25 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=23, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=40, varin=31, theta=0.041667, up=999999999999999983222784.000000
ITER 3: row=41, varin=39, theta=0.040000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28601952.114335
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 3.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 261 nonzeros, 4 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 3 rows, 10 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=65, theta=1.000000, up=1.000000
ITER 2: row=21, varin=76, theta=1.083333, up=1.000000
ITER 3: row=21, varin=45, theta=0.040724, up=1.000000
ITER 4: row=27, varin=17, theta=0.005818, up=999999999999999983222784.000000
ITER 5: row=35, varin=30, theta=0.000831, up=999999999999999983222784.000000
ITER 6: row=24, varin=26, theta=0.001315, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28626809.444615
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.995398
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 3.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 41 rows, 60 cols, 250 nonzeros, 5 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 8 rows, 25 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=79, theta=1.000000, up=1.000000
ITER 2: row=37, varin=101, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28645628.351727
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 265 nonzeros, 0 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=10, theta=1.623188, up=999999999999999983222784.000000
ITER 2: row=41, varin=31, theta=0.608696, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28676300.529100
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.188406
DEBUG SOLUTION: lp->best_solution[9] = 0.188406
DEBUG SOLUTION: lp->best_solution[10] = 1.376812
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 271 nonzeros, 7 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 7 slack rows
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=20, theta=2.450000, up=999999999999999983222784.000000
ITER 2: row=41, varin=46, theta=0.500000, up=1.000000
ITER 3: row=40, varin=53, theta=0.375000, up=1.000000
ITER 4: row=34, varin=20, theta=0.071429, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28751225.521305
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 41 rows, 60 cols, 247 nonzeros, 1 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=2, theta=0.084746, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28757694.468144
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 0.915254
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 243 nonzeros, 1 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 7 rows, 30 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=79, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28767950.777223
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 271 nonzeros, 0 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=19, theta=0.774194, up=999999999999999983222784.000000
ITER 2: row=43, varin=32, theta=0.571429, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28776740.467737
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 53 rows, 60 cols, 284 nonzeros, 4 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % Node 42 LP 1 Solution, length = 28776740.467737, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.142857 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.142857 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.142857 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.142857 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.142857 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.142857 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.142857 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.857143 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.857143 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.857143 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.857143 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.857143 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.857143 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.857143 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=28776740.467737, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 42 at  28.77674046773728377957
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x555cc09971f0
% Resuming node 36 at  28.58661477633499359285
DEBUG CONSTRNT: LP rows=49, pool->nlprows=49, pool->npend=0
DEBUG CONSTRNT: Checking 49 LP rows (pool tracks 49, total LP rows 49)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 73
DEBUG CONSTRNT: Pool row 73 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=48, expected 48
 % @PAP adding 37 rows, 165 nz to LP
DEBUG BB: Processing node 36, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=31, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=37, varin=40, theta=0.600000, up=1.000000
ITER 3: row=27, varin=56, theta=0.750000, up=1.000000
ITER 4: row=26, varin=5, theta=0.065217, up=999999999999999983222784.000000
ITER 5: row=8, varin=64, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 28586614.776335
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 3.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 37 rows, 60 cols, 225 nonzeros, 3 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=62, theta=1.000000, up=1.000000
ITER 2: row=22, varin=42, theta=0.444444, up=1.000000
ITER 3: row=29, varin=7, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 28622696.532013
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 3.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 38 rows, 60 cols, 227 nonzeros, 4 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 4 rows, 17 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=35, varin=16, theta=0.038462, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 28625899.384032
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.970085
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 38 rows, 60 cols, 233 nonzeros, 4 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 4 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=35, varin=95, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 28631631.813600
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 3.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 38 rows, 60 cols, 230 nonzeros, 0 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=23, theta=2.153846, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28639648.691945
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 3.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 236 nonzeros, 3 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=9, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 28640690.676099
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.500000
DEBUG SOLUTION: lp->best_solution[8] = 0.500000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 38 rows, 60 cols, 224 nonzeros, 3 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 2 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=74, theta=0.500000, up=1.000000
ITER 2: row=9, varin=49, theta=0.214286, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 28679872.496339
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 37 rows, 60 cols, 228 nonzeros, 1 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=37, varin=20, theta=0.625000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 28684194.755074
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 38 rows, 60 cols, 222 nonzeros, 1 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 36 LP 1 Solution, length = 28684194.755074, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.125000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.125000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.125000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.500000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.875000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.875000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.875000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28684194.755074, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 36 at  28.68419475507401017467
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x555cc098d550
% @LO 0.03  28.58661477633499359285 99.9000000000
% @LN 0.03  28.59860570402517865318 99.9000000000
% Resuming node 33 at  28.59860570402517865318
DEBUG CONSTRNT: LP rows=37, pool->nlprows=37, pool->npend=0
DEBUG CONSTRNT: Checking 37 LP rows (pool tracks 37, total LP rows 37)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 158
DEBUG CONSTRNT: Pool row 158 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=36, expected 36
 % @PAP adding 41 rows, 174 nz to LP
DEBUG BB: Processing node 33, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=29, varin=29, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=40, varin=28, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28598605.704025
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 3.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 41 rows, 60 cols, 234 nonzeros, 3 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 9 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=69, theta=0.500000, up=1.000000
ITER 2: row=22, varin=49, theta=0.222222, up=1.000000
ITER 3: row=33, varin=15, theta=0.038462, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28619849.433883
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.970085
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 3.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 243 nonzeros, 6 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 5 rows, 53 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=51, theta=0.038279, up=1.000000
ITER 2: row=40, varin=101, theta=0.563723, up=1.000000
ITER 3: row=39, varin=44, theta=22920.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28625581.863452
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 3.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 44 rows, 60 cols, 284 nonzeros, 1 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 33 LP 1 Solution, length = 28625581.863452, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 1.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.500000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.500000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.500000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.500000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.500000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.500000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=28625581.863452, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 33 at  28.62558186345157196229
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x555cc09abe60
% @LO 0.03  28.59860570402517865318 99.9000000000
% @LN 0.03  28.60246506096057572677 99.9000000000
% Resuming node 37 at  28.60246506096057572677
DEBUG CONSTRNT: LP rows=43, pool->nlprows=43, pool->npend=0
DEBUG CONSTRNT: Checking 43 LP rows (pool tracks 43, total LP rows 43)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 158
DEBUG CONSTRNT: Pool row 158 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=42, expected 42
 % @PAP adding 45 rows, 206 nz to LP
DEBUG BB: Processing node 37, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 37 LP 2 Solution, length = 28602465.060961, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.415114 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.415114 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.333333 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.333333 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.333333 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.333333 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.333333 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.584886 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.666667 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.584886 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.584886 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.666667 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.666667 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.666667 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.584886 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.666667 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.666667 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.666667 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=28602465.060961, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28602465.060961, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 3 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 37 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 37
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.415114
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.415114)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.415114
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.415114)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.333333
DEBUG CAREFUL: Adding var 6 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.333333
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.333333
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.333333
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=1.000000
DEBUG CAREFUL: Skipping var 20: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.333333
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 7 fractional variables

  %  Carefully choosing branching variable, nfrac = 7
DEBUG CAREFUL: Testing fvar[0] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 36
DEBUG CAREFUL: New best var: 36
DEBUG CAREFUL: Testing fvar[1] = var 6
DEBUG CAREFUL: Calling compare_branch_vars for var 6
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 6
DEBUG CAREFUL: New best var: 6
DEBUG CAREFUL: Testing fvar[2] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 14
DEBUG CAREFUL: Testing fvar[3] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
DEBUG CAREFUL: Testing fvar[4] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
DEBUG CAREFUL: Testing fvar[5] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
DEBUG CAREFUL: Testing fvar[6] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
  % Initial guess is x6, Z0 = 28602465.0609606        , Z1 = 28724890.6034995        

DEBUG EVAL: Testing var 36 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=29, varin=20, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=20, varin=42, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=4, varin=69, theta=4.483000, up=1.000000
ITER 4: row=4, varin=3, theta=1.401970, up=999999999999999983222784.000000
ITER 5: row=3, varin=22, theta=0.426244, up=999999999999999983222784.000000
ITER 6: row=29, varin=69, theta=1.000000, up=1.000000
ITER 7: row=45, varin=30, theta=1.294573, up=999999999999999983222784.000000
ITER 8: row=20, varin=102, theta=1.513676, up=1.000000
ITER 9: row=20, varin=24, theta=0.376258, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 36 = 1 gives z=28854413.495878
  % 	x36 = 1,	Z1 = 28854413.4958776        
DEBUG EVAL: First branch cutoff check: z=28854413.495878, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 36 = 0
ITER 1: row=29, varin=44, theta=0.500000, up=999999999999999983222784.000000
  % 	x36 = 0,	Z0 = 28606130.641548         
DEBUG EVAL: Second branch cutoff check: z=28606130.641548, best_z=INF, threshold=INF
  %   New best:  x36, Z = 28606130.641548         
DEBUG EVAL: Testing var 6 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=12, varin=44, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=29, varin=20, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=20, varin=38, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=38, varin=7, theta=0.400000, up=999999999999999983222784.000000
ITER 5: row=7, varin=40, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=3, varin=23, theta=0.861009, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 6 = 1 gives z=28717579.191751
  % 	x6 = 1,	Z1 = 28724890.6034995        
DEBUG EVAL: First branch cutoff check: z=28724890.603500, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 6 = 0
ITER 1: row=12, varin=80, theta=1.000000, up=1.000000
  % 	x6 = 0,	Z0 = 28609698.1801181        
DEBUG EVAL: Second branch cutoff check: z=28609698.180118, best_z=INF, threshold=INF
  %   New best:  x6, Z = 28609698.1801181        
DEBUG EVAL: Testing var 14 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=21, varin=80, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 14 = 0 gives z=28609698.180118
  % 	x14 = 0,	Z0 = 28609698.1801181        
DEBUG EVAL: First branch cutoff check: z=28609698.180118, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 14 = 1
ITER 1: row=21, varin=44, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=29, varin=20, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=20, varin=42, theta=0.500000, up=999999999999999983222784.000000
ITER 4: row=3, varin=69, theta=3.610156, up=1.000000
ITER 5: row=3, varin=23, theta=0.554354, up=999999999999999983222784.000000
ITER 6: row=29, varin=69, theta=1.000000, up=1.000000
  % 	x14 = 1,	Z1 = 28661676.6894471        
DEBUG EVAL: Second branch cutoff check: z=28661676.689447, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 7 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=14, varin=44, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=29, varin=20, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=20, varin=42, theta=0.500000, up=999999999999999983222784.000000
ITER 4: row=3, varin=69, theta=3.610156, up=1.000000
ITER 5: row=3, varin=30, theta=0.753745, up=999999999999999983222784.000000
ITER 6: row=29, varin=69, theta=1.000000, up=1.000000
ITER 7: row=20, varin=102, theta=1.709612, up=1.000000
ITER 8: row=20, varin=27, theta=0.968847, up=999999999999999983222784.000000
ITER 9: row=27, varin=80, theta=2.034573, up=1.000000
ITER 10: row=27, varin=75, theta=0.293391, up=1.000000
DEBUG EVAL: Branch var 7 = 1 gives z=28852765.774349
  % 	x7 = 1,	Z1 = 28852765.7743492        
DEBUG EVAL: First branch cutoff check: z=28852765.774349, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 7 = 0
ITER 1: row=14, varin=80, theta=1.000000, up=1.000000
  % 	x7 = 0,	Z0 = 28609698.1801181        
DEBUG EVAL: Second branch cutoff check: z=28609698.180118, best_z=INF, threshold=INF
  %   New best:  x7, Z = 28609698.1801181        
DEBUG EVAL: Testing var 12 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=22, varin=80, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 12 = 0 gives z=28609698.180118
  % 	x12 = 0,	Z0 = 28609698.1801181        
DEBUG EVAL: First branch cutoff check: z=28609698.180118, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 1
ITER 1: row=22, varin=44, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=29, varin=20, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=20, varin=42, theta=0.500000, up=999999999999999983222784.000000
ITER 4: row=3, varin=69, theta=3.610156, up=1.000000
ITER 5: row=3, varin=23, theta=0.554354, up=999999999999999983222784.000000
ITER 6: row=29, varin=69, theta=1.000000, up=1.000000
  % 	x12 = 1,	Z1 = 28661676.6894471        
DEBUG EVAL: Second branch cutoff check: z=28661676.689447, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 0 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=20, theta=0.573833, up=999999999999999983222784.000000
ITER 2: row=20, varin=44, theta=0.975905, up=999999999999999983222784.000000
ITER 3: row=29, varin=42, theta=0.130274, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 0 = 0 gives z=28611111.928156
  % 	x0 = 0,	Z0 = 28611111.9281562        
DEBUG EVAL: First branch cutoff check: z=28611111.928156, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 0 = 1
ITER 1: row=1, varin=80, theta=1.270655, up=1.000000
ITER 2: row=1, varin=102, theta=0.204512, up=1.000000
ITER 3: row=12, varin=3, theta=0.315115, up=999999999999999983222784.000000
ITER 4: row=28, varin=23, theta=0.133514, up=999999999999999983222784.000000
ITER 5: row=23, varin=80, theta=0.836854, up=1.000000
  % 	x0 = 1,	Z1 = 28630303.7339939        
DEBUG EVAL: Second branch cutoff check: z=28630303.733994, best_z=INF, threshold=INF
  %   New best:  x0, Z = 28611111.9281562        
DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=20, theta=0.573833, up=999999999999999983222784.000000
ITER 2: row=20, varin=44, theta=0.975905, up=999999999999999983222784.000000
ITER 3: row=29, varin=42, theta=0.130274, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 0 gives z=28611111.928156
  % 	x1 = 0,	Z0 = 28611111.9281562        
DEBUG EVAL: First branch cutoff check: z=28611111.928156, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 1
ITER 1: row=3, varin=80, theta=1.270655, up=1.000000
ITER 2: row=3, varin=102, theta=0.204512, up=1.000000
ITER 3: row=12, varin=23, theta=0.133514, up=999999999999999983222784.000000
ITER 4: row=23, varin=80, theta=0.836854, up=1.000000
  % 	x1 = 1,	Z1 = 28630303.7339939        
DEBUG EVAL: Second branch cutoff check: z=28630303.733994, best_z=INF, threshold=INF
  % Best branch is x0, Z0 = 28611111.9281562        , Z1 = 28630303.7339939        

DEBUG CAREFUL: Final result - returning best.var = 0
DEBUG BB: Branching variable chosen: j=0
 % @NC   47   37	x0 = 0	28611111.928156
 % @NC   48   37	x0 = 1	28630303.733994
 %      37    21 28602465.0610               28611111.9282    x9 D    31     8
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x555cc09a22d0
% @LO 0.03  28.60246506096057572677 99.9000000000
% @LN 0.03  28.61111192815624804098 99.9000000000
% Resuming node 47 at  28.61111192815624804098
DEBUG CONSTRNT: LP rows=45, pool->nlprows=45, pool->npend=0
DEBUG CONSTRNT: Checking 45 LP rows (pool tracks 45, total LP rows 45)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 141
DEBUG CONSTRNT: Pool row 141 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 60
DEBUG CONSTRNT: Pool row 60 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=44, expected 44
 % @PAP adding 45 rows, 206 nz to LP
DEBUG BB: Processing node 47, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=20, theta=0.573833, up=999999999999999983222784.000000
ITER 2: row=20, varin=44, theta=0.975905, up=999999999999999983222784.000000
ITER 3: row=29, varin=42, theta=0.130274, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28611111.928156
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 266 nonzeros, 5 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 22 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=86, theta=1.457361, up=1.000000
ITER 2: row=49, varin=12, theta=41921.500000, up=999999999999999983222784.000000
ITER 3: row=44, varin=86, theta=0.421443, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28619250.052061
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1712248.750000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 288 nonzeros, 7 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 7 slack rows
  % Node 47 LP 1 Solution, length = 28619250.052061, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.250000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.500000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.500000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.500000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28619250.052061, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 47 at  28.61925005206063232777
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x555cc099a900
% @LO 0.03  28.61111192815624804098 99.9000000000
% @LN 0.03  28.61432291313163389646 99.9000000000
% Resuming node 38 at  28.61432291313163389646
DEBUG CONSTRNT: LP rows=42, pool->nlprows=42, pool->npend=0
DEBUG CONSTRNT: Checking 42 LP rows (pool tracks 42, total LP rows 42)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 141
DEBUG CONSTRNT: Pool row 141 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=41, expected 41
 % @PAP adding 39 rows, 197 nz to LP
DEBUG BB: Processing node 38, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=14, varin=24, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=31, theta=0.734643, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 28614322.913132
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 39 rows, 60 cols, 257 nonzeros, 3 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 2 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=37, varin=3, theta=1.155265, up=999999999999999983222784.000000
ITER 2: row=3, varin=41, theta=0.479837, up=1.000000
ITER 3: row=7, varin=65, theta=0.669421, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 28637273.434957
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 38 rows, 60 cols, 258 nonzeros, 1 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 2 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=63, theta=0.643099, up=1.000000
ITER 2: row=20, varin=46, theta=0.414405, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 28661405.487737
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 39 rows, 60 cols, 258 nonzeros, 0 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=98, theta=0.390872, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28676749.844115
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 41 rows, 60 cols, 262 nonzeros, 0 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=27, theta=0.286306, up=999999999999999983222784.000000
ITER 2: row=45, varin=80, theta=1.120693, up=1.000000
ITER 3: row=45, varin=75, theta=0.034227, up=1.000000
ITER 4: row=42, varin=80, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28708625.325067
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 276 nonzeros, 0 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=71, theta=0.244007, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28743005.571745
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 289 nonzeros, 0 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 38 LP 1 Solution, length = 28743005.571745, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.251998 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.251998 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.251998 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.244007 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.748002 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.748002 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.748002 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.748002 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28743005.571745, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 38 at  28.74300557174481696165
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x555cc09a22d0
% @LO 0.03  28.61432291313163389646 99.9000000000
% @LN 0.03  28.61925005206063232777 99.9000000000
% Resuming node 47 at  28.61925005206063232777
DEBUG CONSTRNT: LP rows=49, pool->nlprows=49, pool->npend=0
DEBUG CONSTRNT: Checking 49 LP rows (pool tracks 49, total LP rows 49)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 141
DEBUG CONSTRNT: Pool row 141 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=48, expected 48
 % @PAP adding 42 rows, 165 nz to LP
DEBUG BB: Processing node 47, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 47 LP 2 Solution, length = 28619250.052061, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.250000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.500000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.500000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.500000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28619250.052061, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28619250.052061, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 47 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 47
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.250000
DEBUG CAREFUL: Adding var 6 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.500000
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.500000
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.500000
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=1.000000
DEBUG CAREFUL: Skipping var 20: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.500000
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 14
DEBUG CAREFUL: New best var: 14
DEBUG CAREFUL: Testing fvar[1] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 7
DEBUG CAREFUL: New best var: 7
DEBUG CAREFUL: Testing fvar[2] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
DEBUG CAREFUL: Testing fvar[3] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 36
DEBUG CAREFUL: New best var: 36
DEBUG CAREFUL: Testing fvar[4] = var 6
DEBUG CAREFUL: Calling compare_branch_vars for var 6
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 6
  % Initial guess is x36, Z0 = 28619250.0520606        , Z1 = 28854413.4958776        

DEBUG EVAL: Testing var 14 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=25, varin=39, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 14 = 1 gives z=28631385.240457
  % 	x14 = 1,	Z1 = 28661676.6894471        
DEBUG EVAL: First branch cutoff check: z=28661676.689447, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 14 = 0
ITER 1: row=25, varin=42, theta=1.000000, up=999999999999999983222784.000000
  % 	x14 = 0,	Z0 = 28653726.7351967        
DEBUG EVAL: Second branch cutoff check: z=28653726.735197, best_z=INF, threshold=INF
  %   New best:  x14, Z = 28653726.7351967        
DEBUG EVAL: Testing var 7 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=22, varin=39, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 7 = 1 gives z=28631385.240457
  % 	x7 = 1,	Z1 = 28852765.7743492        
DEBUG EVAL: First branch cutoff check: z=28852765.774349, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 7 = 0
ITER 1: row=22, varin=42, theta=1.000000, up=999999999999999983222784.000000
  % 	x7 = 0,	Z0 = 28653726.7351967        
DEBUG EVAL: Second branch cutoff check: z=28653726.735197, best_z=INF, threshold=INF
  %   New best:  x7, Z = 28653726.7351967        
DEBUG EVAL: Testing var 12 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=39, varin=25, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=36, varin=29, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 12 = 1 gives z=28841798.281211
  % 	x12 = 1,	Z1 = 28841798.281211         
DEBUG EVAL: First branch cutoff check: z=28841798.281211, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 0
ITER 1: row=39, varin=39, theta=1.000000, up=999999999999999983222784.000000
  % 	x12 = 0,	Z0 = 28631385.2404573        
DEBUG EVAL: Second branch cutoff check: z=28631385.240457, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 36 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=40, varin=39, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 36 = 1 gives z=28631385.240457
  % 	x36 = 1,	Z1 = 28854413.4958776        
DEBUG EVAL: First branch cutoff check: z=28854413.495878, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 36 = 0
ITER 1: row=40, varin=40, theta=0.500000, up=999999999999999983222784.000000
  % 	x36 = 0,	Z0 = 28619920.1626564        
DEBUG EVAL: Second branch cutoff check: z=28619920.162656, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 6 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=40, theta=1.500000, up=999999999999999983222784.000000
ITER 2: row=40, varin=37, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=37, varin=39, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 6 = 1 gives z=28632725.461649
  % 	x6 = 1,	Z1 = 28724890.6034995        
DEBUG EVAL: First branch cutoff check: z=28724890.603500, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 6 = 0
ITER 1: row=1, varin=66, theta=0.500000, up=1.000000
ITER 2: row=19, varin=77, theta=0.500000, up=1.000000
  % 	x6 = 0,	Z0 = 28627052.1131425        
DEBUG EVAL: Second branch cutoff check: z=28627052.113143, best_z=INF, threshold=INF
  % Best branch is x7, Z0 = 28653726.7351967        , Z1 = 28852765.7743492        

DEBUG CAREFUL: Final result - returning best.var = 7
DEBUG BB: Branching variable chosen: j=7
 % @NC   49   47	x7 = 0	28653726.735197
 % @NC   50   47	x7 = 1	28852765.774349
 %      47    22 28619250.0521               28620368.3200    x0 D    37     9
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x555cc09962c0
% @LO 0.03  28.61925005206063232777 99.9000000000
% @LN 0.03  28.62036831996420005453 99.9000000000
% Resuming node 45 at  28.62036831996420005453
DEBUG CONSTRNT: LP rows=42, pool->nlprows=42, pool->npend=0
DEBUG CONSTRNT: Checking 42 LP rows (pool tracks 42, total LP rows 42)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 141
DEBUG CONSTRNT: Pool row 141 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=41, expected 41
 % @PAP adding 47 rows, 178 nz to LP
DEBUG BB: Processing node 45, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=47, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28620368.319964
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 238 nonzeros, 1 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=44, theta=0.250000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28621002.542888
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 243 nonzeros, 3 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % Node 45 LP 1 Solution, length = 28621002.542888, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.250000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.250000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.500000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.500000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.250000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.750000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.750000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28621002.542888, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.04  28.62036831996420005453 99.9000000000
 % @LN 0.04  28.62100254288826661764 99.9000000000
DEBUG CG: Second cutoff check: z=28621002.542888, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 3 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 45 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 45
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.500000
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.250000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.250000
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.500000
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.500000
DEBUG CAREFUL: Adding var 30 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.250000
DEBUG CAREFUL: Adding var 31 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 1
DEBUG CAREFUL: New best var: 1
DEBUG CAREFUL: Testing fvar[1] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 29
DEBUG CAREFUL: Testing fvar[2] = var 30
DEBUG CAREFUL: Calling compare_branch_vars for var 30
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 30
DEBUG CAREFUL: Testing fvar[3] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 2
DEBUG CAREFUL: New best var: 2
DEBUG CAREFUL: Testing fvar[4] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 27
DEBUG CAREFUL: Testing fvar[5] = var 31
DEBUG CAREFUL: Calling compare_branch_vars for var 31
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 31
  % Initial guess is x2, Z0 = 28621002.5428883        , Z1 = 28690680.5788107        

DEBUG EVAL: Testing var 1 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=39, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=46, varin=31, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 1 gives z=29298990.318166
  % 	x1 = 1,	Z1 = 29298990.3181663        
DEBUG EVAL: First branch cutoff check: z=29298990.318166, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 0
ITER 1: row=1, varin=45, theta=1.000000, up=999999999999999983222784.000000
  % 	x1 = 0,	Z0 = 28621636.7658123        
DEBUG EVAL: Second branch cutoff check: z=28621636.765812, best_z=INF, threshold=INF
  %   New best:  x1, Z = 28621636.7658123        
DEBUG EVAL: Testing var 29 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=31, varin=3, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=32, varin=39, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=46, varin=6, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=32, varin=45, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 29 = 1 gives z=29701078.363549
  % 	x29 = 1,	Z1 = 29701078.3635489        
DEBUG EVAL: First branch cutoff check: z=29701078.363549, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 29 = 0
ITER 1: row=31, varin=45, theta=1.000000, up=999999999999999983222784.000000
  % 	x29 = 0,	Z0 = 28621636.7658123        
DEBUG EVAL: Second branch cutoff check: z=28621636.765812, best_z=INF, threshold=INF
  %   New best:  x29, Z = 28621636.7658123        
DEBUG EVAL: Testing var 30 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=39, varin=2, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=40, varin=3, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=32, varin=31, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 30 = 1 gives z=29821428.531009
  % 	x30 = 1,	Z1 = 29821428.5310091        
DEBUG EVAL: First branch cutoff check: z=29821428.531009, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 30 = 0
ITER 1: row=39, varin=45, theta=1.000000, up=999999999999999983222784.000000
  % 	x30 = 0,	Z0 = 28621636.7658123        
DEBUG EVAL: Second branch cutoff check: z=28621636.765812, best_z=INF, threshold=INF
  %   New best:  x30, Z = 28621636.7658123        
DEBUG EVAL: Testing var 2 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=45, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=44, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 1 gives z=28690680.578811
  % 	x2 = 1,	Z1 = 28690680.5788107        
DEBUG EVAL: First branch cutoff check: z=28690680.578811, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 0
ITER 1: row=2, varin=34, theta=0.500000, up=999999999999999983222784.000000
  % 	x2 = 0,	Z0 = 28625760.141904         
DEBUG EVAL: Second branch cutoff check: z=28625760.141904, best_z=INF, threshold=INF
  %   New best:  x2, Z = 28625760.141904         
DEBUG EVAL: Testing var 27 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=19, varin=45, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=44, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 27 = 1 gives z=28690680.578811
  % 	x27 = 1,	Z1 = 28690680.5788107        
DEBUG EVAL: First branch cutoff check: z=28690680.578811, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 27 = 0
ITER 1: row=19, varin=34, theta=0.500000, up=999999999999999983222784.000000
  % 	x27 = 0,	Z0 = 28625760.141904         
DEBUG EVAL: Second branch cutoff check: z=28625760.141904, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 31 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=41, varin=34, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 31 = 0 gives z=28625760.141904
  % 	x31 = 0,	Z0 = 28625760.141904         
DEBUG EVAL: First branch cutoff check: z=28625760.141904, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 31 = 1
ITER 1: row=41, varin=45, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=43, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=43, varin=41, theta=1.000000, up=999999999999999983222784.000000
  % 	x31 = 1,	Z1 = 28788366.009767         
DEBUG EVAL: Second branch cutoff check: z=28788366.009767, best_z=INF, threshold=INF
  %   New best:  x31, Z = 28625760.141904         
  % Best branch is x31, Z0 = 28625760.141904         , Z1 = 28788366.009767         

DEBUG CAREFUL: Final result - returning best.var = 31
DEBUG BB: Branching variable chosen: j=31
 % @NC   51   45	x31 = 0	28625760.141904
 % @NC   52   45	x31 = 1	28788366.009767
 %      45    23 28621002.5429               28625581.8635   x32 D    43    11
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x555cc098d550
% @LO 0.04  28.62100254288826661764 99.9000000000
% @LN 0.04  28.62558186345157196229 99.9000000000
% Resuming node 33 at  28.62558186345157196229
DEBUG CONSTRNT: LP rows=46, pool->nlprows=46, pool->npend=0
DEBUG CONSTRNT: Checking 46 LP rows (pool tracks 46, total LP rows 46)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 143
DEBUG CONSTRNT: Pool row 143 has lprow=45, expected 45
 % @PAP adding 43 rows, 184 nz to LP
DEBUG BB: Processing node 33, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 33 LP 2 Solution, length = 28625581.863452, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 1.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.500000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.500000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.500000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.500000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.500000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.500000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=28625581.863452, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28625581.863452, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 33 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 33
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=1.000000
DEBUG CAREFUL: Skipping var 0: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.500000
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.500000
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.500000
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.500000
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.500000
DEBUG CAREFUL: Adding var 23 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.500000
DEBUG CAREFUL: Adding var 24 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.500000
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 7 fractional variables

  %  Carefully choosing branching variable, nfrac = 7
DEBUG CAREFUL: Testing fvar[0] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 9
DEBUG CAREFUL: New best var: 9
DEBUG CAREFUL: Testing fvar[1] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 12
DEBUG CAREFUL: New best var: 12
DEBUG CAREFUL: Testing fvar[2] = var 23
DEBUG CAREFUL: Calling compare_branch_vars for var 23
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 23
DEBUG CAREFUL: Testing fvar[3] = var 24
DEBUG CAREFUL: Calling compare_branch_vars for var 24
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 24
DEBUG CAREFUL: Testing fvar[4] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 14
DEBUG CAREFUL: Testing fvar[5] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[6] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
  % Initial guess is x12, Z0 = 28625581.8634516        , Z1 = 28907472.0689512        

DEBUG EVAL: Testing var 9 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=31, varin=4, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=19, varin=26, theta=6.461538, up=999999999999999983222784.000000
ITER 3: row=5, varin=29, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=19, varin=68, theta=0.500000, up=1.000000
ITER 5: row=35, varin=21, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=36, varin=26, theta=2.153846, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 9 = 1 gives z=28851295.124305
  % 	x9 = 1,	Z1 = 28851295.1243047        
DEBUG EVAL: First branch cutoff check: z=28851295.124305, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 0
ITER 1: row=31, varin=39, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=19, varin=40, theta=0.478632, up=999999999999999983222784.000000
ITER 3: row=32, varin=31, theta=0.500000, up=999999999999999983222784.000000
ITER 4: row=19, varin=68, theta=0.500000, up=1.000000
  % 	x9 = 0,	Z0 = 28713548.5760965        
DEBUG EVAL: Second branch cutoff check: z=28713548.576096, best_z=INF, threshold=INF
  %   New best:  x9, Z = 28713548.5760965        
DEBUG EVAL: Testing var 12 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=14, varin=39, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=19, varin=40, theta=0.478632, up=999999999999999983222784.000000
ITER 3: row=32, varin=29, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=14, varin=4, theta=0.500000, up=999999999999999983222784.000000
ITER 5: row=35, varin=30, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=19, varin=68, theta=1.500000, up=1.000000
ITER 7: row=19, varin=26, theta=2.153846, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 12 = 1 gives z=28971970.843699
  % 	x12 = 1,	Z1 = 28971970.8436992        
DEBUG EVAL: First branch cutoff check: z=28971970.843699, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 0
ITER 1: row=14, varin=4, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=19, varin=26, theta=6.461538, up=999999999999999983222784.000000
ITER 3: row=5, varin=21, theta=0.500000, up=999999999999999983222784.000000
  % 	x12 = 0,	Z0 = 28674071.6697325        
DEBUG EVAL: Second branch cutoff check: z=28674071.669732, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 23 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=20, varin=26, theta=2.153846, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 23 = 0 gives z=28633598.741797
  % 	x23 = 0,	Z0 = 28633598.7417965        
DEBUG EVAL: First branch cutoff check: z=28633598.741797, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 24 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=19, varin=26, theta=2.153846, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 24 = 0 gives z=28633598.741797
  % 	x24 = 0,	Z0 = 28633598.7417965        
DEBUG EVAL: First branch cutoff check: z=28633598.741797, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 14 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=21, varin=39, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=19, varin=40, theta=0.478632, up=999999999999999983222784.000000
ITER 3: row=32, varin=29, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=21, varin=21, theta=0.500000, up=999999999999999983222784.000000
ITER 5: row=35, varin=39, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 14 = 0 gives z=28756539.302028
  % 	x14 = 0,	Z0 = 28756539.3020278        
DEBUG EVAL: First branch cutoff check: z=28756539.302028, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 14 = 1
ITER 1: row=21, varin=4, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=19, varin=26, theta=6.461538, up=999999999999999983222784.000000
ITER 3: row=5, varin=31, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=21, varin=39, theta=1.000000, up=999999999999999983222784.000000
  % 	x14 = 1,	Z1 = 28783571.2194169        
DEBUG EVAL: Second branch cutoff check: z=28783571.219417, best_z=INF, threshold=INF
  %   New best:  x14, Z = 28756539.3020278        
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=4, varin=39, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=19, varin=4, theta=0.250000, up=999999999999999983222784.000000
ITER 3: row=32, varin=68, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28670598.900717
  % 	x10 = 0,	Z0 = 28670598.900717         
DEBUG EVAL: First branch cutoff check: z=28670598.900717, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 26 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=28, varin=36, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=19, varin=39, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 0 gives z=28652558.022878
  % 	x26 = 0,	Z0 = 28652558.022878         
DEBUG EVAL: First branch cutoff check: z=28652558.022878, best_z=INF, threshold=INF
  % Best branch is x14, Z0 = 28756539.3020278        , Z1 = 28783571.2194169        

DEBUG CAREFUL: Final result - returning best.var = 14
DEBUG BB: Branching variable chosen: j=14
 % @NC   53   33	x14 = 0	28756539.302028
 % @NC   54   33	x14 = 1	28783571.219417
 %      33    24 28625581.8635               28625760.1419   x15 D    20     6
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x555cc09a22d0
% @LO 0.04  28.62558186345157196229 99.9000000000
% @LN 0.04  28.62576014190401707538 99.9000000000
% Resuming node 51 at  28.62576014190401707538
DEBUG CONSTRNT: LP rows=43, pool->nlprows=43, pool->npend=0
DEBUG CONSTRNT: Checking 43 LP rows (pool tracks 43, total LP rows 43)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 158
DEBUG CONSTRNT: Pool row 158 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=42, expected 42
 % @PAP adding 46 rows, 175 nz to LP
DEBUG BB: Processing node 51, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=34, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28625760.141904
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 235 nonzeros, 2 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=44, theta=0.250000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28640642.295646
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 247 nonzeros, 4 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % Node 51 LP 1 Solution, length = 28640642.295646, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.250000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.250000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.250000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.250000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.250000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.500000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.500000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.750000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.750000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.750000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.750000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.750000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.750000 (terminal 19)
 % 8 fractional variables
DEBUG CG: LP optimal, z=28640642.295646, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 51 at  28.64064229564572627851
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x555cc09b4aa0
% @LO 0.04  28.62576014190401707538 99.9000000000
% @LN 0.04  28.63030373399386974143 99.9000000000
% Resuming node 48 at  28.63030373399386974143
DEBUG CONSTRNT: LP rows=44, pool->nlprows=44, pool->npend=0
DEBUG CONSTRNT: Checking 44 LP rows (pool tracks 44, total LP rows 44)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 143
DEBUG CONSTRNT: Pool row 143 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=43, expected 43
 % @PAP adding 45 rows, 206 nz to LP
DEBUG BB: Processing node 48, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=80, theta=1.270655, up=1.000000
ITER 2: row=1, varin=102, theta=0.204512, up=1.000000
ITER 3: row=12, varin=3, theta=0.315115, up=999999999999999983222784.000000
ITER 4: row=28, varin=23, theta=0.133514, up=999999999999999983222784.000000
ITER 5: row=23, varin=80, theta=0.836854, up=1.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28630303.733994
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 266 nonzeros, 0 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 7 rows, 38 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=4, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=48, varin=95, theta=0.226170, up=1.000000
ITER 3: row=46, varin=10, theta=5.048744, up=999999999999999983222784.000000
ITER 4: row=51, varin=82, theta=0.643554, up=1.000000
ITER 5: row=1, varin=59, theta=0.060464, up=1.000000
ITER 6: row=50, varin=51, theta=0.185508, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 29024035.091658
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 304 nonzeros, 8 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 8 slack rows
  % @PAP adding 2 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=68, theta=0.684505, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 29143121.405101
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 268 nonzeros, 0 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 16 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=76, theta=0.689231, up=1.000000
ITER 2: row=50, varin=78, theta=0.594763, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 29196759.646509
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 284 nonzeros, 1 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=42, theta=0.253112, up=999999999999999983222784.000000
ITER 2: row=50, varin=81, theta=0.777494, up=1.000000
ITER 3: row=18, varin=49, theta=0.086181, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 29216333.172099
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 285 nonzeros, 1 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 4 rows, 21 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=18, theta=0.397661, up=999999999999999983222784.000000
ITER 2: row=18, varin=58, theta=0.361304, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 29254653.015684
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1800000.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 55 rows, 60 cols, 299 nonzeros, 4 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % Node 48 LP 1 Solution, length = 29254653.015684, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 1.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.638696 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.200000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.200000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.200000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.200000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.200000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.361304 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.200000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.800000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.800000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.800000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.361304 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.800000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.800000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 8 fractional variables
DEBUG CG: LP optimal, z=29254653.015684, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 48 at  29.25465301568420173339
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x555cc09a0290
% @LO 0.04  28.63030373399386974143 99.9000000000
% @LN 0.04  28.63970312120009609202 99.9000000000
% Resuming node 14 at  28.63970312120009609202
DEBUG CONSTRNT: LP rows=51, pool->nlprows=51, pool->npend=0
DEBUG CONSTRNT: Checking 51 LP rows (pool tracks 51, total LP rows 51)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 141
DEBUG CONSTRNT: Pool row 141 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 60
DEBUG CONSTRNT: Pool row 60 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 70
DEBUG CONSTRNT: Pool row 70 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=50, expected 50
 % @PAP adding 48 rows, 182 nz to LP
DEBUG BB: Processing node 14, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 14 LP 2 Solution, length = 28639703.121200, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.142857 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.142857 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.142857 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.142857 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.142857 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.142857 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.142857 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.857143 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.857143 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.857143 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.857143 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.857143 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.857143 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.857143 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=28639703.121200, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28639703.121200, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 14 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 14
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.142857
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.142857)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.142857
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.142857)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.142857
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.142857)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.142857
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.142857)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.142857
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.142857)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=1.000000
DEBUG CAREFUL: Skipping var 15: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.142857
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.142857)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.142857
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.142857)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 7 fractional variables

  %  Carefully choosing branching variable, nfrac = 7
DEBUG CAREFUL: Testing fvar[0] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[1] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 18
DEBUG CAREFUL: Testing fvar[2] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[3] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 11
DEBUG CAREFUL: New best var: 11
DEBUG CAREFUL: Testing fvar[4] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 4
DEBUG CAREFUL: New best var: 4
DEBUG CAREFUL: Testing fvar[5] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[6] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
  % Initial guess is x4, Z0 = 28639703.1212001        , Z1 = 28792355.4614774        

DEBUG EVAL: Testing var 3 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=43, theta=0.250000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 0 gives z=28645622.202493
  % 	x3 = 0,	Z0 = 28645622.2024931        
DEBUG EVAL: First branch cutoff check: z=28645622.202493, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 1
ITER 1: row=7, varin=42, theta=1.000000, up=999999999999999983222784.000000
  % 	x3 = 1,	Z1 = 28667477.2297936        
DEBUG EVAL: Second branch cutoff check: z=28667477.229794, best_z=INF, threshold=INF
  %   New best:  x3, Z = 28645622.2024931        
DEBUG EVAL: Testing var 18 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=28, varin=18, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=19, varin=36, theta=0.250000, up=999999999999999983222784.000000
ITER 3: row=39, varin=42, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 18 = 0 gives z=28661481.790653
  % 	x18 = 0,	Z0 = 28661481.7906534        
DEBUG EVAL: First branch cutoff check: z=28661481.790653, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 18 = 1
ITER 1: row=28, varin=43, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=7, varin=45, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=45, varin=42, theta=1.500000, up=999999999999999983222784.000000
ITER 4: row=29, varin=41, theta=1.500000, up=999999999999999983222784.000000
ITER 5: row=41, varin=35, theta=1.000000, up=999999999999999983222784.000000
  % 	x18 = 1,	Z1 = 28852550.9524303        
DEBUG EVAL: Second branch cutoff check: z=28852550.952430, best_z=INF, threshold=INF
  %   New best:  x18, Z = 28661481.7906534        
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=18, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=19, varin=42, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28661481.790653
  % 	x10 = 0,	Z0 = 28661481.7906534        
DEBUG EVAL: First branch cutoff check: z=28661481.790653, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 1
ITER 1: row=6, varin=43, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=7, varin=45, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=45, varin=36, theta=1.500000, up=999999999999999983222784.000000
ITER 4: row=39, varin=42, theta=1.500000, up=999999999999999983222784.000000
ITER 5: row=29, varin=41, theta=0.750000, up=999999999999999983222784.000000
  % 	x10 = 1,	Z1 = 28741338.1455623        
DEBUG EVAL: Second branch cutoff check: z=28741338.145562, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 11 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=41, varin=43, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=7, varin=45, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=45, varin=36, theta=1.500000, up=999999999999999983222784.000000
ITER 4: row=39, varin=42, theta=1.500000, up=999999999999999983222784.000000
ITER 5: row=29, varin=35, theta=3.000000, up=999999999999999983222784.000000
ITER 6: row=1, varin=33, theta=2.000000, up=999999999999999983222784.000000
ITER 7: row=18, varin=28, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=40, varin=19, theta=2.000000, up=999999999999999983222784.000000
ITER 9: row=19, varin=10, theta=2.000000, up=999999999999999983222784.000000
ITER 10: row=10, varin=30, theta=2.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 11 = 1 gives z=29165541.046293
  % 	x11 = 1,	Z1 = 29165541.0462927        
DEBUG EVAL: First branch cutoff check: z=29165541.046293, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 11 = 0
ITER 1: row=41, varin=41, theta=0.200000, up=999999999999999983222784.000000
  % 	x11 = 0,	Z0 = 28654938.5442089        
DEBUG EVAL: Second branch cutoff check: z=28654938.544209, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 4 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=29, varin=45, theta=6.000000, up=999999999999999983222784.000000
ITER 2: row=45, varin=41, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=41, varin=28, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=44, varin=35, theta=4.000000, up=999999999999999983222784.000000
ITER 5: row=1, varin=33, theta=3.000000, up=999999999999999983222784.000000
ITER 6: row=18, varin=36, theta=1.500000, up=999999999999999983222784.000000
ITER 7: row=28, varin=29, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 4 = 1 gives z=29252912.171107
  % 	x4 = 1,	Z1 = 29252912.171107         
DEBUG EVAL: First branch cutoff check: z=29252912.171107, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 4 = 0
ITER 1: row=29, varin=43, theta=0.250000, up=999999999999999983222784.000000
  % 	x4 = 0,	Z0 = 28645622.2024931        
DEBUG EVAL: Second branch cutoff check: z=28645622.202493, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 26 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=30, varin=18, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=19, varin=42, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 0 gives z=28661481.790653
  % 	x26 = 0,	Z0 = 28661481.7906534        
DEBUG EVAL: First branch cutoff check: z=28661481.790653, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 1
ITER 1: row=30, varin=43, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=7, varin=45, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=45, varin=36, theta=1.500000, up=999999999999999983222784.000000
ITER 4: row=39, varin=42, theta=1.500000, up=999999999999999983222784.000000
ITER 5: row=29, varin=41, theta=0.750000, up=999999999999999983222784.000000
  % 	x26 = 1,	Z1 = 28741338.1455623        
DEBUG EVAL: Second branch cutoff check: z=28741338.145562, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=18, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=19, varin=35, theta=0.083333, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28657010.935608
  % 	x2 = 0,	Z0 = 28657010.9356078        
DEBUG EVAL: First branch cutoff check: z=28657010.935608, best_z=INF, threshold=INF
  % Best branch is x18, Z0 = 28661481.7906534        , Z1 = 28852550.9524303        

DEBUG CAREFUL: Final result - returning best.var = 18
DEBUG BB: Branching variable chosen: j=18
 % @NC   55   14	x18 = 0	28661481.790653
 % @NC   56   14	x18 = 1	28852550.952430
 %      14    25 28639703.1212               28640642.2956   x15 U    11     5
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x555cc09a22d0
% @LO 0.04  28.63970312120009609202 99.9000000000
% @LN 0.04  28.64064229564572627851 99.9000000000
% Resuming node 51 at  28.64064229564572627851
DEBUG CONSTRNT: LP rows=48, pool->nlprows=48, pool->npend=0
DEBUG CONSTRNT: Checking 48 LP rows (pool tracks 48, total LP rows 48)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=47, expected 47
 % @PAP adding 44 rows, 171 nz to LP
DEBUG BB: Processing node 51, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 51 LP 2 Solution, length = 28640642.295646, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.250000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.250000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.250000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.250000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.250000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.500000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.500000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.750000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.750000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.750000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.750000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.750000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.750000 (terminal 19)
 % 8 fractional variables
DEBUG CG: LP optimal, z=28640642.295646, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28640642.295646, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 3 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 51 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 51
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.500000
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.250000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.250000
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.250000
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.250000
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.250000
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.500000
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.500000
DEBUG CAREFUL: Adding var 30 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 8 fractional variables

  %  Carefully choosing branching variable, nfrac = 8
DEBUG CAREFUL: Testing fvar[0] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 1
DEBUG CAREFUL: New best var: 1
DEBUG CAREFUL: Testing fvar[1] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 29
DEBUG CAREFUL: New best var: 29
DEBUG CAREFUL: Testing fvar[2] = var 30
DEBUG CAREFUL: Calling compare_branch_vars for var 30
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 30
DEBUG CAREFUL: New best var: 30
DEBUG CAREFUL: Testing fvar[3] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 11
DEBUG CAREFUL: Testing fvar[4] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[5] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[6] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[7] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 27
  % Initial guess is x30, Z0 = 28640642.2956457        , Z1 = 29821428.5310091        

DEBUG EVAL: Testing var 1 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=37, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=43, varin=31, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 1 gives z=29377549.329196
  % 	x1 = 1,	Z1 = 29377549.3291961        
DEBUG EVAL: First branch cutoff check: z=29377549.329196, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 0
ITER 1: row=1, varin=42, theta=1.000000, up=999999999999999983222784.000000
  % 	x1 = 0,	Z0 = 28660916.2713272        
DEBUG EVAL: Second branch cutoff check: z=28660916.271327, best_z=INF, threshold=INF
  %   New best:  x1, Z = 28660916.2713272        
DEBUG EVAL: Testing var 29 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=31, varin=3, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=32, varin=37, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=43, varin=6, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=32, varin=42, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 29 = 1 gives z=29779637.374579
  % 	x29 = 1,	Z1 = 29779637.3745788        
DEBUG EVAL: First branch cutoff check: z=29779637.374579, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 29 = 0
ITER 1: row=31, varin=42, theta=1.000000, up=999999999999999983222784.000000
  % 	x29 = 0,	Z0 = 28660916.2713272        
DEBUG EVAL: Second branch cutoff check: z=28660916.271327, best_z=INF, threshold=INF
  %   New best:  x29, Z = 28660916.2713272        
DEBUG EVAL: Testing var 30 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=37, varin=2, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=38, varin=3, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=32, varin=31, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 30 = 1 gives z=29899987.542039
  % 	x30 = 1,	Z1 = 29899987.5420389        
DEBUG EVAL: First branch cutoff check: z=29899987.542039, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 30 = 0
ITER 1: row=37, varin=42, theta=1.000000, up=999999999999999983222784.000000
  % 	x30 = 0,	Z0 = 28660916.2713272        
DEBUG EVAL: Second branch cutoff check: z=28660916.271327, best_z=INF, threshold=INF
  %   New best:  x30, Z = 28660916.2713272        
DEBUG EVAL: Testing var 11 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=8, varin=42, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=41, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=41, varin=39, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 11 = 1 gives z=28866925.020797
  % 	x11 = 1,	Z1 = 28866925.0207968        
DEBUG EVAL: First branch cutoff check: z=28866925.020797, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 11 = 0
ITER 1: row=8, varin=44, theta=0.500000, up=999999999999999983222784.000000
  % 	x11 = 0,	Z0 = 28655524.4493874        
DEBUG EVAL: Second branch cutoff check: z=28655524.449387, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=44, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28655524.449387
  % 	x10 = 0,	Z0 = 28655524.4493874        
DEBUG EVAL: First branch cutoff check: z=28655524.449387, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 26 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=24, varin=44, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 0 gives z=28655524.449387
  % 	x26 = 0,	Z0 = 28655524.4493874        
DEBUG EVAL: First branch cutoff check: z=28655524.449387, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 2 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=44, theta=1.500000, up=999999999999999983222784.000000
ITER 2: row=7, varin=42, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 1 gives z=28690680.578811
  % 	x2 = 1,	Z1 = 28690680.5788107        
DEBUG EVAL: First branch cutoff check: z=28690680.578811, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 0
ITER 1: row=2, varin=82, theta=0.500000, up=1.000000
  % 	x2 = 0,	Z0 = 28657802.1716502        
DEBUG EVAL: Second branch cutoff check: z=28657802.171650, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 27 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=29, varin=44, theta=1.500000, up=999999999999999983222784.000000
ITER 2: row=7, varin=42, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 27 = 1 gives z=28690680.578811
  % 	x27 = 1,	Z1 = 28690680.5788107        
DEBUG EVAL: First branch cutoff check: z=28690680.578811, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 27 = 0
ITER 1: row=29, varin=82, theta=0.500000, up=1.000000
  % 	x27 = 0,	Z0 = 28657802.1716502        
DEBUG EVAL: Second branch cutoff check: z=28657802.171650, best_z=INF, threshold=INF
  % Best branch is x30, Z0 = 28660916.2713272        , Z1 = 29899987.5420389        

DEBUG CAREFUL: Final result - returning best.var = 30
DEBUG BB: Branching variable chosen: j=30
 % @NC   57   51	x30 = 0	28660916.271327
 % @NC   58   51	x30 = 1	29899987.542039
 %      51    26 28640642.2956               28650413.0743   x31 D    45    12
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x555cc0985600
% @LO 0.04  28.64064229564572627851 99.9000000000
% @LN 0.04  28.65041307429839534393 99.9000000000
% Resuming node 27 at  28.65041307429839534393
DEBUG CONSTRNT: LP rows=44, pool->nlprows=44, pool->npend=0
DEBUG CONSTRNT: Checking 44 LP rows (pool tracks 44, total LP rows 44)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 143
DEBUG CONSTRNT: Pool row 143 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=43, expected 43
 % @PAP adding 43 rows, 223 nz to LP
DEBUG BB: Processing node 27, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 27 LP 3 Solution, length = 28650413.074298, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.184695 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.445915 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.184695 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.407653 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.407653 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.445915 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.592347 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.592347 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.554085 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.554085 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.592347 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.592347 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28650413.074298, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28650413.074298, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 27 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 27
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.184695
DEBUG CAREFUL: Adding var 6 to fractional list (xi=0.184695)
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.445915
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.445915)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.184695
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.184695)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.407653
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.407653)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.407653
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.407653)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=1.000000
DEBUG CAREFUL: Skipping var 17: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.445915
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.445915)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 12
DEBUG CAREFUL: New best var: 12
DEBUG CAREFUL: Testing fvar[1] = var 6
DEBUG CAREFUL: Calling compare_branch_vars for var 6
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 6
DEBUG CAREFUL: Testing fvar[2] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[3] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 15
DEBUG CAREFUL: New best var: 15
DEBUG CAREFUL: Testing fvar[4] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 14
DEBUG CAREFUL: Testing fvar[5] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
  % Initial guess is x15, Z0 = 28745678.2733407        , Z1 = 28805712.1602989        

DEBUG EVAL: Testing var 12 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=11, varin=20, theta=2.687206, up=999999999999999983222784.000000
ITER 2: row=20, varin=42, theta=1.822975, up=999999999999999983222784.000000
ITER 3: row=6, varin=31, theta=1.074498, up=999999999999999983222784.000000
ITER 4: row=5, varin=44, theta=0.506408, up=1.000000
ITER 5: row=31, varin=54, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 12 = 1 gives z=28672532.846433
  % 	x12 = 1,	Z1 = 29183547.636901         
DEBUG EVAL: First branch cutoff check: z=29183547.636901, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 0
ITER 1: row=11, varin=78, theta=1.076950, up=1.000000
ITER 2: row=11, varin=100, theta=0.053617, up=1.000000
ITER 3: row=43, varin=78, theta=1.000000, up=1.000000
  % 	x12 = 0,	Z0 = 28683661.71009          
DEBUG EVAL: Second branch cutoff check: z=28683661.710090, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 6 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=20, theta=2.687206, up=999999999999999983222784.000000
ITER 2: row=20, varin=31, theta=2.380126, up=999999999999999983222784.000000
ITER 3: row=5, varin=44, theta=0.942984, up=1.000000
ITER 4: row=31, varin=54, theta=3.000000, up=1.000000
ITER 5: row=31, varin=40, theta=2.000000, up=999999999999999983222784.000000
ITER 6: row=37, varin=6, theta=0.800000, up=999999999999999983222784.000000
ITER 7: row=1, varin=21, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 6 = 1 gives z=28908513.133001
  % 	x6 = 1,	Z1 = 28908513.1330007        
DEBUG EVAL: First branch cutoff check: z=28908513.133001, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 6 = 0
ITER 1: row=6, varin=42, theta=0.334131, up=999999999999999983222784.000000
  % 	x6 = 0,	Z0 = 28651667.0349839        
DEBUG EVAL: Second branch cutoff check: z=28651667.034984, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=5, varin=44, theta=0.296481, up=1.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28657830.283157
  % 	x10 = 0,	Z0 = 28657830.2831572        
DEBUG EVAL: First branch cutoff check: z=28657830.283157, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 15 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=34, varin=20, theta=2.687206, up=999999999999999983222784.000000
ITER 2: row=20, varin=42, theta=1.822975, up=999999999999999983222784.000000
ITER 3: row=6, varin=31, theta=1.074498, up=999999999999999983222784.000000
ITER 4: row=5, varin=36, theta=0.556096, up=999999999999999983222784.000000
ITER 5: row=38, varin=44, theta=0.506408, up=1.000000
ITER 6: row=31, varin=54, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 15 = 0 gives z=28672532.846433
  % 	x15 = 0,	Z0 = 28745678.2733407        
DEBUG EVAL: First branch cutoff check: z=28745678.273341, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 15 = 1
ITER 1: row=34, varin=78, theta=6.907921, up=1.000000
ITER 2: row=34, varin=100, theta=4.116453, up=1.000000
ITER 3: row=34, varin=39, theta=1.149585, up=999999999999999983222784.000000
ITER 4: row=43, varin=78, theta=1.000000, up=1.000000
ITER 5: row=39, varin=2, theta=1.368797, up=999999999999999983222784.000000
ITER 6: row=2, varin=9, theta=3.486527, up=999999999999999983222784.000000
ITER 7: row=12, varin=73, theta=0.989987, up=1.000000
  % 	x15 = 1,	Z1 = 29021419.8749478        
DEBUG EVAL: Second branch cutoff check: z=29021419.874948, best_z=INF, threshold=INF
  %   New best:  x15, Z = 28745678.2733407        
DEBUG EVAL: Testing var 14 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=21, varin=20, theta=2.687206, up=999999999999999983222784.000000
ITER 2: row=20, varin=42, theta=1.822975, up=999999999999999983222784.000000
ITER 3: row=6, varin=31, theta=1.074498, up=999999999999999983222784.000000
ITER 4: row=5, varin=44, theta=0.506408, up=1.000000
ITER 5: row=31, varin=54, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 14 = 0 gives z=28672532.846433
  % 	x14 = 0,	Z0 = 28672532.8464333        
DEBUG EVAL: First branch cutoff check: z=28672532.846433, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 26 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=37, varin=44, theta=0.296481, up=1.000000
DEBUG EVAL: Branch var 26 = 0 gives z=28657830.283157
  % 	x26 = 0,	Z0 = 28657830.2831572        
DEBUG EVAL: First branch cutoff check: z=28657830.283157, best_z=INF, threshold=INF
  % Best branch is x15, Z0 = 28745678.2733407        , Z1 = 29021419.8749478        

DEBUG CAREFUL: Final result - returning best.var = 15
DEBUG BB: Branching variable chosen: j=15
 % @NC   59   27	x15 = 0	28745678.273341
 % @NC   60   27	x15 = 1	29021419.874948
 %      27    27 28650413.0743               28653726.7352   x19 D     8     3
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x555cc09abe60
% @LO 0.04  28.65041307429839534393 99.9000000000
% @LN 0.04  28.65372673519664914465 99.9000000000
% Resuming node 49 at  28.65372673519664914465
DEBUG CONSTRNT: LP rows=43, pool->nlprows=43, pool->npend=0
DEBUG CONSTRNT: Checking 43 LP rows (pool tracks 43, total LP rows 43)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 141
DEBUG CONSTRNT: Pool row 141 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=42, expected 42
 % @PAP adding 42 rows, 165 nz to LP
DEBUG BB: Processing node 49, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=22, varin=42, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28653726.735197
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 225 nonzeros, 1 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 37 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=72, theta=1.000000, up=1.000000
ITER 2: row=19, varin=22, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28669195.934214
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 262 nonzeros, 4 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % Node 49 LP 1 Solution, length = 28669195.934214, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.500000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.500000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28669195.934214, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 49 at  28.66919593421436118774
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x555cc09a0290
% @LO 0.04  28.65372673519664914465 99.9000000000
% @LN 0.04  28.66091627132724539706 99.9000000000
% Resuming node 57 at  28.66091627132724539706
DEBUG CONSTRNT: LP rows=44, pool->nlprows=44, pool->npend=0
DEBUG CONSTRNT: Checking 44 LP rows (pool tracks 44, total LP rows 44)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 141
DEBUG CONSTRNT: Pool row 141 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 60
DEBUG CONSTRNT: Pool row 60 has lprow=43, expected 43
 % @PAP adding 44 rows, 171 nz to LP
DEBUG BB: Processing node 57, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=37, varin=42, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28660916.271327
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 231 nonzeros, 2 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 57 LP 1 Solution, length = 28660916.271327, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.500000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.500000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.500000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.500000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28660916.271327, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28660916.271327, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 57 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 57
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.500000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.500000
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.500000
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.500000
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.500000
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 11
DEBUG CAREFUL: New best var: 11
DEBUG CAREFUL: Testing fvar[1] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[2] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[3] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[4] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 27
  % Initial guess is x11, Z0 = 28660916.2713272        , Z1 = 28866925.0207968        

DEBUG EVAL: Testing var 11 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=8, varin=41, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=41, varin=39, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 11 = 1 gives z=28866925.020797
  % 	x11 = 1,	Z1 = 28866925.0207968        
DEBUG EVAL: First branch cutoff check: z=28866925.020797, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 11 = 0
ITER 1: row=8, varin=44, theta=1.000000, up=999999999999999983222784.000000
  % 	x11 = 0,	Z0 = 28690680.5788107        
DEBUG EVAL: Second branch cutoff check: z=28690680.578811, best_z=INF, threshold=INF
  %   New best:  x11, Z = 28690680.5788107        
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=44, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28690680.578811
  % 	x10 = 0,	Z0 = 28690680.5788107        
DEBUG EVAL: First branch cutoff check: z=28690680.578811, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 1
ITER 1: row=7, varin=30, theta=0.500000, up=999999999999999983222784.000000
  % 	x10 = 1,	Z1 = 28724726.90004          
DEBUG EVAL: Second branch cutoff check: z=28724726.900040, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 26 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=24, varin=44, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 0 gives z=28690680.578811
  % 	x26 = 0,	Z0 = 28690680.5788107        
DEBUG EVAL: First branch cutoff check: z=28690680.578811, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 1
ITER 1: row=24, varin=30, theta=0.500000, up=999999999999999983222784.000000
  % 	x26 = 1,	Z1 = 28724726.90004          
DEBUG EVAL: Second branch cutoff check: z=28724726.900040, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 2 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=44, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 1 gives z=28690680.578811
  % 	x2 = 1,	Z1 = 28690680.5788107        
DEBUG EVAL: First branch cutoff check: z=28690680.578811, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 0
ITER 1: row=1, varin=82, theta=1.000000, up=1.000000
  % 	x2 = 0,	Z0 = 28695236.0233362        
DEBUG EVAL: Second branch cutoff check: z=28695236.023336, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 27 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=29, varin=44, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 27 = 1 gives z=28690680.578811
  % 	x27 = 1,	Z1 = 28690680.5788107        
DEBUG EVAL: First branch cutoff check: z=28690680.578811, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 27 = 0
ITER 1: row=29, varin=82, theta=1.000000, up=1.000000
  % 	x27 = 0,	Z0 = 28695236.0233362        
DEBUG EVAL: Second branch cutoff check: z=28695236.023336, best_z=INF, threshold=INF
  % Best branch is x11, Z0 = 28690680.5788107        , Z1 = 28866925.0207968        

DEBUG CAREFUL: Final result - returning best.var = 11
DEBUG BB: Branching variable chosen: j=11
 % @NC   61   57	x11 = 0	28690680.578811
 % @NC   62   57	x11 = 1	28866925.020797
 %      57    28 28660916.2713               28661481.7907   x30 D    51    13
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x555cc098d550
% @LO 0.04  28.66091627132724539706 99.9000000000
% @LN 0.04  28.66148179065337942006 99.9000000000
% Resuming node 55 at  28.66148179065337942006
DEBUG CONSTRNT: LP rows=44, pool->nlprows=44, pool->npend=0
DEBUG CONSTRNT: Checking 44 LP rows (pool tracks 44, total LP rows 44)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 143
DEBUG CONSTRNT: Pool row 143 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=43, expected 43
 % @PAP adding 48 rows, 182 nz to LP
DEBUG BB: Processing node 55, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=28, varin=18, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=19, varin=36, theta=0.250000, up=999999999999999983222784.000000
ITER 3: row=39, varin=42, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28661481.790653
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 242 nonzeros, 2 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 5 rows, 24 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=87, theta=0.500000, up=1.000000
ITER 2: row=34, varin=28, theta=0.100000, up=999999999999999983222784.000000
ITER 3: row=53, varin=77, theta=1.000000, up=1.000000
ITER 4: row=52, varin=49, theta=0.666667, up=999999999999999983222784.000000
ITER 5: row=42, varin=37, theta=0.060606, up=999999999999999983222784.000000
ITER 6: row=40, varin=42, theta=0.555556, up=999999999999999983222784.000000
ITER 7: row=51, varin=39, theta=0.500000, up=999999999999999983222784.000000
ITER 8: row=40, varin=84, theta=1.000000, up=1.000000
ITER 9: row=46, varin=52, theta=1.250000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=9)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28792780.201732
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 53 rows, 60 cols, 266 nonzeros, 6 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % Node 55 LP 1 Solution, length = 28792780.201732, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.250000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.250000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.250000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.250000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.250000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.250000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.750000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.750000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.750000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.750000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.750000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.750000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.750000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28792780.201732, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 55 at  28.79278020173238417101
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x555cc099b340
% @LO 0.04  28.66148179065337942006 99.9000000000
% @LN 0.04  28.66171703390897462782 99.9000000000
% Resuming node 19 at  28.66171703390897462782
DEBUG CONSTRNT: LP rows=47, pool->nlprows=47, pool->npend=0
DEBUG CONSTRNT: Checking 47 LP rows (pool tracks 47, total LP rows 47)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=46, expected 46
 % @PAP adding 48 rows, 219 nz to LP
DEBUG BB: Processing node 19, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 19 LP 2 Solution, length = 28661717.033909, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 1.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.213989 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.044754 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.044754 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.044754 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.044754 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.044754 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.044754 (FST 22)
  % DEBUG LP_VARS: x[23] = 1.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 1.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.044754 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.213989 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.213989 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.213989 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.955246 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.786011 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.955246 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.786011 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.955246 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.955246 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.955246 (terminal 19)
 % 11 fractional variables
DEBUG CG: LP optimal, z=28661717.033909, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28661717.033909, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 19 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 19
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=1.000000
DEBUG CAREFUL: Skipping var 0: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.213989
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.213989)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.044754
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.044754)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.044754
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.044754)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.044754
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.044754)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.044754
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.044754)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.044754
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.044754)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.044754
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.044754)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=1.000000
DEBUG CAREFUL: Skipping var 23: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=1.000000
DEBUG CAREFUL: Skipping var 24: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.044754
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.044754)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.213989
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.213989)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.213989
DEBUG CAREFUL: Adding var 31 to fractional list (xi=0.213989)
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.213989
DEBUG CAREFUL: Adding var 32 to fractional list (xi=0.213989)
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 11 fractional variables

  %  Carefully choosing branching variable, nfrac = 11
DEBUG CAREFUL: Testing fvar[0] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 2
DEBUG CAREFUL: New best var: 2
DEBUG CAREFUL: Testing fvar[1] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 18
DEBUG CAREFUL: Testing fvar[2] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 10
DEBUG CAREFUL: New best var: 10
DEBUG CAREFUL: Testing fvar[3] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 27
DEBUG CAREFUL: Testing fvar[4] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 4
DEBUG CAREFUL: Testing fvar[5] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 11
DEBUG CAREFUL: Testing fvar[6] = var 31
DEBUG CAREFUL: Calling compare_branch_vars for var 31
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 31
DEBUG CAREFUL: Testing fvar[7] = var 32
DEBUG CAREFUL: Calling compare_branch_vars for var 32
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 32
DEBUG CAREFUL: Testing fvar[8] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[9] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 22
DEBUG CAREFUL: Testing fvar[10] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
  % Initial guess is x10, Z0 = 28661717.033909         , Z1 = 28894019.6987483        

DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=41, theta=9.843427, up=999999999999999983222784.000000
ITER 2: row=42, varin=6, theta=0.306200, up=999999999999999983222784.000000
ITER 3: row=46, varin=26, theta=0.901981, up=999999999999999983222784.000000
ITER 4: row=37, varin=86, theta=1.338645, up=1.000000
ITER 5: row=37, varin=87, theta=0.344058, up=1.000000
ITER 6: row=6, varin=36, theta=0.053676, up=999999999999999983222784.000000
ITER 7: row=10, varin=47, theta=0.600734, up=999999999999999983222784.000000
ITER 8: row=37, varin=86, theta=0.617983, up=1.000000
DEBUG EVAL: Branch var 2 = 0 gives z=29127960.447787
  % 	x2 = 0,	Z0 = 29127960.4477866        
DEBUG EVAL: First branch cutoff check: z=29127960.447787, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 1
ITER 1: row=1, varin=48, theta=1.671592, up=999999999999999983222784.000000
ITER 2: row=41, varin=47, theta=0.699590, up=999999999999999983222784.000000
ITER 3: row=10, varin=5, theta=0.109245, up=999999999999999983222784.000000
ITER 4: row=13, varin=25, theta=0.068477, up=999999999999999983222784.000000
ITER 5: row=26, varin=56, theta=0.367802, up=1.000000
ITER 6: row=11, varin=55, theta=0.375835, up=1.000000
ITER 7: row=14, varin=39, theta=0.216443, up=999999999999999983222784.000000
ITER 8: row=28, varin=36, theta=0.236776, up=999999999999999983222784.000000
ITER 9: row=33, varin=10, theta=0.308765, up=999999999999999983222784.000000
ITER 10: row=48, varin=26, theta=0.157072, up=999999999999999983222784.000000
  % 	x2 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: Second branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=41, theta=9.843427, up=999999999999999983222784.000000
ITER 2: row=42, varin=6, theta=0.306200, up=999999999999999983222784.000000
ITER 3: row=46, varin=26, theta=0.901981, up=999999999999999983222784.000000
ITER 4: row=37, varin=86, theta=1.338645, up=1.000000
ITER 5: row=37, varin=87, theta=0.344058, up=1.000000
ITER 6: row=6, varin=36, theta=0.053676, up=999999999999999983222784.000000
ITER 7: row=10, varin=47, theta=0.600734, up=999999999999999983222784.000000
ITER 8: row=37, varin=86, theta=0.617983, up=1.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 29127960.447787
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.382017
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
   % @PL 48 rows, 60 cols, 279 nonzeros, 2 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
   % @PAP adding 4 rows, 20 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=89, theta=0.371354, up=1.000000
ITER 2: row=50, varin=103, theta=0.016755, up=1.000000
ITER 3: row=25, varin=54, theta=0.014316, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 29149587.188617
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 50 rows, 60 cols, 293 nonzeros, 1 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 7 rows, 22 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=54, varin=41, theta=0.093298, up=999999999999999983222784.000000
ITER 2: row=40, varin=22, theta=0.092355, up=999999999999999983222784.000000
ITER 3: row=22, varin=31, theta=0.006632, up=999999999999999983222784.000000
ITER 4: row=55, varin=49, theta=0.028568, up=999999999999999983222784.000000
ITER 5: row=50, varin=96, theta=0.044599, up=1.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 29175129.814685
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 56 rows, 60 cols, 309 nonzeros, 2 slack, 54 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
   % @PAP adding 3 rows, 11 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=55, varin=52, theta=0.037935, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 29176163.674511
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 57 rows, 60 cols, 308 nonzeros, 2 slack, 55 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 19 at  29.17616367451097403318
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x555cc09abe60
% @LO 0.04  28.66171703390897462782 99.9000000000
% @LN 0.04  28.66919593421436118774 99.9000000000
% Resuming node 49 at  28.66919593421436118774
DEBUG CONSTRNT: LP rows=55, pool->nlprows=55, pool->npend=0
DEBUG CONSTRNT: Checking 55 LP rows (pool tracks 55, total LP rows 55)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 135
DEBUG CONSTRNT: Pool row 135 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 105
DEBUG CONSTRNT: Pool row 105 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 130
DEBUG CONSTRNT: Pool row 130 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=54, expected 54
 % @PAP adding 44 rows, 169 nz to LP
DEBUG BB: Processing node 49, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 49 LP 2 Solution, length = 28669195.934214, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.500000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.500000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28669195.934214, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28669195.934214, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 49 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 49
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.500000
DEBUG CAREFUL: Adding var 6 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.500000
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.500000
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=1.000000
DEBUG CAREFUL: Skipping var 20: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 3 fractional variables

  %  Carefully choosing branching variable, nfrac = 3
DEBUG CAREFUL: Testing fvar[0] = var 6
DEBUG CAREFUL: Calling compare_branch_vars for var 6
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 6
DEBUG CAREFUL: New best var: 6
DEBUG CAREFUL: Testing fvar[1] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 14
DEBUG CAREFUL: Testing fvar[2] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 12
DEBUG CAREFUL: New best var: 12
  % Initial guess is x12, Z0 = 28669195.9342144        , Z1 = 28841798.281211         

DEBUG EVAL: Testing var 6 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=19, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=19, varin=39, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=39, varin=36, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=36, varin=7, theta=0.400000, up=999999999999999983222784.000000
ITER 5: row=41, varin=38, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 6 = 1 gives z=28731277.004765
  % 	x6 = 1,	Z1 = 28731277.0047648        
DEBUG EVAL: First branch cutoff check: z=28731277.004765, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 6 = 0
ITER 1: row=7, varin=79, theta=1.000000, up=1.000000
  % 	x6 = 0,	Z0 = 28669330.8573604        
DEBUG EVAL: Second branch cutoff check: z=28669330.857360, best_z=INF, threshold=INF
  %   New best:  x6, Z = 28669330.8573604        
DEBUG EVAL: Testing var 14 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=20, varin=79, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 14 = 0 gives z=28669330.857360
  % 	x14 = 0,	Z0 = 28669330.8573604        
DEBUG EVAL: First branch cutoff check: z=28669330.857360, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 14 = 1
ITER 1: row=20, varin=19, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=19, varin=42, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=41, varin=38, theta=1.000000, up=999999999999999983222784.000000
  % 	x14 = 1,	Z1 = 28731277.0047648        
DEBUG EVAL: Second branch cutoff check: z=28731277.004765, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 12 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=27, varin=19, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=19, varin=42, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=41, varin=24, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=35, varin=28, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=19, varin=68, theta=2.000000, up=1.000000
ITER 6: row=19, varin=79, theta=1.000000, up=1.000000
ITER 7: row=27, varin=68, theta=1.000000, up=1.000000
ITER 8: row=19, varin=101, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 12 = 1 gives z=29007661.908711
  % 	x12 = 1,	Z1 = 29007661.9087113        
DEBUG EVAL: First branch cutoff check: z=29007661.908711, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 0
ITER 1: row=27, varin=79, theta=1.000000, up=1.000000
  % 	x12 = 0,	Z0 = 28669330.8573604        
DEBUG EVAL: Second branch cutoff check: z=28669330.857360, best_z=INF, threshold=INF
  %   New best:  x12, Z = 28669330.8573604        
  % Best branch is x12, Z0 = 28669330.8573604        , Z1 = 29007661.9087113        

DEBUG CAREFUL: Final result - returning best.var = 12
DEBUG BB: Branching variable chosen: j=12
 % @NC   63   49	x12 = 0	28669330.857360
 % @NC   64   49	x12 = 1	29007661.908711
 %      49    29 28669195.9342               28669330.8574    x7 D    47    10
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x555cc09a0290
% @LO 0.04  28.66919593421436118774 99.9000000000
% @LN 0.04  28.66933085736039643621 99.9000000000
% Resuming node 63 at  28.66933085736039643621
DEBUG CONSTRNT: LP rows=44, pool->nlprows=44, pool->npend=0
DEBUG CONSTRNT: Checking 44 LP rows (pool tracks 44, total LP rows 44)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 141
DEBUG CONSTRNT: Pool row 141 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 60
DEBUG CONSTRNT: Pool row 60 has lprow=43, expected 43
 % @PAP adding 44 rows, 169 nz to LP
DEBUG BB: Processing node 63, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=27, varin=79, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28669330.857360
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 229 nonzeros, 1 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 27 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=38, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=47, varin=105, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28704094.476226
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 256 nonzeros, 1 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 4 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=10, theta=2.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28722212.201222
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 265 nonzeros, 3 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % Node 63 LP 1 Solution, length = 28722212.201222, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 1.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 0 fractional variables
DEBUG CG: LP optimal, z=28722212.201222, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG IFS: Budget mode - accepting integer solution with 2 edges covering 7 vertices
DEBUG CG: integer_feasible_solution returned: TRUE
DEBUG CG: Solution is integer feasible, returning LB_INTEGRAL
DEBUG BB: compute_good_lower_bound returned status=3
DEBUG BB: Node 63 is INTEGRAL (integer solution found)
 %  	=== 28 nodes cut off ===
 % @UO 0.05   9.22221220122238705130 -210.8726001074
 % @UN 0.05   9.22221220122238705130 -210.8726001074
DEBUG BB: Calling heuristic UB for integer solution, current best_z=9222212.201222
DEBUG BB: Heuristic did not improve integer solution
 % *    63     0  9222212.2012  9222212.2012                 x12 D    49    11
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=(nil)
DEBUG BB: No more nodes to process, exiting

 % Certificate of solution:
 % @C	.4767008182741058	.2081993675729823
 % @C	.9346545514704401	.5030260596239182
 % @C	.8743159763680044	.2782542139644725
 % @C	.9603074535474138	.1921833678795793
%%Page: 1 1
BeginPlot
	Plot_Terminals
 % fs2: 13 0 6
	13 T	.4767008182741058	.2081993675729823	S
	.4767008182741058	.2081993675729823	0 T	S
	.4767008182741058	.2081993675729823	6 T	S
 % fs20: 19 15 3 6 12
	19 T	.9346545514704401	.5030260596239182	S
	.9346545514704401	.5030260596239182	.8743159763680044	.2782542139644725	S
	.8743159763680044	.2782542139644725	.9603074535474138	.1921833678795793	S
	.9603074535474138	.1921833678795793	15 T	S
	.9603074535474138	.1921833678795793	3 T	S
	.8743159763680044	.2782542139644725	6 T	S
	.9346545514704401	.5030260596239182	12 T	S
  (Euclidean SMT:  20 points,  length = 9.222212201222386,  0.05 seconds)
EndPlot

% @0 Euclidean SMT
% N M Nodes LPs P1CPU P2CPU TotCPU
% @1 20 40 47 73 0.00 0.05 0.05
% Z RootZ %Gap RootLPs RootCPU RedMST
% @2 9.222212201222386 27816402.380510 -201.62397 2 0.00 -194.9432
% InitPRows InitPNZ InitLPRows InitLPNZ
% @3 163 594 135 555
% RootPRows RootPNZ RootLPRows RootLPNZ
% @4 164 606 34 249
% FinalPRows FinalPNZ FinalLPRows FinalLPNZ
% @5 164 606 48 257
% SMTFSTs SMTAvgFSTSz SMTMaxFSTSz #2FSTs #3FSTs ... #10FSTS #>10FSTs
% @6 2 4.000000 5 0 1 0 1 0 0 0 0 0 0
