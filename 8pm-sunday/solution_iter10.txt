 % ./bb
 % Args:
DEBUG P1READ: Terminal 0 battery=100.00
DEBUG P1READ: Terminal 1 battery=90.60
DEBUG P1READ: Terminal 2 battery=79.70
DEBUG P1READ: Terminal 3 battery=98.00
DEBUG P1READ: Terminal 4 battery=98.00
DEBUG P1READ: Terminal 5 battery=80.50
DEBUG P1READ: Terminal 6 battery=100.00
DEBUG P1READ: Terminal 7 battery=100.00
DEBUG P1READ: Terminal 8 battery=100.00
DEBUG P1READ: Terminal 9 battery=100.00
DEBUG P1READ: Terminal 10 battery=83.20
DEBUG P1READ: Terminal 11 battery=34.00
DEBUG P1READ: Terminal 12 battery=71.00
DEBUG P1READ: Terminal 13 battery=100.00
DEBUG P1READ: Terminal 14 battery=78.30
DEBUG P1READ: Terminal 15 battery=98.00
DEBUG P1READ: Terminal 16 battery=76.00
DEBUG P1READ: Terminal 17 battery=98.00
DEBUG P1READ: Terminal 18 battery=94.20
DEBUG P1READ: Terminal 19 battery=95.60
DEBUG HG: num_verts=20, num_edges=40
 % Phase 1: 0.00 seconds

%%BeginSetup

0 1 0 1 SetAxes

20 DefineTerminals
	.4588350000000000	.2373240000000000	DT
	.1270640000000000	.3509960000000000	DT
	.1544540000000000	.4808220000000000	DT
	.9474030000000000	.1441120000000000	DT
	.2867390000000000	.0565890000000000	DT
	.1326890000000000	.1166050000000000	DT
	.6273950000000000	.2122140000000000	DT
	.0794880000000000	.7970990000000000	DT
	.0327480000000000	.8803250000000000	DT
	.3110550000000000	.8689670000000000	DT
	.0916180000000000	.0221720000000000	DT
	.3600710000000000	.6382240000000000	DT
	.7197120000000000	.7181670000000000	DT
	.4424420000000000	.1450340000000000	DT
	.9983770000000000	.5729870000000000	DT
	.9654920000000000	.1935700000000000	DT
	.1600100000000000	.4187950000000000	DT
	.2909450000000000	.9620800000000000	DT
	.3330000000000000	.9414120000000000	DT
	.9512590000000000	.5074670000000000	DT

%%EndSetup

DEBUG ALGO: num_verts=20 <= 8? NO, num_edges=40 <= 12? NO
DEBUG ALGO: Forcing BRANCH-AND-CUT for multi-objective optimization (vertices=20 > 1)
DEBUG SPANNING: Adding modified spanning constraint for budget mode
DEBUG SPANNING: Added modified spanning constraint: Σ(|FST|-1)*x + Σnot_covered = 19
DEBUG CONSTRAINT: Adding soft cutset constraints with not_covered variables
DEBUG CONSTRAINT: Added constraint x[2] + not_covered[0] ≤ 1 for terminal 0
DEBUG CONSTRAINT: Added constraint x[27] + not_covered[0] ≤ 1 for terminal 0
DEBUG CONSTRAINT: Added constraint x[31] + not_covered[0] ≤ 1 for terminal 0
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 3·not_covered[0] ≤ 3 for terminal 0
DEBUG CONSTRAINT: Added constraint x[0] + not_covered[1] ≤ 1 for terminal 1
DEBUG CONSTRAINT: Added constraint x[24] + not_covered[1] ≤ 1 for terminal 1
DEBUG CONSTRAINT: Added constraint x[33] + not_covered[1] ≤ 1 for terminal 1
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 3·not_covered[1] ≤ 3 for terminal 1
DEBUG CONSTRAINT: Added constraint x[5] + not_covered[2] ≤ 1 for terminal 2
DEBUG CONSTRAINT: Added constraint x[7] + not_covered[2] ≤ 1 for terminal 2
DEBUG CONSTRAINT: Added constraint x[16] + not_covered[2] ≤ 1 for terminal 2
DEBUG CONSTRAINT: Added constraint x[23] + not_covered[2] ≤ 1 for terminal 2
DEBUG CONSTRAINT: Added constraint x[36] + not_covered[2] ≤ 1 for terminal 2
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 5·not_covered[2] ≤ 5 for terminal 2
DEBUG CONSTRAINT: Added constraint x[3] + not_covered[3] ≤ 1 for terminal 3
DEBUG CONSTRAINT: Added constraint x[4] + not_covered[3] ≤ 1 for terminal 3
DEBUG CONSTRAINT: Added constraint x[17] + not_covered[3] ≤ 1 for terminal 3
DEBUG CONSTRAINT: Added constraint x[20] + not_covered[3] ≤ 1 for terminal 3
DEBUG CONSTRAINT: Added constraint x[22] + not_covered[3] ≤ 1 for terminal 3
DEBUG CONSTRAINT: Added constraint x[39] + not_covered[3] ≤ 1 for terminal 3
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 6·not_covered[3] ≤ 6 for terminal 3
DEBUG CONSTRAINT: Added constraint x[0] + not_covered[4] ≤ 1 for terminal 4
DEBUG CONSTRAINT: Added constraint x[1] + not_covered[4] ≤ 1 for terminal 4
DEBUG CONSTRAINT: Added constraint x[30] + not_covered[4] ≤ 1 for terminal 4
DEBUG CONSTRAINT: Added constraint x[32] + not_covered[4] ≤ 1 for terminal 4
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 4·not_covered[4] ≤ 4 for terminal 4
DEBUG CONSTRAINT: Added constraint x[0] + not_covered[5] ≤ 1 for terminal 5
DEBUG CONSTRAINT: Added constraint x[1] + not_covered[5] ≤ 1 for terminal 5
DEBUG CONSTRAINT: Added constraint x[29] + not_covered[5] ≤ 1 for terminal 5
DEBUG CONSTRAINT: Added constraint x[30] + not_covered[5] ≤ 1 for terminal 5
DEBUG CONSTRAINT: Added constraint x[33] + not_covered[5] ≤ 1 for terminal 5
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 5·not_covered[5] ≤ 5 for terminal 5
DEBUG CONSTRAINT: Added constraint x[2] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[3] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[4] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[11] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[17] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[18] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[20] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[31] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[39] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 9·not_covered[6] ≤ 9 for terminal 6
DEBUG CONSTRAINT: Added constraint x[5] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[6] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[8] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[13] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[14] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[15] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[16] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[19] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[28] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[35] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 10·not_covered[7] ≤ 10 for terminal 7
DEBUG CONSTRAINT: Added constraint x[6] + not_covered[8] ≤ 1 for terminal 8
DEBUG CONSTRAINT: Added constraint x[13] + not_covered[8] ≤ 1 for terminal 8
DEBUG CONSTRAINT: Added constraint x[14] + not_covered[8] ≤ 1 for terminal 8
DEBUG CONSTRAINT: Added constraint x[19] + not_covered[8] ≤ 1 for terminal 8
DEBUG CONSTRAINT: Added constraint x[28] + not_covered[8] ≤ 1 for terminal 8
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 5·not_covered[8] ≤ 5 for terminal 8
DEBUG CONSTRAINT: Added constraint x[6] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[7] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[8] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[9] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[12] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[13] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[14] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[15] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[16] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[19] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[25] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[34] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[35] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 13·not_covered[9] ≤ 13 for terminal 9
DEBUG CONSTRAINT: Added constraint x[1] + not_covered[10] ≤ 1 for terminal 10
DEBUG CONSTRAINT: Added constraint x[29] + not_covered[10] ≤ 1 for terminal 10
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 2·not_covered[10] ≤ 2 for terminal 10
DEBUG CONSTRAINT: Added constraint x[5] + not_covered[11] ≤ 1 for terminal 11
DEBUG CONSTRAINT: Added constraint x[7] + not_covered[11] ≤ 1 for terminal 11
DEBUG CONSTRAINT: Added constraint x[8] + not_covered[11] ≤ 1 for terminal 11
DEBUG CONSTRAINT: Added constraint x[9] + not_covered[11] ≤ 1 for terminal 11
DEBUG CONSTRAINT: Added constraint x[13] + not_covered[11] ≤ 1 for terminal 11
DEBUG CONSTRAINT: Added constraint x[16] + not_covered[11] ≤ 1 for terminal 11
DEBUG CONSTRAINT: Added constraint x[34] + not_covered[11] ≤ 1 for terminal 11
DEBUG CONSTRAINT: Added constraint x[36] + not_covered[11] ≤ 1 for terminal 11
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 8·not_covered[11] ≤ 8 for terminal 11
DEBUG CONSTRAINT: Added constraint x[9] + not_covered[12] ≤ 1 for terminal 12
DEBUG CONSTRAINT: Added constraint x[10] + not_covered[12] ≤ 1 for terminal 12
DEBUG CONSTRAINT: Added constraint x[18] + not_covered[12] ≤ 1 for terminal 12
DEBUG CONSTRAINT: Added constraint x[20] + not_covered[12] ≤ 1 for terminal 12
DEBUG CONSTRAINT: Added constraint x[37] + not_covered[12] ≤ 1 for terminal 12
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 5·not_covered[12] ≤ 5 for terminal 12
DEBUG CONSTRAINT: Added constraint x[2] + not_covered[13] ≤ 1 for terminal 13
DEBUG CONSTRAINT: Added constraint x[27] + not_covered[13] ≤ 1 for terminal 13
DEBUG CONSTRAINT: Added constraint x[32] + not_covered[13] ≤ 1 for terminal 13
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 3·not_covered[13] ≤ 3 for terminal 13
DEBUG CONSTRAINT: Added constraint x[10] + not_covered[14] ≤ 1 for terminal 14
DEBUG CONSTRAINT: Added constraint x[26] + not_covered[14] ≤ 1 for terminal 14
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 2·not_covered[14] ≤ 2 for terminal 14
DEBUG CONSTRAINT: Added constraint x[3] + not_covered[15] ≤ 1 for terminal 15
DEBUG CONSTRAINT: Added constraint x[11] + not_covered[15] ≤ 1 for terminal 15
DEBUG CONSTRAINT: Added constraint x[17] + not_covered[15] ≤ 1 for terminal 15
DEBUG CONSTRAINT: Added constraint x[18] + not_covered[15] ≤ 1 for terminal 15
DEBUG CONSTRAINT: Added constraint x[20] + not_covered[15] ≤ 1 for terminal 15
DEBUG CONSTRAINT: Added constraint x[22] + not_covered[15] ≤ 1 for terminal 15
DEBUG CONSTRAINT: Added constraint x[38] + not_covered[15] ≤ 1 for terminal 15
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 7·not_covered[15] ≤ 7 for terminal 15
DEBUG CONSTRAINT: Added constraint x[23] + not_covered[16] ≤ 1 for terminal 16
DEBUG CONSTRAINT: Added constraint x[24] + not_covered[16] ≤ 1 for terminal 16
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 2·not_covered[16] ≤ 2 for terminal 16
DEBUG CONSTRAINT: Added constraint x[12] + not_covered[17] ≤ 1 for terminal 17
DEBUG CONSTRAINT: Added constraint x[15] + not_covered[17] ≤ 1 for terminal 17
DEBUG CONSTRAINT: Added constraint x[19] + not_covered[17] ≤ 1 for terminal 17
DEBUG CONSTRAINT: Added constraint x[21] + not_covered[17] ≤ 1 for terminal 17
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 4·not_covered[17] ≤ 4 for terminal 17
DEBUG CONSTRAINT: Added constraint x[12] + not_covered[18] ≤ 1 for terminal 18
DEBUG CONSTRAINT: Added constraint x[14] + not_covered[18] ≤ 1 for terminal 18
DEBUG CONSTRAINT: Added constraint x[15] + not_covered[18] ≤ 1 for terminal 18
DEBUG CONSTRAINT: Added constraint x[19] + not_covered[18] ≤ 1 for terminal 18
DEBUG CONSTRAINT: Added constraint x[21] + not_covered[18] ≤ 1 for terminal 18
DEBUG CONSTRAINT: Added constraint x[25] + not_covered[18] ≤ 1 for terminal 18
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 6·not_covered[18] ≤ 6 for terminal 18
DEBUG CONSTRAINT: Added constraint x[4] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint x[10] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint x[11] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint x[17] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint x[18] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint x[20] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint x[26] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint x[37] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint x[38] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 9·not_covered[19] ≤ 9 for terminal 19
DEBUG CONSTRAINT: Added source terminal constraint: not_covered[0] = 0
DEBUG BUDGET: Adding budget constraint ≤ 1000000.000 to constraint pool
DEBUG BUDGET: Using raw tree costs directly
DEBUG BUDGET: Budget limit: 1000000.000
DEBUG BUDGET: Building raw cost constraint coefficients:
DEBUG BUDGET:   x[0] coefficient = 398991 (raw=398991.100)
DEBUG BUDGET:   x[1] coefficient = 260889 (raw=260889.712)
DEBUG BUDGET:   x[2] coefficient = 256773 (raw=256773.057)
DEBUG BUDGET:   x[3] coefficient = 376541 (raw=376541.557)
DEBUG BUDGET:   x[4] coefficient = 646084 (raw=646084.462)
DEBUG BUDGET:   x[5] coefficient = 520973 (raw=520973.020)
DEBUG BUDGET:   x[6] coefficient = 334575 (raw=334575.182)
DEBUG BUDGET:   x[7] coefficient = 494448 (raw=494448.457)
DEBUG BUDGET:   x[8] coefficient = 455905 (raw=455905.519)
DEBUG BUDGET:   x[9] coefficient = 584020 (raw=584020.499)
DEBUG BUDGET:   x[10] coefficient = 380918 (raw=380918.244)
DEBUG BUDGET:   x[11] coefficient = 621357 (raw=621357.781)
DEBUG BUDGET:   x[12] coefficient = 120675 (raw=120675.719)
DEBUG BUDGET:   x[13] coefficient = 551354 (raw=551354.477)
DEBUG BUDGET:   x[14] coefficient = 410262 (raw=410262.679)
DEBUG BUDGET:   x[15] coefficient = 362962 (raw=362962.653)
DEBUG BUDGET:   x[16] coefficient = 702244 (raw=702244.403)
DEBUG BUDGET:   x[17] coefficient = 673894 (raw=673894.542)
DEBUG BUDGET:   x[18] coefficient = 933994 (raw=933994.022)
DEBUG BUDGET:   x[19] coefficient = 454199 (raw=454199.906)
DEBUG BUDGET:   x[20] coefficient = 986439 (raw=986439.144)
DEBUG BUDGET:   x[21] coefficient = 46859 (raw=46859.249)
DEBUG BUDGET:   x[22] coefficient = 52662 (raw=52662.185)
DEBUG BUDGET:   x[23] coefficient = 62275 (raw=62275.339)
DEBUG BUDGET:   x[24] coefficient = 75379 (raw=75379.993)
DEBUG BUDGET:   x[25] coefficient = 75695 (raw=75695.846)
DEBUG BUDGET:   x[26] coefficient = 80703 (raw=80703.013)
DEBUG BUDGET:   x[27] coefficient = 93734 (raw=93734.596)
DEBUG BUDGET:   x[28] coefficient = 95452 (raw=95452.578)
DEBUG BUDGET:   x[29] coefficient = 102977 (raw=102977.757)
DEBUG BUDGET:   x[30] coefficient = 165327 (raw=165327.925)
DEBUG BUDGET:   x[31] coefficient = 170420 (raw=170420.027)
DEBUG BUDGET:   x[32] coefficient = 179069 (raw=179069.657)
DEBUG BUDGET:   x[33] coefficient = 234458 (raw=234458.486)
DEBUG BUDGET:   x[34] coefficient = 235891 (raw=235891.713)
DEBUG BUDGET:   x[35] coefficient = 242462 (raw=242462.956)
DEBUG BUDGET:   x[36] coefficient = 258947 (raw=258947.370)
DEBUG BUDGET:   x[37] coefficient = 313063 (raw=313063.098)
DEBUG BUDGET:   x[38] coefficient = 314219 (raw=314219.517)
DEBUG BUDGET:   x[39] coefficient = 327174 (raw=327174.269)
DEBUG BUDGET: Constraint: Σ tree_cost[i] * x[i] ≤ 1000000
DEBUG BUDGET: Budget constraint added to pool with 40 FSTs
DEBUG CONSTRAINT: Adding 'at least one FST' constraint: Σ x[i] ≥ 1
DEBUG CONSTRAINT: Added 'at least one FST' constraint: Σ x[i] ≥ 1
 % _gst_initialize_constraint_pool: 0.00 seconds.
 % Constraint pool initialized with:
 % 	1	Total degree rows	40	coeffs.
 % 	20	Cutset rows		111	coeffs.
 % 	0	Incompatibility rows	0	coeffs.
 % 	29	2-terminal SEC rows	102	coeffs.
 % 	1	At least one FST rows	40	coeffs.
 % 	163	Total rows in pool	135	in LP
 % @PMEM 163 rows, 1 blocks, 415 nzfree, 0 nzwasted, 1172 nztotal
DEBUG SOFT: Found 20 terminals, 40 FSTs
DEBUG SOFT: Adding space for 20 not_covered variables in soft constraints, total ncoeff=514
DEBUG LP_SETUP: Created LP with 0 rows, 60 columns (nedges=40 + nterms=20)
DEBUG SOFT: Set bounds for 40 FST vars [1-40] and 20 coverage vars [41-60]
DEBUG OBJ: Using raw costs - alpha=10000.0 (battery weight), beta=1500000 (coverage penalty)
DEBUG OBJ: Allocated rowvec[0-60] for ncols=60 LP variables
DEBUG OBJ: Full_trees battery_score=0.000 for FST 0
DEBUG OBJ: Recalculating for FST 0 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 5): battery=80.50, running_total=80.50
DEBUG OBJ: Terminal 1 (idx 1): battery=90.60, running_total=171.10
DEBUG OBJ: Terminal 2 (idx 4): battery=98.00, running_total=269.10
DEBUG OBJ: Recalculated battery_score=269.100 for FST 0
DEBUG OBJ: FST 0: tree_cost=398991.100, battery_cost=269.100 (weighted=2691000.0), combined=3089991.1
DEBUG OBJ: Full_trees battery_score=0.000 for FST 1
DEBUG OBJ: Recalculating for FST 1 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 10): battery=83.20, running_total=83.20
DEBUG OBJ: Terminal 1 (idx 5): battery=80.50, running_total=163.70
DEBUG OBJ: Terminal 2 (idx 4): battery=98.00, running_total=261.70
DEBUG OBJ: Recalculated battery_score=261.700 for FST 1
DEBUG OBJ: FST 1: tree_cost=260889.712, battery_cost=261.700 (weighted=2617000.0), combined=2877889.7
DEBUG OBJ: Full_trees battery_score=0.000 for FST 2
DEBUG OBJ: Recalculating for FST 2 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 13): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 0): battery=100.00, running_total=200.00
DEBUG OBJ: Terminal 2 (idx 6): battery=100.00, running_total=300.00
DEBUG OBJ: Recalculated battery_score=300.000 for FST 2
DEBUG OBJ: FST 2: tree_cost=256773.057, battery_cost=300.000 (weighted=3000000.0), combined=3256773.1
DEBUG OBJ: Full_trees battery_score=0.000 for FST 3
DEBUG OBJ: Recalculating for FST 3 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 15): battery=98.00, running_total=98.00
DEBUG OBJ: Terminal 1 (idx 3): battery=98.00, running_total=196.00
DEBUG OBJ: Terminal 2 (idx 6): battery=100.00, running_total=296.00
DEBUG OBJ: Recalculated battery_score=296.000 for FST 3
DEBUG OBJ: FST 3: tree_cost=376541.557, battery_cost=296.000 (weighted=2960000.0), combined=3336541.6
DEBUG OBJ: Full_trees battery_score=0.000 for FST 4
DEBUG OBJ: Recalculating for FST 4 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 19): battery=95.60, running_total=95.60
DEBUG OBJ: Terminal 1 (idx 3): battery=98.00, running_total=193.60
DEBUG OBJ: Terminal 2 (idx 6): battery=100.00, running_total=293.60
DEBUG OBJ: Recalculated battery_score=293.600 for FST 4
DEBUG OBJ: FST 4: tree_cost=646084.462, battery_cost=293.600 (weighted=2936000.0), combined=3582084.5
DEBUG OBJ: Full_trees battery_score=0.000 for FST 5
DEBUG OBJ: Recalculating for FST 5 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 11): battery=34.00, running_total=34.00
DEBUG OBJ: Terminal 1 (idx 2): battery=79.70, running_total=113.70
DEBUG OBJ: Terminal 2 (idx 7): battery=100.00, running_total=213.70
DEBUG OBJ: Recalculated battery_score=213.700 for FST 5
DEBUG OBJ: FST 5: tree_cost=520973.020, battery_cost=213.700 (weighted=2137000.0), combined=2657973.0
DEBUG OBJ: Full_trees battery_score=0.000 for FST 6
DEBUG OBJ: Recalculating for FST 6 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 9): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 7): battery=100.00, running_total=200.00
DEBUG OBJ: Terminal 2 (idx 8): battery=100.00, running_total=300.00
DEBUG OBJ: Recalculated battery_score=300.000 for FST 6
DEBUG OBJ: FST 6: tree_cost=334575.182, battery_cost=300.000 (weighted=3000000.0), combined=3334575.2
DEBUG OBJ: Full_trees battery_score=0.000 for FST 7
DEBUG OBJ: Recalculating for FST 7 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 11): battery=34.00, running_total=34.00
DEBUG OBJ: Terminal 1 (idx 2): battery=79.70, running_total=113.70
DEBUG OBJ: Terminal 2 (idx 9): battery=100.00, running_total=213.70
DEBUG OBJ: Recalculated battery_score=213.700 for FST 7
DEBUG OBJ: FST 7: tree_cost=494448.457, battery_cost=213.700 (weighted=2137000.0), combined=2631448.5
DEBUG OBJ: Full_trees battery_score=0.000 for FST 8
DEBUG OBJ: Recalculating for FST 8 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 11): battery=34.00, running_total=34.00
DEBUG OBJ: Terminal 1 (idx 7): battery=100.00, running_total=134.00
DEBUG OBJ: Terminal 2 (idx 9): battery=100.00, running_total=234.00
DEBUG OBJ: Recalculated battery_score=234.000 for FST 8
DEBUG OBJ: FST 8: tree_cost=455905.519, battery_cost=234.000 (weighted=2340000.0), combined=2795905.5
DEBUG OBJ: Full_trees battery_score=0.000 for FST 9
DEBUG OBJ: Recalculating for FST 9 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 12): battery=71.00, running_total=71.00
DEBUG OBJ: Terminal 1 (idx 11): battery=34.00, running_total=105.00
DEBUG OBJ: Terminal 2 (idx 9): battery=100.00, running_total=205.00
DEBUG OBJ: Recalculated battery_score=205.000 for FST 9
DEBUG OBJ: FST 9: tree_cost=584020.499, battery_cost=205.000 (weighted=2050000.0), combined=2634020.5
DEBUG OBJ: Full_trees battery_score=0.000 for FST 10
DEBUG OBJ: Recalculating for FST 10 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 19): battery=95.60, running_total=95.60
DEBUG OBJ: Terminal 1 (idx 12): battery=71.00, running_total=166.60
DEBUG OBJ: Terminal 2 (idx 14): battery=78.30, running_total=244.90
DEBUG OBJ: Recalculated battery_score=244.900 for FST 10
DEBUG OBJ: FST 10: tree_cost=380918.244, battery_cost=244.900 (weighted=2449000.0), combined=2829918.2
DEBUG OBJ: Full_trees battery_score=0.000 for FST 11
DEBUG OBJ: Recalculating for FST 11 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 19): battery=95.60, running_total=95.60
DEBUG OBJ: Terminal 1 (idx 15): battery=98.00, running_total=193.60
DEBUG OBJ: Terminal 2 (idx 6): battery=100.00, running_total=293.60
DEBUG OBJ: Recalculated battery_score=293.600 for FST 11
DEBUG OBJ: FST 11: tree_cost=621357.781, battery_cost=293.600 (weighted=2936000.0), combined=3557357.8
DEBUG OBJ: Full_trees battery_score=0.000 for FST 12
DEBUG OBJ: Recalculating for FST 12 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 18): battery=94.20, running_total=94.20
DEBUG OBJ: Terminal 1 (idx 9): battery=100.00, running_total=194.20
DEBUG OBJ: Terminal 2 (idx 17): battery=98.00, running_total=292.20
DEBUG OBJ: Recalculated battery_score=292.200 for FST 12
DEBUG OBJ: FST 12: tree_cost=120675.719, battery_cost=292.200 (weighted=2922000.0), combined=3042675.7
DEBUG OBJ: Full_trees battery_score=0.000 for FST 13
DEBUG OBJ: Recalculating for FST 13 with 4 terminals
DEBUG OBJ: Terminal 0 (idx 11): battery=34.00, running_total=34.00
DEBUG OBJ: Terminal 1 (idx 7): battery=100.00, running_total=134.00
DEBUG OBJ: Terminal 2 (idx 8): battery=100.00, running_total=234.00
DEBUG OBJ: Terminal 3 (idx 9): battery=100.00, running_total=334.00
DEBUG OBJ: Recalculated battery_score=334.000 for FST 13
DEBUG OBJ: FST 13: tree_cost=551354.477, battery_cost=334.000 (weighted=3340000.0), combined=3891354.5
DEBUG OBJ: Full_trees battery_score=0.000 for FST 14
DEBUG OBJ: Recalculating for FST 14 with 4 terminals
DEBUG OBJ: Terminal 0 (idx 18): battery=94.20, running_total=94.20
DEBUG OBJ: Terminal 1 (idx 9): battery=100.00, running_total=194.20
DEBUG OBJ: Terminal 2 (idx 7): battery=100.00, running_total=294.20
DEBUG OBJ: Terminal 3 (idx 8): battery=100.00, running_total=394.20
DEBUG OBJ: Recalculated battery_score=394.200 for FST 14
DEBUG OBJ: FST 14: tree_cost=410262.679, battery_cost=394.200 (weighted=3942000.0), combined=4352262.7
DEBUG OBJ: Full_trees battery_score=0.000 for FST 15
DEBUG OBJ: Recalculating for FST 15 with 4 terminals
DEBUG OBJ: Terminal 0 (idx 18): battery=94.20, running_total=94.20
DEBUG OBJ: Terminal 1 (idx 9): battery=100.00, running_total=194.20
DEBUG OBJ: Terminal 2 (idx 7): battery=100.00, running_total=294.20
DEBUG OBJ: Terminal 3 (idx 17): battery=98.00, running_total=392.20
DEBUG OBJ: Recalculated battery_score=392.200 for FST 15
DEBUG OBJ: FST 15: tree_cost=362962.653, battery_cost=392.200 (weighted=3922000.0), combined=4284962.7
DEBUG OBJ: Full_trees battery_score=0.000 for FST 16
DEBUG OBJ: Recalculating for FST 16 with 4 terminals
DEBUG OBJ: Terminal 0 (idx 11): battery=34.00, running_total=34.00
DEBUG OBJ: Terminal 1 (idx 2): battery=79.70, running_total=113.70
DEBUG OBJ: Terminal 2 (idx 7): battery=100.00, running_total=213.70
DEBUG OBJ: Terminal 3 (idx 9): battery=100.00, running_total=313.70
DEBUG OBJ: Recalculated battery_score=313.700 for FST 16
DEBUG OBJ: FST 16: tree_cost=702244.403, battery_cost=313.700 (weighted=3137000.0), combined=3839244.4
DEBUG OBJ: Full_trees battery_score=0.000 for FST 17
DEBUG OBJ: Recalculating for FST 17 with 4 terminals
DEBUG OBJ: Terminal 0 (idx 19): battery=95.60, running_total=95.60
DEBUG OBJ: Terminal 1 (idx 15): battery=98.00, running_total=193.60
DEBUG OBJ: Terminal 2 (idx 3): battery=98.00, running_total=291.60
DEBUG OBJ: Terminal 3 (idx 6): battery=100.00, running_total=391.60
DEBUG OBJ: Recalculated battery_score=391.600 for FST 17
DEBUG OBJ: FST 17: tree_cost=673894.542, battery_cost=391.600 (weighted=3916000.0), combined=4589894.5
DEBUG OBJ: Full_trees battery_score=0.000 for FST 18
DEBUG OBJ: Recalculating for FST 18 with 4 terminals
DEBUG OBJ: Terminal 0 (idx 19): battery=95.60, running_total=95.60
DEBUG OBJ: Terminal 1 (idx 15): battery=98.00, running_total=193.60
DEBUG OBJ: Terminal 2 (idx 6): battery=100.00, running_total=293.60
DEBUG OBJ: Terminal 3 (idx 12): battery=71.00, running_total=364.60
DEBUG OBJ: Recalculated battery_score=364.600 for FST 18
DEBUG OBJ: FST 18: tree_cost=933994.022, battery_cost=364.600 (weighted=3646000.0), combined=4579994.0
DEBUG OBJ: Full_trees battery_score=0.000 for FST 19
DEBUG OBJ: Recalculating for FST 19 with 5 terminals
DEBUG OBJ: Terminal 0 (idx 18): battery=94.20, running_total=94.20
DEBUG OBJ: Terminal 1 (idx 9): battery=100.00, running_total=194.20
DEBUG OBJ: Terminal 2 (idx 7): battery=100.00, running_total=294.20
DEBUG OBJ: Terminal 3 (idx 8): battery=100.00, running_total=394.20
DEBUG OBJ: Terminal 4 (idx 17): battery=98.00, running_total=492.20
DEBUG OBJ: Recalculated battery_score=492.200 for FST 19
DEBUG OBJ: FST 19: tree_cost=454199.906, battery_cost=492.200 (weighted=4922000.0), combined=5376199.9
DEBUG OBJ: Full_trees battery_score=0.000 for FST 20
DEBUG OBJ: Recalculating for FST 20 with 5 terminals
DEBUG OBJ: Terminal 0 (idx 19): battery=95.60, running_total=95.60
DEBUG OBJ: Terminal 1 (idx 15): battery=98.00, running_total=193.60
DEBUG OBJ: Terminal 2 (idx 3): battery=98.00, running_total=291.60
DEBUG OBJ: Terminal 3 (idx 6): battery=100.00, running_total=391.60
DEBUG OBJ: Terminal 4 (idx 12): battery=71.00, running_total=462.60
DEBUG OBJ: Recalculated battery_score=462.600 for FST 20
DEBUG OBJ: FST 20: tree_cost=986439.144, battery_cost=462.600 (weighted=4626000.0), combined=5612439.1
DEBUG OBJ: Full_trees battery_score=0.000 for FST 21
DEBUG OBJ: Recalculating for FST 21 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 18): battery=94.20, running_total=94.20
DEBUG OBJ: Terminal 1 (idx 17): battery=98.00, running_total=192.20
DEBUG OBJ: Recalculated battery_score=192.200 for FST 21
DEBUG OBJ: FST 21: tree_cost=46859.249, battery_cost=192.200 (weighted=1922000.0), combined=1968859.2
DEBUG OBJ: Full_trees battery_score=0.000 for FST 22
DEBUG OBJ: Recalculating for FST 22 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 15): battery=98.00, running_total=98.00
DEBUG OBJ: Terminal 1 (idx 3): battery=98.00, running_total=196.00
DEBUG OBJ: Recalculated battery_score=196.000 for FST 22
DEBUG OBJ: FST 22: tree_cost=52662.185, battery_cost=196.000 (weighted=1960000.0), combined=2012662.2
DEBUG OBJ: Full_trees battery_score=0.000 for FST 23
DEBUG OBJ: Recalculating for FST 23 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 16): battery=76.00, running_total=76.00
DEBUG OBJ: Terminal 1 (idx 2): battery=79.70, running_total=155.70
DEBUG OBJ: Recalculated battery_score=155.700 for FST 23
DEBUG OBJ: FST 23: tree_cost=62275.339, battery_cost=155.700 (weighted=1557000.0), combined=1619275.3
DEBUG OBJ: Full_trees battery_score=0.000 for FST 24
DEBUG OBJ: Recalculating for FST 24 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 16): battery=76.00, running_total=76.00
DEBUG OBJ: Terminal 1 (idx 1): battery=90.60, running_total=166.60
DEBUG OBJ: Recalculated battery_score=166.600 for FST 24
DEBUG OBJ: FST 24: tree_cost=75379.993, battery_cost=166.600 (weighted=1666000.0), combined=1741380.0
DEBUG OBJ: Full_trees battery_score=0.000 for FST 25
DEBUG OBJ: Recalculating for FST 25 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 18): battery=94.20, running_total=94.20
DEBUG OBJ: Terminal 1 (idx 9): battery=100.00, running_total=194.20
DEBUG OBJ: Recalculated battery_score=194.200 for FST 25
DEBUG OBJ: FST 25: tree_cost=75695.846, battery_cost=194.200 (weighted=1942000.0), combined=2017695.8
DEBUG OBJ: Full_trees battery_score=0.000 for FST 26
DEBUG OBJ: Recalculating for FST 26 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 14): battery=78.30, running_total=78.30
DEBUG OBJ: Terminal 1 (idx 19): battery=95.60, running_total=173.90
DEBUG OBJ: Recalculated battery_score=173.900 for FST 26
DEBUG OBJ: FST 26: tree_cost=80703.013, battery_cost=173.900 (weighted=1739000.0), combined=1819703.0
DEBUG OBJ: Full_trees battery_score=0.000 for FST 27
DEBUG OBJ: Recalculating for FST 27 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 0): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 13): battery=100.00, running_total=200.00
DEBUG OBJ: Recalculated battery_score=200.000 for FST 27
DEBUG OBJ: FST 27: tree_cost=93734.596, battery_cost=200.000 (weighted=2000000.0), combined=2093734.6
DEBUG OBJ: Full_trees battery_score=0.000 for FST 28
DEBUG OBJ: Recalculating for FST 28 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 8): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 7): battery=100.00, running_total=200.00
DEBUG OBJ: Recalculated battery_score=200.000 for FST 28
DEBUG OBJ: FST 28: tree_cost=95452.578, battery_cost=200.000 (weighted=2000000.0), combined=2095452.6
DEBUG OBJ: Full_trees battery_score=0.000 for FST 29
DEBUG OBJ: Recalculating for FST 29 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 5): battery=80.50, running_total=80.50
DEBUG OBJ: Terminal 1 (idx 10): battery=83.20, running_total=163.70
DEBUG OBJ: Recalculated battery_score=163.700 for FST 29
DEBUG OBJ: FST 29: tree_cost=102977.757, battery_cost=163.700 (weighted=1637000.0), combined=1739977.8
DEBUG OBJ: Full_trees battery_score=0.000 for FST 30
DEBUG OBJ: Recalculating for FST 30 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 4): battery=98.00, running_total=98.00
DEBUG OBJ: Terminal 1 (idx 5): battery=80.50, running_total=178.50
DEBUG OBJ: Recalculated battery_score=178.500 for FST 30
DEBUG OBJ: FST 30: tree_cost=165327.925, battery_cost=178.500 (weighted=1785000.0), combined=1950327.9
DEBUG OBJ: Full_trees battery_score=0.000 for FST 31
DEBUG OBJ: Recalculating for FST 31 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 6): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 0): battery=100.00, running_total=200.00
DEBUG OBJ: Recalculated battery_score=200.000 for FST 31
DEBUG OBJ: FST 31: tree_cost=170420.027, battery_cost=200.000 (weighted=2000000.0), combined=2170420.0
DEBUG OBJ: Full_trees battery_score=0.000 for FST 32
DEBUG OBJ: Recalculating for FST 32 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 13): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 4): battery=98.00, running_total=198.00
DEBUG OBJ: Recalculated battery_score=198.000 for FST 32
DEBUG OBJ: FST 32: tree_cost=179069.657, battery_cost=198.000 (weighted=1980000.0), combined=2159069.7
DEBUG OBJ: Full_trees battery_score=0.000 for FST 33
DEBUG OBJ: Recalculating for FST 33 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 5): battery=80.50, running_total=80.50
DEBUG OBJ: Terminal 1 (idx 1): battery=90.60, running_total=171.10
DEBUG OBJ: Recalculated battery_score=171.100 for FST 33
DEBUG OBJ: FST 33: tree_cost=234458.486, battery_cost=171.100 (weighted=1711000.0), combined=1945458.5
DEBUG OBJ: Full_trees battery_score=0.000 for FST 34
DEBUG OBJ: Recalculating for FST 34 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 11): battery=34.00, running_total=34.00
DEBUG OBJ: Terminal 1 (idx 9): battery=100.00, running_total=134.00
DEBUG OBJ: Recalculated battery_score=134.000 for FST 34
DEBUG OBJ: FST 34: tree_cost=235891.713, battery_cost=134.000 (weighted=1340000.0), combined=1575891.7
DEBUG OBJ: Full_trees battery_score=0.000 for FST 35
DEBUG OBJ: Recalculating for FST 35 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 9): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 7): battery=100.00, running_total=200.00
DEBUG OBJ: Recalculated battery_score=200.000 for FST 35
DEBUG OBJ: FST 35: tree_cost=242462.956, battery_cost=200.000 (weighted=2000000.0), combined=2242463.0
DEBUG OBJ: Full_trees battery_score=0.000 for FST 36
DEBUG OBJ: Recalculating for FST 36 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 2): battery=79.70, running_total=79.70
DEBUG OBJ: Terminal 1 (idx 11): battery=34.00, running_total=113.70
DEBUG OBJ: Recalculated battery_score=113.700 for FST 36
DEBUG OBJ: FST 36: tree_cost=258947.370, battery_cost=113.700 (weighted=1137000.0), combined=1395947.4
DEBUG OBJ: Full_trees battery_score=0.000 for FST 37
DEBUG OBJ: Recalculating for FST 37 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 19): battery=95.60, running_total=95.60
DEBUG OBJ: Terminal 1 (idx 12): battery=71.00, running_total=166.60
DEBUG OBJ: Recalculated battery_score=166.600 for FST 37
DEBUG OBJ: FST 37: tree_cost=313063.098, battery_cost=166.600 (weighted=1666000.0), combined=1979063.1
DEBUG OBJ: Full_trees battery_score=0.000 for FST 38
DEBUG OBJ: Recalculating for FST 38 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 15): battery=98.00, running_total=98.00
DEBUG OBJ: Terminal 1 (idx 19): battery=95.60, running_total=193.60
DEBUG OBJ: Recalculated battery_score=193.600 for FST 38
DEBUG OBJ: FST 38: tree_cost=314219.517, battery_cost=193.600 (weighted=1936000.0), combined=2250219.5
DEBUG OBJ: Full_trees battery_score=0.000 for FST 39
DEBUG OBJ: Recalculating for FST 39 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 3): battery=98.00, running_total=98.00
DEBUG OBJ: Terminal 1 (idx 6): battery=100.00, running_total=198.00
DEBUG OBJ: Recalculated battery_score=198.000 for FST 39
DEBUG OBJ: FST 39: tree_cost=327174.269, battery_cost=198.000 (weighted=1980000.0), combined=2307174.3
DEBUG OBJ: Added penalty terms beta=1500000 for 20 not_covered variables [41-60]
DEBUG LP_MATRIX: LP has 0 rows, 60 columns after setup
DEBUG EXTRA_COEFF: Calculated extra_coeff=1 for 135 rows
DEBUG SOFT: Added not_covered_0 (RC_var 43 -> matrix_idx 40) to soft constraint 134
DEBUG MATRIX_CHECK: nzi=495, ncoeff=514, extra_coeff=1, expected=515
ERROR: Matrix coefficient count mismatch! nzi=495 != ncoeff=514 + extra_coeff=1
WARNING: Allowing discrepancy in budget mode (nzi=495 vs expected=515)
DEBUG MATRIX: Total matrix has 495 entries (nzi=495)
DEBUG MATRIX: matbeg[135] = 495 (should equal nzi)
DEBUG LP: Calling add_rows with 135 rows
DEBUG LP: Before add_rows: LP has 0 rows, 60 cols, 60 nonzeros
DEBUG LP: After add_rows: LP has 135 rows, 60 cols, 555 nonzeros
DEBUG NLPROWS: nrows=135, extra_rows=0, setting nlprows=135
 % _gst_build_initial_formulation: 0.00 seconds.
DEBUG BB: Expected nlprows=135, total rows=163
DEBUG BB: Row 0 (uid=0) has lprow=0 (included, j=0)
DEBUG BB: Row 1 (uid=1) has lprow=1 (included, j=1)
DEBUG BB: Row 2 (uid=2) has lprow=2 (included, j=2)
DEBUG BB: Row 3 (uid=3) has lprow=3 (included, j=3)
DEBUG BB: Row 4 (uid=4) has lprow=4 (included, j=4)
DEBUG BB: Row 5 (uid=5) has lprow=5 (included, j=5)
DEBUG BB: Row 6 (uid=6) has lprow=6 (included, j=6)
DEBUG BB: Row 7 (uid=7) has lprow=7 (included, j=7)
DEBUG BB: Row 8 (uid=8) has lprow=8 (included, j=8)
DEBUG BB: Row 9 (uid=9) has lprow=9 (included, j=9)
DEBUG BB: Row 10 (uid=10) has lprow=10 (included, j=10)
DEBUG BB: Row 11 (uid=11) has lprow=11 (included, j=11)
DEBUG BB: Row 12 (uid=12) has lprow=12 (included, j=12)
DEBUG BB: Row 13 (uid=13) has lprow=13 (included, j=13)
DEBUG BB: Row 14 (uid=14) has lprow=14 (included, j=14)
DEBUG BB: Row 15 (uid=15) has lprow=15 (included, j=15)
DEBUG BB: Row 16 (uid=16) has lprow=16 (included, j=16)
DEBUG BB: Row 17 (uid=17) has lprow=17 (included, j=17)
DEBUG BB: Row 18 (uid=18) has lprow=18 (included, j=18)
DEBUG BB: Row 19 (uid=19) has lprow=19 (included, j=19)
DEBUG BB: Row 20 (uid=20) has lprow=20 (included, j=20)
DEBUG BB: Row 21 (uid=21) has lprow=21 (included, j=21)
DEBUG BB: Row 22 (uid=22) has lprow=22 (included, j=22)
DEBUG BB: Row 23 (uid=23) has lprow=23 (included, j=23)
DEBUG BB: Row 24 (uid=24) has lprow=24 (included, j=24)
DEBUG BB: Row 25 (uid=25) has lprow=25 (included, j=25)
DEBUG BB: Row 26 (uid=26) has lprow=26 (included, j=26)
DEBUG BB: Row 27 (uid=27) has lprow=27 (included, j=27)
DEBUG BB: Row 28 (uid=28) has lprow=28 (included, j=28)
DEBUG BB: Row 29 (uid=29) has lprow=29 (included, j=29)
DEBUG BB: Row 30 (uid=30) has lprow=30 (included, j=30)
DEBUG BB: Row 31 (uid=31) has lprow=31 (included, j=31)
DEBUG BB: Row 32 (uid=32) has lprow=32 (included, j=32)
DEBUG BB: Row 33 (uid=33) has lprow=33 (included, j=33)
DEBUG BB: Row 34 (uid=34) has lprow=34 (included, j=34)
DEBUG BB: Row 35 (uid=35) has lprow=35 (included, j=35)
DEBUG BB: Row 36 (uid=36) has lprow=36 (included, j=36)
DEBUG BB: Row 37 (uid=37) has lprow=37 (included, j=37)
DEBUG BB: Row 38 (uid=38) has lprow=38 (included, j=38)
DEBUG BB: Row 39 (uid=39) has lprow=39 (included, j=39)
DEBUG BB: Row 40 (uid=40) has lprow=40 (included, j=40)
DEBUG BB: Row 41 (uid=41) has lprow=41 (included, j=41)
DEBUG BB: Row 42 (uid=42) has lprow=42 (included, j=42)
DEBUG BB: Row 43 (uid=43) has lprow=43 (included, j=43)
DEBUG BB: Row 44 (uid=44) has lprow=44 (included, j=44)
DEBUG BB: Row 45 (uid=45) has lprow=45 (included, j=45)
DEBUG BB: Row 46 (uid=46) has lprow=46 (included, j=46)
DEBUG BB: Row 47 (uid=47) has lprow=47 (included, j=47)
DEBUG BB: Row 48 (uid=48) has lprow=48 (included, j=48)
DEBUG BB: Row 49 (uid=49) has lprow=49 (included, j=49)
DEBUG BB: Row 50 (uid=50) has lprow=50 (included, j=50)
DEBUG BB: Row 51 (uid=51) has lprow=51 (included, j=51)
DEBUG BB: Row 52 (uid=52) has lprow=52 (included, j=52)
DEBUG BB: Row 53 (uid=53) has lprow=53 (included, j=53)
DEBUG BB: Row 54 (uid=54) has lprow=54 (included, j=54)
DEBUG BB: Row 55 (uid=55) has lprow=55 (included, j=55)
DEBUG BB: Row 56 (uid=56) has lprow=56 (included, j=56)
DEBUG BB: Row 57 (uid=57) has lprow=57 (included, j=57)
DEBUG BB: Row 58 (uid=58) has lprow=58 (included, j=58)
DEBUG BB: Row 59 (uid=59) has lprow=59 (included, j=59)
DEBUG BB: Row 60 (uid=60) has lprow=60 (included, j=60)
DEBUG BB: Row 61 (uid=61) has lprow=61 (included, j=61)
DEBUG BB: Row 62 (uid=62) has lprow=62 (included, j=62)
DEBUG BB: Row 63 (uid=63) has lprow=63 (included, j=63)
DEBUG BB: Row 64 (uid=64) has lprow=64 (included, j=64)
DEBUG BB: Row 65 (uid=65) has lprow=65 (included, j=65)
DEBUG BB: Row 66 (uid=66) has lprow=66 (included, j=66)
DEBUG BB: Row 67 (uid=67) has lprow=67 (included, j=67)
DEBUG BB: Row 68 (uid=68) has lprow=68 (included, j=68)
DEBUG BB: Row 69 (uid=69) has lprow=69 (included, j=69)
DEBUG BB: Row 70 (uid=70) has lprow=70 (included, j=70)
DEBUG BB: Row 71 (uid=71) has lprow=71 (included, j=71)
DEBUG BB: Row 72 (uid=72) has lprow=72 (included, j=72)
DEBUG BB: Row 73 (uid=73) has lprow=73 (included, j=73)
DEBUG BB: Row 74 (uid=74) has lprow=74 (included, j=74)
DEBUG BB: Row 75 (uid=75) has lprow=75 (included, j=75)
DEBUG BB: Row 76 (uid=76) has lprow=76 (included, j=76)
DEBUG BB: Row 77 (uid=77) has lprow=77 (included, j=77)
DEBUG BB: Row 78 (uid=78) has lprow=78 (included, j=78)
DEBUG BB: Row 79 (uid=79) has lprow=79 (included, j=79)
DEBUG BB: Row 80 (uid=80) has lprow=80 (included, j=80)
DEBUG BB: Row 81 (uid=81) has lprow=81 (included, j=81)
DEBUG BB: Row 82 (uid=82) has lprow=82 (included, j=82)
DEBUG BB: Row 83 (uid=83) has lprow=83 (included, j=83)
DEBUG BB: Row 84 (uid=84) has lprow=84 (included, j=84)
DEBUG BB: Row 85 (uid=85) has lprow=85 (included, j=85)
DEBUG BB: Row 86 (uid=86) has lprow=86 (included, j=86)
DEBUG BB: Row 87 (uid=87) has lprow=87 (included, j=87)
DEBUG BB: Row 88 (uid=88) has lprow=88 (included, j=88)
DEBUG BB: Row 89 (uid=89) has lprow=89 (included, j=89)
DEBUG BB: Row 90 (uid=90) has lprow=90 (included, j=90)
DEBUG BB: Row 91 (uid=91) has lprow=91 (included, j=91)
DEBUG BB: Row 92 (uid=92) has lprow=92 (included, j=92)
DEBUG BB: Row 93 (uid=93) has lprow=93 (included, j=93)
DEBUG BB: Row 94 (uid=94) has lprow=94 (included, j=94)
DEBUG BB: Row 95 (uid=95) has lprow=95 (included, j=95)
DEBUG BB: Row 96 (uid=96) has lprow=96 (included, j=96)
DEBUG BB: Row 97 (uid=97) has lprow=97 (included, j=97)
DEBUG BB: Row 98 (uid=98) has lprow=98 (included, j=98)
DEBUG BB: Row 99 (uid=99) has lprow=99 (included, j=99)
DEBUG BB: Row 100 (uid=100) has lprow=100 (included, j=100)
DEBUG BB: Row 101 (uid=101) has lprow=101 (included, j=101)
DEBUG BB: Row 102 (uid=102) has lprow=102 (included, j=102)
DEBUG BB: Row 103 (uid=103) has lprow=103 (included, j=103)
DEBUG BB: Row 104 (uid=104) has lprow=104 (included, j=104)
DEBUG BB: Row 105 (uid=105) has lprow=105 (included, j=105)
DEBUG BB: Row 106 (uid=106) has lprow=106 (included, j=106)
DEBUG BB: Row 107 (uid=107) has lprow=107 (included, j=107)
DEBUG BB: Row 108 (uid=108) has lprow=108 (included, j=108)
DEBUG BB: Row 109 (uid=109) has lprow=109 (included, j=109)
DEBUG BB: Row 110 (uid=110) has lprow=110 (included, j=110)
DEBUG BB: Row 111 (uid=111) has lprow=111 (included, j=111)
DEBUG BB: Row 112 (uid=112) has lprow=112 (included, j=112)
DEBUG BB: Row 113 (uid=113) has lprow=113 (included, j=113)
DEBUG BB: Row 114 (uid=114) has lprow=114 (included, j=114)
DEBUG BB: Row 115 (uid=115) has lprow=115 (included, j=115)
DEBUG BB: Row 116 (uid=116) has lprow=116 (included, j=116)
DEBUG BB: Row 117 (uid=117) has lprow=117 (included, j=117)
DEBUG BB: Row 118 (uid=118) has lprow=118 (included, j=118)
DEBUG BB: Row 119 (uid=119) has lprow=119 (included, j=119)
DEBUG BB: Row 120 (uid=120) has lprow=120 (included, j=120)
DEBUG BB: Row 121 (uid=121) has lprow=121 (included, j=121)
DEBUG BB: Row 122 (uid=122) has lprow=122 (included, j=122)
DEBUG BB: Row 123 (uid=123) has lprow=123 (included, j=123)
DEBUG BB: Row 124 (uid=124) has lprow=124 (included, j=124)
DEBUG BB: Row 125 (uid=125) has lprow=125 (included, j=125)
DEBUG BB: Row 126 (uid=126) has lprow=126 (included, j=126)
DEBUG BB: Row 127 (uid=127) has lprow=127 (included, j=127)
DEBUG BB: Row 128 (uid=128) has lprow=128 (included, j=128)
DEBUG BB: Row 129 (uid=129) has lprow=129 (included, j=129)
DEBUG BB: Row 130 (uid=130) has lprow=130 (included, j=130)
DEBUG BB: Row 131 (uid=131) has lprow=131 (included, j=131)
DEBUG BB: Row 132 (uid=132) has lprow=132 (included, j=132)
DEBUG BB: Row 133 (uid=133) has lprow=-1 (skipped)
DEBUG BB: Row 134 (uid=134) has lprow=-1 (skipped)
DEBUG BB: Row 135 (uid=135) has lprow=-1 (skipped)
DEBUG BB: Row 136 (uid=136) has lprow=-1 (skipped)
DEBUG BB: Row 137 (uid=137) has lprow=-1 (skipped)
DEBUG BB: Row 138 (uid=138) has lprow=-1 (skipped)
DEBUG BB: Row 139 (uid=139) has lprow=-1 (skipped)
DEBUG BB: Row 140 (uid=140) has lprow=-1 (skipped)
DEBUG BB: Row 141 (uid=141) has lprow=-1 (skipped)
DEBUG BB: Row 142 (uid=142) has lprow=-1 (skipped)
DEBUG BB: Row 143 (uid=143) has lprow=-1 (skipped)
DEBUG BB: Row 144 (uid=144) has lprow=-1 (skipped)
DEBUG BB: Row 145 (uid=145) has lprow=-1 (skipped)
DEBUG BB: Row 146 (uid=146) has lprow=-1 (skipped)
DEBUG BB: Row 147 (uid=147) has lprow=-1 (skipped)
DEBUG BB: Row 148 (uid=148) has lprow=-1 (skipped)
DEBUG BB: Row 149 (uid=149) has lprow=-1 (skipped)
DEBUG BB: Row 150 (uid=150) has lprow=-1 (skipped)
DEBUG BB: Row 151 (uid=151) has lprow=-1 (skipped)
DEBUG BB: Row 152 (uid=152) has lprow=-1 (skipped)
DEBUG BB: Row 153 (uid=153) has lprow=-1 (skipped)
DEBUG BB: Row 154 (uid=154) has lprow=-1 (skipped)
DEBUG BB: Row 155 (uid=155) has lprow=-1 (skipped)
DEBUG BB: Row 156 (uid=156) has lprow=-1 (skipped)
DEBUG BB: Row 157 (uid=157) has lprow=-1 (skipped)
DEBUG BB: Row 158 (uid=158) has lprow=-1 (skipped)
DEBUG BB: Row 159 (uid=159) has lprow=-1 (skipped)
DEBUG BB: Row 160 (uid=160) has lprow=-1 (skipped)
DEBUG BB: Row 161 (uid=161) has lprow=133 (included, j=133)
DEBUG BB: Row 162 (uid=162) has lprow=134 (included, j=134)
DEBUG BB: Found 135 actual LP rows, expected 135
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595daba2600
% Resuming node 0
DEBUG CONSTRNT: LP rows=135, pool->nlprows=135, pool->npend=0
DEBUG CONSTRNT: Checking 135 LP rows (pool tracks 135, total LP rows 135)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 1
DEBUG CONSTRNT: Pool row 1 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 2
DEBUG CONSTRNT: Pool row 2 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 3
DEBUG CONSTRNT: Pool row 3 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 4
DEBUG CONSTRNT: Pool row 4 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=56, expected 56
DEBUG CONSTRNT: Checking LP row 57 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=57, expected 57
DEBUG CONSTRNT: Checking LP row 58 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=58, expected 58
DEBUG CONSTRNT: Checking LP row 59 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=59, expected 59
DEBUG CONSTRNT: Checking LP row 60 -> pool row 60
DEBUG CONSTRNT: Pool row 60 has lprow=60, expected 60
DEBUG CONSTRNT: Checking LP row 61 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=61, expected 61
DEBUG CONSTRNT: Checking LP row 62 -> pool row 62
DEBUG CONSTRNT: Pool row 62 has lprow=62, expected 62
DEBUG CONSTRNT: Checking LP row 63 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=63, expected 63
DEBUG CONSTRNT: Checking LP row 64 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=64, expected 64
DEBUG CONSTRNT: Checking LP row 65 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=65, expected 65
DEBUG CONSTRNT: Checking LP row 66 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=66, expected 66
DEBUG CONSTRNT: Checking LP row 67 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=67, expected 67
DEBUG CONSTRNT: Checking LP row 68 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=68, expected 68
DEBUG CONSTRNT: Checking LP row 69 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=69, expected 69
DEBUG CONSTRNT: Checking LP row 70 -> pool row 70
DEBUG CONSTRNT: Pool row 70 has lprow=70, expected 70
DEBUG CONSTRNT: Checking LP row 71 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=71, expected 71
DEBUG CONSTRNT: Checking LP row 72 -> pool row 72
DEBUG CONSTRNT: Pool row 72 has lprow=72, expected 72
DEBUG CONSTRNT: Checking LP row 73 -> pool row 73
DEBUG CONSTRNT: Pool row 73 has lprow=73, expected 73
DEBUG CONSTRNT: Checking LP row 74 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=74, expected 74
DEBUG CONSTRNT: Checking LP row 75 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=75, expected 75
DEBUG CONSTRNT: Checking LP row 76 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=76, expected 76
DEBUG CONSTRNT: Checking LP row 77 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=77, expected 77
DEBUG CONSTRNT: Checking LP row 78 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=78, expected 78
DEBUG CONSTRNT: Checking LP row 79 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=79, expected 79
DEBUG CONSTRNT: Checking LP row 80 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=80, expected 80
DEBUG CONSTRNT: Checking LP row 81 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=81, expected 81
DEBUG CONSTRNT: Checking LP row 82 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=82, expected 82
DEBUG CONSTRNT: Checking LP row 83 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=83, expected 83
DEBUG CONSTRNT: Checking LP row 84 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=84, expected 84
DEBUG CONSTRNT: Checking LP row 85 -> pool row 85
DEBUG CONSTRNT: Pool row 85 has lprow=85, expected 85
DEBUG CONSTRNT: Checking LP row 86 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=86, expected 86
DEBUG CONSTRNT: Checking LP row 87 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=87, expected 87
DEBUG CONSTRNT: Checking LP row 88 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=88, expected 88
DEBUG CONSTRNT: Checking LP row 89 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=89, expected 89
DEBUG CONSTRNT: Checking LP row 90 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=90, expected 90
DEBUG CONSTRNT: Checking LP row 91 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=91, expected 91
DEBUG CONSTRNT: Checking LP row 92 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=92, expected 92
DEBUG CONSTRNT: Checking LP row 93 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=93, expected 93
DEBUG CONSTRNT: Checking LP row 94 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=94, expected 94
DEBUG CONSTRNT: Checking LP row 95 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=95, expected 95
DEBUG CONSTRNT: Checking LP row 96 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=96, expected 96
DEBUG CONSTRNT: Checking LP row 97 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=97, expected 97
DEBUG CONSTRNT: Checking LP row 98 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=98, expected 98
DEBUG CONSTRNT: Checking LP row 99 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=99, expected 99
DEBUG CONSTRNT: Checking LP row 100 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=100, expected 100
DEBUG CONSTRNT: Checking LP row 101 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=101, expected 101
DEBUG CONSTRNT: Checking LP row 102 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=102, expected 102
DEBUG CONSTRNT: Checking LP row 103 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=103, expected 103
DEBUG CONSTRNT: Checking LP row 104 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=104, expected 104
DEBUG CONSTRNT: Checking LP row 105 -> pool row 105
DEBUG CONSTRNT: Pool row 105 has lprow=105, expected 105
DEBUG CONSTRNT: Checking LP row 106 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=106, expected 106
DEBUG CONSTRNT: Checking LP row 107 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=107, expected 107
DEBUG CONSTRNT: Checking LP row 108 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=108, expected 108
DEBUG CONSTRNT: Checking LP row 109 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=109, expected 109
DEBUG CONSTRNT: Checking LP row 110 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=110, expected 110
DEBUG CONSTRNT: Checking LP row 111 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=111, expected 111
DEBUG CONSTRNT: Checking LP row 112 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=112, expected 112
DEBUG CONSTRNT: Checking LP row 113 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=113, expected 113
DEBUG CONSTRNT: Checking LP row 114 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=114, expected 114
DEBUG CONSTRNT: Checking LP row 115 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=115, expected 115
DEBUG CONSTRNT: Checking LP row 116 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=116, expected 116
DEBUG CONSTRNT: Checking LP row 117 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=117, expected 117
DEBUG CONSTRNT: Checking LP row 118 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=118, expected 118
DEBUG CONSTRNT: Checking LP row 119 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=119, expected 119
DEBUG CONSTRNT: Checking LP row 120 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=120, expected 120
DEBUG CONSTRNT: Checking LP row 121 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=121, expected 121
DEBUG CONSTRNT: Checking LP row 122 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=122, expected 122
DEBUG CONSTRNT: Checking LP row 123 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=123, expected 123
DEBUG CONSTRNT: Checking LP row 124 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=124, expected 124
DEBUG CONSTRNT: Checking LP row 125 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=125, expected 125
DEBUG CONSTRNT: Checking LP row 126 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=126, expected 126
DEBUG CONSTRNT: Checking LP row 127 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=127, expected 127
DEBUG CONSTRNT: Checking LP row 128 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=128, expected 128
DEBUG CONSTRNT: Checking LP row 129 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=129, expected 129
DEBUG CONSTRNT: Checking LP row 130 -> pool row 130
DEBUG CONSTRNT: Pool row 130 has lprow=130, expected 130
DEBUG CONSTRNT: Checking LP row 131 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=131, expected 131
DEBUG CONSTRNT: Checking LP row 132 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=132, expected 132
DEBUG CONSTRNT: Checking LP row 133 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=133, expected 133
DEBUG CONSTRNT: Checking LP row 134 -> pool row 162
DEBUG CONSTRNT: Pool row 162 has lprow=134, expected 134
 % @PAP adding 135 rows, 494 nz to LP
DEBUG BB: Processing node 0, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=152, theta=6.333333, up=1.000000
ITER 2: row=1, varin=149, theta=5.333333, up=1.000000
ITER 3: row=1, varin=143, theta=6.500000, up=1.000000
ITER 4: row=1, varin=145, theta=5.500000, up=1.000000
ITER 5: row=1, varin=141, theta=4.500000, up=1.000000
ITER 6: row=1, varin=155, theta=1.750000, up=1.000000
ITER 7: row=1, varin=172, theta=3.000000, up=1.000000
ITER 8: row=1, varin=144, theta=1.000000, up=1.000000
ITER 9: row=134, varin=172, theta=97.504073, up=1.000000
ITER 10: row=134, varin=151, theta=9.321089, up=1.000000
LP PHASE: Switching to primal (iter=47)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=135)
DEBUG SOLUTION: LP solution array indices: FST[136-175], not_covered[176-195]
DEBUG SOLUTION: lp->best_solution[0] = 27273684.398203
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 0.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 3.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 135 rows, 60 cols, 554 nonzeros, 61 slack, 74 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 61 slack rows
  % @PAP adding 3 rows, 17 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=75, varin=85, theta=1.103859, up=1.000000
ITER 2: row=75, varin=83, theta=0.098571, up=1.000000
ITER 3: row=11, varin=120, theta=0.219714, up=1.000000
ITER 4: row=7, varin=11, theta=3.901429, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=77)
DEBUG SOLUTION: LP solution array indices: FST[78-117], not_covered[118-137]
DEBUG SOLUTION: lp->best_solution[0] = 27473934.309293
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.098571
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.098571
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 77 rows, 60 cols, 361 nonzeros, 5 slack, 72 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 4 rows, 17 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=75, varin=41, theta=0.137321, up=999999999999999983222784.000000
ITER 2: row=74, varin=75, theta=6.901429, up=999999999999999983222784.000000
ITER 3: row=1, varin=96, theta=0.221354, up=1.000000
ITER 4: row=76, varin=86, theta=0.050546, up=1.000000
ITER 5: row=42, varin=129, theta=0.048352, up=1.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=76)
DEBUG SOLUTION: LP solution array indices: FST[77-116], not_covered[117-136]
DEBUG SOLUTION: lp->best_solution[0] = 27493557.893834
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 6.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 76 rows, 60 cols, 364 nonzeros, 8 slack, 68 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 8 slack rows
  % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=70, varin=78, theta=0.194678, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=70)
DEBUG SOLUTION: LP solution array indices: FST[71-110], not_covered[111-130]
DEBUG SOLUTION: lp->best_solution[0] = 27494410.390607
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 6.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 70 rows, 60 cols, 345 nonzeros, 1 slack, 69 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 0 LP 1 Solution, length = 27494410.390607, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.194678 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.805322 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.056022 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.138656 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.861344 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.194678 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.138656 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.138656 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.138656 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.194678 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.943978 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.138656 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.138656 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=27494410.390607, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.00  27.49441039060702607344 99.9000000000
 % @LN 0.00  27.49441039060702607344 99.9000000000
DEBUG CG: Second cutoff check: z=27494410.390607, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % initially 3 congested vertices:
 % _gst_find_congested_components found 1 components:
 % 	component 0:	3 verts,	5 edges
 % @PAP adding 1 rows, 12 nz to LP
 % @PMEM 164 rows, 1 blocks, 402 nzfree, 0 nzwasted, 1172 nztotal
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=70, varin=69, theta=0.608489, up=999999999999999983222784.000000
ITER 2: row=35, varin=72, theta=0.158055, up=1.000000
ITER 3: row=15, varin=81, theta=0.105507, up=1.000000
ITER 4: row=46, varin=115, theta=0.149811, up=1.000000
ITER 5: row=20, varin=48, theta=0.103604, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=70)
DEBUG SOLUTION: LP solution array indices: FST[71-110], not_covered[111-130]
DEBUG SOLUTION: lp->best_solution[0] = 27501915.508569
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 6.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 70 rows, 60 cols, 355 nonzeros, 3 slack, 67 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 4 rows, 20 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=69, varin=41, theta=0.020572, up=999999999999999983222784.000000
ITER 2: row=70, varin=92, theta=0.040611, up=1.000000
ITER 3: row=71, varin=131, theta=0.004829, up=1.000000
ITER 4: row=10, varin=108, theta=0.122326, up=1.000000
ITER 5: row=69, varin=115, theta=0.035051, up=1.000000
ITER 6: row=31, varin=71, theta=0.660410, up=999999999999999983222784.000000
ITER 7: row=68, varin=117, theta=0.142384, up=1.000000
ITER 8: row=38, varin=118, theta=0.031845, up=1.000000
ITER 9: row=51, varin=69, theta=0.162569, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=9)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=71)
DEBUG SOLUTION: LP solution array indices: FST[72-111], not_covered[112-131]
DEBUG SOLUTION: lp->best_solution[0] = 27504757.442383
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 6.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 71 rows, 60 cols, 364 nonzeros, 2 slack, 69 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 0 LP 2 Solution, length = 27504757.442383, 0.00/0.00/0.00/0.00/0.00/0.00/0.00 1
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.445810 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.500000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.054190 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.054190 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.054190 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.945810 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.945810 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.945810 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=27504757.442383, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.00  27.49441039060702607344 99.9000000000
 % @LN 0.00  27.50475744238338648984 99.9000000000
DEBUG CG: Second cutoff check: z=27504757.442383, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 0 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 0
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.445810
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.445810)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.500000
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.054190
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.054190)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.054190
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.054190)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.054190
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.054190)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 7
DEBUG CAREFUL: New best var: 7
DEBUG CAREFUL: Testing fvar[1] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 5
DEBUG CAREFUL: Testing fvar[2] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 36
DEBUG CAREFUL: New best var: 36
DEBUG CAREFUL: Testing fvar[3] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[4] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x36, Z0 = 27504757.4423834        , Z1 = 27580813.1935748        

DEBUG EVAL: Testing var 7 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=38, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=24, varin=54, theta=6.000000, up=999999999999999983222784.000000
ITER 3: row=61, varin=82, theta=0.504851, up=1.000000
ITER 4: row=34, varin=68, theta=0.023586, up=999999999999999983222784.000000
ITER 5: row=46, varin=89, theta=0.013452, up=1.000000
ITER 6: row=41, varin=31, theta=0.009154, up=999999999999999983222784.000000
ITER 7: row=24, varin=20, theta=0.029604, up=999999999999999983222784.000000
ITER 8: row=18, varin=51, theta=0.009383, up=999999999999999983222784.000000
ITER 9: row=13, varin=106, theta=0.025976, up=1.000000
ITER 10: row=15, varin=10, theta=0.009718, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 7 = 1 gives z=27536245.839024
  % 	x7 = 1,	Z1 = 27536245.8390243        
DEBUG EVAL: First branch cutoff check: z=27536245.839024, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 7 = 0
ITER 1: row=6, varin=51, theta=0.461538, up=999999999999999983222784.000000
ITER 2: row=34, varin=40, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=61, varin=31, theta=0.123224, up=999999999999999983222784.000000
ITER 4: row=13, varin=10, theta=0.102443, up=999999999999999983222784.000000
ITER 5: row=10, varin=68, theta=0.619716, up=999999999999999983222784.000000
ITER 6: row=46, varin=35, theta=0.904833, up=999999999999999983222784.000000
ITER 7: row=35, varin=38, theta=0.904833, up=999999999999999983222784.000000
  % 	x7 = 0,	Z0 = 27522552.0667387        
DEBUG EVAL: Second branch cutoff check: z=27522552.066739, best_z=INF, threshold=INF
  %   New best:  x7, Z = 27522552.0667387        
DEBUG EVAL: Testing var 5 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=15, varin=40, theta=0.622669, up=999999999999999983222784.000000
ITER 2: row=61, varin=51, theta=0.137556, up=999999999999999983222784.000000
ITER 3: row=34, varin=31, theta=0.123224, up=999999999999999983222784.000000
ITER 4: row=13, varin=10, theta=0.102443, up=999999999999999983222784.000000
ITER 5: row=10, varin=68, theta=0.619716, up=999999999999999983222784.000000
ITER 6: row=46, varin=54, theta=6.333832, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 5 = 1 gives z=27522552.066739
  % 	x5 = 1,	Z1 = 27522552.0667391        
DEBUG EVAL: First branch cutoff check: z=27522552.066739, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 5 = 0
ITER 1: row=15, varin=38, theta=0.353488, up=999999999999999983222784.000000
ITER 2: row=24, varin=51, theta=0.868958, up=999999999999999983222784.000000
ITER 3: row=34, varin=68, theta=0.822659, up=999999999999999983222784.000000
ITER 4: row=69, varin=31, theta=0.215095, up=999999999999999983222784.000000
ITER 5: row=13, varin=20, theta=0.471332, up=999999999999999983222784.000000
ITER 6: row=18, varin=89, theta=0.121733, up=1.000000
  % 	x5 = 0,	Z0 = 27521834.7389486        
DEBUG EVAL: Second branch cutoff check: z=27521834.738949, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 36 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=61, varin=51, theta=0.592474, up=999999999999999983222784.000000
ITER 2: row=34, varin=38, theta=1.242563, up=999999999999999983222784.000000
ITER 3: row=24, varin=31, theta=0.622042, up=999999999999999983222784.000000
ITER 4: row=13, varin=68, theta=1.745314, up=999999999999999983222784.000000
ITER 5: row=68, varin=10, theta=0.251964, up=999999999999999983222784.000000
ITER 6: row=10, varin=20, theta=0.884055, up=999999999999999983222784.000000
ITER 7: row=18, varin=46, theta=0.772200, up=999999999999999983222784.000000
ITER 8: row=46, varin=15, theta=0.862183, up=999999999999999983222784.000000
ITER 9: row=1, varin=89, theta=0.539072, up=1.000000
ITER 10: row=15, varin=67, theta=0.615636, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 36 = 1 gives z=27592388.562197
  % 	x36 = 1,	Z1 = 27592388.5621968        
DEBUG EVAL: First branch cutoff check: z=27592388.562197, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 36 = 0
ITER 1: row=61, varin=54, theta=0.234842, up=999999999999999983222784.000000
  % 	x36 = 0,	Z0 = 27505222.2733662        
DEBUG EVAL: Second branch cutoff check: z=27505222.273366, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 9 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=41, varin=51, theta=0.592474, up=999999999999999983222784.000000
ITER 2: row=34, varin=38, theta=1.242563, up=999999999999999983222784.000000
ITER 3: row=24, varin=31, theta=0.622042, up=999999999999999983222784.000000
ITER 4: row=13, varin=68, theta=1.745314, up=999999999999999983222784.000000
ITER 5: row=46, varin=10, theta=0.251964, up=999999999999999983222784.000000
ITER 6: row=10, varin=66, theta=1.155561, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 9 = 1 gives z=27528470.064972
  % 	x9 = 1,	Z1 = 27552410.7639901        
DEBUG EVAL: First branch cutoff check: z=27552410.763990, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 0
ITER 1: row=41, varin=54, theta=0.234842, up=999999999999999983222784.000000
  % 	x9 = 0,	Z0 = 27505222.2733672        
DEBUG EVAL: Second branch cutoff check: z=27505222.273367, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=46, varin=51, theta=0.592474, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=27507738.322777
  % 	x10 = 1,	Z1 = 27553931.2203691        
DEBUG EVAL: First branch cutoff check: z=27553931.220369, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=46, varin=54, theta=0.234842, up=999999999999999983222784.000000
  % 	x10 = 0,	Z0 = 27505222.2733672        
DEBUG EVAL: Second branch cutoff check: z=27505222.273367, best_z=INF, threshold=INF
  % Best branch is x7, Z0 = 27522552.0667387        , Z1 = 27536245.8390243        

DEBUG CAREFUL: Final result - returning best.var = 7
DEBUG BB: Branching variable chosen: j=7
 % @NC    1    0	x7 = 0	27522552.066739
 % @NC    2    0	x7 = 1	27536245.839024
 %       0     2 27504757.4424               27522552.0667
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabad4e0
% @LO 0.00  27.50475744238338648984 99.9000000000
% @LN 0.00  27.52255206673866538836 99.9000000000
% Resuming node 1 at  27.52255206673866538836
DEBUG CONSTRNT: LP rows=69, pool->nlprows=69, pool->npend=0
DEBUG CONSTRNT: Checking 69 LP rows (pool tracks 69, total LP rows 69)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 105
DEBUG CONSTRNT: Pool row 105 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=56, expected 56
DEBUG CONSTRNT: Checking LP row 57 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=57, expected 57
DEBUG CONSTRNT: Checking LP row 58 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=58, expected 58
DEBUG CONSTRNT: Checking LP row 59 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=59, expected 59
DEBUG CONSTRNT: Checking LP row 60 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=60, expected 60
DEBUG CONSTRNT: Checking LP row 61 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=61, expected 61
DEBUG CONSTRNT: Checking LP row 62 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=62, expected 62
DEBUG CONSTRNT: Checking LP row 63 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=63, expected 63
DEBUG CONSTRNT: Checking LP row 64 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=64, expected 64
DEBUG CONSTRNT: Checking LP row 65 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=65, expected 65
DEBUG CONSTRNT: Checking LP row 66 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=66, expected 66
DEBUG CONSTRNT: Checking LP row 67 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=67, expected 67
DEBUG CONSTRNT: Checking LP row 68 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=68, expected 68
 % @PAP adding 69 rows, 288 nz to LP
DEBUG BB: Processing node 1, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=6, varin=51, theta=0.461538, up=999999999999999983222784.000000
ITER 2: row=34, varin=40, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=61, varin=31, theta=0.123224, up=999999999999999983222784.000000
ITER 4: row=13, varin=10, theta=0.102443, up=999999999999999983222784.000000
ITER 5: row=10, varin=68, theta=0.619716, up=999999999999999983222784.000000
ITER 6: row=46, varin=35, theta=0.904833, up=999999999999999983222784.000000
ITER 7: row=35, varin=38, theta=0.904833, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=69)
DEBUG SOLUTION: LP solution array indices: FST[70-109], not_covered[110-129]
DEBUG SOLUTION: lp->best_solution[0] = 27522552.066739
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 6.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.904833
  % @PL 69 rows, 60 cols, 348 nonzeros, 12 slack, 57 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 12 slack rows
  % @PAP adding 4 rows, 19 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=58, varin=6, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=60, varin=53, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=1, varin=109, theta=1.000000, up=1.000000
ITER 4: row=26, varin=54, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=61, varin=98, theta=0.142857, up=1.000000
ITER 6: row=49, varin=81, theta=0.049126, up=1.000000
ITER 7: row=61, varin=55, theta=0.013997, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=61)
DEBUG SOLUTION: LP solution array indices: FST[62-101], not_covered[102-121]
DEBUG SOLUTION: lp->best_solution[0] = 27535731.897716
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.876750
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 6.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 61 rows, 60 cols, 335 nonzeros, 6 slack, 55 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=56, varin=55, theta=2.766044, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 27536499.683212
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 6.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 56 rows, 60 cols, 309 nonzeros, 1 slack, 55 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 1 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=56, varin=93, theta=0.149991, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 27543506.382967
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 6.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 56 rows, 60 cols, 312 nonzeros, 0 slack, 56 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 1 LP 1 Solution, length = 27543506.382967, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.449999 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.449999 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.100002 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.899998 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.149991 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.550001 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.100002 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.100002 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.100002 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.550001 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.550001 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.100002 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.100002 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=27543506.382967, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 1 at  27.54350638296745046318
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabaf550
% @LO 0.00  27.52255206673866538836 99.9000000000
% @LN 0.00  27.53624583902434608262 99.9000000000
% Resuming node 2 at  27.53624583902434608262
DEBUG CONSTRNT: LP rows=56, pool->nlprows=56, pool->npend=0
DEBUG CONSTRNT: Checking 56 LP rows (pool tracks 56, total LP rows 56)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 105
DEBUG CONSTRNT: Pool row 105 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=55, expected 55
 % @PAP adding 69 rows, 288 nz to LP
DEBUG BB: Processing node 2, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=6, varin=38, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=24, varin=54, theta=6.000000, up=999999999999999983222784.000000
ITER 3: row=61, varin=82, theta=0.504851, up=1.000000
ITER 4: row=34, varin=68, theta=0.023586, up=999999999999999983222784.000000
ITER 5: row=46, varin=89, theta=0.013452, up=1.000000
ITER 6: row=41, varin=31, theta=0.009154, up=999999999999999983222784.000000
ITER 7: row=24, varin=20, theta=0.029604, up=999999999999999983222784.000000
ITER 8: row=18, varin=51, theta=0.009383, up=999999999999999983222784.000000
ITER 9: row=13, varin=106, theta=0.025976, up=1.000000
ITER 10: row=15, varin=10, theta=0.009718, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=13)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=69)
DEBUG SOLUTION: LP solution array indices: FST[70-109], not_covered[110-129]
DEBUG SOLUTION: lp->best_solution[0] = 27536245.839025
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 6.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 69 rows, 60 cols, 348 nonzeros, 3 slack, 66 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 5 rows, 20 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=69, varin=73, theta=0.234005, up=1.000000
ITER 2: row=20, varin=108, theta=0.236230, up=1.000000
ITER 3: row=63, varin=92, theta=0.062190, up=1.000000
ITER 4: row=67, varin=37, theta=0.219322, up=999999999999999983222784.000000
ITER 5: row=68, varin=87, theta=0.244265, up=1.000000
ITER 6: row=31, varin=34, theta=0.612324, up=999999999999999983222784.000000
ITER 7: row=51, varin=54, theta=0.470730, up=999999999999999983222784.000000
ITER 8: row=10, varin=24, theta=1.218141, up=999999999999999983222784.000000
ITER 9: row=15, varin=13, theta=0.402052, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=9)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=71)
DEBUG SOLUTION: LP solution array indices: FST[72-111], not_covered[112-131]
DEBUG SOLUTION: lp->best_solution[0] = 27601782.475670
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.919590
DEBUG SOLUTION: lp->best_solution[8] = 0.919590
DEBUG SOLUTION: lp->best_solution[9] = 0.919590
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.919590
DEBUG SOLUTION: lp->best_solution[12] = 0.919590
DEBUG SOLUTION: lp->best_solution[13] = 5.597948
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 71 rows, 60 cols, 351 nonzeros, 23 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 23 slack rows
  % @PAP adding 4 rows, 20 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=25, theta=0.082889, up=999999999999999983222784.000000
ITER 2: row=51, varin=70, theta=0.106864, up=1.000000
ITER 3: row=52, varin=63, theta=0.012162, up=1.000000
LP PHASE: Switching to primal (iter=3)
ITER 4: row=42, varin=51, theta=0.000000, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 27609975.333265
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 306 nonzeros, 2 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 6 rows, 23 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=50, theta=0.230056, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 27610294.826431
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 56 rows, 60 cols, 321 nonzeros, 3 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % Node 2 LP 1 Solution, length = 27610294.826431, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.038343 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.294991 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.038343 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.705009 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.038343 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.961657 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.961657 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.294991 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.294991 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.961657 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.961657 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.961657 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.294991 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.294991 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.961657 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=27610294.826431, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 2 at  27.61029482643070309678
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabad4e0
% @LO 0.00  27.53624583902434608262 99.9000000000
% @LN 0.00  27.54350638296745046318 99.9000000000
% Resuming node 1 at  27.54350638296745046318
DEBUG CONSTRNT: LP rows=53, pool->nlprows=53, pool->npend=0
DEBUG CONSTRNT: Checking 53 LP rows (pool tracks 53, total LP rows 53)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=52, expected 52
 % @PAP adding 56 rows, 252 nz to LP
DEBUG BB: Processing node 1, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 1 LP 2 Solution, length = 27543506.382967, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.449999 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.449999 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.100002 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.899998 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.149991 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.550001 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.100002 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.100002 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.100002 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.550001 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.550001 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.100002 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.100002 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=27543506.382967, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27543506.382967, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 1 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 1
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.449999
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.449999)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.449999
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.449999)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.100002
DEBUG CAREFUL: Adding var 13 to fractional list (xi=0.100002)
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.899998
DEBUG CAREFUL: Adding var 19 to fractional list (xi=0.899998)
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.149991
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.149991)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 19
DEBUG CAREFUL: Calling compare_branch_vars for var 19
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 19
DEBUG CAREFUL: New best var: 19
DEBUG CAREFUL: Testing fvar[1] = var 13
DEBUG CAREFUL: Calling compare_branch_vars for var 13
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 13
DEBUG CAREFUL: Testing fvar[2] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 36
DEBUG CAREFUL: Testing fvar[3] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[4] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 5
  % Initial guess is x19, Z0 = 27675806.751981         , Z1 = 27543506.3829674        

DEBUG EVAL: Testing var 19 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=25, varin=56, theta=0.321895, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 19 = 1 gives z=27567375.220635
  % 	x19 = 1,	Z1 = 27567375.2206352        
DEBUG EVAL: First branch cutoff check: z=27567375.220635, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 19 = 0
ITER 1: row=25, varin=28, theta=4.732578, up=999999999999999983222784.000000
ITER 2: row=55, varin=58, theta=3.704794, up=1.000000
ITER 3: row=55, varin=67, theta=1.852501, up=1.000000
ITER 4: row=55, varin=55, theta=1.427878, up=999999999999999983222784.000000
ITER 5: row=28, varin=46, theta=1.254052, up=999999999999999983222784.000000
ITER 6: row=49, varin=67, theta=0.507093, up=1.000000
ITER 7: row=56, varin=45, theta=1.000000, up=999999999999999983222784.000000
  % 	x19 = 0,	Z0 = 27685409.7673878        
DEBUG EVAL: Second branch cutoff check: z=27685409.767388, best_z=INF, threshold=INF
  %   New best:  x19, Z = 27567375.2206352        
DEBUG EVAL: Testing var 13 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=48, varin=73, theta=0.112465, up=1.000000
DEBUG EVAL: Branch var 13 = 0 gives z=27546785.214186
  % 	x13 = 0,	Z0 = 27546785.214186         
DEBUG EVAL: First branch cutoff check: z=27546785.214186, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 36 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=49, varin=56, theta=0.535493, up=999999999999999983222784.000000
ITER 2: row=25, varin=55, theta=0.550612, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 36 = 1 gives z=27583823.106320
  % 	x36 = 1,	Z1 = 27592388.5621968        
DEBUG EVAL: First branch cutoff check: z=27592388.562197, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 36 = 0
ITER 1: row=49, varin=77, theta=0.040185, up=1.000000
ITER 2: row=21, varin=24, theta=0.349300, up=999999999999999983222784.000000
ITER 3: row=38, varin=69, theta=0.153210, up=1.000000
  % 	x36 = 0,	Z0 = 27549152.5277721        
DEBUG EVAL: Second branch cutoff check: z=27549152.527772, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 9 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=28, varin=54, theta=1.247502, up=999999999999999983222784.000000
ITER 2: row=53, varin=53, theta=0.315559, up=999999999999999983222784.000000
ITER 3: row=1, varin=69, theta=0.748116, up=1.000000
ITER 4: row=49, varin=49, theta=0.149616, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 9 = 1 gives z=27611193.459865
  % 	x9 = 1,	Z1 = 27611193.4598647        
DEBUG EVAL: First branch cutoff check: z=27611193.459865, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 0
ITER 1: row=28, varin=55, theta=0.839601, up=999999999999999983222784.000000
  % 	x9 = 0,	Z0 = 27554171.4286558        
DEBUG EVAL: Second branch cutoff check: z=27554171.428656, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 5 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=54, theta=0.804837, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 5 = 0 gives z=27561780.184907
  % 	x5 = 0,	Z0 = 27561780.1849074        
DEBUG EVAL: First branch cutoff check: z=27561780.184907, best_z=INF, threshold=INF
  % Best branch is x19, Z0 = 27685409.7673878        , Z1 = 27567375.2206352        

DEBUG CAREFUL: Final result - returning best.var = 19
DEBUG BB: Branching variable chosen: j=19
 % @NC    3    1	x19 = 1	27567375.220635
 % @NC    4    1	x19 = 0	27685409.767388
 %       1     3 27543506.3830               27567375.2206    x7 D     0     1
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595daba2600
% @LO 0.00  27.54350638296745046318 99.9000000000
% @LN 0.00  27.56737522063517431548 99.9000000000
% Resuming node 3 at  27.56737522063517431548
DEBUG CONSTRNT: LP rows=56, pool->nlprows=56, pool->npend=0
DEBUG CONSTRNT: Checking 56 LP rows (pool tracks 56, total LP rows 56)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 105
DEBUG CONSTRNT: Pool row 105 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=55, expected 55
 % @PAP adding 56 rows, 252 nz to LP
DEBUG BB: Processing node 3, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=25, varin=56, theta=0.321895, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
ITER 2: row=48, varin=69, theta=0.267644, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 27558603.010042
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 6.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 56 rows, 60 cols, 312 nonzeros, 1 slack, 55 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=57, varin=96, theta=0.660948, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=59)
DEBUG SOLUTION: LP solution array indices: FST[60-99], not_covered[100-119]
DEBUG SOLUTION: lp->best_solution[0] = 27567375.220635
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 6.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 59 rows, 60 cols, 324 nonzeros, 1 slack, 58 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=61, varin=82, theta=0.093614, up=1.000000
ITER 2: row=21, varin=24, theta=1.284030, up=999999999999999983222784.000000
ITER 3: row=38, varin=62, theta=0.141115, up=1.000000
ITER 4: row=2, varin=79, theta=0.104558, up=1.000000
ITER 5: row=36, varin=41, theta=0.447279, up=999999999999999983222784.000000
ITER 6: row=9, varin=64, theta=0.154765, up=1.000000
ITER 7: row=21, varin=96, theta=0.305258, up=1.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=61)
DEBUG SOLUTION: LP solution array indices: FST[62-101], not_covered[102-121]
DEBUG SOLUTION: lp->best_solution[0] = 27617280.474626
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 6.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 61 rows, 60 cols, 328 nonzeros, 0 slack, 61 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 3 LP 1 Solution, length = 27617280.474626, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.347371 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.347371 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.305258 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.347371 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.652629 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.652629 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.652629 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=27617280.474626, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 3 at  27.61728047462571211668
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabaf550
% @LO 0.00  27.56737522063517431548 99.9000000000
% @LN 0.00  27.61029482643070309678 99.9000000000
% Resuming node 2 at  27.61029482643070309678
DEBUG CONSTRNT: LP rows=61, pool->nlprows=61, pool->npend=0
DEBUG CONSTRNT: Checking 61 LP rows (pool tracks 61, total LP rows 61)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 105
DEBUG CONSTRNT: Pool row 105 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=56, expected 56
DEBUG CONSTRNT: Checking LP row 57 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=57, expected 57
DEBUG CONSTRNT: Checking LP row 58 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=58, expected 58
DEBUG CONSTRNT: Checking LP row 59 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=59, expected 59
DEBUG CONSTRNT: Checking LP row 60 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=60, expected 60
 % @PAP adding 53 rows, 236 nz to LP
DEBUG BB: Processing node 2, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 2 LP 2 Solution, length = 27610294.826431, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.038343 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.294991 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.038343 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.705009 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.038343 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.961657 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.961657 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.294991 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.294991 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.961657 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.961657 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.961657 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.294991 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.294991 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.961657 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=27610294.826431, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27610294.826431, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 2 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 2
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=1.000000
DEBUG CAREFUL: Skipping var 7: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.038343
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.038343)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.294991
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.294991)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.038343
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.038343)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.705009
DEBUG CAREFUL: Adding var 19 to fractional list (xi=0.705009)
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.038343
DEBUG CAREFUL: Adding var 20 to fractional list (xi=0.038343)
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 15
DEBUG CAREFUL: New best var: 15
DEBUG CAREFUL: Testing fvar[1] = var 19
DEBUG CAREFUL: Calling compare_branch_vars for var 19
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 19
DEBUG CAREFUL: Testing fvar[2] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[3] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
DEBUG CAREFUL: Testing fvar[4] = var 20
DEBUG CAREFUL: Calling compare_branch_vars for var 20
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 20
  % Initial guess is x17, Z0 = 27610294.8264307        , Z1 = 28107497.6673287        

DEBUG EVAL: Testing var 15 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=37, varin=50, theta=1.099511, up=999999999999999983222784.000000
ITER 2: row=40, varin=44, theta=0.285714, up=999999999999999983222784.000000
ITER 3: row=29, varin=12, theta=12.000000, up=999999999999999983222784.000000
ITER 4: row=1, varin=48, theta=1.500000, up=999999999999999983222784.000000
ITER 5: row=37, varin=7, theta=0.394489, up=999999999999999983222784.000000
ITER 6: row=22, varin=24, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=51, varin=19, theta=0.234463, up=999999999999999983222784.000000
ITER 8: row=52, varin=30, theta=0.198882, up=999999999999999983222784.000000
ITER 9: row=7, varin=39, theta=0.780191, up=999999999999999983222784.000000
ITER 10: row=39, varin=28, theta=3.931689, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 15 = 1 gives z=27849671.209639
  % 	x15 = 1,	Z1 = 27849671.2096385        
DEBUG EVAL: First branch cutoff check: z=27849671.209639, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 15 = 0
ITER 1: row=37, varin=59, theta=0.297747, up=1.000000
ITER 2: row=39, varin=54, theta=0.826110, up=1.000000
ITER 3: row=2, varin=41, theta=1.651442, up=999999999999999983222784.000000
ITER 4: row=49, varin=68, theta=0.301682, up=1.000000
  % 	x15 = 0,	Z0 = 27636463.2240418        
DEBUG EVAL: Second branch cutoff check: z=27636463.224042, best_z=INF, threshold=INF
  %   New best:  x15, Z = 27636463.2240418        
DEBUG EVAL: Testing var 19 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=20, varin=54, theta=0.826110, up=1.000000
ITER 2: row=2, varin=41, theta=1.651442, up=999999999999999983222784.000000
ITER 3: row=49, varin=72, theta=0.568128, up=1.000000
ITER 4: row=40, varin=7, theta=0.246186, up=999999999999999983222784.000000
ITER 5: row=51, varin=56, theta=0.991858, up=1.000000
ITER 6: row=25, varin=9, theta=1.065158, up=999999999999999983222784.000000
ITER 7: row=18, varin=19, theta=0.349107, up=999999999999999983222784.000000
ITER 8: row=9, varin=77, theta=2.783772, up=1.000000
ITER 9: row=9, varin=57, theta=0.676851, up=1.000000
ITER 10: row=31, varin=77, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 19 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x19 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=20, varin=50, theta=1.099511, up=999999999999999983222784.000000
ITER 2: row=40, varin=45, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=29, varin=59, theta=1.000000, up=1.000000
ITER 4: row=39, varin=12, theta=12.000000, up=999999999999999983222784.000000
ITER 5: row=1, varin=48, theta=1.500000, up=999999999999999983222784.000000
ITER 6: row=20, varin=7, theta=0.394489, up=999999999999999983222784.000000
ITER 7: row=22, varin=24, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=51, varin=19, theta=0.234463, up=999999999999999983222784.000000
ITER 9: row=52, varin=30, theta=0.198882, up=999999999999999983222784.000000
ITER 10: row=7, varin=28, theta=3.931689, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=14)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 27849671.209639
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.453446
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.453446
DEBUG SOLUTION: lp->best_solution[11] = 0.453446
DEBUG SOLUTION: lp->best_solution[12] = 2.360337
DEBUG SOLUTION: lp->best_solution[13] = 0.453446
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 53 rows, 60 cols, 296 nonzeros, 17 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 17 slack rows
   % @PAP adding 6 rows, 29 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=37, varin=11, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=39, varin=19, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=1, varin=96, theta=1.546554, up=1.000000
ITER 4: row=1, varin=53, theta=0.222170, up=1.000000
ITER 5: row=41, varin=20, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=26, varin=36, theta=1.059228, up=999999999999999983222784.000000
ITER 7: row=8, varin=63, theta=0.250000, up=1.000000
ITER 8: row=32, varin=8, theta=0.763732, up=999999999999999983222784.000000
ITER 9: row=9, varin=57, theta=0.203686, up=1.000000
ITER 10: row=7, varin=33, theta=0.096074, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=13)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 27882217.211580
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.333333
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 42 rows, 60 cols, 281 nonzeros, 10 slack, 32 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 10 slack rows
   % @PAP adding 4 rows, 16 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=33, varin=11, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=35, varin=29, theta=0.123537, up=999999999999999983222784.000000
ITER 3: row=36, varin=35, theta=0.204410, up=999999999999999983222784.000000
ITER 4: row=23, varin=89, theta=0.024587, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=36)
DEBUG SOLUTION: LP solution array indices: FST[37-76], not_covered[77-96]
DEBUG SOLUTION: lp->best_solution[0] = 27899107.752327
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.549173
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 36 rows, 60 cols, 257 nonzeros, 6 slack, 30 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 6 slack rows
   % @PAP adding 3 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=32, varin=88, theta=0.087898, up=1.000000
ITER 2: row=31, varin=32, theta=0.142153, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=33)
DEBUG SOLUTION: LP solution array indices: FST[34-73], not_covered[74-93]
DEBUG SOLUTION: lp->best_solution[0] = 27899459.940653
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 33 rows, 60 cols, 255 nonzeros, 2 slack, 31 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
   % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=32, varin=30, theta=0.260956, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=32)
DEBUG SOLUTION: LP solution array indices: FST[33-72], not_covered[73-92]
DEBUG SOLUTION: lp->best_solution[0] = 27901554.396309
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 32 rows, 60 cols, 245 nonzeros, 1 slack, 31 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 2 at  27.90155439630868272616
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595daba2600
% @LO 0.00  27.61029482643070309678 99.9000000000
% @LN 0.00  27.61728047462571211668 99.9000000000
% Resuming node 3 at  27.61728047462571211668
DEBUG CONSTRNT: LP rows=31, pool->nlprows=31, pool->npend=0
DEBUG CONSTRNT: Checking 31 LP rows (pool tracks 31, total LP rows 31)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=30, expected 30
 % @PAP adding 61 rows, 268 nz to LP
DEBUG BB: Processing node 3, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 3 LP 2 Solution, length = 27617280.474626, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.347371 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.347371 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.305258 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.347371 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.652629 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.652629 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.652629 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=27617280.474626, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27617280.474626, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 3 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 3
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.347371
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.347371)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.347371
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.347371)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.305258
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.305258)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.347371
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.347371)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 9
DEBUG CAREFUL: New best var: 9
DEBUG CAREFUL: Testing fvar[1] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 34
DEBUG CAREFUL: New best var: 34
DEBUG CAREFUL: Testing fvar[2] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 5
DEBUG CAREFUL: Testing fvar[3] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 36
  % Initial guess is x34, Z0 = 27617280.4746257        , Z1 = 27807540.3238987        

DEBUG EVAL: Testing var 9 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=28, varin=55, theta=0.569657, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 9 = 0 gives z=27654746.931540
  % 	x9 = 0,	Z0 = 27654746.9315397        
DEBUG EVAL: First branch cutoff check: z=27654746.931540, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 1
ITER 1: row=28, varin=91, theta=4.380637, up=1.000000
ITER 2: row=28, varin=21, theta=0.453178, up=999999999999999983222784.000000
ITER 3: row=48, varin=54, theta=1.660499, up=999999999999999983222784.000000
ITER 4: row=60, varin=9, theta=0.517295, up=999999999999999983222784.000000
ITER 5: row=41, varin=36, theta=1.568139, up=999999999999999983222784.000000
ITER 6: row=15, varin=85, theta=6.119789, up=1.000000
ITER 7: row=15, varin=88, theta=1.924526, up=1.000000
ITER 8: row=15, varin=61, theta=0.615871, up=999999999999999983222784.000000
ITER 9: row=12, varin=88, theta=0.972544, up=1.000000
ITER 10: row=42, varin=85, theta=1.000000, up=1.000000
  % 	x9 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: Second branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=28, varin=55, theta=0.569657, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=61)
DEBUG SOLUTION: LP solution array indices: FST[62-101], not_covered[102-121]
DEBUG SOLUTION: lp->best_solution[0] = 27654746.931540
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 6.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 61 rows, 60 cols, 328 nonzeros, 1 slack, 60 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 1 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=61, varin=24, theta=0.277870, up=999999999999999983222784.000000
ITER 2: row=55, varin=12, theta=0.145183, up=999999999999999983222784.000000
ITER 3: row=1, varin=55, theta=0.211480, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=61)
DEBUG SOLUTION: LP solution array indices: FST[62-101], not_covered[102-121]
DEBUG SOLUTION: lp->best_solution[0] = 27659318.824153
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.947130
DEBUG SOLUTION: lp->best_solution[7] = 0.947130
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.947130
DEBUG SOLUTION: lp->best_solution[11] = 0.947130
DEBUG SOLUTION: lp->best_solution[12] = 5.788520
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 61 rows, 60 cols, 330 nonzeros, 20 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 20 slack rows
   % @PAP adding 5 rows, 22 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=57, theta=0.011667, up=1.000000
ITER 2: row=43, varin=15, theta=0.010877, up=999999999999999983222784.000000
ITER 3: row=42, varin=43, theta=0.135614, up=999999999999999983222784.000000
ITER 4: row=44, varin=65, theta=0.084478, up=1.000000
ITER 5: row=42, varin=46, theta=0.056489, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 27669668.997716
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 46 rows, 60 cols, 283 nonzeros, 2 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
   % @PAP adding 4 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=42, theta=0.048587, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 27670623.951484
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 48 rows, 60 cols, 279 nonzeros, 1 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 3 at  27.67062395148364828401
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595daba2600
% @LO 0.00  27.61728047462571211668 99.9000000000
% @LN 0.00  27.67062395148364828401 99.9000000000
% Resuming node 3 at  27.67062395148364828401
DEBUG CONSTRNT: LP rows=47, pool->nlprows=47, pool->npend=0
DEBUG CONSTRNT: Checking 47 LP rows (pool tracks 47, total LP rows 47)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=46, expected 46
 % @PAP adding 47 rows, 213 nz to LP
DEBUG BB: Processing node 3, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 3 LP 3 Solution, length = 27670623.951484, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.500000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.024294 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.024294 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.024294 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.024294 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.354239 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.500000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.975706 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.975706 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.975706 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.975706 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.975706 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.975706 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=27670623.951484, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27670623.951484, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 3 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 3
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.500000
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.024294
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.024294)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.024294
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.024294)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.024294
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.024294)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.024294
DEBUG CAREFUL: Adding var 20 to fractional list (xi=0.024294)
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.354239
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.354239)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.500000
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 7 fractional variables

  %  Carefully choosing branching variable, nfrac = 7
DEBUG CAREFUL: Testing fvar[0] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 5
DEBUG CAREFUL: New best var: 5
DEBUG CAREFUL: Testing fvar[1] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 36
DEBUG CAREFUL: Testing fvar[2] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 10
DEBUG CAREFUL: New best var: 10
DEBUG CAREFUL: Testing fvar[3] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
DEBUG CAREFUL: Testing fvar[4] = var 20
DEBUG CAREFUL: Calling compare_branch_vars for var 20
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 20
DEBUG CAREFUL: Testing fvar[5] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
DEBUG CAREFUL: Testing fvar[6] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 34
  % Initial guess is x18, Z0 = 27670623.9514836        , Z1 = 28384724.2937703        

DEBUG EVAL: Testing var 5 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=40, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=33, varin=47, theta=0.090181, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 5 = 0 gives z=27786876.235827
  % 	x5 = 0,	Z0 = 27786876.2358269        
DEBUG EVAL: First branch cutoff check: z=27786876.235827, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 5 = 1
ITER 1: row=1, varin=39, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=33, varin=42, theta=1.222062, up=999999999999999983222784.000000
ITER 3: row=44, varin=50, theta=0.370491, up=1.000000
ITER 4: row=15, varin=21, theta=0.664024, up=999999999999999983222784.000000
ITER 5: row=6, varin=51, theta=0.343076, up=1.000000
ITER 6: row=32, varin=6, theta=0.709806, up=999999999999999983222784.000000
ITER 7: row=15, varin=47, theta=0.144099, up=999999999999999983222784.000000
ITER 8: row=7, varin=44, theta=0.571704, up=999999999999999983222784.000000
ITER 9: row=28, varin=77, theta=2.474550, up=1.000000
ITER 10: row=28, varin=71, theta=3.947537, up=1.000000
  % 	x5 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: Second branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=40, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=33, varin=47, theta=0.090181, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 27786876.235827
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 47 rows, 60 cols, 273 nonzeros, 5 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 5 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 3 at  27.78687623582690946478
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595daba91d0
% @LO 0.00  27.67062395148364828401 99.9000000000
% @LN 0.00  27.68540976738780656774 99.9000000000
% Resuming node 4 at  27.68540976738780656774
DEBUG CONSTRNT: LP rows=42, pool->nlprows=42, pool->npend=0
DEBUG CONSTRNT: Checking 42 LP rows (pool tracks 42, total LP rows 42)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=41, expected 41
 % @PAP adding 56 rows, 252 nz to LP
DEBUG BB: Processing node 4, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=25, varin=28, theta=4.732578, up=999999999999999983222784.000000
ITER 2: row=55, varin=58, theta=3.704794, up=1.000000
ITER 3: row=55, varin=67, theta=1.852501, up=1.000000
ITER 4: row=55, varin=55, theta=1.427878, up=999999999999999983222784.000000
ITER 5: row=28, varin=46, theta=1.254052, up=999999999999999983222784.000000
ITER 6: row=49, varin=67, theta=0.507093, up=1.000000
ITER 7: row=56, varin=45, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 27685409.767388
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 6.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 56 rows, 60 cols, 312 nonzeros, 3 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 10 rows, 53 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=57, varin=25, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=59, varin=26, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=1, varin=119, theta=1.000000, up=1.000000
ITER 4: row=61, varin=27, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=1, varin=125, theta=1.000000, up=1.000000
ITER 6: row=63, varin=117, theta=1.000000, up=1.000000
ITER 7: row=1, varin=76, theta=0.500000, up=1.000000
ITER 8: row=66, varin=54, theta=1.250000, up=999999999999999983222784.000000
ITER 9: row=28, varin=83, theta=0.375000, up=1.000000
ITER 10: row=65, varin=28, theta=1.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=11)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=66)
DEBUG SOLUTION: LP solution array indices: FST[67-106], not_covered[107-126]
DEBUG SOLUTION: lp->best_solution[0] = 27693041.293086
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 6.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 66 rows, 60 cols, 365 nonzeros, 12 slack, 54 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 12 slack rows
  % @PAP adding 4 rows, 16 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=55, varin=48, theta=0.666667, up=999999999999999983222784.000000
ITER 2: row=57, varin=111, theta=0.202135, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=58)
DEBUG SOLUTION: LP solution array indices: FST[59-98], not_covered[99-118]
DEBUG SOLUTION: lp->best_solution[0] = 27696613.535012
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 6.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 58 rows, 60 cols, 319 nonzeros, 4 slack, 54 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=55, varin=94, theta=0.473179, up=1.000000
ITER 2: row=29, varin=59, theta=0.033013, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 27698629.220401
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 6.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 57 rows, 60 cols, 309 nonzeros, 0 slack, 57 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 4 LP 1 Solution, length = 27698629.220401, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.966987 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.500000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.500000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.466987 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.033013 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.033013 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.033013 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=27698629.220401, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.00  27.68540976738780656774 99.9000000000
 % @LN 0.00  27.69862922040118391465 99.9000000000
DEBUG CG: Second cutoff check: z=27698629.220401, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 4 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 4
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.966987
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.966987)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.500000
DEBUG CAREFUL: Adding var 13 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.500000
DEBUG CAREFUL: Adding var 16 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.466987
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.466987)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 16
DEBUG CAREFUL: Calling compare_branch_vars for var 16
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 16
DEBUG CAREFUL: New best var: 16
DEBUG CAREFUL: Testing fvar[1] = var 13
DEBUG CAREFUL: Calling compare_branch_vars for var 13
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 13
DEBUG CAREFUL: Testing fvar[2] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 36
DEBUG CAREFUL: New best var: 36
DEBUG CAREFUL: Testing fvar[3] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 1
DEBUG CAREFUL: New best var: 1
  % Initial guess is x1, Z0 = 27700819.4431173        , Z1 = 27698629.2204012        

DEBUG EVAL: Testing var 16 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=45, varin=48, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=56, varin=50, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=57, varin=52, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=47, varin=78, theta=0.020210, up=1.000000
ITER 5: row=21, varin=24, theta=0.183890, up=999999999999999983222784.000000
ITER 6: row=34, varin=37, theta=0.158973, up=999999999999999983222784.000000
ITER 7: row=9, varin=12, theta=0.155569, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 16 = 1 gives z=27719334.013331
  % 	x16 = 1,	Z1 = 27719334.0133309        
DEBUG EVAL: First branch cutoff check: z=27719334.013331, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 16 = 0
ITER 1: row=45, varin=55, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=47, varin=78, theta=0.098788, up=1.000000
ITER 3: row=21, varin=24, theta=0.898859, up=999999999999999983222784.000000
ITER 4: row=34, varin=37, theta=0.777065, up=999999999999999983222784.000000
ITER 5: row=9, varin=12, theta=0.760421, up=999999999999999983222784.000000
  % 	x16 = 0,	Z0 = 27709788.8698729        
DEBUG EVAL: Second branch cutoff check: z=27709788.869873, best_z=INF, threshold=INF
  %   New best:  x16, Z = 27709788.8698729        
DEBUG EVAL: Testing var 13 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=44, varin=48, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=56, varin=50, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=57, varin=52, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=47, varin=78, theta=0.020210, up=1.000000
ITER 5: row=21, varin=24, theta=0.183890, up=999999999999999983222784.000000
ITER 6: row=34, varin=37, theta=0.158973, up=999999999999999983222784.000000
ITER 7: row=9, varin=12, theta=0.155569, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 13 = 0 gives z=27719334.013331
  % 	x13 = 0,	Z0 = 27719334.0133309        
DEBUG EVAL: First branch cutoff check: z=27719334.013331, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 13 = 1
ITER 1: row=44, varin=55, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=47, varin=78, theta=0.098788, up=1.000000
ITER 3: row=21, varin=24, theta=0.898859, up=999999999999999983222784.000000
ITER 4: row=34, varin=37, theta=0.777065, up=999999999999999983222784.000000
ITER 5: row=9, varin=12, theta=0.760421, up=999999999999999983222784.000000
  % 	x13 = 1,	Z1 = 27709788.8698729        
DEBUG EVAL: Second branch cutoff check: z=27709788.869873, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 36 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=47, varin=55, theta=0.593600, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 36 = 1 gives z=27702274.550580
  % 	x36 = 1,	Z1 = 27702274.5505799        
DEBUG EVAL: First branch cutoff check: z=27702274.550580, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 1 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=48, theta=0.317638, up=999999999999999983222784.000000
ITER 2: row=56, varin=73, theta=0.018898, up=1.000000
DEBUG EVAL: Branch var 1 = 1 gives z=27701478.592491
  % 	x1 = 1,	Z1 = 27701478.5924911        
DEBUG EVAL: First branch cutoff check: z=27701478.592491, best_z=INF, threshold=INF
  % Best branch is x16, Z0 = 27709788.8698729        , Z1 = 27719334.0133309        

DEBUG CAREFUL: Final result - returning best.var = 16
DEBUG BB: Branching variable chosen: j=16
 % @NC    5    4	x16 = 0	27709788.869873
 % @NC    6    4	x16 = 1	27719334.013331
 %       4     4 27698629.2204               27709788.8699   x19 D     1     2
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabad4e0
% @LO 0.00  27.69862922040118391465 99.9000000000
% @LN 0.00  27.70978886987285605414 99.9000000000
% Resuming node 5 at  27.70978886987285605414
DEBUG CONSTRNT: LP rows=57, pool->nlprows=57, pool->npend=0
DEBUG CONSTRNT: Checking 57 LP rows (pool tracks 57, total LP rows 57)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 105
DEBUG CONSTRNT: Pool row 105 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=56, expected 56
 % @PAP adding 57 rows, 249 nz to LP
DEBUG BB: Processing node 5, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=55, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=47, varin=78, theta=0.098788, up=1.000000
ITER 3: row=21, varin=24, theta=0.898859, up=999999999999999983222784.000000
ITER 4: row=34, varin=37, theta=0.777065, up=999999999999999983222784.000000
ITER 5: row=9, varin=12, theta=0.760421, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 27709788.869873
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.847916
DEBUG SOLUTION: lp->best_solution[7] = 0.847916
DEBUG SOLUTION: lp->best_solution[8] = 0.847916
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.847916
DEBUG SOLUTION: lp->best_solution[11] = 0.847916
DEBUG SOLUTION: lp->best_solution[12] = 5.239579
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 57 rows, 60 cols, 309 nonzeros, 25 slack, 32 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 25 slack rows
  % @PAP adding 6 rows, 28 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=33, varin=75, theta=1.000000, up=1.000000
ITER 2: row=35, varin=49, theta=0.518910, up=1.000000
ITER 3: row=15, varin=23, theta=0.200000, up=999999999999999983222784.000000
ITER 4: row=34, varin=31, theta=0.100000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 27733474.056296
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 38 rows, 60 cols, 268 nonzeros, 4 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=35, varin=32, theta=1.200000, up=999999999999999983222784.000000
ITER 2: row=36, varin=46, theta=0.200000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=36)
DEBUG SOLUTION: LP solution array indices: FST[37-76], not_covered[77-96]
DEBUG SOLUTION: lp->best_solution[0] = 27733981.230565
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 36 rows, 60 cols, 248 nonzeros, 1 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 5 LP 1 Solution, length = 27733981.230565, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.200000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.200000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.209257 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.800000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.209257 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.200000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.800000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.790743 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.790743 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.200000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.200000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.200000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.200000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.790743 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.790743 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.790743 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.790743 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=27733981.230565, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 5 at  27.73398123056502484474
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabbed00
% @LO 0.00  27.70978886987285605414 99.9000000000
% @LN 0.00  27.71933401333086521845 99.9000000000
% Resuming node 6 at  27.71933401333086521845
DEBUG CONSTRNT: LP rows=35, pool->nlprows=35, pool->npend=0
DEBUG CONSTRNT: Checking 35 LP rows (pool tracks 35, total LP rows 35)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=34, expected 34
 % @PAP adding 57 rows, 249 nz to LP
DEBUG BB: Processing node 6, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=48, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=56, varin=50, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=57, varin=52, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=47, varin=78, theta=0.020210, up=1.000000
ITER 5: row=21, varin=24, theta=0.183890, up=999999999999999983222784.000000
ITER 6: row=34, varin=37, theta=0.158973, up=999999999999999983222784.000000
ITER 7: row=9, varin=12, theta=0.155569, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 27719334.013331
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.968886
DEBUG SOLUTION: lp->best_solution[7] = 0.968886
DEBUG SOLUTION: lp->best_solution[8] = 0.968886
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.968886
DEBUG SOLUTION: lp->best_solution[11] = 0.968886
DEBUG SOLUTION: lp->best_solution[12] = 5.844431
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 57 rows, 60 cols, 309 nonzeros, 25 slack, 32 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 5 rows, 24 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=62, varin=72, theta=1.000000, up=1.000000
ITER 2: row=47, varin=99, theta=1.000000, up=1.000000
ITER 3: row=34, varin=75, theta=0.371818, up=1.000000
ITER 4: row=59, varin=54, theta=0.050613, up=999999999999999983222784.000000
ITER 5: row=60, varin=73, theta=0.178355, up=1.000000
ITER 6: row=58, varin=60, theta=0.283755, up=999999999999999983222784.000000
ITER 7: row=59, varin=59, theta=0.520899, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=62)
DEBUG SOLUTION: LP solution array indices: FST[63-102], not_covered[103-122]
DEBUG SOLUTION: lp->best_solution[0] = 27763757.020835
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.826367
DEBUG SOLUTION: lp->best_solution[7] = 0.826367
DEBUG SOLUTION: lp->best_solution[8] = 0.826367
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.826367
DEBUG SOLUTION: lp->best_solution[11] = 0.826367
DEBUG SOLUTION: lp->best_solution[12] = 5.131834
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 62 rows, 60 cols, 333 nonzeros, 27 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 27 slack rows
  % @PAP adding 4 rows, 16 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=55, theta=0.333333, up=1.000000
ITER 2: row=37, varin=23, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=23, varin=97, theta=0.250000, up=1.000000
ITER 4: row=39, varin=98, theta=0.200000, up=1.000000
ITER 5: row=25, varin=37, theta=3.600000, up=999999999999999983222784.000000
ITER 6: row=38, varin=57, theta=0.333333, up=1.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 27839387.170073
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 39 rows, 60 cols, 264 nonzeros, 0 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 23 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=46, theta=0.397841, up=1.000000
ITER 2: row=2, varin=29, theta=1.004576, up=999999999999999983222784.000000
ITER 3: row=34, varin=27, theta=1.466758, up=999999999999999983222784.000000
ITER 4: row=27, varin=64, theta=0.345594, up=1.000000
ITER 5: row=44, varin=15, theta=0.081712, up=999999999999999983222784.000000
ITER 6: row=41, varin=48, theta=0.101167, up=1.000000
ITER 7: row=10, varin=6, theta=0.030136, up=999999999999999983222784.000000
ITER 8: row=6, varin=75, theta=0.130144, up=1.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 27894830.157946
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 287 nonzeros, 2 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 11 rows, 47 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=75, theta=0.101850, up=1.000000
ITER 2: row=44, varin=78, theta=1.022717, up=1.000000
ITER 3: row=44, varin=58, theta=0.007239, up=1.000000
ITER 4: row=15, varin=78, theta=1.000000, up=1.000000
ITER 5: row=47, varin=81, theta=0.015132, up=1.000000
ITER 6: row=41, varin=47, theta=0.129523, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 27931152.854724
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 54 rows, 60 cols, 330 nonzeros, 3 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 6 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=41, theta=0.077204, up=999999999999999983222784.000000
ITER 2: row=54, varin=40, theta=0.937334, up=999999999999999983222784.000000
ITER 3: row=43, varin=82, theta=0.292829, up=1.000000
ITER 4: row=3, varin=79, theta=0.226221, up=1.000000
ITER 5: row=36, varin=38, theta=0.159575, up=999999999999999983222784.000000
ITER 6: row=50, varin=33, theta=0.074116, up=999999999999999983222784.000000
ITER 7: row=52, varin=46, theta=0.046428, up=999999999999999983222784.000000
ITER 8: row=56, varin=41, theta=0.124277, up=999999999999999983222784.000000
ITER 9: row=6, varin=80, theta=0.248291, up=1.000000
LP PHASE: Switching to primal (iter=9)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 27992057.720932
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 57 rows, 60 cols, 317 nonzeros, 3 slack, 54 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 4 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=55, varin=39, theta=0.161168, up=999999999999999983222784.000000
ITER 2: row=57, varin=84, theta=0.186053, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=58)
DEBUG SOLUTION: LP solution array indices: FST[59-98], not_covered[99-118]
DEBUG SOLUTION: lp->best_solution[0] = 27999145.122657
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 58 rows, 60 cols, 314 nonzeros, 2 slack, 56 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 2 rows, 9 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=58, varin=34, theta=0.079794, up=999999999999999983222784.000000
ITER 2: row=57, varin=100, theta=0.316482, up=1.000000
ITER 3: row=40, varin=6, theta=0.175389, up=999999999999999983222784.000000
ITER 4: row=26, varin=58, theta=0.335559, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=58)
DEBUG SOLUTION: LP solution array indices: FST[59-98], not_covered[99-118]
DEBUG SOLUTION: lp->best_solution[0] = 28015007.516323
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 58 rows, 60 cols, 308 nonzeros, 2 slack, 56 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 6 LP 1 Solution, length = 28015007.516323, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.077629 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.077629 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.111853 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 1.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.077629 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.077629 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.077629 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.111853 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.077629 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.111853 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.077629 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.922371 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.922371 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.922371 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.922371 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.922371 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.888147 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.888147 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.922371 (terminal 19)
 % 10 fractional variables
DEBUG CG: LP optimal, z=28015007.516323, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 6 at  28.01500751632258356949
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabad4e0
% @LO 0.00  27.71933401333086521845 99.9000000000
% @LN 0.00  27.73398123056502484474 99.9000000000
% Resuming node 5 at  27.73398123056502484474
DEBUG CONSTRNT: LP rows=56, pool->nlprows=56, pool->npend=0
DEBUG CONSTRNT: Checking 56 LP rows (pool tracks 56, total LP rows 56)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=55, expected 55
 % @PAP adding 35 rows, 182 nz to LP
DEBUG BB: Processing node 5, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 5 LP 2 Solution, length = 27733981.230565, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.200000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.200000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.209257 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.800000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.209257 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.200000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.800000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.790743 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.790743 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.200000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.200000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.200000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.200000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.790743 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.790743 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.790743 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.790743 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=27733981.230565, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27733981.230565, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 5 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 5
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.200000
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.200000)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.200000
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.200000)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.209257
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.209257)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.800000
DEBUG CAREFUL: Adding var 13 to fractional list (xi=0.800000)
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.209257
DEBUG CAREFUL: Adding var 20 to fractional list (xi=0.209257)
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.200000
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.200000)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 9
DEBUG CAREFUL: New best var: 9
DEBUG CAREFUL: Testing fvar[1] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 5
DEBUG CAREFUL: Testing fvar[2] = var 13
DEBUG CAREFUL: Calling compare_branch_vars for var 13
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 13
DEBUG CAREFUL: Testing fvar[3] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 36
DEBUG CAREFUL: Testing fvar[4] = var 20
DEBUG CAREFUL: Calling compare_branch_vars for var 20
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 20
DEBUG CAREFUL: New best var: 20
DEBUG CAREFUL: Testing fvar[5] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x20, Z0 = 27733981.230565         , Z1 = 27975064.0075088        

DEBUG EVAL: Testing var 9 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=22, varin=35, theta=0.800000, up=999999999999999983222784.000000
ITER 2: row=1, varin=86, theta=1.500000, up=1.000000
ITER 3: row=1, varin=32, theta=0.500000, up=999999999999999983222784.000000
ITER 4: row=9, varin=6, theta=0.177915, up=999999999999999983222784.000000
ITER 5: row=15, varin=9, theta=0.146086, up=999999999999999983222784.000000
ITER 6: row=6, varin=31, theta=0.486110, up=999999999999999983222784.000000
ITER 7: row=25, varin=7, theta=0.816567, up=999999999999999983222784.000000
ITER 8: row=7, varin=29, theta=0.816567, up=999999999999999983222784.000000
ITER 9: row=31, varin=27, theta=0.316567, up=999999999999999983222784.000000
ITER 10: row=1, varin=30, theta=0.316567, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 9 = 1 gives z=27764028.277676
  % 	x9 = 1,	Z1 = 27764028.277676         
DEBUG EVAL: First branch cutoff check: z=27764028.277676, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 0
ITER 1: row=22, varin=51, theta=0.166667, up=1.000000
  % 	x9 = 0,	Z0 = 27739846.7718818        
DEBUG EVAL: Second branch cutoff check: z=27739846.771882, best_z=INF, threshold=INF
  %   New best:  x9, Z = 27739846.7718818        
DEBUG EVAL: Testing var 5 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=35, theta=0.200000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 5 = 0 gives z=27734022.662032
  % 	x5 = 0,	Z0 = 27734022.6620321        
DEBUG EVAL: First branch cutoff check: z=27734022.662032, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 13 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=24, varin=48, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 13 = 1 gives z=27754330.353611
  % 	x13 = 1,	Z1 = 27754330.3536109        
DEBUG EVAL: First branch cutoff check: z=27754330.353611, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 13 = 0
ITER 1: row=24, varin=86, theta=4.000000, up=1.000000
ITER 2: row=24, varin=32, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=6, varin=35, theta=9.022884, up=999999999999999983222784.000000
ITER 4: row=22, varin=31, theta=2.762431, up=999999999999999983222784.000000
ITER 5: row=25, varin=45, theta=2.540106, up=1.000000
ITER 6: row=25, varin=6, theta=1.795014, up=999999999999999983222784.000000
ITER 7: row=6, varin=45, theta=1.000000, up=1.000000
ITER 8: row=9, varin=29, theta=1.960527, up=999999999999999983222784.000000
ITER 9: row=31, varin=9, theta=0.960527, up=999999999999999983222784.000000
ITER 10: row=14, varin=28, theta=1.402443, up=999999999999999983222784.000000
  % 	x13 = 0,	Z0 = 27857787.9878213        
DEBUG EVAL: Second branch cutoff check: z=27857787.987821, best_z=INF, threshold=INF
  %   New best:  x13, Z = 27754330.3536109        
DEBUG EVAL: Testing var 36 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=25, varin=35, theta=0.200000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 36 = 0 gives z=27734022.662032
  % 	x36 = 0,	Z0 = 27734022.6620321        
DEBUG EVAL: First branch cutoff check: z=27734022.662032, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 20 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=35, theta=5.519286, up=999999999999999983222784.000000
ITER 2: row=1, varin=30, theta=2.735623, up=999999999999999983222784.000000
ITER 3: row=33, varin=28, theta=3.994221, up=999999999999999983222784.000000
ITER 4: row=7, varin=51, theta=3.025734, up=1.000000
ITER 5: row=7, varin=23, theta=2.708482, up=999999999999999983222784.000000
ITER 6: row=14, varin=31, theta=3.245136, up=999999999999999983222784.000000
ITER 7: row=25, varin=7, theta=3.199320, up=999999999999999983222784.000000
ITER 8: row=8, varin=48, theta=3.492653, up=1.000000
ITER 9: row=8, varin=50, theta=1.057145, up=1.000000
ITER 10: row=8, varin=24, theta=0.050327, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 20 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x20 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=6, varin=34, theta=1.104971, up=999999999999999983222784.000000
ITER 2: row=25, varin=32, theta=0.160626, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=35)
DEBUG SOLUTION: LP solution array indices: FST[36-75], not_covered[76-95]
DEBUG SOLUTION: lp->best_solution[0] = 27736918.072999
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 35 rows, 60 cols, 242 nonzeros, 3 slack, 32 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 3 slack rows
   % @PAP adding 3 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=35, varin=32, theta=0.226321, up=999999999999999983222784.000000
ITER 2: row=34, varin=72, theta=0.232109, up=1.000000
ITER 3: row=33, varin=34, theta=0.037824, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=35)
DEBUG SOLUTION: LP solution array indices: FST[36-75], not_covered[76-95]
DEBUG SOLUTION: lp->best_solution[0] = 27737957.190449
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 35 rows, 60 cols, 244 nonzeros, 1 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 5 at  27.73795719044898788752
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabad4e0
% @LO 0.00  27.73398123056502484474 99.9000000000
% @LN 0.00  27.73795719044898788752 99.9000000000
% Resuming node 5 at  27.73795719044898788752
DEBUG CONSTRNT: LP rows=34, pool->nlprows=34, pool->npend=0
DEBUG CONSTRNT: Checking 34 LP rows (pool tracks 34, total LP rows 34)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=33, expected 33
 % @PAP adding 34 rows, 182 nz to LP
DEBUG BB: Processing node 5, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 5 LP 3 Solution, length = 27737957.190449, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.259456 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.259456 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.297280 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.740544 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.740544 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.259456 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.259456 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.259456 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.259456 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.259456 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.702720 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.702720 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.702720 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=27737957.190449, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27737957.190449, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 5 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 5
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.259456
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.259456)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.259456
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.259456)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.297280
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.297280)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.740544
DEBUG CAREFUL: Adding var 13 to fractional list (xi=0.740544)
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.740544
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.740544)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 9
DEBUG CAREFUL: New best var: 9
DEBUG CAREFUL: Testing fvar[1] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 5
DEBUG CAREFUL: Testing fvar[2] = var 13
DEBUG CAREFUL: Calling compare_branch_vars for var 13
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 13
DEBUG CAREFUL: New best var: 13
DEBUG CAREFUL: Testing fvar[3] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 36
DEBUG CAREFUL: Testing fvar[4] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x13, Z0 = 27857787.9878213        , Z1 = 27754330.3536109        

DEBUG EVAL: Testing var 9 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=22, varin=33, theta=0.303958, up=999999999999999983222784.000000
ITER 2: row=32, varin=50, theta=0.241875, up=1.000000
DEBUG EVAL: Branch var 9 = 0 gives z=27748196.558955
  % 	x9 = 0,	Z0 = 27748196.5589545        
DEBUG EVAL: First branch cutoff check: z=27748196.558955, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 5 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=34, theta=0.252225, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 5 = 0 gives z=27738030.770164
  % 	x5 = 0,	Z0 = 27738030.7701643        
DEBUG EVAL: First branch cutoff check: z=27738030.770164, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 13 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=24, varin=34, theta=9.050661, up=999999999999999983222784.000000
ITER 2: row=1, varin=47, theta=0.646583, up=1.000000
DEBUG EVAL: Branch var 13 = 1 gives z=27765032.921830
  % 	x13 = 1,	Z1 = 27765032.9218298        
DEBUG EVAL: First branch cutoff check: z=27765032.921830, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 13 = 0
ITER 1: row=24, varin=85, theta=13.568929, up=1.000000
ITER 2: row=24, varin=33, theta=4.685292, up=999999999999999983222784.000000
ITER 3: row=1, varin=34, theta=5.826042, up=999999999999999983222784.000000
ITER 4: row=25, varin=6, theta=3.960527, up=999999999999999983222784.000000
ITER 5: row=6, varin=25, theta=2.960527, up=999999999999999983222784.000000
ITER 6: row=26, varin=29, theta=1.960527, up=999999999999999983222784.000000
ITER 7: row=31, varin=27, theta=0.960527, up=999999999999999983222784.000000
ITER 8: row=14, varin=85, theta=1.402443, up=1.000000
ITER 9: row=14, varin=28, theta=0.402443, up=999999999999999983222784.000000
ITER 10: row=7, varin=7, theta=0.402443, up=999999999999999983222784.000000
  % 	x13 = 0,	Z0 = 27857787.9878213        
DEBUG EVAL: Second branch cutoff check: z=27857787.987821, best_z=INF, threshold=INF
  %   New best:  x13, Z = 27765032.9218298        
DEBUG EVAL: Testing var 36 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=25, varin=34, theta=9.050661, up=999999999999999983222784.000000
ITER 2: row=1, varin=29, theta=0.266599, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 36 = 1 gives z=27743133.961857
  % 	x36 = 1,	Z1 = 27743133.9618575        
DEBUG EVAL: First branch cutoff check: z=27743133.961857, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=14, varin=34, theta=2.074018, up=999999999999999983222784.000000
ITER 2: row=1, varin=85, theta=0.355410, up=1.000000
DEBUG EVAL: Branch var 10 = 0 gives z=27738681.421704
  % 	x10 = 0,	Z0 = 27738681.4217041        
DEBUG EVAL: First branch cutoff check: z=27738681.421704, best_z=INF, threshold=INF
  % Best branch is x13, Z0 = 27857787.9878213        , Z1 = 27765032.9218298        

DEBUG CAREFUL: Final result - returning best.var = 13
DEBUG BB: Branching variable chosen: j=13
 % @NC    7    5	x13 = 1	27765032.921830
 % @NC    8    5	x13 = 0	27857787.987821
 %       5     5 27737957.1904               27765032.9218   x16 D     4     3
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595daba91d0
% @LO 0.00  27.73795719044898788752 99.9000000000
% @LN 0.00  27.76503292182977844504 99.9000000000
% Resuming node 7 at  27.76503292182977844504
DEBUG CONSTRNT: LP rows=34, pool->nlprows=34, pool->npend=0
DEBUG CONSTRNT: Checking 34 LP rows (pool tracks 34, total LP rows 34)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=33, expected 33
 % @PAP adding 34 rows, 182 nz to LP
DEBUG BB: Processing node 7, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=24, varin=34, theta=9.050661, up=999999999999999983222784.000000
ITER 2: row=1, varin=47, theta=0.646583, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=34)
DEBUG SOLUTION: LP solution array indices: FST[35-74], not_covered[75-94]
DEBUG SOLUTION: lp->best_solution[0] = 27765032.921830
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 34 rows, 60 cols, 242 nonzeros, 0 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 16 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=35, varin=96, theta=1.137610, up=1.000000
ITER 2: row=35, varin=56, theta=0.037995, up=1.000000
ITER 3: row=37, varin=96, theta=1.000000, up=1.000000
ITER 4: row=1, varin=54, theta=0.078378, up=1.000000
ITER 5: row=24, varin=33, theta=0.134901, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 27831303.547546
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 38 rows, 60 cols, 258 nonzeros, 2 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 8 rows, 43 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=37, varin=45, theta=0.500000, up=1.000000
ITER 2: row=2, varin=63, theta=0.333333, up=1.000000
ITER 3: row=40, varin=9, theta=0.038462, up=999999999999999983222784.000000
ITER 4: row=42, varin=15, theta=0.052023, up=999999999999999983222784.000000
ITER 5: row=44, varin=23, theta=0.042169, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 27883869.963882
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.957831
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 295 nonzeros, 6 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 5 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=54, theta=0.396226, up=1.000000
ITER 2: row=39, varin=6, theta=0.512716, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 27924093.650516
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.487284
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 3.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 297 nonzeros, 5 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=44, theta=0.465190, up=1.000000
ITER 2: row=8, varin=34, theta=2.070423, up=999999999999999983222784.000000
ITER 3: row=33, varin=24, theta=0.535064, up=999999999999999983222784.000000
ITER 4: row=24, varin=45, theta=0.194988, up=1.000000
ITER 5: row=41, varin=43, theta=0.942520, up=1.000000
ITER 6: row=33, varin=83, theta=1.253034, up=1.000000
ITER 7: row=33, varin=39, theta=0.035021, up=999999999999999983222784.000000
ITER 8: row=24, varin=84, theta=0.191757, up=1.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 27961392.716851
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 3.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 41 rows, 60 cols, 284 nonzeros, 3 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 4 rows, 15 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=84, theta=1.000000, up=1.000000
ITER 2: row=30, varin=46, theta=0.280547, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 27970135.625072
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 3.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 291 nonzeros, 3 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 6 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=75, theta=0.334156, up=1.000000
ITER 2: row=39, varin=69, theta=0.697287, up=1.000000
ITER 3: row=10, varin=36, theta=0.586036, up=999999999999999983222784.000000
ITER 4: row=2, varin=72, theta=0.279262, up=1.000000
ITER 5: row=43, varin=32, theta=2.217703, up=999999999999999983222784.000000
ITER 6: row=41, varin=87, theta=1.242992, up=1.000000
ITER 7: row=41, varin=31, theta=0.140862, up=999999999999999983222784.000000
ITER 8: row=10, varin=87, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28041281.737401
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 3.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 289 nonzeros, 2 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 3 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=4, theta=0.028131, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28041554.689152
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.971869
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 3.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 278 nonzeros, 2 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 3 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=7, theta=0.349032, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28044477.479971
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.825484
DEBUG SOLUTION: lp->best_solution[6] = 0.825484
DEBUG SOLUTION: lp->best_solution[7] = 2.650968
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 47 rows, 60 cols, 281 nonzeros, 3 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=70, theta=0.005832, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28044708.061920
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 275 nonzeros, 0 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=71, theta=0.004520, up=1.000000
ITER 2: row=23, varin=61, theta=0.006526, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28045143.443059
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 289 nonzeros, 0 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 7 LP 1 Solution, length = 28045143.443059, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.164491 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.164491 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.164491 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.006526 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.164491 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.164491 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.164491 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.835509 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.835509 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.835509 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.835509 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.835509 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.835509 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.835509 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=28045143.443059, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 7 at  28.04514344305915685140
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595daba2600
% @LO 0.00  27.76503292182977844504 99.9000000000
% @LN 0.00  27.78687623582690946478 99.9000000000
% Resuming node 3 at  27.78687623582690946478
DEBUG CONSTRNT: LP rows=49, pool->nlprows=49, pool->npend=0
DEBUG CONSTRNT: Checking 49 LP rows (pool tracks 49, total LP rows 49)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=48, expected 48
 % @PAP adding 42 rows, 201 nz to LP
DEBUG BB: Processing node 3, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 3 LP 4 Solution, length = 27786876.235827, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.211757 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.211757 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.121576 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.211757 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.788243 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.788243 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.788243 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.788243 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.788243 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.788243 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=27786876.235827, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27786876.235827, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 3 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 3
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.211757
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.211757)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.211757
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.211757)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.121576
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.121576)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.211757
DEBUG CAREFUL: Adding var 20 to fractional list (xi=0.211757)
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 10
DEBUG CAREFUL: New best var: 10
DEBUG CAREFUL: Testing fvar[1] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
DEBUG CAREFUL: Testing fvar[2] = var 20
DEBUG CAREFUL: Calling compare_branch_vars for var 20
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 20
DEBUG CAREFUL: Testing fvar[3] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
  % Initial guess is x18, Z0 = 27786876.2358269        , Z1 = 28384724.2937703        

DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=41, theta=1.201625, up=999999999999999983222784.000000
ITER 2: row=7, varin=77, theta=1.941247, up=1.000000
ITER 3: row=7, varin=45, theta=0.270907, up=1.000000
ITER 4: row=15, varin=72, theta=0.340804, up=1.000000
ITER 5: row=20, varin=77, theta=0.534240, up=1.000000
DEBUG EVAL: Branch var 10 = 1 gives z=27869671.221930
  % 	x10 = 1,	Z1 = 27869671.2219297        
DEBUG EVAL: First branch cutoff check: z=27869671.221930, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=1, varin=20, theta=0.237693, up=999999999999999983222784.000000
ITER 2: row=42, varin=44, theta=0.898733, up=1.000000
  % 	x10 = 0,	Z0 = 27793119.9813758        
DEBUG EVAL: Second branch cutoff check: z=27793119.981376, best_z=INF, threshold=INF
  %   New best:  x10, Z = 27793119.9813758        
DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=19, varin=21, theta=1.292812, up=999999999999999983222784.000000
ITER 2: row=6, varin=77, theta=11.569240, up=1.000000
ITER 3: row=6, varin=45, theta=3.042002, up=1.000000
ITER 4: row=6, varin=72, theta=2.568866, up=1.000000
ITER 5: row=6, varin=66, theta=3.500137, up=1.000000
ITER 6: row=6, varin=46, theta=0.948675, up=1.000000
ITER 7: row=20, varin=7, theta=1.627099, up=999999999999999983222784.000000
ITER 8: row=10, varin=69, theta=9.225506, up=1.000000
ITER 9: row=10, varin=32, theta=4.592829, up=999999999999999983222784.000000
ITER 10: row=1, varin=77, theta=14.534698, up=1.000000
DEBUG EVAL: Branch var 17 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x17 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=19, varin=41, theta=0.615538, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
ITER 2: row=32, varin=44, theta=0.898733, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 27793119.981376
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 42 rows, 60 cols, 261 nonzeros, 0 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 10 rows, 47 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=112, theta=0.615538, up=1.000000
ITER 2: row=48, varin=20, theta=0.143995, up=999999999999999983222784.000000
ITER 3: row=43, varin=87, theta=0.605296, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 27814539.071664
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.868432
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.868432
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 52 rows, 60 cols, 308 nonzeros, 9 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 9 slack rows
   % @PAP adding 3 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=42, theta=1.247674, up=999999999999999983222784.000000
ITER 2: row=29, varin=39, theta=0.361623, up=999999999999999983222784.000000
ITER 3: row=7, varin=31, theta=0.649272, up=999999999999999983222784.000000
ITER 4: row=35, varin=49, theta=0.116454, up=1.000000
ITER 5: row=13, varin=50, theta=0.104391, up=1.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 27830214.469888
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 46 rows, 60 cols, 281 nonzeros, 2 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
   % @PAP adding 3 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=102, theta=0.061607, up=1.000000
ITER 2: row=46, varin=47, theta=1.235321, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 27842194.982530
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 47 rows, 60 cols, 287 nonzeros, 1 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 3 at  27.84219498253028035606
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595daba2600
% @LO 0.01  27.78687623582690946478 99.9000000000
% @LN 0.01  27.84219498253028035606 99.9000000000
% Resuming node 3 at  27.84219498253028035606
DEBUG CONSTRNT: LP rows=46, pool->nlprows=46, pool->npend=0
DEBUG CONSTRNT: Checking 46 LP rows (pool tracks 46, total LP rows 46)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 85
DEBUG CONSTRNT: Pool row 85 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=45, expected 45
 % @PAP adding 46 rows, 217 nz to LP
DEBUG BB: Processing node 3, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 3 LP 5 Solution, length = 27842194.982530, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.191170 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.205887 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.205887 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.205887 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.794113 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.794113 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.794113 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.794113 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.794113 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.794113 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=27842194.982530, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27842194.982530, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 3 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 3
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.191170
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.191170)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.205887
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.205887)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.205887
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.205887)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.205887
DEBUG CAREFUL: Adding var 20 to fractional list (xi=0.205887)
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[1] = var 20
DEBUG CAREFUL: Calling compare_branch_vars for var 20
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 20
DEBUG CAREFUL: Testing fvar[2] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
DEBUG CAREFUL: Testing fvar[3] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x18, Z0 = 27842194.9825303        , Z1 = 28384724.2937703        

DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=13, varin=35, theta=3.439035, up=999999999999999983222784.000000
ITER 2: row=44, varin=13, theta=0.610960, up=999999999999999983222784.000000
ITER 3: row=1, varin=43, theta=1.623946, up=999999999999999983222784.000000
ITER 4: row=43, varin=91, theta=3.589178, up=1.000000
ITER 5: row=43, varin=46, theta=1.773316, up=999999999999999983222784.000000
ITER 6: row=39, varin=91, theta=1.000000, up=1.000000
ITER 7: row=17, varin=44, theta=11.583082, up=999999999999999983222784.000000
ITER 8: row=13, varin=38, theta=0.434377, up=999999999999999983222784.000000
ITER 9: row=25, varin=2, theta=0.500000, up=999999999999999983222784.000000
ITER 10: row=2, varin=32, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 1 gives z=28133518.546308
  % 	x3 = 1,	Z1 = 28133518.5463083        
DEBUG EVAL: First branch cutoff check: z=28133518.546308, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=13, varin=76, theta=0.333237, up=1.000000
ITER 2: row=40, varin=70, theta=0.688850, up=1.000000
ITER 3: row=19, varin=9, theta=0.368713, up=999999999999999983222784.000000
ITER 4: row=41, varin=88, theta=0.601196, up=1.000000
  % 	x3 = 0,	Z0 = 27866806.221427         
DEBUG EVAL: Second branch cutoff check: z=27866806.221427, best_z=INF, threshold=INF
  %   New best:  x3, Z = 27866806.221427         
DEBUG EVAL: Testing var 20 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=38, theta=3.735304, up=999999999999999983222784.000000
ITER 2: row=13, varin=35, theta=4.832335, up=999999999999999983222784.000000
ITER 3: row=44, varin=76, theta=4.256046, up=1.000000
ITER 4: row=44, varin=70, theta=7.264231, up=1.000000
ITER 5: row=44, varin=73, theta=2.536638, up=1.000000
ITER 6: row=44, varin=68, theta=1.339998, up=1.000000
ITER 7: row=44, varin=69, theta=0.347625, up=1.000000
ITER 8: row=25, varin=43, theta=4.880537, up=999999999999999983222784.000000
ITER 9: row=43, varin=29, theta=3.819982, up=999999999999999983222784.000000
ITER 10: row=17, varin=50, theta=3.413046, up=1.000000
DEBUG EVAL: Branch var 20 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x20 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=6, varin=9, theta=0.641364, up=999999999999999983222784.000000
ITER 2: row=41, varin=91, theta=1.370431, up=1.000000
ITER 3: row=41, varin=46, theta=0.253707, up=999999999999999983222784.000000
ITER 4: row=39, varin=91, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 27884831.561843
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 46 rows, 60 cols, 277 nonzeros, 2 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
   % @PAP adding 8 rows, 39 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=94, theta=1.696705, up=1.000000
ITER 2: row=49, varin=69, theta=0.972960, up=1.000000
ITER 3: row=26, varin=37, theta=0.130308, up=999999999999999983222784.000000
ITER 4: row=42, varin=41, theta=0.257929, up=999999999999999983222784.000000
ITER 5: row=45, varin=18, theta=0.111650, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
ITER 6: row=41, varin=45, theta=0.000000, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 27956132.705518
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.888350
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 52 rows, 60 cols, 312 nonzeros, 11 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 11 slack rows
   % @PAP adding 4 rows, 15 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=87, theta=1.000000, up=1.000000
ITER 2: row=39, varin=75, theta=1.000000, up=1.000000
ITER 3: row=34, varin=69, theta=2.000000, up=1.000000
ITER 4: row=34, varin=96, theta=0.500000, up=1.000000
ITER 5: row=14, varin=69, theta=1.000000, up=1.000000
ITER 6: row=35, varin=12, theta=0.857786, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28105037.567882
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.571107
DEBUG SOLUTION: lp->best_solution[11] = 0.571107
DEBUG SOLUTION: lp->best_solution[12] = 2.142214
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 45 rows, 60 cols, 285 nonzeros, 5 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 5 slack rows
   % @PAP adding 4 rows, 17 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=56, theta=0.240011, up=1.000000
ITER 2: row=42, varin=71, theta=0.318192, up=1.000000
ITER 3: row=44, varin=97, theta=0.026328, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28120830.992750
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 44 rows, 60 cols, 283 nonzeros, 0 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 8 rows, 31 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=42, theta=0.381421, up=999999999999999983222784.000000
ITER 2: row=46, varin=57, theta=0.244190, up=1.000000
ITER 3: row=37, varin=3, theta=0.045296, up=999999999999999983222784.000000
ITER 4: row=45, varin=44, theta=0.170713, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28129826.774964
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.960976
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 52 rows, 60 cols, 314 nonzeros, 4 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 4 slack rows
   % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=41, theta=0.600647, up=999999999999999983222784.000000
ITER 2: row=49, varin=76, theta=0.347177, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28137105.972224
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 51 rows, 60 cols, 305 nonzeros, 0 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 4 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=36, theta=0.424844, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 28137945.946465
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 55 rows, 60 cols, 318 nonzeros, 5 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 5 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 3 at  28.13794594646489954926
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabb5780
% @LO 0.01  27.84219498253028035606 99.9000000000
% @LN 0.01  27.85778798782127552158 99.9000000000
% Resuming node 8 at  27.85778798782127552158
DEBUG CONSTRNT: LP rows=50, pool->nlprows=50, pool->npend=0
DEBUG CONSTRNT: Checking 50 LP rows (pool tracks 50, total LP rows 50)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 85
DEBUG CONSTRNT: Pool row 85 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=49, expected 49
 % @PAP adding 34 rows, 182 nz to LP
DEBUG BB: Processing node 8, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=24, varin=85, theta=13.568929, up=1.000000
ITER 2: row=24, varin=33, theta=4.685292, up=999999999999999983222784.000000
ITER 3: row=1, varin=34, theta=5.826042, up=999999999999999983222784.000000
ITER 4: row=25, varin=6, theta=3.960527, up=999999999999999983222784.000000
ITER 5: row=6, varin=25, theta=2.960527, up=999999999999999983222784.000000
ITER 6: row=26, varin=29, theta=1.960527, up=999999999999999983222784.000000
ITER 7: row=31, varin=27, theta=0.960527, up=999999999999999983222784.000000
ITER 8: row=14, varin=85, theta=1.402443, up=1.000000
ITER 9: row=14, varin=28, theta=0.402443, up=999999999999999983222784.000000
ITER 10: row=7, varin=7, theta=0.402443, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=12)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=34)
DEBUG SOLUTION: LP solution array indices: FST[35-74], not_covered[75-94]
DEBUG SOLUTION: lp->best_solution[0] = 27857787.987821
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 34 rows, 60 cols, 242 nonzeros, 6 slack, 28 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 5 rows, 18 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=35, varin=31, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=37, varin=83, theta=1.179776, up=1.000000
ITER 3: row=37, varin=87, theta=0.179776, up=1.000000
ITER 4: row=39, varin=30, theta=0.164045, up=999999999999999983222784.000000
ITER 5: row=38, varin=39, theta=3.280894, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 27857787.987821
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 39 rows, 60 cols, 260 nonzeros, 8 slack, 31 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=93, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 27857787.987821
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 41 rows, 60 cols, 273 nonzeros, 8 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=60, theta=0.073928, up=1.000000
ITER 2: row=42, varin=44, theta=6.386939, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 27861926.282438
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 286 nonzeros, 12 slack, 32 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 12 slack rows
  % @PAP adding 4 rows, 16 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=33, varin=94, theta=0.500000, up=1.000000
ITER 2: row=35, varin=95, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=36)
DEBUG SOLUTION: LP solution array indices: FST[37-76], not_covered[77-96]
DEBUG SOLUTION: lp->best_solution[0] = 27870202.871673
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 36 rows, 60 cols, 244 nonzeros, 4 slack, 32 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 2 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=33, varin=40, theta=0.318780, up=1.000000
ITER 2: row=34, varin=33, theta=0.225586, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=34)
DEBUG SOLUTION: LP solution array indices: FST[35-74], not_covered[75-94]
DEBUG SOLUTION: lp->best_solution[0] = 27871486.207547
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 34 rows, 60 cols, 242 nonzeros, 3 slack, 31 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=32, varin=34, theta=0.041595, up=1.000000
ITER 2: row=7, varin=77, theta=0.055167, up=1.000000
ITER 3: row=8, varin=69, theta=0.055445, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=32)
DEBUG SOLUTION: LP solution array indices: FST[33-72], not_covered[73-92]
DEBUG SOLUTION: lp->best_solution[0] = 27873731.510498
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 32 rows, 60 cols, 234 nonzeros, 0 slack, 32 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 8 LP 1 Solution, length = 27873731.510498, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.685148 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.685148 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.629703 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.055445 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.314852 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.314852 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.314852 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.314852 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.314852 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.370297 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.370297 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=27873731.510498, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.01  27.85778798782127552158 99.9000000000
 % @LN 0.01  27.87373151049785846567 99.9000000000
DEBUG CG: Second cutoff check: z=27873731.510498, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % initially 3 congested vertices:
 % _gst_find_congested_components found 1 components:
 % 	component 0:	3 verts,	3 edges
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 8 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 8
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.685148
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.685148)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.685148
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.685148)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.629703
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.629703)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.055445
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.055445)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 15
DEBUG CAREFUL: New best var: 15
DEBUG CAREFUL: Testing fvar[1] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 36
DEBUG CAREFUL: New best var: 36
DEBUG CAREFUL: Testing fvar[2] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 5
DEBUG CAREFUL: Testing fvar[3] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
  % Initial guess is x36, Z0 = 27873731.5104979        , Z1 = 27916005.9883734        

DEBUG EVAL: Testing var 15 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=24, varin=78, theta=0.820330, up=1.000000
ITER 2: row=23, varin=43, theta=0.561840, up=1.000000
ITER 3: row=25, varin=83, theta=0.500000, up=1.000000
ITER 4: row=14, varin=32, theta=0.283408, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 15 = 1 gives z=27890601.941028
  % 	x15 = 1,	Z1 = 27890601.9410279        
DEBUG EVAL: First branch cutoff check: z=27890601.941028, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 15 = 0
ITER 1: row=24, varin=47, theta=0.347089, up=1.000000
ITER 2: row=25, varin=8, theta=0.213429, up=999999999999999983222784.000000
ITER 3: row=7, varin=31, theta=0.120927, up=999999999999999983222784.000000
  % 	x15 = 0,	Z0 = 27890171.866832         
DEBUG EVAL: Second branch cutoff check: z=27890171.866832, best_z=INF, threshold=INF
  %   New best:  x15, Z = 27890171.866832         
DEBUG EVAL: Testing var 36 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=25, varin=8, theta=0.939818, up=999999999999999983222784.000000
ITER 2: row=7, varin=7, theta=0.708604, up=999999999999999983222784.000000
ITER 3: row=8, varin=32, theta=3.843016, up=999999999999999983222784.000000
ITER 4: row=26, varin=31, theta=0.502045, up=999999999999999983222784.000000
ITER 5: row=1, varin=82, theta=0.376836, up=1.000000
DEBUG EVAL: Branch var 36 = 1 gives z=27916005.988373
  % 	x36 = 1,	Z1 = 27916005.9883734        
DEBUG EVAL: First branch cutoff check: z=27916005.988373, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 36 = 0
ITER 1: row=25, varin=78, theta=0.081887, up=1.000000
ITER 2: row=23, varin=43, theta=0.056084, up=1.000000
  % 	x36 = 0,	Z0 = 27875098.6151122        
DEBUG EVAL: Second branch cutoff check: z=27875098.615112, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 5 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=32, theta=0.758200, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 5 = 1 gives z=27881278.045348
  % 	x5 = 1,	Z1 = 27881278.0453476        
DEBUG EVAL: First branch cutoff check: z=27881278.045348, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 9 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=20, varin=28, theta=0.872846, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 9 = 1 gives z=27889605.136710
  % 	x9 = 1,	Z1 = 27889605.1367095        
DEBUG EVAL: First branch cutoff check: z=27889605.136710, best_z=INF, threshold=INF
  % Best branch is x15, Z0 = 27890171.866832         , Z1 = 27890601.9410279        

DEBUG CAREFUL: Final result - returning best.var = 15
DEBUG BB: Branching variable chosen: j=15
 % @NC    9    8	x15 = 0	27890171.866832
 % @NC   10    8	x15 = 1	27890601.941028
 %       8     6 27873731.5105               27890171.8668   x13 D     5     4
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabad4e0
% @LO 0.01  27.87373151049785846567 99.9000000000
% @LN 0.01  27.89017186683203064490 99.9000000000
% Resuming node 9 at  27.89017186683203064490
DEBUG CONSTRNT: LP rows=32, pool->nlprows=32, pool->npend=0
DEBUG CONSTRNT: Checking 32 LP rows (pool tracks 32, total LP rows 32)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=31, expected 31
 % @PAP adding 32 rows, 174 nz to LP
DEBUG BB: Processing node 9, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=24, varin=47, theta=0.347089, up=1.000000
ITER 2: row=25, varin=8, theta=0.213429, up=999999999999999983222784.000000
ITER 3: row=7, varin=31, theta=0.120927, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=32)
DEBUG SOLUTION: LP solution array indices: FST[33-72], not_covered[73-92]
DEBUG SOLUTION: lp->best_solution[0] = 27890171.866832
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 32 rows, 60 cols, 234 nonzeros, 1 slack, 31 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 17 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=33, varin=45, theta=0.375109, up=1.000000
ITER 2: row=31, varin=81, theta=0.233356, up=1.000000
ITER 3: row=8, varin=73, theta=0.234310, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=36)
DEBUG SOLUTION: LP solution array indices: FST[37-76], not_covered[77-96]
DEBUG SOLUTION: lp->best_solution[0] = 27896226.487788
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 36 rows, 60 cols, 251 nonzeros, 0 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 9 LP 1 Solution, length = 27896226.487788, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.744770 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.255230 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.744770 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.234310 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.255230 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.255230 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.255230 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.255230 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.255230 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=27896226.487788, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 9 at  27.89622648778751923260
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabbedc0
% @LO 0.01  27.89017186683203064490 99.9000000000
% @LN 0.01  27.89060194102786738313 99.9000000000
% Resuming node 10 at  27.89060194102786738313
DEBUG CONSTRNT: LP rows=36, pool->nlprows=36, pool->npend=0
DEBUG CONSTRNT: Checking 36 LP rows (pool tracks 36, total LP rows 36)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=35, expected 35
 % @PAP adding 32 rows, 174 nz to LP
DEBUG BB: Processing node 10, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=24, varin=78, theta=0.820330, up=1.000000
ITER 2: row=23, varin=43, theta=0.561840, up=1.000000
ITER 3: row=25, varin=83, theta=0.500000, up=1.000000
ITER 4: row=14, varin=32, theta=0.283408, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=32)
DEBUG SOLUTION: LP solution array indices: FST[33-72], not_covered[73-92]
DEBUG SOLUTION: lp->best_solution[0] = 27890601.941028
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 32 rows, 60 cols, 234 nonzeros, 1 slack, 31 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=33, varin=14, theta=0.323884, up=999999999999999983222784.000000
ITER 2: row=32, varin=25, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=33, varin=27, theta=1.163668, up=999999999999999983222784.000000
ITER 4: row=31, varin=88, theta=0.139185, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=33)
DEBUG SOLUTION: LP solution array indices: FST[34-73], not_covered[74-93]
DEBUG SOLUTION: lp->best_solution[0] = 27895310.355510
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 33 rows, 60 cols, 236 nonzeros, 1 slack, 32 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 2 rows, 11 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=33, varin=87, theta=0.500000, up=1.000000
ITER 2: row=8, varin=71, theta=0.500000, up=1.000000
ITER 3: row=7, varin=7, theta=0.172227, up=999999999999999983222784.000000
ITER 4: row=20, varin=49, theta=0.056905, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=34)
DEBUG SOLUTION: LP solution array indices: FST[35-74], not_covered[75-94]
DEBUG SOLUTION: lp->best_solution[0] = 27905473.268958
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 34 rows, 60 cols, 245 nonzeros, 2 slack, 32 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 5 rows, 24 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=33, varin=50, theta=0.113116, up=1.000000
ITER 2: row=37, varin=46, theta=0.049483, up=1.000000
ITER 3: row=35, varin=29, theta=0.106216, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 27911008.013836
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 37 rows, 60 cols, 258 nonzeros, 1 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=37, varin=32, theta=0.087136, up=999999999999999983222784.000000
ITER 2: row=32, varin=39, theta=0.046564, up=1.000000
ITER 3: row=2, varin=56, theta=0.032749, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 27921768.094991
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 38 rows, 60 cols, 250 nonzeros, 0 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 8 rows, 43 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=81, theta=0.100727, up=1.000000
LP PHASE: Switching to primal (iter=1)
ITER 2: row=10, varin=49, theta=0.000000, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 27927475.365967
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 293 nonzeros, 0 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 10 LP 1 Solution, length = 27927475.365967, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.449637 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.449637 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.100727 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.449637 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.550363 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.550363 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.550363 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=27927475.365967, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 10 at  27.92747536596722213176
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabad4e0
% @LO 0.01  27.89060194102786738313 99.9000000000
% @LN 0.01  27.89622648778751923260 99.9000000000
% Resuming node 9 at  27.89622648778751923260
DEBUG CONSTRNT: LP rows=46, pool->nlprows=46, pool->npend=0
DEBUG CONSTRNT: Checking 46 LP rows (pool tracks 46, total LP rows 46)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 150
DEBUG CONSTRNT: Pool row 150 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=45, expected 45
 % @PAP adding 36 rows, 191 nz to LP
DEBUG BB: Processing node 9, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 9 LP 2 Solution, length = 27896226.487788, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.744770 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.255230 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.744770 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.234310 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.255230 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.255230 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.255230 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.255230 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.255230 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=27896226.487788, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27896226.487788, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 9 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 9
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.744770
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.744770)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.255230
DEBUG CAREFUL: Adding var 8 to fractional list (xi=0.255230)
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.744770
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.744770)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.234310
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.234310)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 36
DEBUG CAREFUL: New best var: 36
DEBUG CAREFUL: Testing fvar[1] = var 8
DEBUG CAREFUL: Calling compare_branch_vars for var 8
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 8
DEBUG CAREFUL: New best var: 8
DEBUG CAREFUL: Testing fvar[2] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 5
DEBUG CAREFUL: Testing fvar[3] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
  % Initial guess is x8, Z0 = 27896226.4877875        , Z1 = 28047342.3627713        

DEBUG EVAL: Testing var 36 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=25, varin=31, theta=0.819103, up=999999999999999983222784.000000
ITER 2: row=20, varin=8, theta=0.266451, up=999999999999999983222784.000000
ITER 3: row=8, varin=33, theta=0.097696, up=999999999999999983222784.000000
ITER 4: row=33, varin=32, theta=0.623164, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 36 = 1 gives z=27916005.988373
  % 	x36 = 1,	Z1 = 27916005.9883734        
DEBUG EVAL: First branch cutoff check: z=27916005.988373, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 36 = 0
ITER 1: row=25, varin=22, theta=0.279351, up=999999999999999983222784.000000
ITER 2: row=35, varin=49, theta=0.201246, up=1.000000
ITER 3: row=36, varin=35, theta=0.719776, up=999999999999999983222784.000000
ITER 4: row=34, varin=30, theta=0.035879, up=999999999999999983222784.000000
  % 	x36 = 0,	Z0 = 27902858.4257107        
DEBUG EVAL: Second branch cutoff check: z=27902858.425711, best_z=INF, threshold=INF
  %   New best:  x36, Z = 27902858.4257107        
DEBUG EVAL: Testing var 8 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=20, varin=33, theta=1.012818, up=999999999999999983222784.000000
ITER 2: row=33, varin=22, theta=4.101183, up=999999999999999983222784.000000
ITER 3: row=22, varin=82, theta=3.078098, up=1.000000
ITER 4: row=22, varin=47, theta=1.423280, up=1.000000
ITER 5: row=22, varin=32, theta=1.646095, up=999999999999999983222784.000000
ITER 6: row=23, varin=87, theta=1.000000, up=1.000000
ITER 7: row=22, varin=85, theta=0.377344, up=1.000000
ITER 8: row=25, varin=32, theta=3.099656, up=999999999999999983222784.000000
ITER 9: row=34, varin=47, theta=0.091004, up=1.000000
ITER 10: row=26, varin=25, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 8 = 1 gives z=28047342.362771
  % 	x8 = 1,	Z1 = 28047342.3627713        
DEBUG EVAL: First branch cutoff check: z=28047342.362771, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 8 = 0
ITER 1: row=20, varin=22, theta=0.460916, up=999999999999999983222784.000000
ITER 2: row=35, varin=31, theta=0.533660, up=999999999999999983222784.000000
  % 	x8 = 0,	Z0 = 27904622.5557173        
DEBUG EVAL: Second branch cutoff check: z=27904622.555717, best_z=INF, threshold=INF
  %   New best:  x8, Z = 27904622.5557173        
DEBUG EVAL: Testing var 5 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=32, theta=0.591758, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 5 = 1 gives z=27905699.040851
  % 	x5 = 1,	Z1 = 27905699.040851         
DEBUG EVAL: First branch cutoff check: z=27905699.040851, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 5 = 0
ITER 1: row=1, varin=28, theta=1.215144, up=999999999999999983222784.000000
ITER 2: row=24, varin=33, theta=0.560299, up=999999999999999983222784.000000
ITER 3: row=33, varin=82, theta=0.720718, up=1.000000
ITER 4: row=23, varin=47, theta=0.493617, up=1.000000
  % 	x5 = 0,	Z0 = 27948018.057494         
DEBUG EVAL: Second branch cutoff check: z=27948018.057494, best_z=INF, threshold=INF
  %   New best:  x5, Z = 27905699.040851         
DEBUG EVAL: Testing var 9 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=24, varin=28, theta=0.659350, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 9 = 1 gives z=27914778.774465
  % 	x9 = 1,	Z1 = 27914778.774465         
DEBUG EVAL: First branch cutoff check: z=27914778.774465, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 0
ITER 1: row=24, varin=32, theta=1.309619, up=999999999999999983222784.000000
ITER 2: row=1, varin=33, theta=0.748171, up=999999999999999983222784.000000
ITER 3: row=33, varin=82, theta=0.962381, up=1.000000
ITER 4: row=23, varin=47, theta=0.659130, up=1.000000
  % 	x9 = 0,	Z0 = 27943819.7833342        
DEBUG EVAL: Second branch cutoff check: z=27943819.783334, best_z=INF, threshold=INF
  %   New best:  x9, Z = 27914778.774465         
  % Best branch is x9, Z0 = 27943819.7833342        , Z1 = 27914778.774465         

DEBUG CAREFUL: Final result - returning best.var = 9
DEBUG BB: Branching variable chosen: j=9
 % @NC   11    9	x9 = 1	27914778.774465
 % @NC   12    9	x9 = 0	27943819.783334
 %       9     7 27896226.4878               27901554.3963   x15 D     8     5
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabaf550
% @LO 0.01  27.89622648778751923260 99.9000000000
% @LN 0.01  27.90155439630868272616 99.9000000000
% Resuming node 2 at  27.90155439630868272616
DEBUG CONSTRNT: LP rows=36, pool->nlprows=36, pool->npend=0
DEBUG CONSTRNT: Checking 36 LP rows (pool tracks 36, total LP rows 36)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=35, expected 35
 % @PAP adding 31 rows, 179 nz to LP
DEBUG BB: Processing node 2, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 2 LP 3 Solution, length = 27901554.396309, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.086985 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.500000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.500000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.086985 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.913015 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.913015 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.913015 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.913015 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.913015 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.913015 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=27901554.396309, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27901554.396309, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 2 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 2
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=1.000000
DEBUG CAREFUL: Skipping var 7: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.086985
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.086985)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.500000
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.500000
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.086985
DEBUG CAREFUL: Adding var 20 to fractional list (xi=0.086985)
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 14
DEBUG CAREFUL: New best var: 14
DEBUG CAREFUL: Testing fvar[1] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 15
DEBUG CAREFUL: Testing fvar[2] = var 20
DEBUG CAREFUL: Calling compare_branch_vars for var 20
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 20
DEBUG CAREFUL: New best var: 20
DEBUG CAREFUL: Testing fvar[3] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x20, Z0 = 27901554.3963087        , Z1 = 27975064.0075088        

DEBUG EVAL: Testing var 14 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=12, varin=76, theta=1.000000, up=1.000000
ITER 2: row=7, varin=31, theta=0.434737, up=999999999999999983222784.000000
ITER 3: row=1, varin=13, theta=0.634749, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 14 = 1 gives z=27939110.215836
  % 	x14 = 1,	Z1 = 27939110.2158357        
DEBUG EVAL: First branch cutoff check: z=27939110.215836, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 14 = 0
ITER 1: row=12, varin=44, theta=0.500000, up=1.000000
ITER 2: row=25, varin=21, theta=0.500000, up=999999999999999983222784.000000
  % 	x14 = 0,	Z0 = 27937710.4818283        
DEBUG EVAL: Second branch cutoff check: z=27937710.481828, best_z=INF, threshold=INF
  %   New best:  x14, Z = 27937710.4818283        
DEBUG EVAL: Testing var 15 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=18, varin=76, theta=1.000000, up=1.000000
ITER 2: row=7, varin=21, theta=0.177674, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 15 = 0 gives z=27931241.459394
  % 	x15 = 0,	Z0 = 27931241.4593945        
DEBUG EVAL: First branch cutoff check: z=27931241.459394, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 20 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=31, theta=3.277390, up=999999999999999983222784.000000
ITER 2: row=1, varin=8, theta=3.325165, up=999999999999999983222784.000000
ITER 3: row=8, varin=21, theta=2.390055, up=999999999999999983222784.000000
ITER 4: row=18, varin=44, theta=2.368953, up=1.000000
ITER 5: row=18, varin=20, theta=3.580773, up=999999999999999983222784.000000
ITER 6: row=20, varin=34, theta=2.582797, up=1.000000
ITER 7: row=20, varin=61, theta=2.378194, up=1.000000
ITER 8: row=20, varin=58, theta=1.131482, up=1.000000
ITER 9: row=20, varin=53, theta=0.103366, up=1.000000
ITER 10: row=12, varin=61, theta=14.393243, up=1.000000
DEBUG EVAL: Branch var 20 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x20 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=7, varin=44, theta=1.620988, up=1.000000
ITER 2: row=7, varin=30, theta=0.112626, up=999999999999999983222784.000000
ITER 3: row=25, varin=44, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=3)
ITER 4: row=12, varin=25, theta=0.000000, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=31)
DEBUG SOLUTION: LP solution array indices: FST[32-71], not_covered[72-91]
DEBUG SOLUTION: lp->best_solution[0] = 27909951.199455
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 31 rows, 60 cols, 239 nonzeros, 1 slack, 30 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=31, varin=45, theta=0.134775, up=1.000000
ITER 2: row=25, varin=50, theta=0.065472, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=32)
DEBUG SOLUTION: LP solution array indices: FST[33-72], not_covered[73-92]
DEBUG SOLUTION: lp->best_solution[0] = 27922539.822556
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 32 rows, 60 cols, 241 nonzeros, 0 slack, 32 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 6 rows, 31 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=33, varin=39, theta=0.102461, up=1.000000
ITER 2: row=2, varin=57, theta=0.057272, up=1.000000
ITER 3: row=36, varin=10, theta=0.006496, up=999999999999999983222784.000000
ITER 4: row=38, varin=13, theta=0.008581, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 27926810.483891
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.993326
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.991419
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 38 rows, 60 cols, 272 nonzeros, 4 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 4 slack rows
   % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=35, varin=33, theta=0.579696, up=999999999999999983222784.000000
ITER 2: row=36, varin=7, theta=0.071872, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
ITER 3: row=33, varin=36, theta=0.002678, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=36)
DEBUG SOLUTION: LP solution array indices: FST[37-76], not_covered[77-96]
DEBUG SOLUTION: lp->best_solution[0] = 27930909.478892
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.925029
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
   % @PL 36 rows, 60 cols, 268 nonzeros, 3 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 3 slack rows
   % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=52, theta=5.666667, up=1.000000
ITER 2: row=1, varin=49, theta=4.666667, up=1.000000
ITER 3: row=1, varin=45, theta=5.500000, up=1.000000
ITER 4: row=1, varin=41, theta=4.500000, up=1.000000
ITER 5: row=1, varin=72, theta=7.000000, up=1.000000
ITER 6: row=1, varin=44, theta=3.000000, up=1.000000
ITER 7: row=1, varin=46, theta=2.000000, up=1.000000
ITER 8: row=1, varin=51, theta=0.666667, up=1.000000
ITER 9: row=15, varin=46, theta=22.964640, up=1.000000
ITER 10: row=15, varin=72, theta=22.121250, up=1.000000
LP PHASE: Switching to primal (iter=84)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=35)
DEBUG SOLUTION: LP solution array indices: FST[36-75], not_covered[76-95]
DEBUG SOLUTION: lp->best_solution[0] = 27932678.359141
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
   % @PL 35 rows, 60 cols, 261 nonzeros, 2 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
   % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=34, varin=31, theta=0.216204, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=34)
DEBUG SOLUTION: LP solution array indices: FST[35-74], not_covered[75-94]
DEBUG SOLUTION: lp->best_solution[0] = 27935343.821905
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
   % @PL 34 rows, 60 cols, 251 nonzeros, 1 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 2 at  27.93534382190465237272
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabb5780
% @LO 0.01  27.90155439630868272616 99.9000000000
% @LN 0.01  27.91477877446500954761 99.9000000000
% Resuming node 11 at  27.91477877446500954761
DEBUG CONSTRNT: LP rows=33, pool->nlprows=33, pool->npend=0
DEBUG CONSTRNT: Checking 33 LP rows (pool tracks 33, total LP rows 33)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=32, expected 32
 % @PAP adding 36 rows, 191 nz to LP
DEBUG BB: Processing node 11, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=24, varin=28, theta=0.659350, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=36)
DEBUG SOLUTION: LP solution array indices: FST[37-76], not_covered[77-96]
DEBUG SOLUTION: lp->best_solution[0] = 27914778.774465
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 36 rows, 60 cols, 251 nonzeros, 1 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=37, varin=22, theta=0.578965, up=999999999999999983222784.000000
ITER 2: row=35, varin=50, theta=0.916220, up=1.000000
ITER 3: row=36, varin=31, theta=0.698577, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 27926873.230983
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 37 rows, 60 cols, 257 nonzeros, 2 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=29, theta=0.048105, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 27927145.422410
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 37 rows, 60 cols, 249 nonzeros, 4 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 3 rows, 9 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=34, varin=27, theta=0.496388, up=999999999999999983222784.000000
ITER 2: row=36, varin=31, theta=1.414866, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=36)
DEBUG SOLUTION: LP solution array indices: FST[37-76], not_covered[77-96]
DEBUG SOLUTION: lp->best_solution[0] = 27966350.328084
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 36 rows, 60 cols, 244 nonzeros, 3 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=34, varin=35, theta=0.044160, up=1.000000
ITER 2: row=2, varin=52, theta=0.032926, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=34)
DEBUG SOLUTION: LP solution array indices: FST[35-74], not_covered[75-94]
DEBUG SOLUTION: lp->best_solution[0] = 27971413.192499
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 34 rows, 60 cols, 232 nonzeros, 0 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 8 rows, 43 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=35, varin=45, theta=0.044482, up=1.000000
ITER 2: row=38, varin=72, theta=0.062796, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 27976912.915987
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 275 nonzeros, 0 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=9, theta=0.005510, up=999999999999999983222784.000000
ITER 2: row=10, varin=53, theta=0.038886, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 27977604.784791
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 288 nonzeros, 0 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 11 LP 1 Solution, length = 27977604.784791, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.307409 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.038886 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.307409 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.307409 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.307409 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.692591 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.692591 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.692591 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.692591 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.692591 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=27977604.784791, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 11 at  27.97760478479122170370
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabbedc0
% @LO 0.01  27.91477877446500954761 99.9000000000
% @LN 0.01  27.92747536596722213176 99.9000000000
% Resuming node 10 at  27.92747536596722213176
DEBUG CONSTRNT: LP rows=46, pool->nlprows=46, pool->npend=0
DEBUG CONSTRNT: Checking 46 LP rows (pool tracks 46, total LP rows 46)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=45, expected 45
 % @PAP adding 46 rows, 233 nz to LP
DEBUG BB: Processing node 10, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 10 LP 2 Solution, length = 27927475.365967, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.449637 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.449637 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.100727 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.449637 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.550363 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.550363 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.550363 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=27927475.365967, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27927475.365967, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 10 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 10
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.449637
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.449637)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.449637
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.449637)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=1.000000
DEBUG CAREFUL: Skipping var 15: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.100727
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.100727)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.449637
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.449637)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 36
DEBUG CAREFUL: New best var: 36
DEBUG CAREFUL: Testing fvar[1] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 5
DEBUG CAREFUL: Testing fvar[2] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[3] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 34
DEBUG CAREFUL: New best var: 34
  % Initial guess is x34, Z0 = 27927475.3659672        , Z1 = 28180316.4677169        

DEBUG EVAL: Testing var 36 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=25, varin=10, theta=1.960947, up=999999999999999983222784.000000
ITER 2: row=24, varin=37, theta=0.421847, up=999999999999999983222784.000000
ITER 3: row=1, varin=81, theta=0.461565, up=1.000000
DEBUG EVAL: Branch var 36 = 0 gives z=27999034.454850
  % 	x36 = 0,	Z0 = 27999034.4548503        
DEBUG EVAL: First branch cutoff check: z=27999034.454850, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 36 = 1
ITER 1: row=25, varin=76, theta=3.694201, up=1.000000
ITER 2: row=25, varin=31, theta=1.028633, up=999999999999999983222784.000000
ITER 3: row=24, varin=76, theta=0.702975, up=1.000000
ITER 4: row=20, varin=24, theta=0.341826, up=999999999999999983222784.000000
ITER 5: row=38, varin=10, theta=1.118739, up=999999999999999983222784.000000
ITER 6: row=24, varin=39, theta=0.433604, up=999999999999999983222784.000000
ITER 7: row=39, varin=73, theta=1.251284, up=1.000000
ITER 8: row=39, varin=2, theta=0.202880, up=999999999999999983222784.000000
ITER 9: row=46, varin=73, theta=1.000000, up=1.000000
ITER 10: row=2, varin=8, theta=0.859303, up=999999999999999983222784.000000
  % 	x36 = 1,	Z1 = 28211706.5960558        
DEBUG EVAL: Second branch cutoff check: z=28211706.596056, best_z=INF, threshold=INF
  %   New best:  x36, Z = 27999034.4548503        
DEBUG EVAL: Testing var 5 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=10, varin=10, theta=1.960947, up=999999999999999983222784.000000
ITER 2: row=24, varin=65, theta=0.850243, up=1.000000
ITER 3: row=1, varin=81, theta=5.317408, up=1.000000
ITER 4: row=1, varin=26, theta=0.557698, up=999999999999999983222784.000000
ITER 5: row=44, varin=81, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 5 = 0 gives z=28109473.285714
  % 	x5 = 0,	Z0 = 28109473.2857144        
DEBUG EVAL: First branch cutoff check: z=28109473.285714, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 5 = 1
ITER 1: row=10, varin=76, theta=3.694201, up=1.000000
ITER 2: row=10, varin=31, theta=1.028633, up=999999999999999983222784.000000
ITER 3: row=24, varin=76, theta=0.702975, up=1.000000
ITER 4: row=20, varin=10, theta=1.118739, up=999999999999999983222784.000000
ITER 5: row=24, varin=39, theta=0.433604, up=999999999999999983222784.000000
ITER 6: row=39, varin=73, theta=1.251284, up=1.000000
ITER 7: row=39, varin=2, theta=0.202880, up=999999999999999983222784.000000
ITER 8: row=46, varin=73, theta=1.000000, up=1.000000
ITER 9: row=2, varin=37, theta=0.875214, up=999999999999999983222784.000000
ITER 10: row=1, varin=46, theta=0.073427, up=999999999999999983222784.000000
  % 	x5 = 1,	Z1 = 28154044.6115897        
DEBUG EVAL: Second branch cutoff check: z=28154044.611590, best_z=INF, threshold=INF
  %   New best:  x5, Z = 28109473.2857144        
DEBUG EVAL: Testing var 9 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=20, varin=31, theta=0.737363, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 9 = 0 gives z=27975971.886866
  % 	x9 = 0,	Z0 = 27975971.8868659        
DEBUG EVAL: First branch cutoff check: z=27975971.886866, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 34 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=24, varin=10, theta=0.303953, up=999999999999999983222784.000000
ITER 2: row=1, varin=39, theta=0.292378, up=999999999999999983222784.000000
ITER 3: row=39, varin=2, theta=0.415718, up=999999999999999983222784.000000
ITER 4: row=2, varin=61, theta=0.777941, up=1.000000
ITER 5: row=32, varin=37, theta=0.948286, up=999999999999999983222784.000000
ITER 6: row=25, varin=36, theta=0.192000, up=999999999999999983222784.000000
ITER 7: row=36, varin=8, theta=0.475234, up=999999999999999983222784.000000
ITER 8: row=23, varin=34, theta=0.228694, up=999999999999999983222784.000000
ITER 9: row=34, varin=32, theta=0.138102, up=999999999999999983222784.000000
ITER 10: row=2, varin=23, theta=0.205812, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 34 = 1 gives z=28097495.042677
  % 	x34 = 1,	Z1 = 28180316.4677169        
DEBUG EVAL: First branch cutoff check: z=28180316.467717, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 34 = 0
ITER 1: row=24, varin=76, theta=0.077604, up=1.000000
  % 	x34 = 0,	Z0 = 27929065.6565444        
DEBUG EVAL: Second branch cutoff check: z=27929065.656544, best_z=INF, threshold=INF
  % Best branch is x5, Z0 = 28109473.2857144        , Z1 = 28154044.6115897        

DEBUG CAREFUL: Final result - returning best.var = 5
DEBUG BB: Branching variable chosen: j=5
 % @NC   13   10	x5 = 0	28109473.285714
 % @NC   14   10	x5 = 1	28154044.611590
 %      10     8 27927475.3660               27935343.8219   x15 U     8     5
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabaf550
% @LO 0.01  27.92747536596722213176 99.9000000000
% @LN 0.01  27.93534382190465237272 99.9000000000
% Resuming node 2 at  27.93534382190465237272
DEBUG CONSTRNT: LP rows=46, pool->nlprows=46, pool->npend=0
DEBUG CONSTRNT: Checking 46 LP rows (pool tracks 46, total LP rows 46)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 150
DEBUG CONSTRNT: Pool row 150 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=45, expected 45
 % @PAP adding 33 rows, 183 nz to LP
DEBUG BB: Processing node 2, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 2 LP 4 Solution, length = 27935343.821905, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.129722 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.500000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.500000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.043241 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.043241 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.956759 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.956759 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.870278 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.870278 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.956759 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.870278 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=27935343.821905, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27935343.821905, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 2 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 2
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=1.000000
DEBUG CAREFUL: Skipping var 7: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.129722
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.129722)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.500000
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.500000
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.043241
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.043241)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.043241
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.043241)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 14
DEBUG CAREFUL: New best var: 14
DEBUG CAREFUL: Testing fvar[1] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 15
DEBUG CAREFUL: Testing fvar[2] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 18
DEBUG CAREFUL: Testing fvar[3] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[4] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x14, Z0 = 27937710.4818283        , Z1 = 27939110.2158357        

DEBUG EVAL: Testing var 14 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=15, varin=18, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=2, varin=28, theta=0.003012, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 14 = 0 gives z=28003607.259961
  % 	x14 = 0,	Z0 = 28003607.2599609        
DEBUG EVAL: First branch cutoff check: z=28003607.259961, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 14 = 1
ITER 1: row=15, varin=23, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=29, varin=25, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=2, varin=57, theta=0.930302, up=1.000000
ITER 4: row=11, varin=36, theta=0.540602, up=1.000000
ITER 5: row=31, varin=31, theta=0.030243, up=999999999999999983222784.000000
ITER 6: row=30, varin=30, theta=0.034263, up=999999999999999983222784.000000
ITER 7: row=32, varin=9, theta=0.126860, up=999999999999999983222784.000000
ITER 8: row=9, varin=33, theta=0.060303, up=999999999999999983222784.000000
ITER 9: row=23, varin=2, theta=0.119258, up=999999999999999983222784.000000
ITER 10: row=1, varin=32, theta=0.114626, up=999999999999999983222784.000000
  % 	x14 = 1,	Z1 = 28244887.9590398        
DEBUG EVAL: Second branch cutoff check: z=28244887.959040, best_z=INF, threshold=INF
  %   New best:  x14, Z = 28003607.2599609        
DEBUG EVAL: Testing var 15 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=18, varin=23, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=29, varin=18, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=2, varin=84, theta=0.004968, up=1.000000
DEBUG EVAL: Branch var 15 = 0 gives z=28003717.092353
  % 	x15 = 0,	Z0 = 28003717.0923535        
DEBUG EVAL: First branch cutoff check: z=28003717.092353, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 15 = 1
ITER 1: row=18, varin=28, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=2, varin=57, theta=0.830447, up=1.000000
ITER 3: row=11, varin=36, theta=0.482576, up=1.000000
  % 	x15 = 1,	Z1 = 28042297.0003228        
DEBUG EVAL: Second branch cutoff check: z=28042297.000323, best_z=INF, threshold=INF
  %   New best:  x15, Z = 28003717.0923535        
DEBUG EVAL: Testing var 18 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=23, varin=32, theta=1.833006, up=999999999999999983222784.000000
ITER 2: row=22, varin=2, theta=0.771206, up=999999999999999983222784.000000
ITER 3: row=1, varin=84, theta=9.964025, up=1.000000
ITER 4: row=1, varin=22, theta=1.219184, up=999999999999999983222784.000000
ITER 5: row=2, varin=84, theta=3.349484, up=1.000000
ITER 6: row=2, varin=9, theta=2.892864, up=999999999999999983222784.000000
ITER 7: row=7, varin=18, theta=2.313134, up=999999999999999983222784.000000
ITER 8: row=18, varin=28, theta=1.479493, up=999999999999999983222784.000000
ITER 9: row=26, varin=7, theta=2.136319, up=999999999999999983222784.000000
ITER 10: row=8, varin=26, theta=1.868890, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 18 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x18 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=23, varin=57, theta=0.268371, up=1.000000
ITER 2: row=11, varin=5, theta=0.305010, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=33)
DEBUG SOLUTION: LP solution array indices: FST[34-73], not_covered[74-93]
DEBUG SOLUTION: lp->best_solution[0] = 27937846.899817
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.847495
DEBUG SOLUTION: lp->best_solution[4] = 0.847495
DEBUG SOLUTION: lp->best_solution[5] = 2.694990
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
   % @PL 33 rows, 60 cols, 243 nonzeros, 3 slack, 30 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 3 slack rows
   % @PAP adding 4 rows, 15 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=31, varin=37, theta=0.116767, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=34)
DEBUG SOLUTION: LP solution array indices: FST[35-74], not_covered[75-94]
DEBUG SOLUTION: lp->best_solution[0] = 27940323.862960
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 34 rows, 60 cols, 250 nonzeros, 0 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 4 rows, 18 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=35, varin=30, theta=0.112759, up=999999999999999983222784.000000
ITER 2: row=36, varin=28, theta=0.013105, up=999999999999999983222784.000000
ITER 3: row=37, varin=35, theta=0.013053, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 27942861.290482
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 38 rows, 60 cols, 268 nonzeros, 3 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 3 slack rows
   % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=41, theta=0.097283, up=1.000000
LP PHASE: Switching to primal (iter=1)
ITER 2: row=37, varin=88, theta=0.180245, up=1.000000
ITER 3: row=1, varin=44, theta=0.000000, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 27944271.803417
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 37 rows, 60 cols, 266 nonzeros, 2 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 2 at  27.94427180341661198781
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabbe180
% @LO 0.01  27.93534382190465237272 99.9000000000
% @LN 0.01  27.94381978333416682858 99.9000000000
% Resuming node 12 at  27.94381978333416682858
DEBUG CONSTRNT: LP rows=35, pool->nlprows=35, pool->npend=0
DEBUG CONSTRNT: Checking 35 LP rows (pool tracks 35, total LP rows 35)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=34, expected 34
 % @PAP adding 36 rows, 191 nz to LP
DEBUG BB: Processing node 12, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=24, varin=32, theta=1.309619, up=999999999999999983222784.000000
ITER 2: row=1, varin=33, theta=0.748171, up=999999999999999983222784.000000
ITER 3: row=33, varin=82, theta=0.962381, up=1.000000
ITER 4: row=23, varin=47, theta=0.659130, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=36)
DEBUG SOLUTION: LP solution array indices: FST[37-76], not_covered[77-96]
DEBUG SOLUTION: lp->best_solution[0] = 27943819.783334
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 36 rows, 60 cols, 251 nonzeros, 1 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 5 rows, 28 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=92, theta=0.482988, up=1.000000
ITER 2: row=37, varin=25, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=41, varin=31, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=14, varin=56, theta=0.184487, up=1.000000
ITER 5: row=33, varin=22, theta=0.236127, up=999999999999999983222784.000000
ITER 6: row=35, varin=30, theta=0.327914, up=999999999999999983222784.000000
ITER 7: row=38, varin=37, theta=0.026002, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 27965881.134188
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 41 rows, 60 cols, 279 nonzeros, 8 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 8 slack rows
  % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=35, varin=72, theta=1.000000, up=1.000000
ITER 2: row=34, varin=24, theta=6.164477, up=999999999999999983222784.000000
ITER 3: row=1, varin=41, theta=0.490909, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=35)
DEBUG SOLUTION: LP solution array indices: FST[36-75], not_covered[76-95]
DEBUG SOLUTION: lp->best_solution[0] = 28004664.133269
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 35 rows, 60 cols, 250 nonzeros, 2 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=34, varin=29, theta=4.445595, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=34)
DEBUG SOLUTION: LP solution array indices: FST[35-74], not_covered[75-94]
DEBUG SOLUTION: lp->best_solution[0] = 28007089.085128
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 34 rows, 60 cols, 244 nonzeros, 1 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 12 LP 1 Solution, length = 28007089.085128, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.595855 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.404145 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.616580 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.404145 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.404145 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.404145 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.404145 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.595855 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.595855 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.404145 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.383420 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.383420 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.595855 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.383420 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28007089.085128, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 12 at  28.00708908512782358002
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabaf550
% @LO 0.01  27.94381978333416682858 99.9000000000
% @LN 0.01  27.94427180341661198781 99.9000000000
% Resuming node 2 at  27.94427180341661198781
DEBUG CONSTRNT: LP rows=33, pool->nlprows=33, pool->npend=0
DEBUG CONSTRNT: Checking 33 LP rows (pool tracks 33, total LP rows 33)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 62
DEBUG CONSTRNT: Pool row 62 has lprow=32, expected 32
 % @PAP adding 35 rows, 195 nz to LP
DEBUG BB: Processing node 2, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 2 LP 5 Solution, length = 27944271.803417, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.180245 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.180245 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.500000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.500000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.819755 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.819755 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.819755 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.819755 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=27944271.803417, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27944271.803417, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 2 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 2
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.180245
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.180245)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.180245
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.180245)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=1.000000
DEBUG CAREFUL: Skipping var 7: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.500000
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.500000
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 14
DEBUG CAREFUL: New best var: 14
DEBUG CAREFUL: Testing fvar[1] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 15
DEBUG CAREFUL: New best var: 15
DEBUG CAREFUL: Testing fvar[2] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[3] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
  % Initial guess is x15, Z0 = 28003717.0923535        , Z1 = 28042297.0003228        

DEBUG EVAL: Testing var 14 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=15, varin=15, theta=1.500000, up=999999999999999983222784.000000
ITER 2: row=4, varin=35, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 14 = 0 gives z=28003849.719104
  % 	x14 = 0,	Z0 = 28003849.7191043        
DEBUG EVAL: First branch cutoff check: z=28003849.719104, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 14 = 1
ITER 1: row=15, varin=39, theta=1.600000, up=1.000000
ITER 2: row=15, varin=20, theta=0.375000, up=999999999999999983222784.000000
ITER 3: row=4, varin=39, theta=1.000000, up=1.000000
ITER 4: row=26, varin=22, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=1, varin=34, theta=0.144076, up=999999999999999983222784.000000
ITER 6: row=27, varin=27, theta=0.118566, up=999999999999999983222784.000000
ITER 7: row=31, varin=16, theta=0.273170, up=999999999999999983222784.000000
ITER 8: row=16, varin=4, theta=0.398849, up=999999999999999983222784.000000
ITER 9: row=2, varin=60, theta=0.839384, up=1.000000
ITER 10: row=9, varin=65, theta=1.079767, up=1.000000
  % 	x14 = 1,	Z1 = 28251202.9470403        
DEBUG EVAL: Second branch cutoff check: z=28251202.947040, best_z=INF, threshold=INF
  %   New best:  x14, Z = 28003849.7191043        
DEBUG EVAL: Testing var 15 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=19, varin=20, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=26, varin=15, theta=1.500000, up=999999999999999983222784.000000
ITER 3: row=4, varin=35, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 15 = 0 gives z=28003849.719104
  % 	x15 = 0,	Z0 = 28003849.7191043        
DEBUG EVAL: First branch cutoff check: z=28003849.719104, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 15 = 1
ITER 1: row=19, varin=39, theta=1.600000, up=1.000000
ITER 2: row=19, varin=65, theta=1.125000, up=1.000000
ITER 3: row=19, varin=60, theta=0.125000, up=1.000000
ITER 4: row=4, varin=25, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=19, varin=65, theta=1.875000, up=1.000000
ITER 6: row=19, varin=39, theta=0.466667, up=1.000000
ITER 7: row=5, varin=34, theta=0.105323, up=999999999999999983222784.000000
ITER 8: row=27, varin=27, theta=0.064670, up=999999999999999983222784.000000
ITER 9: row=31, varin=29, theta=0.284280, up=999999999999999983222784.000000
ITER 10: row=23, varin=16, theta=0.148996, up=999999999999999983222784.000000
  % 	x15 = 1,	Z1 = 28130981.865687         
DEBUG EVAL: Second branch cutoff check: z=28130981.865687, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=39, theta=0.255514, up=1.000000
ITER 2: row=4, varin=12, theta=118940.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 0 gives z=28110168.397537
  % 	x1 = 0,	Z0 = 28110168.3975366        
DEBUG EVAL: First branch cutoff check: z=28110168.397537, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 1
ITER 1: row=2, varin=34, theta=0.454754, up=999999999999999983222784.000000
ITER 2: row=27, varin=15, theta=1.872955, up=999999999999999983222784.000000
ITER 3: row=4, varin=29, theta=0.813532, up=999999999999999983222784.000000
  % 	x1 = 1,	Z1 = 28027013.7179528        
DEBUG EVAL: Second branch cutoff check: z=28027013.717953, best_z=INF, threshold=INF
  %   New best:  x1, Z = 28027013.7179528        
DEBUG EVAL: Testing var 0 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=34, theta=0.454754, up=999999999999999983222784.000000
ITER 2: row=27, varin=15, theta=1.872955, up=999999999999999983222784.000000
ITER 3: row=4, varin=27, theta=0.418943, up=999999999999999983222784.000000
ITER 4: row=31, varin=32, theta=0.712608, up=999999999999999983222784.000000
ITER 5: row=32, varin=8, theta=1.648142, up=999999999999999983222784.000000
ITER 6: row=8, varin=28, theta=0.347394, up=999999999999999983222784.000000
ITER 7: row=20, varin=4, theta=2.073449, up=999999999999999983222784.000000
ITER 8: row=30, varin=16, theta=1.420096, up=999999999999999983222784.000000
ITER 9: row=7, varin=19, theta=0.828965, up=999999999999999983222784.000000
ITER 10: row=25, varin=5, theta=1.070376, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 0 = 1 gives z=28274286.793645
  % 	x0 = 1,	Z1 = 28274286.7936449        
DEBUG EVAL: First branch cutoff check: z=28274286.793645, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 0 = 0
ITER 1: row=1, varin=39, theta=0.255514, up=1.000000
  % 	x0 = 0,	Z0 = 27944278.6597381        
DEBUG EVAL: Second branch cutoff check: z=27944278.659738, best_z=INF, threshold=INF
  % Best branch is x1, Z0 = 28110168.3975366        , Z1 = 28027013.7179528        

DEBUG CAREFUL: Final result - returning best.var = 1
DEBUG BB: Branching variable chosen: j=1
 % @NC   15    2	x1 = 1	28027013.717953
 % @NC   16    2	x1 = 0	28110168.397537
 %       2     9 27944271.8034               27977604.7848    x7 U     0     1
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabb5780
% @LO 0.01  27.94427180341661198781 99.9000000000
% @LN 0.01  27.97760478479122170370 99.9000000000
% Resuming node 11 at  27.97760478479122170370
DEBUG CONSTRNT: LP rows=35, pool->nlprows=35, pool->npend=0
DEBUG CONSTRNT: Checking 35 LP rows (pool tracks 35, total LP rows 35)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=34, expected 34
 % @PAP adding 46 rows, 228 nz to LP
DEBUG BB: Processing node 11, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 11 LP 2 Solution, length = 27977604.784791, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.307409 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.038886 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.307409 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.307409 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.307409 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.692591 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.692591 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.692591 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.692591 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.692591 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=27977604.784791, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27977604.784791, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 11 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 11
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.307409
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.307409)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.038886
DEBUG CAREFUL: Adding var 6 to fractional list (xi=0.038886)
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=1.000000
DEBUG CAREFUL: Skipping var 9: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.307409
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.307409)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.307409
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.307409)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.307409
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.307409)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 12
DEBUG CAREFUL: New best var: 12
DEBUG CAREFUL: Testing fvar[1] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 14
DEBUG CAREFUL: Testing fvar[2] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 5
DEBUG CAREFUL: Testing fvar[3] = var 6
DEBUG CAREFUL: Calling compare_branch_vars for var 6
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 6
DEBUG CAREFUL: New best var: 6
DEBUG CAREFUL: Testing fvar[4] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 36
  % Initial guess is x6, Z0 = 27977604.7847912        , Z1 = 28422427.6054025        

DEBUG EVAL: Testing var 12 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=23, varin=43, theta=3.867059, up=999999999999999983222784.000000
ITER 2: row=43, varin=33, theta=0.290662, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 12 = 0 gives z=28031459.718398
  % 	x12 = 0,	Z0 = 28031459.7183978        
DEBUG EVAL: First branch cutoff check: z=28031459.718398, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 1
ITER 1: row=23, varin=29, theta=0.814014, up=999999999999999983222784.000000
  % 	x12 = 1,	Z1 = 28140203.1863809        
DEBUG EVAL: Second branch cutoff check: z=28140203.186381, best_z=INF, threshold=INF
  %   New best:  x12, Z = 28031459.7183978        
DEBUG EVAL: Testing var 14 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=28, varin=43, theta=3.867059, up=999999999999999983222784.000000
ITER 2: row=43, varin=34, theta=0.405941, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 14 = 0 gives z=28052317.344816
  % 	x14 = 0,	Z0 = 28052317.3448162        
DEBUG EVAL: First branch cutoff check: z=28052317.344816, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 14 = 1
ITER 1: row=28, varin=70, theta=26.220626, up=1.000000
ITER 2: row=28, varin=26, theta=1.210148, up=999999999999999983222784.000000
ITER 3: row=16, varin=70, theta=1.000000, up=1.000000
ITER 4: row=26, varin=73, theta=1.327686, up=1.000000
ITER 5: row=26, varin=35, theta=0.148844, up=999999999999999983222784.000000
ITER 6: row=42, varin=73, theta=0.585297, up=1.000000
ITER 7: row=35, varin=68, theta=0.954566, up=1.000000
ITER 8: row=20, varin=10, theta=0.416780, up=999999999999999983222784.000000
ITER 9: row=1, varin=31, theta=0.542025, up=999999999999999983222784.000000
ITER 10: row=31, varin=8, theta=0.537107, up=999999999999999983222784.000000
  % 	x14 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: Second branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=28, varin=43, theta=3.867059, up=999999999999999983222784.000000
ITER 2: row=43, varin=34, theta=0.405941, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28052317.344816
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 46 rows, 60 cols, 288 nonzeros, 1 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=77, theta=0.537623, up=1.000000
ITER 2: row=42, varin=66, theta=0.275899, up=1.000000
ITER 3: row=39, varin=71, theta=1.110640, up=1.000000
ITER 4: row=39, varin=15, theta=0.004289, up=999999999999999983222784.000000
ITER 5: row=16, varin=71, theta=1.000000, up=1.000000
ITER 6: row=41, varin=58, theta=0.039215, up=1.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28090658.730696
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.965142
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 47 rows, 60 cols, 294 nonzeros, 5 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 5 slack rows
   % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=49, theta=0.322004, up=1.000000
ITER 2: row=33, varin=89, theta=0.056544, up=1.000000
ITER 3: row=45, varin=72, theta=0.168020, up=1.000000
LP PHASE: Switching to primal (iter=3)
ITER 4: row=44, varin=45, theta=0.069816, up=999999999999999983222784.000000
ITER 5: row=6, varin=43, theta=0.000000, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28103779.667227
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 3.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 45 rows, 60 cols, 290 nonzeros, 1 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 3 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=53, theta=8.500000, up=1.000000
ITER 2: row=1, varin=84, theta=15.000000, up=1.000000
ITER 3: row=1, varin=56, theta=7.000000, up=1.000000
ITER 4: row=1, varin=58, theta=6.000000, up=1.000000
ITER 5: row=1, varin=49, theta=5.000000, up=1.000000
ITER 6: row=1, varin=88, theta=8.000000, up=1.000000
ITER 7: row=1, varin=89, theta=7.000000, up=1.000000
ITER 8: row=1, varin=90, theta=6.000000, up=1.000000
ITER 9: row=1, varin=91, theta=5.000000, up=1.000000
ITER 10: row=1, varin=92, theta=4.000000, up=1.000000
LP PHASE: Switching to primal (iter=59)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28105601.371496
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.944852
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 3.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 47 rows, 60 cols, 295 nonzeros, 2 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
   % @PAP adding 7 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=98, theta=0.099100, up=1.000000
ITER 2: row=14, varin=32, theta=1.678557, up=999999999999999983222784.000000
ITER 3: row=48, varin=74, theta=0.496466, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28142177.096340
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 3.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 52 rows, 60 cols, 305 nonzeros, 0 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 5 rows, 20 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=53, varin=33, theta=0.890634, up=999999999999999983222784.000000
ITER 2: row=51, varin=114, theta=0.313234, up=1.000000
ITER 3: row=39, varin=48, theta=0.171497, up=999999999999999983222784.000000
ITER 4: row=46, varin=35, theta=0.679211, up=999999999999999983222784.000000
ITER 5: row=49, varin=111, theta=0.695674, up=1.000000
ITER 6: row=53, varin=46, theta=0.179796, up=999999999999999983222784.000000
ITER 7: row=39, varin=83, theta=0.516795, up=1.000000
ITER 8: row=56, varin=80, theta=0.175787, up=1.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 28188257.716514
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.736319
DEBUG SOLUTION: lp->best_solution[10] = 0.736319
DEBUG SOLUTION: lp->best_solution[11] = 2.472639
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 57 rows, 60 cols, 325 nonzeros, 5 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 5 slack rows
   % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=54, varin=30, theta=0.321181, up=999999999999999983222784.000000
ITER 2: row=53, varin=43, theta=0.055442, up=999999999999999983222784.000000
ITER 3: row=46, varin=114, theta=0.106127, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 28198700.273548
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1000000.000000
   % @PL 55 rows, 60 cols, 309 nonzeros, 2 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
   % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=54, varin=31, theta=0.174211, up=999999999999999983222784.000000
ITER 2: row=31, varin=30, theta=0.313392, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 28209647.697183
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1000000.000000
   % @PL 54 rows, 60 cols, 304 nonzeros, 3 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 3 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 11 at  28.20964769718324305359
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabbe180
% @LO 0.01  27.97760478479122170370 99.9000000000
% @LN 0.01  28.00708908512782358002 99.9000000000
% Resuming node 12 at  28.00708908512782358002
DEBUG CONSTRNT: LP rows=51, pool->nlprows=51, pool->npend=0
DEBUG CONSTRNT: Checking 51 LP rows (pool tracks 51, total LP rows 51)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=50, expected 50
 % @PAP adding 33 rows, 170 nz to LP
DEBUG BB: Processing node 12, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 12 LP 2 Solution, length = 28007089.085128, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.595855 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.404145 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.616580 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.404145 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.404145 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.404145 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.404145 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.595855 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.595855 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.404145 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.383420 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.383420 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.595855 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.383420 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28007089.085128, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28007089.085128, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 12 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 12
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.595855
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.595855)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.404145
DEBUG CAREFUL: Adding var 8 to fractional list (xi=0.404145)
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.616580
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.616580)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.404145
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.404145)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.404145
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.404145)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 5
DEBUG CAREFUL: New best var: 5
DEBUG CAREFUL: Testing fvar[1] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[2] = var 8
DEBUG CAREFUL: Calling compare_branch_vars for var 8
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 8
DEBUG CAREFUL: New best var: 8
DEBUG CAREFUL: Testing fvar[3] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 14
DEBUG CAREFUL: Testing fvar[4] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 36
  % Initial guess is x8, Z0 = 28007089.0851278        , Z1 = 28047342.3627713        

DEBUG EVAL: Testing var 5 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=33, theta=2.096087, up=999999999999999983222784.000000
ITER 2: row=23, varin=46, theta=0.509549, up=1.000000
DEBUG EVAL: Branch var 5 = 1 gives z=28028732.711516
  % 	x5 = 1,	Z1 = 28028732.7115165        
DEBUG EVAL: First branch cutoff check: z=28028732.711516, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 5 = 0
ITER 1: row=1, varin=35, theta=10.563014, up=1.000000
ITER 2: row=1, varin=31, theta=1.450794, up=999999999999999983222784.000000
ITER 3: row=23, varin=32, theta=0.557397, up=999999999999999983222784.000000
  % 	x5 = 0,	Z0 = 28052462.6017105        
DEBUG EVAL: Second branch cutoff check: z=28052462.601711, best_z=INF, threshold=INF
  %   New best:  x5, Z = 28028732.7115165        
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=14, varin=31, theta=0.786807, up=999999999999999983222784.000000
ITER 2: row=23, varin=30, theta=0.079595, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28027621.545608
  % 	x10 = 1,	Z1 = 28027621.5456085        
DEBUG EVAL: First branch cutoff check: z=28027621.545608, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 8 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=20, varin=35, theta=10.563014, up=1.000000
ITER 2: row=20, varin=31, theta=1.450794, up=999999999999999983222784.000000
ITER 3: row=32, varin=28, theta=0.304291, up=999999999999999983222784.000000
ITER 4: row=23, varin=32, theta=0.557397, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 8 = 1 gives z=28052462.601711
  % 	x8 = 1,	Z1 = 28052462.6017105        
DEBUG EVAL: First branch cutoff check: z=28052462.601711, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 8 = 0
ITER 1: row=20, varin=33, theta=2.096087, up=999999999999999983222784.000000
ITER 2: row=28, varin=46, theta=0.509549, up=1.000000
  % 	x8 = 0,	Z0 = 28028732.7115165        
DEBUG EVAL: Second branch cutoff check: z=28028732.711516, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 14 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=23, varin=31, theta=0.643367, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 14 = 0 gives z=28021577.199169
  % 	x14 = 0,	Z0 = 28021577.1991688        
DEBUG EVAL: First branch cutoff check: z=28021577.199169, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 36 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=27, varin=33, theta=2.096087, up=999999999999999983222784.000000
ITER 2: row=28, varin=32, theta=0.417267, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 36 = 0 gives z=28024963.554762
  % 	x36 = 0,	Z0 = 28024963.5547619        
DEBUG EVAL: First branch cutoff check: z=28024963.554762, best_z=INF, threshold=INF
  % Best branch is x5, Z0 = 28052462.6017105        , Z1 = 28028732.7115165        

DEBUG CAREFUL: Final result - returning best.var = 5
DEBUG BB: Branching variable chosen: j=5
 % @NC   17   12	x5 = 1	28028732.711516
 % @NC   18   12	x5 = 0	28052462.601711
 %      12    10 28007089.0851               28015007.5163    x9 D     9     6
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabbed00
% @LO 0.01  28.00708908512782358002 99.9000000000
% @LN 0.01  28.01500751632258356949 99.9000000000
% Resuming node 6 at  28.01500751632258356949
DEBUG CONSTRNT: LP rows=33, pool->nlprows=33, pool->npend=0
DEBUG CONSTRNT: Checking 33 LP rows (pool tracks 33, total LP rows 33)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 62
DEBUG CONSTRNT: Pool row 62 has lprow=32, expected 32
 % @PAP adding 56 rows, 236 nz to LP
DEBUG BB: Processing node 6, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 6 LP 2 Solution, length = 28015007.516323, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.077629 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.077629 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.111853 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 1.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.077629 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.077629 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.077629 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.111853 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.077629 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.111853 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.077629 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.922371 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.922371 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.922371 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.922371 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.922371 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.888147 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.888147 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.922371 (terminal 19)
 % 10 fractional variables
DEBUG CG: LP optimal, z=28015007.516323, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28015007.516323, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 6 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 6
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.077629
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.077629)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.077629
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.077629)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.111853
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.111853)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=1.000000
DEBUG CAREFUL: Skipping var 16: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.077629
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.077629)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.077629
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.077629)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.077629
DEBUG CAREFUL: Adding var 20 to fractional list (xi=0.077629)
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.111853
DEBUG CAREFUL: Adding var 21 to fractional list (xi=0.111853)
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.077629
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.077629)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.111853
DEBUG CAREFUL: Adding var 25 to fractional list (xi=0.111853)
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.077629
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.077629)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 10 fractional variables

  %  Carefully choosing branching variable, nfrac = 10
DEBUG CAREFUL: Testing fvar[0] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 26
DEBUG CAREFUL: New best var: 26
DEBUG CAREFUL: Testing fvar[1] = var 20
DEBUG CAREFUL: Calling compare_branch_vars for var 20
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 20
DEBUG CAREFUL: Testing fvar[2] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[3] = var 21
DEBUG CAREFUL: Calling compare_branch_vars for var 21
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 21
DEBUG CAREFUL: New best var: 21
DEBUG CAREFUL: Testing fvar[4] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
DEBUG CAREFUL: Testing fvar[5] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[6] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[7] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 22
DEBUG CAREFUL: Testing fvar[8] = var 25
DEBUG CAREFUL: Calling compare_branch_vars for var 25
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 25
DEBUG CAREFUL: Testing fvar[9] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
  % Initial guess is x18, Z0 = 28015007.5163226        , Z1 = 28384724.2937703        

DEBUG EVAL: Testing var 26 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=48, varin=46, theta=2.539647, up=999999999999999983222784.000000
ITER 2: row=53, varin=39, theta=7.132755, up=999999999999999983222784.000000
ITER 3: row=2, varin=14, theta=0.956387, up=999999999999999983222784.000000
ITER 4: row=51, varin=52, theta=2.771549, up=999999999999999983222784.000000
ITER 5: row=35, varin=37, theta=3.106219, up=999999999999999983222784.000000
ITER 6: row=6, varin=21, theta=1.019958, up=999999999999999983222784.000000
ITER 7: row=19, varin=85, theta=0.106947, up=1.000000
ITER 8: row=40, varin=69, theta=0.500258, up=1.000000
ITER 9: row=19, varin=9, theta=0.000011, up=999999999999999983222784.000000
ITER 10: row=33, varin=85, theta=-0.000516, up=1.000000
DEBUG EVAL: Branch var 26 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x26 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=13, theta=2.606444, up=999999999999999983222784.000000
ITER 2: row=1, varin=26, theta=0.055143, up=999999999999999983222784.000000
ITER 3: row=44, varin=59, theta=0.173329, up=1.000000
ITER 4: row=31, varin=58, theta=0.232343, up=1.000000
ITER 5: row=48, varin=48, theta=0.018212, up=999999999999999983222784.000000
ITER 6: row=42, varin=13, theta=1.325377, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 28026699.670517
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.337311
DEBUG SOLUTION: lp->best_solution[12] = 0.337311
DEBUG SOLUTION: lp->best_solution[13] = 1.674623
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 56 rows, 60 cols, 296 nonzeros, 6 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 6 slack rows
   % @PAP adding 2 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=74, theta=0.139804, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28034874.852358
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
   % @PL 52 rows, 60 cols, 293 nonzeros, 1 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 6 at  28.03487485235797649352
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabbedc0
% @LO 0.01  28.01500751632258356949 99.9000000000
% @LN 0.01  28.02701371795280493870 99.9000000000
% Resuming node 15 at  28.02701371795280493870
DEBUG CONSTRNT: LP rows=51, pool->nlprows=51, pool->npend=0
DEBUG CONSTRNT: Checking 51 LP rows (pool tracks 51, total LP rows 51)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=50, expected 50
 % @PAP adding 35 rows, 195 nz to LP
DEBUG BB: Processing node 15, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=2, varin=34, theta=0.454754, up=999999999999999983222784.000000
ITER 2: row=27, varin=15, theta=1.872955, up=999999999999999983222784.000000
ITER 3: row=4, varin=29, theta=0.813532, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=35)
DEBUG SOLUTION: LP solution array indices: FST[36-75], not_covered[76-95]
DEBUG SOLUTION: lp->best_solution[0] = 28027013.717953
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 35 rows, 60 cols, 255 nonzeros, 3 slack, 32 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 5 rows, 19 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=27, theta=0.456039, up=999999999999999983222784.000000
ITER 2: row=40, varin=47, theta=0.414181, up=1.000000
ITER 3: row=7, varin=40, theta=0.711376, up=999999999999999983222784.000000
ITER 4: row=1, varin=7, theta=0.223095, up=999999999999999983222784.000000
ITER 5: row=16, varin=35, theta=0.460535, up=999999999999999983222784.000000
ITER 6: row=27, varin=65, theta=1.793396, up=1.000000
ITER 7: row=27, varin=70, theta=1.133871, up=1.000000
ITER 8: row=27, varin=21, theta=0.070842, up=999999999999999983222784.000000
ITER 9: row=9, varin=65, theta=1.000000, up=1.000000
ITER 10: row=38, varin=67, theta=1.160922, up=1.000000
LP PHASE: Switching to primal (iter=14)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28398280.698982
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 274 nonzeros, 6 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 5 rows, 19 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=69, theta=1.000000, up=1.000000
ITER 2: row=35, varin=61, theta=1.145348, up=1.000000
ITER 3: row=35, varin=62, theta=0.150286, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 28487245.176026
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 39 rows, 60 cols, 260 nonzeros, 0 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 9 rows, 39 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=70, theta=0.794318, up=1.000000
ITER 2: row=40, varin=74, theta=1.170587, up=1.000000
ITER 3: row=40, varin=76, theta=0.203178, up=1.000000
ITER 4: row=47, varin=23, theta=0.350472, up=999999999999999983222784.000000
ITER 5: row=29, varin=77, theta=0.078447, up=1.000000
ITER 6: row=23, varin=20, theta=0.031029, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28684901.711150
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 299 nonzeros, 6 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 4 rows, 15 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=72, theta=0.905437, up=1.000000
ITER 2: row=43, varin=42, theta=2.952093, up=999999999999999983222784.000000
ITER 3: row=46, varin=103, theta=1.140853, up=1.000000
ITER 4: row=46, varin=53, theta=0.098606, up=1.000000
ITER 5: row=12, varin=17, theta=0.295111, up=999999999999999983222784.000000
ITER 6: row=17, varin=100, theta=0.374174, up=1.000000
ITER 7: row=46, varin=24, theta=0.554300, up=999999999999999983222784.000000
ITER 8: row=24, varin=19, theta=1.961655, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 297 nonzeros, 4 slack, 42 tight.
  % Node 15 LP 1 Solution, length = 999999999999999983222784.000000, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 1.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.322990 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.291961 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.322990 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 1.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.093088 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.708039 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.677010 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.677010 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 15 is INFEASIBLE
 %      15     9    infeasible               28028732.7115    x1 U     2     2
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabaf550
% @LO 0.01  28.02701371795280493870 99.9000000000
% @LN 0.01  28.02873271151648992827 99.9000000000
% Resuming node 17 at  28.02873271151648992827
DEBUG CONSTRNT: LP rows=46, pool->nlprows=46, pool->npend=0
DEBUG CONSTRNT: Checking 46 LP rows (pool tracks 46, total LP rows 46)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 143
DEBUG CONSTRNT: Pool row 143 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=45, expected 45
 % @PAP adding 33 rows, 170 nz to LP
DEBUG BB: Processing node 17, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=33, theta=2.096087, up=999999999999999983222784.000000
ITER 2: row=23, varin=46, theta=0.509549, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=33)
DEBUG SOLUTION: LP solution array indices: FST[34-73], not_covered[74-93]
DEBUG SOLUTION: lp->best_solution[0] = 28028732.711517
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 33 rows, 60 cols, 230 nonzeros, 1 slack, 32 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 3 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=33, varin=26, theta=0.896510, up=999999999999999983222784.000000
ITER 2: row=35, varin=53, theta=0.247534, up=1.000000
ITER 3: row=1, varin=50, theta=0.303113, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=35)
DEBUG SOLUTION: LP solution array indices: FST[36-75], not_covered[76-95]
DEBUG SOLUTION: lp->best_solution[0] = 28088834.501244
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 35 rows, 60 cols, 240 nonzeros, 2 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 8 rows, 43 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=34, varin=42, theta=0.366351, up=1.000000
ITER 2: row=2, varin=60, theta=0.198780, up=1.000000
ITER 3: row=37, varin=9, theta=0.022488, up=999999999999999983222784.000000
ITER 4: row=39, varin=15, theta=0.029605, up=999999999999999983222784.000000
ITER 5: row=41, varin=52, theta=0.025734, up=1.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28109992.563853
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.977125
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 41 rows, 60 cols, 276 nonzeros, 5 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 5 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=37, varin=76, theta=0.681954, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28122550.423326
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 3.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 41 rows, 60 cols, 280 nonzeros, 0 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=86, theta=0.106648, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28123818.911657
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.893352
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 3.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 292 nonzeros, 6 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=37, varin=32, theta=0.372630, up=999999999999999983222784.000000
ITER 2: row=39, varin=34, theta=0.278258, up=999999999999999983222784.000000
ITER 3: row=38, varin=37, theta=0.068481, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 28126979.237648
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 3.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 39 rows, 60 cols, 277 nonzeros, 3 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 4 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=37, varin=36, theta=0.054628, up=999999999999999983222784.000000
ITER 2: row=39, varin=32, theta=0.234059, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28130912.852233
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 3.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 267 nonzeros, 2 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 17 LP 1 Solution, length = 28130912.852233, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.046812 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.453188 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.546812 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.046812 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.046812 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.453188 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.953188 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.953188 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.453188 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.453188 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.953188 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.953188 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.953188 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.546812 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.453188 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.953188 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28130912.852233, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 17 at  28.13091285223294590878
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabbed00
% @LO 0.01  28.02873271151648992827 99.9000000000
% @LN 0.01  28.03487485235797649352 99.9000000000
% Resuming node 6 at  28.03487485235797649352
DEBUG CONSTRNT: LP rows=38, pool->nlprows=38, pool->npend=0
DEBUG CONSTRNT: Checking 38 LP rows (pool tracks 38, total LP rows 38)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=37, expected 37
 % @PAP adding 51 rows, 223 nz to LP
DEBUG BB: Processing node 6, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 6 LP 3 Solution, length = 28034874.852358, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.072039 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.072039 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.072039 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.139804 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 1.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.072039 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.072039 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.072039 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.139804 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.072039 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.139804 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.927961 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.927961 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.927961 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.927961 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.927961 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.927961 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.860196 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.860196 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.927961 (terminal 19)
 % 10 fractional variables
DEBUG CG: LP optimal, z=28034874.852358, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28034874.852358, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 6 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 6
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.072039
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.072039)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.072039
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.072039)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.072039
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.072039)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.139804
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.139804)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=1.000000
DEBUG CAREFUL: Skipping var 16: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.072039
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.072039)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.072039
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.072039)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.072039
DEBUG CAREFUL: Adding var 20 to fractional list (xi=0.072039)
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.139804
DEBUG CAREFUL: Adding var 21 to fractional list (xi=0.139804)
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.072039
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.072039)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.139804
DEBUG CAREFUL: Adding var 25 to fractional list (xi=0.139804)
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 10 fractional variables

  %  Carefully choosing branching variable, nfrac = 10
DEBUG CAREFUL: Testing fvar[0] = var 20
DEBUG CAREFUL: Calling compare_branch_vars for var 20
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 20
DEBUG CAREFUL: New best var: 20
DEBUG CAREFUL: Testing fvar[1] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[2] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
DEBUG CAREFUL: Testing fvar[3] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[4] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[5] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 22
DEBUG CAREFUL: Testing fvar[6] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[7] = var 21
DEBUG CAREFUL: Calling compare_branch_vars for var 21
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 21
DEBUG CAREFUL: Testing fvar[8] = var 25
DEBUG CAREFUL: Calling compare_branch_vars for var 25
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 25
DEBUG CAREFUL: Testing fvar[9] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
  % Initial guess is x18, Z0 = 28034874.852358         , Z1 = 28384724.2937703        

DEBUG EVAL: Testing var 20 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=9, varin=28, theta=0.112428, up=999999999999999983222784.000000
ITER 2: row=33, varin=35, theta=0.201696, up=999999999999999983222784.000000
ITER 3: row=35, varin=8, theta=0.110872, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 20 = 0 gives z=28090172.565873
  % 	x20 = 0,	Z0 = 28090172.5658732        
DEBUG EVAL: First branch cutoff check: z=28090172.565873, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 20 = 1
ITER 1: row=9, varin=39, theta=4.042647, up=999999999999999983222784.000000
ITER 2: row=1, varin=51, theta=16.787213, up=999999999999999983222784.000000
ITER 3: row=7, varin=43, theta=2.589292, up=999999999999999983222784.000000
ITER 4: row=47, varin=46, theta=2.825727, up=999999999999999983222784.000000
ITER 5: row=16, varin=34, theta=4.848004, up=999999999999999983222784.000000
ITER 6: row=6, varin=79, theta=3.485233, up=1.000000
ITER 7: row=6, varin=80, theta=2.509330, up=1.000000
ITER 8: row=6, varin=82, theta=3.477528, up=1.000000
ITER 9: row=6, varin=18, theta=1.759634, up=999999999999999983222784.000000
ITER 10: row=45, varin=82, theta=3.216771, up=1.000000
  % 	x20 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: Second branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=9, varin=28, theta=0.112428, up=999999999999999983222784.000000
ITER 2: row=33, varin=35, theta=0.201696, up=999999999999999983222784.000000
ITER 3: row=35, varin=8, theta=0.110872, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28090172.565873
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.445641
DEBUG SOLUTION: lp->best_solution[5] = 2.445641
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.889128
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
   % @PL 51 rows, 60 cols, 283 nonzeros, 4 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 4 slack rows
   % @PAP adding 3 rows, 9 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=101, theta=0.162449, up=1.000000
ITER 2: row=50, varin=41, theta=0.254995, up=999999999999999983222784.000000
ITER 3: row=33, varin=6, theta=0.096596, up=999999999999999983222784.000000
ITER 4: row=36, varin=33, theta=0.155504, up=999999999999999983222784.000000
ITER 5: row=20, varin=48, theta=0.434789, up=999999999999999983222784.000000
ITER 6: row=18, varin=62, theta=0.465825, up=1.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28134049.523989
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 50 rows, 60 cols, 282 nonzeros, 0 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 6 rows, 34 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=61, theta=0.437233, up=1.000000
ITER 2: row=52, varin=15, theta=0.053935, up=999999999999999983222784.000000
ITER 3: row=54, varin=24, theta=0.031637, up=999999999999999983222784.000000
ITER 4: row=41, varin=54, theta=0.089534, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 28163942.469300
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.955233
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.955233
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 56 rows, 60 cols, 316 nonzeros, 6 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 6 slack rows
   % @PAP adding 4 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=48, theta=0.193841, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 28166420.621580
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
   % @PL 54 rows, 60 cols, 303 nonzeros, 2 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 6 at  28.16642062157985648696
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595daba91d0
% @LO 0.01  28.03487485235797649352 99.9000000000
% @LN 0.01  28.04514344305915685140 99.9000000000
% Resuming node 7 at  28.04514344305915685140
DEBUG CONSTRNT: LP rows=52, pool->nlprows=52, pool->npend=0
DEBUG CONSTRNT: Checking 52 LP rows (pool tracks 52, total LP rows 52)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=51, expected 51
 % @PAP adding 49 rows, 229 nz to LP
DEBUG BB: Processing node 7, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 7 LP 2 Solution, length = 28045143.443059, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.164491 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.164491 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.164491 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.006526 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.164491 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.164491 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.164491 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.835509 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.835509 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.835509 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.835509 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.835509 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.835509 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.835509 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=28045143.443059, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28045143.443059, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 7 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 7
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.164491
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.164491)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.164491
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.164491)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.164491
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.164491)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.006526
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.006526)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=1.000000
DEBUG CAREFUL: Skipping var 13: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.164491
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.164491)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.164491
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.164491)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.164491
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.164491)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 7 fractional variables

  %  Carefully choosing branching variable, nfrac = 7
DEBUG CAREFUL: Testing fvar[0] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 11
DEBUG CAREFUL: New best var: 11
DEBUG CAREFUL: Testing fvar[1] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[2] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[3] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[4] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[5] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 18
DEBUG CAREFUL: Testing fvar[6] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
  % Initial guess is x11, Z0 = 28045143.4430592        , Z1 = 28521175.5796109        

DEBUG EVAL: Testing var 11 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=12, varin=23, theta=0.688185, up=999999999999999983222784.000000
ITER 2: row=23, varin=46, theta=0.887931, up=999999999999999983222784.000000
ITER 3: row=6, varin=45, theta=1.433986, up=999999999999999983222784.000000
ITER 4: row=1, varin=43, theta=1.097465, up=999999999999999983222784.000000
ITER 5: row=43, varin=39, theta=0.774770, up=999999999999999983222784.000000
ITER 6: row=33, varin=28, theta=1.098992, up=999999999999999983222784.000000
ITER 7: row=37, varin=92, theta=1.616646, up=1.000000
ITER 8: row=37, varin=33, theta=0.344525, up=999999999999999983222784.000000
ITER 9: row=36, varin=30, theta=1.400791, up=999999999999999983222784.000000
ITER 10: row=47, varin=8, theta=0.518490, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 11 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x11 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=12, varin=72, theta=0.004586, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28045145.385382
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 49 rows, 60 cols, 289 nonzeros, 0 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 7 at  28.04514538538170853599
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595daba91d0
% @LO 0.01  28.04514344305915685140 99.9000000000
% @LN 0.01  28.04514538538170853599 99.9000000000
% Resuming node 7 at  28.04514538538170853599
DEBUG CONSTRNT: LP rows=49, pool->nlprows=49, pool->npend=0
DEBUG CONSTRNT: Checking 49 LP rows (pool tracks 49, total LP rows 49)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=48, expected 48
 % @PAP adding 49 rows, 229 nz to LP
DEBUG BB: Processing node 7, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 7 LP 3 Solution, length = 28045145.385382, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.165902 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.165902 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.165902 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.165902 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.165902 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.004586 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.165902 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.834098 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.834098 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.834098 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.834098 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.834098 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.834098 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.834098 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=28045145.385382, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28045145.385382, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 7 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 7
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.165902
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.165902)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.165902
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.165902)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.165902
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.165902)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=1.000000
DEBUG CAREFUL: Skipping var 13: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.165902
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.165902)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.165902
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.165902)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.004586
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.004586)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.165902
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.165902)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 7 fractional variables

  %  Carefully choosing branching variable, nfrac = 7
DEBUG CAREFUL: Testing fvar[0] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 2
DEBUG CAREFUL: New best var: 2
DEBUG CAREFUL: Testing fvar[1] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[2] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[3] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[4] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
DEBUG CAREFUL: Testing fvar[5] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 22
DEBUG CAREFUL: Testing fvar[6] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
  % Initial guess is x18, Z0 = 28045145.3853817        , Z1 = 28384724.2937703        

DEBUG EVAL: Testing var 2 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=27, theta=1.608614, up=999999999999999983222784.000000
ITER 2: row=35, varin=30, theta=4.505718, up=999999999999999983222784.000000
ITER 3: row=2, varin=34, theta=0.934645, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 1 gives z=28502636.015152
  % 	x2 = 1,	Z1 = 28502636.0151518        
DEBUG EVAL: First branch cutoff check: z=28502636.015152, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 0
ITER 1: row=1, varin=108, theta=3.834602, up=1.000000
ITER 2: row=1, varin=28, theta=0.715764, up=999999999999999983222784.000000
ITER 3: row=27, varin=108, theta=0.988452, up=1.000000
ITER 4: row=37, varin=45, theta=0.179825, up=999999999999999983222784.000000
  % 	x2 = 0,	Z0 = 28058059.6609269        
DEBUG EVAL: Second branch cutoff check: z=28058059.660927, best_z=INF, threshold=INF
  %   New best:  x2, Z = 28058059.6609269        
DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=4, varin=27, theta=1.608614, up=999999999999999983222784.000000
ITER 2: row=35, varin=30, theta=4.505718, up=999999999999999983222784.000000
ITER 3: row=2, varin=45, theta=9.753845, up=999999999999999983222784.000000
ITER 4: row=1, varin=36, theta=1.507853, up=999999999999999983222784.000000
ITER 5: row=27, varin=108, theta=0.389005, up=1.000000
ITER 6: row=26, varin=26, theta=1.135356, up=999999999999999983222784.000000
ITER 7: row=23, varin=75, theta=0.258911, up=1.000000
ITER 8: row=37, varin=19, theta=0.081228, up=999999999999999983222784.000000
ITER 9: row=5, varin=46, theta=1.091706, up=999999999999999983222784.000000
ITER 10: row=6, varin=17, theta=0.337643, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x3 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=4, varin=108, theta=3.834602, up=1.000000
ITER 2: row=4, varin=28, theta=0.715764, up=999999999999999983222784.000000
ITER 3: row=27, varin=108, theta=0.988452, up=1.000000
ITER 4: row=37, varin=100, theta=0.522859, up=1.000000
ITER 5: row=48, varin=54, theta=0.766158, up=1.000000
ITER 6: row=23, varin=33, theta=0.256633, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28094482.386302
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 49 rows, 60 cols, 289 nonzeros, 3 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 3 slack rows
   % @PAP adding 5 rows, 24 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=32, theta=0.062500, up=999999999999999983222784.000000
ITER 2: row=47, varin=73, theta=0.202795, up=1.000000
ITER 3: row=48, varin=94, theta=0.380409, up=1.000000
ITER 4: row=39, varin=74, theta=-10.503806, up=1.000000
ITER 5: row=39, varin=49, theta=0.737923, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28117621.091300
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.961836
DEBUG SOLUTION: lp->best_solution[10] = 0.961836
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 51 rows, 60 cols, 307 nonzeros, 7 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 7 slack rows
   % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=69, theta=0.105591, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28118162.529039
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 46 rows, 60 cols, 278 nonzeros, 0 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 7 at  28.11816252903912527472
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabd9c70
% @LO 0.01  28.04514538538170853599 99.9000000000
% @LN 0.01  28.05246260171051275734 99.9000000000
% Resuming node 18 at  28.05246260171051275734
DEBUG CONSTRNT: LP rows=46, pool->nlprows=46, pool->npend=0
DEBUG CONSTRNT: Checking 46 LP rows (pool tracks 46, total LP rows 46)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=45, expected 45
 % @PAP adding 33 rows, 170 nz to LP
DEBUG BB: Processing node 18, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=35, theta=10.563014, up=1.000000
ITER 2: row=1, varin=31, theta=1.450794, up=999999999999999983222784.000000
ITER 3: row=23, varin=32, theta=0.557397, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=33)
DEBUG SOLUTION: LP solution array indices: FST[34-73], not_covered[74-93]
DEBUG SOLUTION: lp->best_solution[0] = 28052462.601711
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 33 rows, 60 cols, 230 nonzeros, 2 slack, 31 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 7 rows, 34 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=25, theta=0.194823, up=999999999999999983222784.000000
ITER 2: row=36, varin=24, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=34, varin=55, theta=0.899591, up=1.000000
ITER 4: row=38, varin=23, theta=7.000000, up=999999999999999983222784.000000
ITER 5: row=14, varin=40, theta=6.000000, up=999999999999999983222784.000000
ITER 6: row=1, varin=77, theta=3.075011, up=1.000000
ITER 7: row=1, varin=42, theta=0.800592, up=1.000000
ITER 8: row=34, varin=77, theta=0.516835, up=1.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28094390.105375
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 264 nonzeros, 8 slack, 32 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 8 slack rows
  % @PAP adding 2 rows, 20 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=33, varin=49, theta=1.000000, up=1.000000
ITER 2: row=7, varin=45, theta=4.549209, up=1.000000
ITER 3: row=7, varin=27, theta=0.894721, up=999999999999999983222784.000000
ITER 4: row=28, varin=47, theta=0.292536, up=1.000000
ITER 5: row=8, varin=45, theta=0.302061, up=1.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=34)
DEBUG SOLUTION: LP solution array indices: FST[35-74], not_covered[75-94]
DEBUG SOLUTION: lp->best_solution[0] = 28116217.276401
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 34 rows, 60 cols, 246 nonzeros, 2 slack, 32 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 3 rows, 9 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=33, varin=72, theta=0.500000, up=1.000000
ITER 2: row=34, varin=23, theta=0.872107, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=35)
DEBUG SOLUTION: LP solution array indices: FST[36-75], not_covered[76-95]
DEBUG SOLUTION: lp->best_solution[0] = 28160946.028297
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 35 rows, 60 cols, 239 nonzeros, 2 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 3 rows, 9 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=34, varin=54, theta=0.102742, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=36)
DEBUG SOLUTION: LP solution array indices: FST[37-76], not_covered[77-96]
DEBUG SOLUTION: lp->best_solution[0] = 28165166.986922
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 36 rows, 60 cols, 241 nonzeros, 0 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 31 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=37, varin=43, theta=0.160788, up=1.000000
ITER 2: row=2, varin=61, theta=0.089874, up=1.000000
ITER 3: row=40, varin=9, theta=0.010194, up=999999999999999983222784.000000
ITER 4: row=42, varin=15, theta=0.013467, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28171868.718812
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.989526
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 272 nonzeros, 4 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=84, theta=0.117647, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28178301.063442
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.882353
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 3.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 268 nonzeros, 3 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=35, theta=0.432234, up=999999999999999983222784.000000
ITER 2: row=39, varin=74, theta=0.302600, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 28179852.843924
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 3.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 39 rows, 60 cols, 261 nonzeros, 0 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 18 LP 1 Solution, length = 28179852.843924, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.500000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.802600 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.500000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.302600 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.500000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.197400 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.197400 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.197400 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28179852.843924, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 18 at  28.17985284392407763221
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabad4e0
% @LO 0.01  28.05246260171051275734 99.9000000000
% @LN 0.01  28.10947328571435832600 99.9000000000
% Resuming node 13 at  28.10947328571435832600
DEBUG CONSTRNT: LP rows=39, pool->nlprows=39, pool->npend=0
DEBUG CONSTRNT: Checking 39 LP rows (pool tracks 39, total LP rows 39)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 62
DEBUG CONSTRNT: Pool row 62 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=38, expected 38
 % @PAP adding 46 rows, 233 nz to LP
DEBUG BB: Processing node 13, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=10, varin=10, theta=1.960947, up=999999999999999983222784.000000
ITER 2: row=24, varin=65, theta=0.850243, up=1.000000
ITER 3: row=1, varin=81, theta=5.317408, up=1.000000
ITER 4: row=1, varin=26, theta=0.557698, up=999999999999999983222784.000000
ITER 5: row=44, varin=81, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28109473.285714
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 293 nonzeros, 2 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 20 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=15, theta=0.029713, up=999999999999999983222784.000000
ITER 2: row=42, varin=9, theta=0.023583, up=999999999999999983222784.000000
ITER 3: row=46, varin=60, theta=0.025879, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28121799.804530
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.976996
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 313 nonzeros, 8 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 8 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=47, theta=0.385531, up=1.000000
ITER 2: row=9, varin=88, theta=0.255256, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28144597.005025
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.744744
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 3.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 303 nonzeros, 4 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=35, theta=0.937207, up=999999999999999983222784.000000
ITER 2: row=43, varin=37, theta=0.733390, up=999999999999999983222784.000000
ITER 3: row=42, varin=47, theta=0.238858, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28166815.198463
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 3.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 296 nonzeros, 2 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=39, theta=0.150992, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28168792.969210
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 3.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 282 nonzeros, 2 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=87, theta=0.536924, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28171921.327805
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.463076
DEBUG SOLUTION: lp->best_solution[4] = 0.463076
DEBUG SOLUTION: lp->best_solution[5] = 1.926151
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 3.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 284 nonzeros, 4 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 4 rows, 15 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=91, theta=1.537616, up=1.000000
ITER 2: row=42, varin=32, theta=0.136637, up=999999999999999983222784.000000
ITER 3: row=3, varin=91, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28177865.353893
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 3.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1000000.000000
  % @PL 45 rows, 60 cols, 289 nonzeros, 1 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=75, theta=0.025540, up=1.000000
ITER 2: row=44, varin=69, theta=0.054242, up=1.000000
ITER 3: row=10, varin=41, theta=0.031932, up=999999999999999983222784.000000
ITER 4: row=41, varin=72, theta=0.024090, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28179634.775267
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 3.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1000000.000000
  % @PL 45 rows, 60 cols, 283 nonzeros, 0 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 13 LP 1 Solution, length = 28179634.775267, 0.02 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.095182 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.500000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.095182 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.095182 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.095182 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.024090 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.500000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.904818 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.904818 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.904818 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.904818 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.904818 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=28179634.775267, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 13 at  28.17963477526728510725
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabd7d60
% @LO 0.03  28.10947328571435832600 99.9000000000
% @LN 0.03  28.11016839753657592382 99.9000000000
% Resuming node 16 at  28.11016839753657592382
DEBUG CONSTRNT: LP rows=45, pool->nlprows=45, pool->npend=0
DEBUG CONSTRNT: Checking 45 LP rows (pool tracks 45, total LP rows 45)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 150
DEBUG CONSTRNT: Pool row 150 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=44, expected 44
 % @PAP adding 35 rows, 195 nz to LP
DEBUG BB: Processing node 16, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=2, varin=39, theta=0.255514, up=1.000000
ITER 2: row=4, varin=12, theta=118940.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=35)
DEBUG SOLUTION: LP solution array indices: FST[36-75], not_covered[76-95]
DEBUG SOLUTION: lp->best_solution[0] = 27950061.122936
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 881060.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 35 rows, 60 cols, 255 nonzeros, 1 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 16 LP 1 Solution, length = 27950061.122936, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.500000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.500000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 2 fractional variables
DEBUG CG: LP optimal, z=27950061.122936, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27950061.122936, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 16 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 16
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=1.000000
DEBUG CAREFUL: Skipping var 7: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.500000
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.500000
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 2 fractional variables

  %  Carefully choosing branching variable, nfrac = 2
DEBUG CAREFUL: Testing fvar[0] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 14
DEBUG CAREFUL: New best var: 14
DEBUG CAREFUL: Testing fvar[1] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 15
  % Initial guess is x14, Z0 = 28003849.7191043        , Z1 = 28251202.9470403        

DEBUG EVAL: Testing var 14 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=15, varin=42, theta=1.000000, up=1.000000
ITER 2: row=1, varin=35, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=12, varin=15, theta=0.996389, up=999999999999999983222784.000000
ITER 4: row=7, varin=12, theta=3959.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 14 = 0 gives z=28016083.145425
  % 	x14 = 0,	Z0 = 28016083.1454246        
DEBUG EVAL: First branch cutoff check: z=28016083.145425, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 14 = 1
ITER 1: row=15, varin=20, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=26, varin=22, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=12, varin=34, theta=0.144076, up=999999999999999983222784.000000
ITER 4: row=16, varin=35, theta=0.209494, up=999999999999999983222784.000000
ITER 5: row=27, varin=29, theta=0.521199, up=999999999999999983222784.000000
ITER 6: row=29, varin=7, theta=0.273170, up=999999999999999983222784.000000
ITER 7: row=7, varin=60, theta=0.839384, up=1.000000
ITER 8: row=9, varin=65, theta=1.079767, up=1.000000
ITER 9: row=9, varin=42, theta=0.025088, up=1.000000
ITER 10: row=1, varin=65, theta=0.135256, up=1.000000
  % 	x14 = 1,	Z1 = 28251202.9470403        
DEBUG EVAL: Second branch cutoff check: z=28251202.947040, best_z=INF, threshold=INF
  %   New best:  x14, Z = 28016083.1454246        
DEBUG EVAL: Testing var 15 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=20, varin=20, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=26, varin=42, theta=1.000000, up=1.000000
ITER 3: row=1, varin=35, theta=3.000000, up=999999999999999983222784.000000
ITER 4: row=12, varin=15, theta=0.996389, up=999999999999999983222784.000000
ITER 5: row=7, varin=12, theta=3959.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 15 = 0 gives z=28016083.145425
  % 	x15 = 0,	Z0 = 28016083.1454246        
DEBUG EVAL: First branch cutoff check: z=28016083.145425, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 15 = 1
ITER 1: row=20, varin=25, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=12, varin=34, theta=0.105323, up=999999999999999983222784.000000
ITER 3: row=16, varin=35, theta=0.114265, up=999999999999999983222784.000000
ITER 4: row=27, varin=29, theta=0.284280, up=999999999999999983222784.000000
ITER 5: row=29, varin=7, theta=0.148996, up=999999999999999983222784.000000
ITER 6: row=7, varin=42, theta=0.160460, up=1.000000
ITER 7: row=15, varin=60, theta=0.457828, up=1.000000
ITER 8: row=9, varin=65, theta=0.588941, up=1.000000
  % 	x15 = 1,	Z1 = 28130981.865687         
DEBUG EVAL: Second branch cutoff check: z=28130981.865687, best_z=INF, threshold=INF
  % Best branch is x14, Z0 = 28016083.1454246        , Z1 = 28251202.9470403        

DEBUG CAREFUL: Final result - returning best.var = 14
DEBUG BB: Branching variable chosen: j=14
 % @NC   19   16	x14 = 0	28016083.145425
 % @NC   20   16	x14 = 1	28251202.947040
 %      16    10 27950061.1229               28016083.1454    x1 D     2     2
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabbedc0
% Resuming node 19 at  28.01608314542461286578
DEBUG CONSTRNT: LP rows=35, pool->nlprows=35, pool->npend=0
DEBUG CONSTRNT: Checking 35 LP rows (pool tracks 35, total LP rows 35)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=34, expected 34
 % @PAP adding 35 rows, 195 nz to LP
DEBUG BB: Processing node 19, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=15, varin=42, theta=1.000000, up=1.000000
ITER 2: row=1, varin=35, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=12, varin=15, theta=0.996389, up=999999999999999983222784.000000
ITER 4: row=7, varin=12, theta=3959.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=35)
DEBUG SOLUTION: LP solution array indices: FST[36-75], not_covered[76-95]
DEBUG SOLUTION: lp->best_solution[0] = 28004042.420601
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 996041.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 35 rows, 60 cols, 255 nonzeros, 3 slack, 32 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 16 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=25, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=12, varin=50, theta=0.518915, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 28043923.412273
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 39 rows, 60 cols, 271 nonzeros, 6 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=34, varin=39, theta=0.215713, up=1.000000
LP PHASE: Switching to primal (iter=1)
ITER 2: row=7, varin=12, theta=263733.500000, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=35)
DEBUG SOLUTION: LP solution array indices: FST[36-75], not_covered[76-95]
DEBUG SOLUTION: lp->best_solution[0] = 28767426.467279
DEBUG SOLUTION: lp->best_solution[1] = 19.431426
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 835662.183003
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 35 rows, 60 cols, 249 nonzeros, 1 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 7 rows, 33 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=58, theta=5.666667, up=1.000000
ITER 2: row=1, varin=55, theta=4.666667, up=1.000000
ITER 3: row=1, varin=51, theta=5.500000, up=1.000000
ITER 4: row=1, varin=47, theta=4.500000, up=1.000000
ITER 5: row=1, varin=78, theta=7.000000, up=1.000000
ITER 6: row=1, varin=50, theta=3.000000, up=1.000000
ITER 7: row=1, varin=52, theta=2.000000, up=1.000000
ITER 8: row=1, varin=57, theta=0.666667, up=1.000000
ITER 9: row=16, varin=50, theta=4.000000, up=1.000000
ITER 10: row=16, varin=51, theta=3.000000, up=1.000000
LP PHASE: Switching to primal (iter=53)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28045267.643313
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 41 rows, 60 cols, 242 nonzeros, 0 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 19 LP 1 Solution, length = 28045267.643313, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.500000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 2 fractional variables
DEBUG CG: LP optimal, z=28045267.643313, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28045267.643313, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 19 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 19
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=1.000000
DEBUG CAREFUL: Skipping var 7: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.500000
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.500000
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 2 fractional variables

  %  Carefully choosing branching variable, nfrac = 2
DEBUG CAREFUL: Testing fvar[0] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 15
DEBUG CAREFUL: New best var: 15
DEBUG CAREFUL: Testing fvar[1] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
  % Initial guess is x15, Z0 = 28767426.4672793        , Z1 = 28767426.4672793        

DEBUG EVAL: Testing var 15 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=17, varin=31, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=41, varin=45, theta=0.503937, up=1.000000
ITER 3: row=35, varin=48, theta=0.555556, up=1.000000
ITER 4: row=33, varin=27, theta=3.733333, up=999999999999999983222784.000000
ITER 5: row=40, varin=65, theta=2.000000, up=1.000000
ITER 6: row=40, varin=71, theta=0.500000, up=1.000000
ITER 7: row=8, varin=65, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 15 = 1 gives z=28156388.867800
  % 	x15 = 1,	Z1 = 28767426.4672793        
DEBUG EVAL: First branch cutoff check: z=28767426.467279, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 15 = 0
ITER 1: row=17, varin=19, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=32, varin=17, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=41, varin=45, theta=0.503937, up=1.000000
ITER 4: row=35, varin=48, theta=0.555556, up=1.000000
ITER 5: row=33, varin=27, theta=3.733333, up=999999999999999983222784.000000
ITER 6: row=40, varin=65, theta=2.000000, up=1.000000
ITER 7: row=40, varin=71, theta=0.500000, up=1.000000
ITER 8: row=8, varin=65, theta=1.000000, up=1.000000
  % 	x15 = 0,	Z0 = 28767426.4672793        
DEBUG EVAL: Second branch cutoff check: z=28767426.467279, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 12 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=31, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=41, varin=45, theta=0.503937, up=1.000000
ITER 3: row=35, varin=48, theta=0.555556, up=1.000000
ITER 4: row=33, varin=27, theta=3.733333, up=999999999999999983222784.000000
ITER 5: row=40, varin=65, theta=2.000000, up=1.000000
ITER 6: row=40, varin=71, theta=0.500000, up=1.000000
ITER 7: row=8, varin=65, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 12 = 0 gives z=28156388.867800
  % 	x12 = 0,	Z0 = 28767426.4672793        
DEBUG EVAL: First branch cutoff check: z=28767426.467279, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 1
ITER 1: row=7, varin=19, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=32, varin=20, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=41, varin=45, theta=0.503937, up=1.000000
ITER 4: row=35, varin=48, theta=0.555556, up=1.000000
ITER 5: row=33, varin=27, theta=3.733333, up=999999999999999983222784.000000
ITER 6: row=40, varin=65, theta=2.000000, up=1.000000
ITER 7: row=40, varin=71, theta=0.500000, up=1.000000
ITER 8: row=8, varin=65, theta=1.000000, up=1.000000
  % 	x12 = 1,	Z1 = 28767426.4672793        
DEBUG EVAL: Second branch cutoff check: z=28767426.467279, best_z=INF, threshold=INF
  % 2 consecutive failures: giving up.
  % Best branch is x15, Z0 = 28767426.4672793        , Z1 = 28767426.4672793        

DEBUG CAREFUL: Final result - returning best.var = 15
DEBUG BB: Branching variable chosen: j=15
 % @NC   21   19	x15 = 0	28767426.467279
 % @NC   22   19	x15 = 1	28767426.467279
 %      19    11 28045267.6433               28118162.5290   x14 D    16     3
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595daba91d0
% @LO 0.03  28.11016839753657592382 99.9000000000
% @LN 0.03  28.11816252903912527472 99.9000000000
% Resuming node 7 at  28.11816252903912527472
DEBUG CONSTRNT: LP rows=41, pool->nlprows=41, pool->npend=0
DEBUG CONSTRNT: Checking 41 LP rows (pool tracks 41, total LP rows 41)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=40, expected 40
 % @PAP adding 46 rows, 218 nz to LP
DEBUG BB: Processing node 7, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 7 LP 4 Solution, length = 28118162.529039, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.149068 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.149068 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.149068 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.149068 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.149068 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.105591 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.149068 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.850932 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.850932 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.850932 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.850932 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.850932 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.850932 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.850932 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=28118162.529039, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28118162.529039, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 7 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 7
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.149068
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.149068)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.149068
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.149068)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.149068
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.149068)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=1.000000
DEBUG CAREFUL: Skipping var 13: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.149068
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.149068)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.149068
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.149068)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.105591
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.105591)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.149068
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.149068)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 7 fractional variables

  %  Carefully choosing branching variable, nfrac = 7
DEBUG CAREFUL: Testing fvar[0] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 26
DEBUG CAREFUL: New best var: 26
DEBUG CAREFUL: Testing fvar[1] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[2] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 4
DEBUG CAREFUL: New best var: 4
DEBUG CAREFUL: Testing fvar[3] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[4] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[5] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 18
DEBUG CAREFUL: Testing fvar[6] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 22
  % Initial guess is x4, Z0 = 28118162.5290391        , Z1 = 28568987.8342888        

DEBUG EVAL: Testing var 26 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=31, varin=43, theta=0.243502, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 0 gives z=28128421.559624
  % 	x26 = 0,	Z0 = 28128421.5596239        
DEBUG EVAL: First branch cutoff check: z=28128421.559624, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 1
ITER 1: row=31, varin=34, theta=0.875221, up=999999999999999983222784.000000
ITER 2: row=41, varin=42, theta=4.180061, up=999999999999999983222784.000000
ITER 3: row=4, varin=40, theta=1.537490, up=999999999999999983222784.000000
ITER 4: row=27, varin=45, theta=33.305251, up=999999999999999983222784.000000
ITER 5: row=21, varin=5, theta=0.845066, up=999999999999999983222784.000000
ITER 6: row=33, varin=26, theta=1.857034, up=999999999999999983222784.000000
ITER 7: row=1, varin=25, theta=1.039683, up=999999999999999983222784.000000
ITER 8: row=24, varin=68, theta=0.173148, up=1.000000
ITER 9: row=27, varin=72, theta=0.168097, up=1.000000
ITER 10: row=41, varin=69, theta=-2.849694, up=1.000000
  % 	x26 = 1,	Z1 = 28701541.7741856        
DEBUG EVAL: Second branch cutoff check: z=28701541.774186, best_z=INF, threshold=INF
  %   New best:  x26, Z = 28128421.5596239        
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=5, varin=43, theta=0.243502, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28128421.559624
  % 	x10 = 0,	Z0 = 28128421.5596239        
DEBUG EVAL: First branch cutoff check: z=28128421.559624, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 1
ITER 1: row=5, varin=34, theta=0.875221, up=999999999999999983222784.000000
ITER 2: row=41, varin=42, theta=4.180061, up=999999999999999983222784.000000
ITER 3: row=4, varin=40, theta=1.537490, up=999999999999999983222784.000000
ITER 4: row=27, varin=45, theta=33.305251, up=999999999999999983222784.000000
ITER 5: row=21, varin=26, theta=1.857034, up=999999999999999983222784.000000
ITER 6: row=1, varin=25, theta=1.039683, up=999999999999999983222784.000000
ITER 7: row=24, varin=68, theta=0.173148, up=1.000000
ITER 8: row=27, varin=72, theta=0.168097, up=1.000000
ITER 9: row=41, varin=69, theta=-2.849694, up=1.000000
ITER 10: row=41, varin=24, theta=0.083870, up=999999999999999983222784.000000
  % 	x10 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: Second branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=5, varin=43, theta=0.243502, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28128421.559624
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 46 rows, 60 cols, 278 nonzeros, 2 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
   % @PAP adding 8 rows, 33 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=30, theta=0.055569, up=999999999999999983222784.000000
ITER 2: row=48, varin=52, theta=5.099338, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28134537.268323
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 52 rows, 60 cols, 307 nonzeros, 8 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 8 slack rows
   % @PAP adding 5 rows, 24 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=33, theta=0.250000, up=999999999999999983222784.000000
ITER 2: row=25, varin=75, theta=0.220240, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28139674.862112
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 49 rows, 60 cols, 302 nonzeros, 5 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 5 slack rows
   % @PAP adding 4 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=21, theta=0.243631, up=999999999999999983222784.000000
ITER 2: row=45, varin=79, theta=0.651682, up=1.000000
ITER 3: row=48, varin=92, theta=0.122527, up=1.000000
ITER 4: row=40, varin=47, theta=0.164009, up=999999999999999983222784.000000
ITER 5: row=20, varin=44, theta=0.237968, up=999999999999999983222784.000000
ITER 6: row=44, varin=27, theta=0.367363, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28192573.310035
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 48 rows, 60 cols, 295 nonzeros, 1 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 7 at  28.19257331003466049424
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabaf550
% @LO 0.03  28.11816252903912527472 99.9000000000
% @LN 0.03  28.13091285223294590878 99.9000000000
% Resuming node 17 at  28.13091285223294590878
DEBUG CONSTRNT: LP rows=47, pool->nlprows=47, pool->npend=0
DEBUG CONSTRNT: Checking 47 LP rows (pool tracks 47, total LP rows 47)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=46, expected 46
 % @PAP adding 38 rows, 193 nz to LP
DEBUG BB: Processing node 17, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 17 LP 2 Solution, length = 28130912.852233, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.046812 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.453188 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.546812 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.046812 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.046812 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.453188 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.953188 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.953188 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.453188 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.453188 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.953188 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.953188 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.953188 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.546812 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.453188 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.953188 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28130912.852233, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28130912.852233, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 17 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 17
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.046812
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.046812)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.453188
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.453188)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.546812
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.546812)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.046812
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.046812)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.046812
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.046812)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.453188
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.453188)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 12
DEBUG CAREFUL: New best var: 12
DEBUG CAREFUL: Testing fvar[1] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 34
DEBUG CAREFUL: New best var: 34
DEBUG CAREFUL: Testing fvar[2] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 14
DEBUG CAREFUL: Testing fvar[3] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
DEBUG CAREFUL: Testing fvar[4] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[5] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x18, Z0 = 28130912.8522329        , Z1 = 28523074.7357445        

DEBUG EVAL: Testing var 12 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=12, varin=80, theta=1.554618, up=1.000000
ITER 2: row=12, varin=41, theta=0.235781, up=1.000000
ITER 3: row=29, varin=30, theta=1.005454, up=999999999999999983222784.000000
ITER 4: row=12, varin=80, theta=0.575947, up=1.000000
DEBUG EVAL: Branch var 12 = 0 gives z=28177195.137157
  % 	x12 = 0,	Z0 = 28177195.1371565        
DEBUG EVAL: First branch cutoff check: z=28177195.137157, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 1
ITER 1: row=12, varin=36, theta=0.812075, up=999999999999999983222784.000000
ITER 2: row=29, varin=33, theta=0.419023, up=999999999999999983222784.000000
  % 	x12 = 1,	Z1 = 28145926.4667253        
DEBUG EVAL: Second branch cutoff check: z=28145926.466725, best_z=INF, threshold=INF
  %   New best:  x12, Z = 28145926.4667253        
DEBUG EVAL: Testing var 34 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=31, varin=36, theta=0.812075, up=999999999999999983222784.000000
ITER 2: row=29, varin=34, theta=0.180018, up=999999999999999983222784.000000
ITER 3: row=32, varin=2, theta=0.222649, up=999999999999999983222784.000000
ITER 4: row=2, varin=31, theta=0.142271, up=999999999999999983222784.000000
ITER 5: row=23, varin=30, theta=0.515272, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 34 = 1 gives z=28172107.503319
  % 	x34 = 1,	Z1 = 28172107.503319         
DEBUG EVAL: First branch cutoff check: z=28172107.503319, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 34 = 0
ITER 1: row=31, varin=80, theta=1.554618, up=1.000000
ITER 2: row=31, varin=33, theta=0.257187, up=999999999999999983222784.000000
ITER 3: row=29, varin=80, theta=0.479577, up=1.000000
  % 	x34 = 0,	Z0 = 28148386.8266894        
DEBUG EVAL: Second branch cutoff check: z=28148386.826689, best_z=INF, threshold=INF
  %   New best:  x34, Z = 28148386.8266894        
DEBUG EVAL: Testing var 14 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=17, varin=80, theta=1.554618, up=1.000000
ITER 2: row=17, varin=41, theta=0.235781, up=1.000000
ITER 3: row=29, varin=42, theta=-4.826920, up=1.000000
ITER 4: row=29, varin=80, theta=1.348262, up=1.000000
ITER 5: row=29, varin=25, theta=0.223930, up=999999999999999983222784.000000
ITER 6: row=8, varin=42, theta=0.500000, up=1.000000
ITER 7: row=1, varin=34, theta=0.401898, up=999999999999999983222784.000000
ITER 8: row=23, varin=68, theta=1.401109, up=1.000000
ITER 9: row=23, varin=45, theta=0.381888, up=1.000000
ITER 10: row=31, varin=62, theta=1.073815, up=1.000000
DEBUG EVAL: Branch var 14 = 1 gives z=28382551.498072
  % 	x14 = 1,	Z1 = 28382551.4980716        
DEBUG EVAL: First branch cutoff check: z=28382551.498072, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 14 = 0
ITER 1: row=17, varin=36, theta=0.812075, up=999999999999999983222784.000000
ITER 2: row=29, varin=33, theta=0.419023, up=999999999999999983222784.000000
  % 	x14 = 0,	Z0 = 28145926.4667253        
DEBUG EVAL: Second branch cutoff check: z=28145926.466725, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 18 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=29, varin=33, theta=7.409973, up=999999999999999983222784.000000
ITER 2: row=31, varin=34, theta=1.763374, up=999999999999999983222784.000000
ITER 3: row=24, varin=73, theta=9.465643, up=1.000000
ITER 4: row=24, varin=25, theta=2.245901, up=999999999999999983222784.000000
ITER 5: row=38, varin=41, theta=2.806723, up=1.000000
ITER 6: row=38, varin=23, theta=1.901669, up=999999999999999983222784.000000
ITER 7: row=30, varin=45, theta=1.622953, up=1.000000
ITER 8: row=30, varin=42, theta=0.710871, up=1.000000
ITER 9: row=32, varin=68, theta=10.612806, up=1.000000
ITER 10: row=32, varin=62, theta=25.734570, up=1.000000
DEBUG EVAL: Branch var 18 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x18 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=29, varin=36, theta=0.270040, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 28133415.672444
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 3.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 38 rows, 60 cols, 253 nonzeros, 3 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 3 slack rows
   % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=37, varin=80, theta=0.122595, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 28133569.355684
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.877405
DEBUG SOLUTION: lp->best_solution[4] = 0.877405
DEBUG SOLUTION: lp->best_solution[5] = 2.754810
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 3.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 38 rows, 60 cols, 253 nonzeros, 3 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 3 slack rows
   % @PAP adding 4 rows, 15 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=32, theta=0.090645, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 28136119.538279
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 3.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1000000.000000
   % @PL 39 rows, 60 cols, 260 nonzeros, 1 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 2 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=43, theta=0.107233, up=1.000000
ITER 2: row=40, varin=42, theta=0.144895, up=1.000000
LP PHASE: Switching to primal (iter=2)
ITER 3: row=3, varin=40, theta=0.000000, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28138734.180872
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 3.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1000000.000000
   % @PL 40 rows, 60 cols, 270 nonzeros, 2 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 17 at  28.13873418087244360208
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595daba2600
% @LO 0.03  28.13091285223294590878 99.9000000000
% @LN 0.03  28.13794594646489954926 99.9000000000
% Resuming node 3 at  28.13794594646489954926
DEBUG CONSTRNT: LP rows=38, pool->nlprows=38, pool->npend=0
DEBUG CONSTRNT: Checking 38 LP rows (pool tracks 38, total LP rows 38)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=37, expected 37
 % @PAP adding 50 rows, 226 nz to LP
DEBUG BB: Processing node 3, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 3 LP 6 Solution, length = 28137945.946465, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.256523 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.256523 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.106211 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.106211 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.106211 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.106211 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.106211 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.106211 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.106211 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.256523 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.743477 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.893789 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.743477 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.743477 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.893789 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.743477 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.893789 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.893789 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.893789 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.893789 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.893789 (terminal 19)
 % 10 fractional variables
DEBUG CG: LP optimal, z=28137945.946465, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28137945.946465, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 3 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 3 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 3
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.256523
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.256523)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.256523
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.256523)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.106211
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.106211)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.106211
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.106211)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.106211
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.106211)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.106211
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.106211)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.106211
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.106211)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.106211
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.106211)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.106211
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.106211)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.256523
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.256523)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 10 fractional variables

  %  Carefully choosing branching variable, nfrac = 10
DEBUG CAREFUL: Testing fvar[0] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 29
DEBUG CAREFUL: New best var: 29
DEBUG CAREFUL: Testing fvar[1] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[2] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
DEBUG CAREFUL: Testing fvar[3] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 26
DEBUG CAREFUL: New best var: 26
DEBUG CAREFUL: Testing fvar[4] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 11
DEBUG CAREFUL: New best var: 11
DEBUG CAREFUL: Testing fvar[5] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 18
DEBUG CAREFUL: Testing fvar[6] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[7] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 4
DEBUG CAREFUL: New best var: 4
DEBUG CAREFUL: Testing fvar[8] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[9] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x4, Z0 = 28137945.9464649        , Z1 = 28568987.8342888        

DEBUG EVAL: Testing var 29 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=30, varin=49, theta=0.224725, up=999999999999999983222784.000000
ITER 2: row=10, varin=47, theta=0.191977, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 29 = 0 gives z=28141639.601922
  % 	x29 = 0,	Z0 = 28141639.6019217        
DEBUG EVAL: First branch cutoff check: z=28141639.601922, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 29 = 1
ITER 1: row=30, varin=64, theta=1.438505, up=1.000000
ITER 2: row=30, varin=29, theta=0.077948, up=999999999999999983222784.000000
ITER 3: row=17, varin=64, theta=1.000000, up=1.000000
  % 	x29 = 1,	Z1 = 28172168.9309135        
DEBUG EVAL: Second branch cutoff check: z=28172168.930913, best_z=INF, threshold=INF
  %   New best:  x29, Z = 28141639.6019217        
DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=49, theta=0.224725, up=999999999999999983222784.000000
ITER 2: row=10, varin=47, theta=0.191977, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 0 gives z=28141639.601922
  % 	x1 = 0,	Z0 = 28141639.6019217        
DEBUG EVAL: First branch cutoff check: z=28141639.601922, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 1
ITER 1: row=2, varin=64, theta=1.438505, up=1.000000
ITER 2: row=2, varin=72, theta=0.156033, up=1.000000
ITER 3: row=17, varin=64, theta=1.000000, up=1.000000
ITER 4: row=25, varin=73, theta=0.518965, up=1.000000
ITER 5: row=8, varin=46, theta=0.083359, up=999999999999999983222784.000000
ITER 6: row=3, varin=28, theta=0.168223, up=999999999999999983222784.000000
ITER 7: row=9, varin=47, theta=0.401391, up=999999999999999983222784.000000
ITER 8: row=16, varin=40, theta=0.420624, up=999999999999999983222784.000000
ITER 9: row=35, varin=31, theta=0.261933, up=999999999999999983222784.000000
ITER 10: row=36, varin=37, theta=0.626734, up=999999999999999983222784.000000
  % 	x1 = 1,	Z1 = 28348960.6203142        
DEBUG EVAL: Second branch cutoff check: z=28348960.620314, best_z=INF, threshold=INF
  %   New best:  x1, Z = 28141639.6019217        
DEBUG EVAL: Testing var 0 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=49, theta=0.224725, up=999999999999999983222784.000000
ITER 2: row=10, varin=47, theta=0.191977, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 0 = 0 gives z=28141639.601922
  % 	x0 = 0,	Z0 = 28141639.6019217        
DEBUG EVAL: First branch cutoff check: z=28141639.601922, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 0 = 1
ITER 1: row=1, varin=64, theta=1.438505, up=1.000000
ITER 2: row=1, varin=72, theta=0.156033, up=1.000000
ITER 3: row=17, varin=64, theta=1.000000, up=1.000000
ITER 4: row=25, varin=73, theta=0.518965, up=1.000000
ITER 5: row=8, varin=46, theta=0.083359, up=999999999999999983222784.000000
ITER 6: row=3, varin=28, theta=0.168223, up=999999999999999983222784.000000
ITER 7: row=9, varin=47, theta=0.401391, up=999999999999999983222784.000000
ITER 8: row=16, varin=40, theta=0.420624, up=999999999999999983222784.000000
ITER 9: row=35, varin=31, theta=0.261933, up=999999999999999983222784.000000
ITER 10: row=36, varin=26, theta=0.490881, up=999999999999999983222784.000000
  % 	x0 = 1,	Z1 = 29070077.4688528        
DEBUG EVAL: Second branch cutoff check: z=29070077.468853, best_z=INF, threshold=INF
  %   New best:  x0, Z = 28141639.6019217        
DEBUG EVAL: Testing var 26 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=40, varin=49, theta=2.921568, up=999999999999999983222784.000000
ITER 2: row=1, varin=47, theta=3.156900, up=999999999999999983222784.000000
ITER 3: row=40, varin=64, theta=4.674392, up=1.000000
ITER 4: row=40, varin=72, theta=1.885710, up=1.000000
ITER 5: row=40, varin=9, theta=0.313924, up=999999999999999983222784.000000
ITER 6: row=17, varin=64, theta=1.000000, up=1.000000
ITER 7: row=25, varin=72, theta=1.000000, up=1.000000
ITER 8: row=45, varin=73, theta=2.447214, up=1.000000
ITER 9: row=45, varin=31, theta=0.929745, up=999999999999999983222784.000000
ITER 10: row=8, varin=73, theta=0.078722, up=1.000000
DEBUG EVAL: Branch var 26 = 1 gives z=28515722.270104
  % 	x26 = 1,	Z1 = 28515722.2701045        
DEBUG EVAL: First branch cutoff check: z=28515722.270104, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 0
ITER 1: row=40, varin=41, theta=0.159427, up=999999999999999983222784.000000
  % 	x26 = 0,	Z0 = 28147114.7129018        
DEBUG EVAL: Second branch cutoff check: z=28147114.712902, best_z=INF, threshold=INF
  %   New best:  x26, Z = 28147114.7129018        
DEBUG EVAL: Testing var 11 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=35, varin=49, theta=2.921568, up=999999999999999983222784.000000
ITER 2: row=1, varin=47, theta=3.156900, up=999999999999999983222784.000000
ITER 3: row=35, varin=64, theta=4.674392, up=1.000000
ITER 4: row=35, varin=28, theta=0.776658, up=999999999999999983222784.000000
ITER 5: row=17, varin=64, theta=1.000000, up=1.000000
ITER 6: row=43, varin=72, theta=2.398914, up=1.000000
ITER 7: row=43, varin=73, theta=1.427080, up=1.000000
ITER 8: row=43, varin=81, theta=0.701176, up=1.000000
ITER 9: row=8, varin=46, theta=3.172907, up=999999999999999983222784.000000
ITER 10: row=16, varin=36, theta=3.377827, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 11 = 1 gives z=29132727.934070
  % 	x11 = 1,	Z1 = 29132727.9340704        
DEBUG EVAL: First branch cutoff check: z=29132727.934070, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 11 = 0
ITER 1: row=35, varin=40, theta=0.190522, up=999999999999999983222784.000000
  % 	x11 = 0,	Z0 = 28153736.3463272        
DEBUG EVAL: Second branch cutoff check: z=28153736.346327, best_z=INF, threshold=INF
  %   New best:  x11, Z = 28153736.3463272        
DEBUG EVAL: Testing var 18 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=28, varin=49, theta=2.921568, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 18 = 1 gives z=28145014.510657
  % 	x18 = 1,	Z1 = 28384724.2937703        
DEBUG EVAL: First branch cutoff check: z=28384724.293770, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 18 = 0
ITER 1: row=28, varin=46, theta=0.561861, up=999999999999999983222784.000000
  % 	x18 = 0,	Z0 = 28156360.4625211        
DEBUG EVAL: Second branch cutoff check: z=28156360.462521, best_z=INF, threshold=INF
  %   New best:  x18, Z = 28156360.4625211        
DEBUG EVAL: Testing var 3 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=8, varin=47, theta=0.279106, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 0 gives z=28143315.985704
  % 	x3 = 0,	Z0 = 28143315.985704         
DEBUG EVAL: First branch cutoff check: z=28143315.985704, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 4 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=16, varin=49, theta=2.921568, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 4 = 1 gives z=28145014.510657
  % 	x4 = 1,	Z1 = 28568987.8342888        
DEBUG EVAL: First branch cutoff check: z=28568987.834289, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 4 = 0
ITER 1: row=16, varin=47, theta=0.279106, up=999999999999999983222784.000000
  % 	x4 = 0,	Z0 = 28143315.985704         
DEBUG EVAL: Second branch cutoff check: z=28143315.985704, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=39, theta=0.141171, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28148777.762032
  % 	x2 = 0,	Z0 = 28148777.7620323        
DEBUG EVAL: First branch cutoff check: z=28148777.762032, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=9, varin=36, theta=0.124574, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28154517.181686
  % 	x10 = 0,	Z0 = 28154517.1816858        
DEBUG EVAL: First branch cutoff check: z=28154517.181686, best_z=INF, threshold=INF
  % Best branch is x18, Z0 = 28156360.4625211        , Z1 = 28384724.2937703        

DEBUG CAREFUL: Final result - returning best.var = 18
DEBUG BB: Branching variable chosen: j=18
 % @NC   23    3	x18 = 0	28156360.462521
 % @NC   24    3	x18 = 1	28384724.293770
 %       3    12 28137945.9465               28138734.1809   x19 U     1     2
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabaf550
% @LO 0.03  28.13794594646489954926 99.9000000000
% @LN 0.03  28.13873418087244360208 99.9000000000
% Resuming node 17 at  28.13873418087244360208
DEBUG CONSTRNT: LP rows=50, pool->nlprows=50, pool->npend=0
DEBUG CONSTRNT: Checking 50 LP rows (pool tracks 50, total LP rows 50)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 85
DEBUG CONSTRNT: Pool row 85 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=49, expected 49
 % @PAP adding 38 rows, 199 nz to LP
DEBUG BB: Processing node 17, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 17 LP 3 Solution, length = 28138734.180872, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.144895 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.144895 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.500000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.500000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.855105 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.855105 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.855105 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.855105 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28138734.180872, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28138734.180872, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 17 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 17
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.144895
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.144895)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.144895
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.144895)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.500000
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.500000
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.500000
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 12
DEBUG CAREFUL: New best var: 12
DEBUG CAREFUL: Testing fvar[1] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 34
DEBUG CAREFUL: New best var: 34
DEBUG CAREFUL: Testing fvar[2] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 14
DEBUG CAREFUL: Testing fvar[3] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[4] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
  % Initial guess is x34, Z0 = 28148386.8266894        , Z1 = 28172107.503319         

DEBUG EVAL: Testing var 12 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=8, varin=30, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=32, varin=24, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=34, varin=21, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=38, varin=29, theta=0.075000, up=999999999999999983222784.000000
ITER 5: row=5, varin=45, theta=0.500000, up=1.000000
ITER 6: row=8, varin=42, theta=0.500000, up=1.000000
ITER 7: row=1, varin=37, theta=0.204509, up=999999999999999983222784.000000
ITER 8: row=28, varin=3, theta=0.294701, up=999999999999999983222784.000000
ITER 9: row=36, varin=68, theta=0.797817, up=1.000000
DEBUG EVAL: Branch var 12 = 1 gives z=28504021.553834
  % 	x12 = 1,	Z1 = 28504021.5538339        
DEBUG EVAL: First branch cutoff check: z=28504021.553834, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 0
ITER 1: row=8, varin=33, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=38, varin=29, theta=0.075000, up=999999999999999983222784.000000
ITER 3: row=5, varin=42, theta=0.500000, up=1.000000
ITER 4: row=1, varin=27, theta=0.399308, up=999999999999999983222784.000000
  % 	x12 = 0,	Z0 = 28203986.4068063        
DEBUG EVAL: Second branch cutoff check: z=28203986.406806, best_z=INF, threshold=INF
  %   New best:  x12, Z = 28203986.4068063        
DEBUG EVAL: Testing var 34 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=20, varin=33, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=38, varin=29, theta=0.075000, up=999999999999999983222784.000000
ITER 3: row=5, varin=45, theta=0.333333, up=1.000000
DEBUG EVAL: Branch var 34 = 0 gives z=28182614.604956
  % 	x34 = 0,	Z0 = 28182614.604956         
DEBUG EVAL: First branch cutoff check: z=28182614.604956, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 14 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=14, varin=30, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=32, varin=24, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=34, varin=27, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=38, varin=29, theta=0.075000, up=999999999999999983222784.000000
ITER 5: row=5, varin=45, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 14 = 0 gives z=28310086.913268
  % 	x14 = 0,	Z0 = 28310086.9132677        
DEBUG EVAL: First branch cutoff check: z=28310086.913268, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 14 = 1
ITER 1: row=14, varin=33, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=38, varin=29, theta=0.075000, up=999999999999999983222784.000000
ITER 3: row=5, varin=42, theta=0.500000, up=1.000000
ITER 4: row=1, varin=37, theta=0.306256, up=999999999999999983222784.000000
ITER 5: row=28, varin=3, theta=0.500520, up=999999999999999983222784.000000
ITER 6: row=36, varin=68, theta=1.355013, up=1.000000
ITER 7: row=36, varin=45, theta=0.339873, up=1.000000
ITER 8: row=20, varin=62, theta=0.914818, up=1.000000
ITER 9: row=10, varin=28, theta=0.115055, up=999999999999999983222784.000000
ITER 10: row=31, varin=65, theta=0.288363, up=1.000000
  % 	x14 = 1,	Z1 = 28382551.4980716        
DEBUG EVAL: Second branch cutoff check: z=28382551.498072, best_z=INF, threshold=INF
  %   New best:  x14, Z = 28310086.9132677        
DEBUG EVAL: Testing var 1 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=37, theta=1.085483, up=999999999999999983222784.000000
ITER 2: row=28, varin=30, theta=2.147633, up=999999999999999983222784.000000
ITER 3: row=32, varin=35, theta=2.303815, up=999999999999999983222784.000000
ITER 4: row=38, varin=29, theta=0.172300, up=999999999999999983222784.000000
ITER 5: row=1, varin=28, theta=0.912306, up=999999999999999983222784.000000
ITER 6: row=5, varin=45, theta=1.377569, up=1.000000
ITER 7: row=5, varin=68, theta=0.563786, up=1.000000
ITER 8: row=28, varin=27, theta=1.000000, up=999999999999999983222784.000000
ITER 9: row=37, varin=30, theta=0.415198, up=999999999999999983222784.000000
ITER 10: row=27, varin=45, theta=0.905272, up=1.000000
DEBUG EVAL: Branch var 1 = 1 gives z=28532902.749415
  % 	x1 = 1,	Z1 = 28532902.7494152        
DEBUG EVAL: First branch cutoff check: z=28532902.749415, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 0
ITER 1: row=2, varin=49, theta=0.178722, up=1.000000
  % 	x1 = 0,	Z0 = 28140525.3208829        
DEBUG EVAL: Second branch cutoff check: z=28140525.320883, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 0 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=37, theta=1.085483, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 0 = 1 gives z=28180923.583242
  % 	x0 = 1,	Z1 = 28197809.0992307        
DEBUG EVAL: First branch cutoff check: z=28197809.099231, best_z=INF, threshold=INF
  % Best branch is x14, Z0 = 28310086.9132677        , Z1 = 28382551.4980716        

DEBUG CAREFUL: Final result - returning best.var = 14
DEBUG BB: Branching variable chosen: j=14
 % @NC   25   17	x14 = 0	28310086.913268
 % @NC   26   17	x14 = 1	28382551.498072
 %      17    13 28138734.1809               28154044.6116    x5 U    12     7
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabd7f60
% @LO 0.03  28.13873418087244360208 99.9000000000
% @LN 0.03  28.15404461158967919232 99.9000000000
% Resuming node 14 at  28.15404461158967919232
DEBUG CONSTRNT: LP rows=38, pool->nlprows=38, pool->npend=0
DEBUG CONSTRNT: Checking 38 LP rows (pool tracks 38, total LP rows 38)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=37, expected 37
 % @PAP adding 46 rows, 233 nz to LP
DEBUG BB: Processing node 14, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=10, varin=76, theta=3.694201, up=1.000000
ITER 2: row=10, varin=31, theta=1.028633, up=999999999999999983222784.000000
ITER 3: row=24, varin=76, theta=0.702975, up=1.000000
ITER 4: row=20, varin=10, theta=1.118739, up=999999999999999983222784.000000
ITER 5: row=24, varin=39, theta=0.433604, up=999999999999999983222784.000000
ITER 6: row=39, varin=73, theta=1.251284, up=1.000000
ITER 7: row=39, varin=2, theta=0.202880, up=999999999999999983222784.000000
ITER 8: row=46, varin=73, theta=1.000000, up=1.000000
ITER 9: row=2, varin=37, theta=0.875214, up=999999999999999983222784.000000
ITER 10: row=1, varin=46, theta=0.073427, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=11)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28154044.611590
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 293 nonzeros, 3 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 5 rows, 17 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=78, theta=0.801609, up=1.000000
ITER 2: row=46, varin=54, theta=0.817378, up=1.000000
ITER 3: row=42, varin=52, theta=1.201669, up=1.000000
ITER 4: row=42, varin=75, theta=0.356838, up=1.000000
ITER 5: row=20, varin=52, theta=1.056608, up=1.000000
ITER 6: row=20, varin=8, theta=0.062235, up=999999999999999983222784.000000
ITER 7: row=42, varin=52, theta=0.624288, up=1.000000
ITER 8: row=23, varin=73, theta=0.301093, up=1.000000
ITER 9: row=16, varin=75, theta=1.000000, up=1.000000
ITER 10: row=2, varin=102, theta=0.323347, up=1.000000
LP PHASE: Switching to primal (iter=16)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28253172.632349
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 310 nonzeros, 5 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 4 rows, 19 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=72, theta=0.633893, up=1.000000
ITER 2: row=50, varin=54, theta=0.240274, up=1.000000
ITER 3: row=36, varin=61, theta=0.182932, up=1.000000
ITER 4: row=49, varin=47, theta=0.175958, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28291343.791492
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 319 nonzeros, 2 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 4 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=96, theta=0.147444, up=1.000000
ITER 2: row=40, varin=77, theta=1.085213, up=1.000000
ITER 3: row=40, varin=15, theta=0.012098, up=999999999999999983222784.000000
ITER 4: row=3, varin=77, theta=1.000000, up=1.000000
ITER 5: row=10, varin=81, theta=0.862166, up=1.000000
ITER 6: row=31, varin=75, theta=1.215245, up=1.000000
ITER 7: row=31, varin=83, theta=0.286632, up=1.000000
ITER 8: row=43, varin=80, theta=0.173311, up=1.000000
ITER 9: row=36, varin=35, theta=0.120827, up=999999999999999983222784.000000
ITER 10: row=11, varin=21, theta=0.032008, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=12)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28566211.248411
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.825793
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.982026
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.883479
DEBUG SOLUTION: lp->best_solution[13] = 2.883479
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 328 nonzeros, 8 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 8 slack rows
  % @PAP adding 8 rows, 19 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=81, theta=8.722504, up=1.000000
ITER 2: row=50, varin=75, theta=1.041208, up=1.000000
ITER 3: row=50, varin=31, theta=0.155105, up=999999999999999983222784.000000
ITER 4: row=46, varin=67, theta=0.315588, up=1.000000
ITER 5: row=27, varin=75, theta=0.041439, up=1.000000
ITER 6: row=47, varin=6, theta=0.305096, up=999999999999999983222784.000000
ITER 7: row=6, varin=98, theta=0.126168, up=1.000000
ITER 8: row=37, varin=54, theta=0.215132, up=1.000000
ITER 9: row=47, varin=85, theta=0.417858, up=1.000000
ITER 10: row=15, varin=6, theta=0.105877, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.825793
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.982026
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.883479
DEBUG SOLUTION: lp->best_solution[13] = 2.883479
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 329 nonzeros, 7 slack, 45 tight.
  % Node 14 LP 1 Solution, length = 999999999999999983222784.000000, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.116521 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.027268 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.017974 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 1.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.002247 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.116521 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.825793 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.982026 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.883479 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.850680 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.997753 (terminal 19)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 14 is INFEASIBLE
 %      14    12    infeasible               28156360.4625    x5 U    10     6
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabbedc0
% @LO 0.03  28.15404461158967919232 99.9000000000
% @LN 0.03  28.15636046252106083898 99.9000000000
% Resuming node 23 at  28.15636046252106083898
DEBUG CONSTRNT: LP rows=52, pool->nlprows=52, pool->npend=0
DEBUG CONSTRNT: Checking 52 LP rows (pool tracks 52, total LP rows 52)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 150
DEBUG CONSTRNT: Pool row 150 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=51, expected 51
 % @PAP adding 50 rows, 226 nz to LP
DEBUG BB: Processing node 23, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=28, varin=46, theta=0.561861, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28156360.462521
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 286 nonzeros, 1 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 4 rows, 22 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=67, theta=1.438505, up=1.000000
ITER 2: row=50, varin=28, theta=0.034578, up=999999999999999983222784.000000
ITER 3: row=17, varin=67, theta=1.000000, up=1.000000
ITER 4: row=53, varin=75, theta=0.303152, up=1.000000
ITER 5: row=25, varin=50, theta=0.380500, up=999999999999999983222784.000000
ITER 6: row=3, varin=84, theta=0.363255, up=1.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28172136.778558
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 53 rows, 60 cols, 306 nonzeros, 0 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=54, varin=32, theta=0.017032, up=999999999999999983222784.000000
ITER 2: row=44, varin=59, theta=0.509336, up=1.000000
ITER 3: row=50, varin=89, theta=0.570716, up=1.000000
ITER 4: row=55, varin=72, theta=0.312436, up=1.000000
ITER 5: row=17, varin=21, theta=0.118441, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
ITER 6: row=32, varin=50, theta=0.000000, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 28189478.868808
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 55 rows, 60 cols, 311 nonzeros, 4 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % Node 23 LP 1 Solution, length = 28189478.868808, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.500000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.118441 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.118441 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.500000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.381559 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.118441 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.118441 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.500000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.881559 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.881559 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.881559 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 8 fractional variables
DEBUG CG: LP optimal, z=28189478.868808, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 23 at  28.18947886880835085321
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabbed00
% @LO 0.03  28.15636046252106083898 99.9000000000
% @LN 0.03  28.16642062157985648696 99.9000000000
% Resuming node 6 at  28.16642062157985648696
DEBUG CONSTRNT: LP rows=51, pool->nlprows=51, pool->npend=0
DEBUG CONSTRNT: Checking 51 LP rows (pool tracks 51, total LP rows 51)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 143
DEBUG CONSTRNT: Pool row 143 has lprow=50, expected 50
 % @PAP adding 52 rows, 226 nz to LP
DEBUG BB: Processing node 6, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 6 LP 4 Solution, length = 28166420.621580, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.064614 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.064614 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.064614 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.064614 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.064614 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.176932 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 1.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.064614 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.064614 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.176932 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.064614 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.176932 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.935386 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.935386 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.935386 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.935386 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.935386 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.935386 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.823068 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.823068 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.935386 (terminal 19)
 % 11 fractional variables
DEBUG CG: LP optimal, z=28166420.621580, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28166420.621580, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 6 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 6
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.064614
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.064614)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.064614
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.064614)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.064614
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.064614)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.064614
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.064614)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.064614
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.064614)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.176932
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.176932)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=1.000000
DEBUG CAREFUL: Skipping var 16: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.064614
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.064614)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.064614
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.064614)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.176932
DEBUG CAREFUL: Adding var 21 to fractional list (xi=0.176932)
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.064614
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.064614)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.176932
DEBUG CAREFUL: Adding var 25 to fractional list (xi=0.176932)
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 11 fractional variables

  %  Carefully choosing branching variable, nfrac = 11
DEBUG CAREFUL: Testing fvar[0] = var 21
DEBUG CAREFUL: Calling compare_branch_vars for var 21
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 21
DEBUG CAREFUL: New best var: 21
DEBUG CAREFUL: Testing fvar[1] = var 25
DEBUG CAREFUL: Calling compare_branch_vars for var 25
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 25
DEBUG CAREFUL: New best var: 25
DEBUG CAREFUL: Testing fvar[2] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
DEBUG CAREFUL: Testing fvar[3] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[4] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
DEBUG CAREFUL: Testing fvar[5] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[6] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[7] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 22
DEBUG CAREFUL: Testing fvar[8] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 4
DEBUG CAREFUL: New best var: 4
DEBUG CAREFUL: Testing fvar[9] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[10] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 11
  % Initial guess is x4, Z0 = 28166420.6215799        , Z1 = 28568987.8342888        

DEBUG EVAL: Testing var 21 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=40, varin=37, theta=0.852378, up=999999999999999983222784.000000
ITER 2: row=13, varin=50, theta=3.152202, up=999999999999999983222784.000000
ITER 3: row=11, varin=42, theta=1.387194, up=999999999999999983222784.000000
ITER 4: row=42, varin=38, theta=0.362377, up=999999999999999983222784.000000
ITER 5: row=38, varin=47, theta=0.426467, up=999999999999999983222784.000000
ITER 6: row=35, varin=3, theta=0.336691, up=999999999999999983222784.000000
ITER 7: row=46, varin=43, theta=0.486537, up=999999999999999983222784.000000
ITER 8: row=4, varin=46, theta=1.406315, up=999999999999999983222784.000000
ITER 9: row=1, varin=9, theta=0.252389, up=999999999999999983222784.000000
ITER 10: row=3, varin=31, theta=0.343452, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 21 = 1 gives z=28314616.326986
  % 	x21 = 1,	Z1 = 28314616.3269856        
DEBUG EVAL: First branch cutoff check: z=28314616.326986, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 21 = 0
ITER 1: row=40, varin=80, theta=0.321032, up=1.000000
  % 	x21 = 0,	Z0 = 28182295.7847794        
DEBUG EVAL: Second branch cutoff check: z=28182295.784779, best_z=INF, threshold=INF
  %   New best:  x21, Z = 28182295.7847794        
DEBUG EVAL: Testing var 25 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=42, varin=37, theta=0.852378, up=999999999999999983222784.000000
ITER 2: row=13, varin=50, theta=3.152202, up=999999999999999983222784.000000
ITER 3: row=11, varin=38, theta=1.298281, up=999999999999999983222784.000000
ITER 4: row=38, varin=47, theta=1.696020, up=999999999999999983222784.000000
ITER 5: row=35, varin=40, theta=1.212298, up=999999999999999983222784.000000
ITER 6: row=40, varin=3, theta=0.262135, up=999999999999999983222784.000000
ITER 7: row=3, varin=43, theta=0.378799, up=999999999999999983222784.000000
ITER 8: row=4, varin=7, theta=0.217200, up=999999999999999983222784.000000
ITER 9: row=7, varin=46, theta=1.094905, up=999999999999999983222784.000000
ITER 10: row=1, varin=31, theta=0.267399, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 25 = 1 gives z=28371460.768063
  % 	x25 = 1,	Z1 = 28371460.7680632        
DEBUG EVAL: First branch cutoff check: z=28371460.768063, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 25 = 0
ITER 1: row=42, varin=80, theta=0.321032, up=1.000000
  % 	x25 = 0,	Z0 = 28182295.7847794        
DEBUG EVAL: Second branch cutoff check: z=28182295.784779, best_z=INF, threshold=INF
  %   New best:  x25, Z = 28182295.7847794        
DEBUG EVAL: Testing var 12 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=23, varin=80, theta=0.321032, up=1.000000
DEBUG EVAL: Branch var 12 = 0 gives z=28182295.784779
  % 	x12 = 0,	Z0 = 28182295.7847794        
DEBUG EVAL: First branch cutoff check: z=28182295.784779, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 1
ITER 1: row=23, varin=37, theta=0.852378, up=999999999999999983222784.000000
ITER 2: row=13, varin=50, theta=3.152202, up=999999999999999983222784.000000
ITER 3: row=11, varin=42, theta=1.387194, up=999999999999999983222784.000000
ITER 4: row=42, varin=38, theta=0.362377, up=999999999999999983222784.000000
ITER 5: row=38, varin=47, theta=0.426467, up=999999999999999983222784.000000
ITER 6: row=35, varin=40, theta=0.272679, up=999999999999999983222784.000000
  % 	x12 = 1,	Z1 = 28255277.6126207        
DEBUG EVAL: Second branch cutoff check: z=28255277.612621, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=82, theta=0.391629, up=1.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28185955.952428
  % 	x10 = 0,	Z0 = 28185955.9524278        
DEBUG EVAL: First branch cutoff check: z=28185955.952428, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 1
ITER 1: row=6, varin=37, theta=1.541311, up=999999999999999983222784.000000
ITER 2: row=13, varin=50, theta=6.329663, up=999999999999999983222784.000000
ITER 3: row=11, varin=47, theta=5.678187, up=999999999999999983222784.000000
ITER 4: row=35, varin=16, theta=2.911001, up=999999999999999983222784.000000
ITER 5: row=45, varin=32, theta=2.560862, up=999999999999999983222784.000000
ITER 6: row=6, varin=46, theta=3.304711, up=999999999999999983222784.000000
ITER 7: row=1, varin=27, theta=1.226258, up=999999999999999983222784.000000
ITER 8: row=23, varin=80, theta=1.395067, up=1.000000
ITER 9: row=23, varin=81, theta=0.397989, up=1.000000
ITER 10: row=48, varin=80, theta=-188.983120, up=1.000000
  % 	x10 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: Second branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=6, varin=82, theta=0.391629, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28185955.952428
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
   % @PL 52 rows, 60 cols, 286 nonzeros, 2 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
   % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=18, theta=0.071406, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28195608.513562
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.928594
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
   % @PL 52 rows, 60 cols, 283 nonzeros, 2 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 6 at  28.19560851356180464222
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabad4e0
% @LO 0.03  28.16642062157985648696 99.9000000000
% @LN 0.03  28.17963477526728510725 99.9000000000
% Resuming node 13 at  28.17963477526728510725
DEBUG CONSTRNT: LP rows=50, pool->nlprows=50, pool->npend=0
DEBUG CONSTRNT: Checking 50 LP rows (pool tracks 50, total LP rows 50)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=49, expected 49
 % @PAP adding 45 rows, 223 nz to LP
DEBUG BB: Processing node 13, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 13 LP 2 Solution, length = 28179634.775267, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.095182 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.500000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.095182 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.095182 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.095182 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.024090 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.500000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.904818 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.904818 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.904818 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.904818 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.904818 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=28179634.775267, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28179634.775267, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 13 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 13
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.095182
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.095182)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.500000
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.095182
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.095182)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=1.000000
DEBUG CAREFUL: Skipping var 15: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.095182
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.095182)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.095182
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.095182)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.024090
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.024090)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.500000
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 7 fractional variables

  %  Carefully choosing branching variable, nfrac = 7
DEBUG CAREFUL: Testing fvar[0] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 9
DEBUG CAREFUL: New best var: 9
DEBUG CAREFUL: Testing fvar[1] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 34
DEBUG CAREFUL: New best var: 34
DEBUG CAREFUL: Testing fvar[2] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 26
DEBUG CAREFUL: New best var: 26
DEBUG CAREFUL: Testing fvar[3] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[4] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
DEBUG CAREFUL: Testing fvar[5] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[6] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
  % Initial guess is x18, Z0 = 28179634.7752673        , Z1 = 28523074.7357445        

DEBUG EVAL: Testing var 9 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=14, varin=45, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=34, varin=4, theta=0.020100, up=999999999999999983222784.000000
ITER 3: row=31, varin=72, theta=-0.576552, up=1.000000
ITER 4: row=44, varin=35, theta=0.024974, up=999999999999999983222784.000000
ITER 5: row=31, varin=75, theta=0.151042, up=1.000000
ITER 6: row=19, varin=15, theta=0.109775, up=999999999999999983222784.000000
ITER 7: row=9, varin=67, theta=0.338190, up=1.000000
ITER 8: row=31, varin=32, theta=0.146457, up=999999999999999983222784.000000
ITER 9: row=32, varin=37, theta=0.097888, up=999999999999999983222784.000000
ITER 10: row=5, varin=3, theta=0.123925, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 9 = 1 gives z=28360698.646508
  % 	x9 = 1,	Z1 = 28360698.6465083        
DEBUG EVAL: First branch cutoff check: z=28360698.646508, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 0
ITER 1: row=14, varin=32, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=34, varin=46, theta=0.553922, up=1.000000
ITER 3: row=41, varin=10, theta=0.470472, up=999999999999999983222784.000000
ITER 4: row=10, varin=44, theta=0.443048, up=999999999999999983222784.000000
ITER 5: row=44, varin=36, theta=0.430456, up=999999999999999983222784.000000
  % 	x9 = 0,	Z0 = 28279019.5420122        
DEBUG EVAL: Second branch cutoff check: z=28279019.542012, best_z=INF, threshold=INF
  %   New best:  x9, Z = 28279019.5420122        
DEBUG EVAL: Testing var 34 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=32, varin=60, theta=1.000000, up=1.000000
ITER 2: row=25, varin=24, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 34 = 1 gives z=28474396.125051
  % 	x34 = 1,	Z1 = 28474396.125051         
DEBUG EVAL: First branch cutoff check: z=28474396.125051, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 34 = 0
ITER 1: row=32, varin=32, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=34, varin=45, theta=0.280759, up=999999999999999983222784.000000
  % 	x34 = 0,	Z0 = 28249480.457551         
DEBUG EVAL: Second branch cutoff check: z=28249480.457551, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 26 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=34, varin=46, theta=1.293568, up=1.000000
ITER 2: row=34, varin=10, theta=0.249341, up=999999999999999983222784.000000
ITER 3: row=41, varin=46, theta=1.000000, up=1.000000
ITER 4: row=10, varin=44, theta=1.034645, up=999999999999999983222784.000000
ITER 5: row=44, varin=45, theta=0.932574, up=999999999999999983222784.000000
ITER 6: row=31, varin=3, theta=0.106118, up=999999999999999983222784.000000
ITER 7: row=10, varin=41, theta=0.034080, up=999999999999999983222784.000000
ITER 8: row=41, varin=37, theta=0.025806, up=999999999999999983222784.000000
ITER 9: row=5, varin=35, theta=0.015810, up=999999999999999983222784.000000
ITER 10: row=41, varin=5, theta=0.022051, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 1 gives z=28256035.130606
  % 	x26 = 1,	Z1 = 28262299.1442424        
DEBUG EVAL: First branch cutoff check: z=28262299.144242, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=9, varin=4, theta=0.972188, up=999999999999999983222784.000000
ITER 2: row=44, varin=46, theta=0.443492, up=1.000000
ITER 3: row=34, varin=75, theta=0.924710, up=1.000000
ITER 4: row=41, varin=15, theta=0.110730, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28213118.525221
  % 	x10 = 0,	Z0 = 28213118.5252207        
DEBUG EVAL: First branch cutoff check: z=28213118.525221, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=19, varin=39, theta=2.297604, up=999999999999999983222784.000000
ITER 2: row=31, varin=32, theta=2.712398, up=999999999999999983222784.000000
ITER 3: row=34, varin=3, theta=0.324341, up=999999999999999983222784.000000
ITER 4: row=44, varin=10, theta=1.215925, up=999999999999999983222784.000000
ITER 5: row=10, varin=37, theta=0.669294, up=999999999999999983222784.000000
ITER 6: row=32, varin=69, theta=13.112703, up=1.000000
ITER 7: row=32, varin=24, theta=0.975147, up=999999999999999983222784.000000
ITER 8: row=39, varin=72, theta=3.587643, up=1.000000
ITER 9: row=39, varin=15, theta=1.444847, up=999999999999999983222784.000000
ITER 10: row=44, varin=69, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 17 = 1 gives z=29012121.539486
  % 	x17 = 1,	Z1 = 29012121.5394857        
DEBUG EVAL: First branch cutoff check: z=29012121.539486, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 0
ITER 1: row=19, varin=4, theta=0.972188, up=999999999999999983222784.000000
  % 	x17 = 0,	Z0 = 28223042.0418356        
DEBUG EVAL: Second branch cutoff check: z=28223042.041836, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=5, varin=39, theta=2.297604, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 1 gives z=28322910.621693
  % 	x3 = 1,	Z1 = 28430291.1334261        
DEBUG EVAL: First branch cutoff check: z=28430291.133426, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=5, varin=37, theta=0.106905, up=999999999999999983222784.000000
  % 	x3 = 0,	Z0 = 28197215.8648638        
DEBUG EVAL: Second branch cutoff check: z=28197215.864864, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 18 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=31, varin=32, theta=4.802710, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 18 = 1 gives z=28501927.896257
  % 	x18 = 1,	Z1 = 28523074.7357445        
DEBUG EVAL: First branch cutoff check: z=28523074.735745, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 18 = 0
ITER 1: row=31, varin=39, theta=0.157017, up=999999999999999983222784.000000
  % 	x18 = 0,	Z0 = 28189426.1422079        
DEBUG EVAL: Second branch cutoff check: z=28189426.142208, best_z=INF, threshold=INF
  % Best branch is x9, Z0 = 28279019.5420122        , Z1 = 28360698.6465083        

DEBUG CAREFUL: Final result - returning best.var = 9
DEBUG BB: Branching variable chosen: j=9
 % @NC   27   13	x9 = 0	28279019.542012
 % @NC   28   13	x9 = 1	28360698.646508
 %      13    13 28179634.7753               28179852.8439    x5 D    10     6
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabd9c70
% @LO 0.03  28.17963477526728510725 99.9000000000
% @LN 0.03  28.17985284392407763221 99.9000000000
% Resuming node 18 at  28.17985284392407763221
DEBUG CONSTRNT: LP rows=45, pool->nlprows=45, pool->npend=0
DEBUG CONSTRNT: Checking 45 LP rows (pool tracks 45, total LP rows 45)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 150
DEBUG CONSTRNT: Pool row 150 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=44, expected 44
 % @PAP adding 39 rows, 201 nz to LP
DEBUG BB: Processing node 18, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 18 LP 2 Solution, length = 28179852.843924, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.500000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.802600 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.500000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.302600 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.500000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.197400 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.197400 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.197400 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28179852.843924, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28179852.843924, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 18 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 18
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.500000
DEBUG CAREFUL: Adding var 8 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.802600
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.802600)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.500000
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.500000
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.302600
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.302600)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.500000
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 8
DEBUG CAREFUL: Calling compare_branch_vars for var 8
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 8
DEBUG CAREFUL: New best var: 8
DEBUG CAREFUL: Testing fvar[1] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
DEBUG CAREFUL: Testing fvar[2] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 36
DEBUG CAREFUL: Testing fvar[3] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 14
DEBUG CAREFUL: Testing fvar[4] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 34
DEBUG CAREFUL: New best var: 34
DEBUG CAREFUL: Testing fvar[5] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x34, Z0 = 28179852.8439241        , Z1 = 28247792.5559299        

DEBUG EVAL: Testing var 8 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=24, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=33, varin=31, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 8 = 0 gives z=28262206.522951
  % 	x8 = 0,	Z0 = 28262206.5229507        
DEBUG EVAL: First branch cutoff check: z=28262206.522951, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 8 = 1
ITER 1: row=1, varin=23, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=32, varin=31, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=34, varin=38, theta=0.021931, up=999999999999999983222784.000000
  % 	x8 = 1,	Z1 = 28260545.8226733        
DEBUG EVAL: Second branch cutoff check: z=28260545.822673, best_z=INF, threshold=INF
  %   New best:  x8, Z = 28260545.8226733        
DEBUG EVAL: Testing var 12 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=17, varin=31, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 12 = 0 gives z=28205257.891356
  % 	x12 = 0,	Z0 = 28205257.8913558        
DEBUG EVAL: First branch cutoff check: z=28205257.891356, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 36 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=25, varin=24, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=33, varin=29, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=18, varin=33, theta=0.095929, up=999999999999999983222784.000000
ITER 4: row=25, varin=38, theta=0.012013, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 36 = 0 gives z=28212284.803490
  % 	x36 = 0,	Z0 = 28212284.8034899        
DEBUG EVAL: First branch cutoff check: z=28212284.803490, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 14 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=20, varin=23, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=32, varin=31, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=34, varin=38, theta=0.021931, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 14 = 0 gives z=28260545.822673
  % 	x14 = 0,	Z0 = 28260545.8226733        
DEBUG EVAL: First branch cutoff check: z=28260545.822673, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 14 = 1
ITER 1: row=20, varin=24, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=33, varin=31, theta=1.000000, up=999999999999999983222784.000000
  % 	x14 = 1,	Z1 = 28262206.5229507        
DEBUG EVAL: Second branch cutoff check: z=28262206.522951, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 34 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=34, varin=39, theta=0.101650, up=999999999999999983222784.000000
ITER 2: row=35, varin=38, theta=0.237248, up=999999999999999983222784.000000
ITER 3: row=36, varin=37, theta=0.193114, up=999999999999999983222784.000000
ITER 4: row=30, varin=2, theta=0.370566, up=999999999999999983222784.000000
ITER 5: row=2, varin=34, theta=0.250108, up=999999999999999983222784.000000
ITER 6: row=24, varin=31, theta=0.857593, up=999999999999999983222784.000000
ITER 7: row=17, varin=23, theta=0.784549, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 34 = 1 gives z=28248380.563552
  % 	x34 = 1,	Z1 = 28248380.5635525        
DEBUG EVAL: First branch cutoff check: z=28248380.563552, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=12, varin=39, theta=0.118857, up=999999999999999983222784.000000
ITER 2: row=35, varin=38, theta=0.357752, up=999999999999999983222784.000000
ITER 3: row=36, varin=24, theta=0.580068, up=999999999999999983222784.000000
ITER 4: row=33, varin=29, theta=0.470204, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28210185.741310
  % 	x10 = 1,	Z1 = 28210185.7413095        
DEBUG EVAL: First branch cutoff check: z=28210185.741310, best_z=INF, threshold=INF
  % Best branch is x8, Z0 = 28262206.5229507        , Z1 = 28260545.8226733        

DEBUG CAREFUL: Final result - returning best.var = 8
DEBUG BB: Branching variable chosen: j=8
 % @NC   29   18	x8 = 1	28260545.822673
 % @NC   30   18	x8 = 0	28262206.522951
 %      18    14 28179852.8439               28189478.8688    x5 D    12     7
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabbedc0
% @LO 0.03  28.17985284392407763221 99.9000000000
% @LN 0.03  28.18947886880835085321 99.9000000000
% Resuming node 23 at  28.18947886880835085321
DEBUG CONSTRNT: LP rows=39, pool->nlprows=39, pool->npend=0
DEBUG CONSTRNT: Checking 39 LP rows (pool tracks 39, total LP rows 39)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 62
DEBUG CONSTRNT: Pool row 62 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=38, expected 38
 % @PAP adding 51 rows, 232 nz to LP
DEBUG BB: Processing node 23, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 23 LP 2 Solution, length = 28189478.868808, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.500000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.118441 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.118441 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.500000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.381559 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.118441 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.118441 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.500000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.881559 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.881559 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.881559 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 8 fractional variables
DEBUG CG: LP optimal, z=28189478.868808, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28189478.868808, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 23 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 23
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.500000
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.500000
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.118441
DEBUG CAREFUL: Adding var 23 to fractional list (xi=0.118441)
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.118441
DEBUG CAREFUL: Adding var 24 to fractional list (xi=0.118441)
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.500000
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.381559
DEBUG CAREFUL: Adding var 33 to fractional list (xi=0.381559)
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.118441
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.118441)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.118441
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.118441)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 8 fractional variables

  %  Carefully choosing branching variable, nfrac = 8
DEBUG CAREFUL: Testing fvar[0] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 29
DEBUG CAREFUL: New best var: 29
DEBUG CAREFUL: Testing fvar[1] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 1
DEBUG CAREFUL: New best var: 1
DEBUG CAREFUL: Testing fvar[2] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 0
DEBUG CAREFUL: New best var: 0
DEBUG CAREFUL: Testing fvar[3] = var 33
DEBUG CAREFUL: Calling compare_branch_vars for var 33
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 33
DEBUG CAREFUL: Testing fvar[4] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 36
DEBUG CAREFUL: Testing fvar[5] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 34
DEBUG CAREFUL: Testing fvar[6] = var 23
DEBUG CAREFUL: Calling compare_branch_vars for var 23
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 23
DEBUG CAREFUL: Testing fvar[7] = var 24
DEBUG CAREFUL: Calling compare_branch_vars for var 24
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 24
  % Initial guess is x0, Z0 = 28189478.8688084        , Z1 = 29070077.4688528        

DEBUG EVAL: Testing var 29 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=12, varin=51, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=28, varin=50, theta=0.814432, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 29 = 0 gives z=28230560.480948
  % 	x29 = 0,	Z0 = 28230560.4809484        
DEBUG EVAL: First branch cutoff check: z=28230560.480948, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 29 = 1
ITER 1: row=12, varin=27, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=28, varin=50, theta=1.270949, up=999999999999999983222784.000000
ITER 3: row=16, varin=23, theta=0.216139, up=999999999999999983222784.000000
ITER 4: row=23, varin=41, theta=0.168815, up=999999999999999983222784.000000
ITER 5: row=47, varin=45, theta=0.255797, up=999999999999999983222784.000000
  % 	x29 = 1,	Z1 = 28275221.3967908        
DEBUG EVAL: Second branch cutoff check: z=28275221.396791, best_z=INF, threshold=INF
  %   New best:  x29, Z = 28230560.4809484        
DEBUG EVAL: Testing var 1 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=28, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=28, varin=30, theta=0.703698, up=999999999999999983222784.000000
ITER 3: row=46, varin=10, theta=1.693262, up=999999999999999983222784.000000
ITER 4: row=11, varin=65, theta=5.405938, up=1.000000
ITER 5: row=11, varin=37, theta=1.259777, up=999999999999999983222784.000000
ITER 6: row=10, varin=74, theta=1.449792, up=1.000000
ITER 7: row=10, varin=89, theta=1.105589, up=1.000000
ITER 8: row=10, varin=79, theta=0.040179, up=1.000000
ITER 9: row=47, varin=89, theta=1.448516, up=1.000000
ITER 10: row=47, varin=46, theta=0.211647, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 1 gives z=28813465.202323
  % 	x1 = 1,	Z1 = 28813465.2023231        
DEBUG EVAL: First branch cutoff check: z=28813465.202323, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 0
ITER 1: row=2, varin=51, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=28, varin=50, theta=0.814432, up=999999999999999983222784.000000
  % 	x1 = 0,	Z0 = 28230560.4809484        
DEBUG EVAL: Second branch cutoff check: z=28230560.480948, best_z=INF, threshold=INF
  %   New best:  x1, Z = 28230560.4809484        
DEBUG EVAL: Testing var 0 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=3, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=16, varin=51, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=35, varin=4, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=28, varin=30, theta=0.621258, up=999999999999999983222784.000000
ITER 5: row=46, varin=10, theta=1.494891, up=999999999999999983222784.000000
ITER 6: row=11, varin=65, theta=4.772616, up=1.000000
ITER 7: row=11, varin=27, theta=1.334582, up=999999999999999983222784.000000
ITER 8: row=16, varin=37, theta=0.674562, up=999999999999999983222784.000000
ITER 9: row=10, varin=74, theta=0.796086, up=1.000000
ITER 10: row=17, varin=65, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 0 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x0 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=51, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=28, varin=50, theta=0.814432, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28230560.480948
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 51 rows, 60 cols, 292 nonzeros, 2 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
   % @PAP adding 6 rows, 21 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=30, theta=0.231457, up=999999999999999983222784.000000
ITER 2: row=46, varin=23, theta=3.211618, up=999999999999999983222784.000000
ITER 3: row=52, varin=29, theta=0.232991, up=999999999999999983222784.000000
ITER 4: row=48, varin=46, theta=0.223401, up=999999999999999983222784.000000
ITER 5: row=40, varin=89, theta=2.659620, up=1.000000
ITER 6: row=40, varin=37, theta=0.384783, up=999999999999999983222784.000000
ITER 7: row=51, varin=89, theta=1.000000, up=1.000000
ITER 8: row=44, varin=45, theta=1.008294, up=999999999999999983222784.000000
ITER 9: row=46, varin=27, theta=1.000000, up=999999999999999983222784.000000
ITER 10: row=55, varin=93, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=10)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 28342018.031391
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 55 rows, 60 cols, 308 nonzeros, 1 slack, 54 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 4 rows, 20 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=58, varin=48, theta=0.555556, up=999999999999999983222784.000000
ITER 2: row=55, varin=58, theta=0.800000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=58)
DEBUG SOLUTION: LP solution array indices: FST[59-98], not_covered[99-118]
DEBUG SOLUTION: lp->best_solution[0] = 28347878.466692
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 58 rows, 60 cols, 326 nonzeros, 7 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 7 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 23 at  28.34787846669222943774
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595daba91d0
% @LO 0.03  28.18947886880835085321 99.9000000000
% @LN 0.03  28.19257331003466049424 99.9000000000
% Resuming node 7 at  28.19257331003466049424
DEBUG CONSTRNT: LP rows=51, pool->nlprows=51, pool->npend=0
DEBUG CONSTRNT: Checking 51 LP rows (pool tracks 51, total LP rows 51)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=50, expected 50
 % @PAP adding 47 rows, 229 nz to LP
DEBUG BB: Processing node 7, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 7 LP 5 Solution, length = 28192573.310035, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.341841 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.341841 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.341841 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.341841 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.341841 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.316318 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.341841 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.658159 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.658159 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.658159 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.658159 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.658159 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.658159 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=28192573.310035, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28192573.310035, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 7 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 7
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.341841
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.341841)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.341841
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.341841)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=1.000000
DEBUG CAREFUL: Skipping var 13: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.341841
DEBUG CAREFUL: Adding var 23 to fractional list (xi=0.341841)
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.341841
DEBUG CAREFUL: Adding var 24 to fractional list (xi=0.341841)
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.341841
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.341841)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.316318
DEBUG CAREFUL: Adding var 30 to fractional list (xi=0.316318)
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.341841
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.341841)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 7 fractional variables

  %  Carefully choosing branching variable, nfrac = 7
DEBUG CAREFUL: Testing fvar[0] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 29
DEBUG CAREFUL: New best var: 29
DEBUG CAREFUL: Testing fvar[1] = var 30
DEBUG CAREFUL: Calling compare_branch_vars for var 30
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 30
DEBUG CAREFUL: New best var: 30
DEBUG CAREFUL: Testing fvar[2] = var 23
DEBUG CAREFUL: Calling compare_branch_vars for var 23
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 23
DEBUG CAREFUL: Testing fvar[3] = var 24
DEBUG CAREFUL: Calling compare_branch_vars for var 24
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 24
DEBUG CAREFUL: Testing fvar[4] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[5] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 36
DEBUG CAREFUL: Testing fvar[6] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
  % Initial guess is x30, Z0 = 28192573.3100347        , Z1 = 28281093.8557052        

DEBUG EVAL: Testing var 29 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=20, varin=26, theta=1.085975, up=999999999999999983222784.000000
ITER 2: row=45, varin=17, theta=0.153192, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 29 = 0 gives z=28220267.669595
  % 	x29 = 0,	Z0 = 28220267.6695948        
DEBUG EVAL: First branch cutoff check: z=28220267.669595, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 29 = 1
ITER 1: row=20, varin=70, theta=4.841654, up=1.000000
ITER 2: row=20, varin=39, theta=0.851058, up=999999999999999983222784.000000
ITER 3: row=30, varin=70, theta=0.940573, up=1.000000
ITER 4: row=23, varin=37, theta=0.404716, up=999999999999999983222784.000000
ITER 5: row=43, varin=32, theta=2.732921, up=999999999999999983222784.000000
ITER 6: row=33, varin=73, theta=2.073666, up=1.000000
ITER 7: row=33, varin=44, theta=0.365919, up=999999999999999983222784.000000
ITER 8: row=46, varin=73, theta=1.000000, up=1.000000
ITER 9: row=42, varin=78, theta=0.635343, up=1.000000
  % 	x29 = 1,	Z1 = 28405732.6506853        
DEBUG EVAL: Second branch cutoff check: z=28405732.650685, best_z=INF, threshold=INF
  %   New best:  x29, Z = 28220267.6695948        
DEBUG EVAL: Testing var 30 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=30, varin=35, theta=0.445527, up=999999999999999983222784.000000
ITER 2: row=10, varin=26, theta=1.085975, up=999999999999999983222784.000000
ITER 3: row=45, varin=33, theta=1.094120, up=999999999999999983222784.000000
ITER 4: row=18, varin=32, theta=0.077965, up=999999999999999983222784.000000
ITER 5: row=44, varin=34, theta=0.027707, up=999999999999999983222784.000000
ITER 6: row=34, varin=28, theta=0.035728, up=999999999999999983222784.000000
ITER 7: row=28, varin=31, theta=0.048158, up=999999999999999983222784.000000
ITER 8: row=4, varin=8, theta=0.035451, up=999999999999999983222784.000000
ITER 9: row=8, varin=30, theta=0.036934, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 30 = 1 gives z=28236443.481863
  % 	x30 = 1,	Z1 = 28281093.8557052        
DEBUG EVAL: First branch cutoff check: z=28281093.855705, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 30 = 0
ITER 1: row=30, varin=70, theta=0.248703, up=1.000000
ITER 2: row=42, varin=73, theta=0.215923, up=1.000000
ITER 3: row=46, varin=47, theta=0.429204, up=999999999999999983222784.000000
  % 	x30 = 0,	Z0 = 28204385.5304836        
DEBUG EVAL: Second branch cutoff check: z=28204385.530484, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 23 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=26, theta=1.085975, up=999999999999999983222784.000000
ITER 2: row=45, varin=17, theta=0.153192, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 23 = 0 gives z=28220267.669595
  % 	x23 = 0,	Z0 = 28220267.6695948        
DEBUG EVAL: First branch cutoff check: z=28220267.669595, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 23 = 1
ITER 1: row=6, varin=70, theta=4.841654, up=1.000000
ITER 2: row=6, varin=39, theta=0.851058, up=999999999999999983222784.000000
ITER 3: row=30, varin=70, theta=0.940573, up=1.000000
ITER 4: row=23, varin=37, theta=0.404716, up=999999999999999983222784.000000
ITER 5: row=43, varin=8, theta=1.215513, up=999999999999999983222784.000000
ITER 6: row=42, varin=78, theta=1.149347, up=1.000000
ITER 7: row=42, varin=73, theta=0.093284, up=1.000000
ITER 8: row=46, varin=47, theta=0.191105, up=999999999999999983222784.000000
ITER 9: row=15, varin=34, theta=0.094086, up=999999999999999983222784.000000
ITER 10: row=34, varin=42, theta=0.355015, up=999999999999999983222784.000000
  % 	x23 = 1,	Z1 = 28412648.6266421        
DEBUG EVAL: Second branch cutoff check: z=28412648.626642, best_z=INF, threshold=INF
  %   New best:  x23, Z = 28220267.6695948        
DEBUG EVAL: Testing var 24 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=8, varin=26, theta=1.085975, up=999999999999999983222784.000000
ITER 2: row=45, varin=17, theta=0.153192, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 24 = 0 gives z=28220267.669595
  % 	x24 = 0,	Z0 = 28220267.6695948        
DEBUG EVAL: First branch cutoff check: z=28220267.669595, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 24 = 1
ITER 1: row=8, varin=70, theta=4.841654, up=1.000000
ITER 2: row=8, varin=39, theta=0.851058, up=999999999999999983222784.000000
ITER 3: row=30, varin=70, theta=0.940573, up=1.000000
ITER 4: row=23, varin=37, theta=0.404716, up=999999999999999983222784.000000
ITER 5: row=43, varin=6, theta=1.160052, up=999999999999999983222784.000000
ITER 6: row=6, varin=73, theta=1.860749, up=1.000000
ITER 7: row=6, varin=34, theta=0.605164, up=999999999999999983222784.000000
ITER 8: row=46, varin=73, theta=1.000000, up=1.000000
ITER 9: row=34, varin=78, theta=12.835716, up=1.000000
ITER 10: row=34, varin=47, theta=6.123455, up=999999999999999983222784.000000
  % 	x24 = 1,	Z1 = 28789576.8049208        
DEBUG EVAL: Second branch cutoff check: z=28789576.804921, best_z=INF, threshold=INF
  %   New best:  x24, Z = 28220267.6695948        
DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=17, theta=0.153192, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 0 gives z=28220267.669595
  % 	x1 = 0,	Z0 = 28220267.6695948        
DEBUG EVAL: First branch cutoff check: z=28220267.669595, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 1
ITER 1: row=2, varin=26, theta=0.960505, up=999999999999999983222784.000000
  % 	x1 = 1,	Z1 = 28207167.2458479        
DEBUG EVAL: Second branch cutoff check: z=28207167.245848, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 36 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=18, varin=26, theta=1.085975, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 36 = 0 gives z=28209073.649947
  % 	x36 = 0,	Z0 = 28209073.6499465        
DEBUG EVAL: First branch cutoff check: z=28209073.649947, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 0 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=26, theta=1.085975, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 0 = 0 gives z=28209073.649947
  % 	x0 = 0,	Z0 = 28209073.6499465        
DEBUG EVAL: First branch cutoff check: z=28209073.649947, best_z=INF, threshold=INF
  % Best branch is x24, Z0 = 28220267.6695948        , Z1 = 28789576.8049208        

DEBUG CAREFUL: Final result - returning best.var = 24
DEBUG BB: Branching variable chosen: j=24
 % @NC   31    7	x24 = 0	28220267.669595
 % @NC   32    7	x24 = 1	28789576.804921
 %       7    15 28192573.3100               28195608.5136   x13 U     5     4
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabbed00
% @LO 0.03  28.19257331003466049424 99.9000000000
% @LN 0.03  28.19560851356180464222 99.9000000000
% Resuming node 6 at  28.19560851356180464222
DEBUG CONSTRNT: LP rows=47, pool->nlprows=47, pool->npend=0
DEBUG CONSTRNT: Checking 47 LP rows (pool tracks 47, total LP rows 47)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=46, expected 46
 % @PAP adding 50 rows, 219 nz to LP
DEBUG BB: Processing node 6, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 6 LP 5 Solution, length = 28195608.513562, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.071406 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.071406 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.071406 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.071406 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.178675 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 1.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.071406 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.071406 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.178675 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.071406 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.178675 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.928594 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.928594 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.928594 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.928594 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.928594 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.821325 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.821325 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.928594 (terminal 19)
 % 10 fractional variables
DEBUG CG: LP optimal, z=28195608.513562, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28195608.513562, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 6 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 6
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.071406
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.071406)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.071406
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.071406)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.071406
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.071406)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.071406
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.071406)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.178675
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.178675)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=1.000000
DEBUG CAREFUL: Skipping var 16: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.071406
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.071406)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.071406
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.071406)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.178675
DEBUG CAREFUL: Adding var 21 to fractional list (xi=0.178675)
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.071406
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.071406)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.178675
DEBUG CAREFUL: Adding var 25 to fractional list (xi=0.178675)
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 10 fractional variables

  %  Carefully choosing branching variable, nfrac = 10
DEBUG CAREFUL: Testing fvar[0] = var 21
DEBUG CAREFUL: Calling compare_branch_vars for var 21
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 21
DEBUG CAREFUL: New best var: 21
DEBUG CAREFUL: Testing fvar[1] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
DEBUG CAREFUL: Testing fvar[2] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[3] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[4] = var 25
DEBUG CAREFUL: Calling compare_branch_vars for var 25
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 25
DEBUG CAREFUL: Testing fvar[5] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 22
DEBUG CAREFUL: Testing fvar[6] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
DEBUG CAREFUL: Testing fvar[7] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 4
DEBUG CAREFUL: New best var: 4
DEBUG CAREFUL: Testing fvar[8] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[9] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 11
  % Initial guess is x4, Z0 = 28195608.5135618        , Z1 = 28568987.8342888        

DEBUG EVAL: Testing var 21 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=38, varin=40, theta=1.406937, up=999999999999999983222784.000000
ITER 2: row=40, varin=36, theta=0.379613, up=999999999999999983222784.000000
ITER 3: row=36, varin=46, theta=0.563544, up=999999999999999983222784.000000
ITER 4: row=11, varin=3, theta=0.383639, up=999999999999999983222784.000000
ITER 5: row=3, varin=43, theta=0.391258, up=999999999999999983222784.000000
ITER 6: row=33, varin=29, theta=0.359563, up=999999999999999983222784.000000
ITER 7: row=49, varin=35, theta=0.348473, up=999999999999999983222784.000000
ITER 8: row=27, varin=41, theta=0.429029, up=999999999999999983222784.000000
ITER 9: row=41, varin=50, theta=0.256439, up=999999999999999983222784.000000
ITER 10: row=26, varin=7, theta=0.242532, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 21 = 1 gives z=28344440.909002
  % 	x21 = 1,	Z1 = 28344440.9090025        
DEBUG EVAL: First branch cutoff check: z=28344440.909002, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 21 = 0
ITER 1: row=38, varin=78, theta=0.324356, up=1.000000
  % 	x21 = 0,	Z0 = 28213146.5638615        
DEBUG EVAL: Second branch cutoff check: z=28213146.563862, best_z=INF, threshold=INF
  %   New best:  x21, Z = 28213146.5638615        
DEBUG EVAL: Testing var 18 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=30, varin=50, theta=2.546468, up=999999999999999983222784.000000
ITER 2: row=2, varin=35, theta=1.384574, up=999999999999999983222784.000000
ITER 3: row=27, varin=46, theta=5.685999, up=999999999999999983222784.000000
ITER 4: row=11, varin=43, theta=4.992431, up=999999999999999983222784.000000
ITER 5: row=33, varin=42, theta=3.800983, up=999999999999999983222784.000000
ITER 6: row=1, varin=24, theta=2.448191, up=999999999999999983222784.000000
ITER 7: row=32, varin=41, theta=11.169479, up=999999999999999983222784.000000
ITER 8: row=4, varin=78, theta=49.299385, up=1.000000
ITER 9: row=4, varin=79, theta=51.471037, up=1.000000
ITER 10: row=4, varin=25, theta=2.667441, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 18 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x18 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=30, varin=81, theta=0.473049, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28214477.804775
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 50 rows, 60 cols, 279 nonzeros, 0 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=26, theta=0.251274, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28221939.999764
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 52 rows, 60 cols, 283 nonzeros, 1 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 6 at  28.22193999976436629140
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabb5780
% @LO 0.04  28.19560851356180464222 99.9000000000
% @LN 0.04  28.20964769718324305359 99.9000000000
% Resuming node 11 at  28.20964769718324305359
DEBUG CONSTRNT: LP rows=51, pool->nlprows=51, pool->npend=0
DEBUG CONSTRNT: Checking 51 LP rows (pool tracks 51, total LP rows 51)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=50, expected 50
 % @PAP adding 51 rows, 219 nz to LP
DEBUG BB: Processing node 11, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 11 LP 3 Solution, length = 28209647.697183, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.104464 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.104464 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.164287 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.104464 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.104464 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.104464 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.104464 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.104464 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.164287 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.835713 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.895536 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.895536 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.835713 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.895536 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.895536 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.895536 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.895536 (terminal 19)
 % 9 fractional variables
DEBUG CG: LP optimal, z=28209647.697183, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28209647.697183, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 11 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 11
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.104464
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.104464)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.104464
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.104464)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.164287
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.164287)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=1.000000
DEBUG CAREFUL: Skipping var 9: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.104464
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.104464)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.104464
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.104464)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.104464
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.104464)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.104464
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.104464)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.104464
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.104464)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.164287
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.164287)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 9 fractional variables

  %  Carefully choosing branching variable, nfrac = 9
DEBUG CAREFUL: Testing fvar[0] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 10
DEBUG CAREFUL: New best var: 10
DEBUG CAREFUL: Testing fvar[1] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
DEBUG CAREFUL: Testing fvar[2] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
DEBUG CAREFUL: Testing fvar[3] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 22
DEBUG CAREFUL: Testing fvar[4] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[5] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[6] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[7] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 5
DEBUG CAREFUL: Testing fvar[8] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 36
  % Initial guess is x18, Z0 = 28209647.6971832        , Z1 = 28523074.7357445        

DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=9, varin=81, theta=0.746728, up=1.000000
ITER 2: row=2, varin=51, theta=2.729374, up=999999999999999983222784.000000
ITER 3: row=45, varin=43, theta=0.985582, up=999999999999999983222784.000000
ITER 4: row=14, varin=77, theta=0.156283, up=1.000000
ITER 5: row=2, varin=47, theta=0.332208, up=999999999999999983222784.000000
ITER 6: row=42, varin=7, theta=0.289028, up=999999999999999983222784.000000
ITER 7: row=6, varin=40, theta=0.074016, up=999999999999999983222784.000000
ITER 8: row=41, varin=49, theta=0.337685, up=999999999999999983222784.000000
ITER 9: row=1, varin=34, theta=0.080191, up=999999999999999983222784.000000
ITER 10: row=27, varin=79, theta=1.637022, up=1.000000
DEBUG EVAL: Branch var 10 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x10 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=9, varin=7, theta=0.083933, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28214031.363501
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.580333
DEBUG SOLUTION: lp->best_solution[5] = 2.580333
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.916067
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1000000.000000
   % @PL 51 rows, 60 cols, 279 nonzeros, 4 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 4 slack rows
   % @PAP adding 4 rows, 11 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=36, theta=0.316747, up=999999999999999983222784.000000
ITER 2: row=40, varin=43, theta=0.829265, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28219055.006238
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 51 rows, 60 cols, 280 nonzeros, 2 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 11 at  28.21905500623775608915
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabb5780
% @LO 0.04  28.20964769718324305359 99.9000000000
% @LN 0.04  28.21905500623775608915 99.9000000000
% Resuming node 11 at  28.21905500623775608915
DEBUG CONSTRNT: LP rows=49, pool->nlprows=49, pool->npend=0
DEBUG CONSTRNT: Checking 49 LP rows (pool tracks 49, total LP rows 49)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=48, expected 48
 % @PAP adding 49 rows, 211 nz to LP
DEBUG BB: Processing node 11, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 11 LP 4 Solution, length = 28219055.006238, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.447156 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.276422 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.276422 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.276422 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.447156 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.552844 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.552844 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.723578 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.723578 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28219055.006238, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28219055.006238, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 11 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 11
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.447156
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.447156)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=1.000000
DEBUG CAREFUL: Skipping var 9: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.276422
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.276422)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.276422
DEBUG CAREFUL: Adding var 21 to fractional list (xi=0.276422)
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.276422
DEBUG CAREFUL: Adding var 25 to fractional list (xi=0.276422)
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.447156
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.447156)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 5
DEBUG CAREFUL: New best var: 5
DEBUG CAREFUL: Testing fvar[1] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 36
DEBUG CAREFUL: Testing fvar[2] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
DEBUG CAREFUL: Testing fvar[3] = var 21
DEBUG CAREFUL: Calling compare_branch_vars for var 21
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 21
DEBUG CAREFUL: New best var: 21
DEBUG CAREFUL: Testing fvar[4] = var 25
DEBUG CAREFUL: Calling compare_branch_vars for var 25
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 25
DEBUG CAREFUL: New best var: 25
  % Initial guess is x25, Z0 = 28219055.0062378        , Z1 = 28439135.2870983        

DEBUG EVAL: Testing var 5 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=100, theta=0.271483, up=1.000000
ITER 2: row=49, varin=47, theta=0.726615, up=999999999999999983222784.000000
ITER 3: row=13, varin=61, theta=0.778481, up=1.000000
ITER 4: row=23, varin=46, theta=0.448123, up=999999999999999983222784.000000
ITER 5: row=22, varin=12, theta=0.245005, up=999999999999999983222784.000000
ITER 6: row=13, varin=43, theta=0.102137, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 5 = 0 gives z=28316021.785097
  % 	x5 = 0,	Z0 = 28316021.7850972        
DEBUG EVAL: First branch cutoff check: z=28316021.785097, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 5 = 1
ITER 1: row=1, varin=40, theta=0.440646, up=999999999999999983222784.000000
ITER 2: row=5, varin=47, theta=1.145406, up=999999999999999983222784.000000
ITER 3: row=2, varin=39, theta=0.590199, up=999999999999999983222784.000000
ITER 4: row=37, varin=79, theta=2.304701, up=1.000000
ITER 5: row=37, varin=5, theta=0.292525, up=999999999999999983222784.000000
ITER 6: row=48, varin=79, theta=1.000000, up=1.000000
ITER 7: row=30, varin=30, theta=0.639444, up=999999999999999983222784.000000
ITER 8: row=40, varin=38, theta=1.006158, up=999999999999999983222784.000000
ITER 9: row=24, varin=77, theta=13.053568, up=1.000000
ITER 10: row=24, varin=78, theta=12.845084, up=1.000000
  % 	x5 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: Second branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=100, theta=0.271483, up=1.000000
ITER 2: row=49, varin=47, theta=0.726615, up=999999999999999983222784.000000
ITER 3: row=13, varin=61, theta=0.778481, up=1.000000
ITER 4: row=23, varin=46, theta=0.448123, up=999999999999999983222784.000000
ITER 5: row=22, varin=12, theta=0.245005, up=999999999999999983222784.000000
ITER 6: row=13, varin=43, theta=0.102137, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28316021.785097
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.816310
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 49 rows, 60 cols, 271 nonzeros, 4 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 4 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 11 at  28.31602178509723088951
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabd9c70
% @LO 0.04  28.21905500623775608915 99.9000000000
% @LN 0.04  28.22026766959477228625 99.9000000000
% Resuming node 31 at  28.22026766959477228625
DEBUG CONSTRNT: LP rows=45, pool->nlprows=45, pool->npend=0
DEBUG CONSTRNT: Checking 45 LP rows (pool tracks 45, total LP rows 45)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=44, expected 44
 % @PAP adding 47 rows, 229 nz to LP
DEBUG BB: Processing node 31, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=8, varin=26, theta=1.085975, up=999999999999999983222784.000000
ITER 2: row=45, varin=17, theta=0.153192, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28220267.669595
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 289 nonzeros, 5 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 4 rows, 15 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=69, theta=0.311361, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28224643.017110
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 276 nonzeros, 0 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=74, theta=0.122375, up=1.000000
ITER 2: row=41, varin=82, theta=0.230158, up=1.000000
ITER 3: row=46, varin=31, theta=0.170578, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28228182.438290
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 280 nonzeros, 2 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 31 LP 1 Solution, length = 28228182.438290, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.170578 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.170578 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.097653 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.097653 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.097653 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.097653 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.097653 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.170578 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.170578 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.170578 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.829422 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.902347 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.829422 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.829422 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.902347 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.829422 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.902347 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.902347 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.902347 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.902347 (terminal 19)
 % 10 fractional variables
DEBUG CG: LP optimal, z=28228182.438290, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 31 at  28.22818243828989537292
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabbed00
% @LO 0.04  28.22026766959477228625 99.9000000000
% @LN 0.04  28.22193999976436629140 99.9000000000
% Resuming node 6 at  28.22193999976436629140
DEBUG CONSTRNT: LP rows=46, pool->nlprows=46, pool->npend=0
DEBUG CONSTRNT: Checking 46 LP rows (pool tracks 46, total LP rows 46)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=45, expected 45
 % @PAP adding 51 rows, 217 nz to LP
DEBUG BB: Processing node 6, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 6 LP 6 Solution, length = 28221939.999764, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.251274 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.251274 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.123089 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 1.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.123089 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.251274 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.251274 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.123089 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.251274 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.251274 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.748726 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.748726 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.748726 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.748726 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.748726 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.876911 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.876911 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 9 fractional variables
DEBUG CG: LP optimal, z=28221939.999764, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28221939.999764, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 6 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 6
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.251274
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.251274)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.251274
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.251274)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.123089
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.123089)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=1.000000
DEBUG CAREFUL: Skipping var 16: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.123089
DEBUG CAREFUL: Adding var 21 to fractional list (xi=0.123089)
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.251274
DEBUG CAREFUL: Adding var 23 to fractional list (xi=0.251274)
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.251274
DEBUG CAREFUL: Adding var 24 to fractional list (xi=0.251274)
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.123089
DEBUG CAREFUL: Adding var 25 to fractional list (xi=0.123089)
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.251274
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.251274)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.251274
DEBUG CAREFUL: Adding var 30 to fractional list (xi=0.251274)
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 9 fractional variables

  %  Carefully choosing branching variable, nfrac = 9
DEBUG CAREFUL: Testing fvar[0] = var 23
DEBUG CAREFUL: Calling compare_branch_vars for var 23
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 23
DEBUG CAREFUL: New best var: 23
DEBUG CAREFUL: Testing fvar[1] = var 24
DEBUG CAREFUL: Calling compare_branch_vars for var 24
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 24
DEBUG CAREFUL: Testing fvar[2] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
DEBUG CAREFUL: Testing fvar[3] = var 30
DEBUG CAREFUL: Calling compare_branch_vars for var 30
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 30
DEBUG CAREFUL: New best var: 30
DEBUG CAREFUL: Testing fvar[4] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 29
DEBUG CAREFUL: New best var: 29
DEBUG CAREFUL: Testing fvar[5] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[6] = var 21
DEBUG CAREFUL: Calling compare_branch_vars for var 21
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 21
DEBUG CAREFUL: New best var: 21
DEBUG CAREFUL: Testing fvar[7] = var 25
DEBUG CAREFUL: Calling compare_branch_vars for var 25
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 25
DEBUG CAREFUL: New best var: 25
DEBUG CAREFUL: Testing fvar[8] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
  % Initial guess is x25, Z0 = 28221939.9997644        , Z1 = 28371460.7680632        

DEBUG EVAL: Testing var 23 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=32, theta=0.115800, up=999999999999999983222784.000000
ITER 2: row=36, varin=35, theta=0.110778, up=999999999999999983222784.000000
ITER 3: row=43, varin=42, theta=0.145342, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 23 = 0 gives z=28264460.571343
  % 	x23 = 0,	Z0 = 28264460.5713425        
DEBUG EVAL: First branch cutoff check: z=28264460.571343, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 23 = 1
ITER 1: row=7, varin=9, theta=0.821727, up=999999999999999983222784.000000
  % 	x23 = 1,	Z1 = 28358277.4093165        
DEBUG EVAL: Second branch cutoff check: z=28358277.409317, best_z=INF, threshold=INF
  %   New best:  x23, Z = 28264460.5713425        
DEBUG EVAL: Testing var 24 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=32, theta=0.115800, up=999999999999999983222784.000000
ITER 2: row=36, varin=35, theta=0.110778, up=999999999999999983222784.000000
ITER 3: row=43, varin=42, theta=0.145342, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 24 = 0 gives z=28264460.571343
  % 	x24 = 0,	Z0 = 28264460.5713425        
DEBUG EVAL: First branch cutoff check: z=28264460.571343, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 24 = 1
ITER 1: row=3, varin=34, theta=0.317248, up=999999999999999983222784.000000
ITER 2: row=5, varin=24, theta=0.514817, up=999999999999999983222784.000000
ITER 3: row=23, varin=5, theta=1.022534, up=999999999999999983222784.000000
ITER 4: row=5, varin=45, theta=1.302834, up=999999999999999983222784.000000
ITER 5: row=45, varin=42, theta=1.388030, up=999999999999999983222784.000000
ITER 6: row=42, varin=51, theta=12.006932, up=999999999999999983222784.000000
ITER 7: row=37, varin=2, theta=0.925933, up=999999999999999983222784.000000
  % 	x24 = 1,	Z1 = 28653678.2276293        
DEBUG EVAL: Second branch cutoff check: z=28653678.227629, best_z=INF, threshold=INF
  %   New best:  x24, Z = 28264460.5713425        
DEBUG EVAL: Testing var 0 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=32, theta=0.115800, up=999999999999999983222784.000000
ITER 2: row=36, varin=35, theta=0.110778, up=999999999999999983222784.000000
ITER 3: row=43, varin=42, theta=0.145342, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 0 = 0 gives z=28264460.571343
  % 	x0 = 0,	Z0 = 28264460.5713425        
DEBUG EVAL: First branch cutoff check: z=28264460.571343, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 0 = 1
ITER 1: row=1, varin=34, theta=0.317248, up=999999999999999983222784.000000
ITER 2: row=5, varin=24, theta=0.514817, up=999999999999999983222784.000000
ITER 3: row=23, varin=5, theta=1.022534, up=999999999999999983222784.000000
ITER 4: row=5, varin=45, theta=1.302834, up=999999999999999983222784.000000
ITER 5: row=45, varin=42, theta=1.388030, up=999999999999999983222784.000000
ITER 6: row=42, varin=51, theta=12.006932, up=999999999999999983222784.000000
ITER 7: row=37, varin=49, theta=1.986120, up=999999999999999983222784.000000
ITER 8: row=50, varin=79, theta=8.568318, up=1.000000
ITER 9: row=50, varin=80, theta=8.065303, up=1.000000
ITER 10: row=50, varin=20, theta=1.345974, up=999999999999999983222784.000000
  % 	x0 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: Second branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=32, theta=0.115800, up=999999999999999983222784.000000
ITER 2: row=36, varin=35, theta=0.110778, up=999999999999999983222784.000000
ITER 3: row=43, varin=42, theta=0.145342, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
ITER 4: row=32, varin=30, theta=0.099178, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28228201.546165
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 51 rows, 60 cols, 277 nonzeros, 3 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 3 slack rows
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=62, theta=5.333333, up=1.000000
ITER 2: row=1, varin=58, theta=6.500000, up=1.000000
ITER 3: row=1, varin=54, theta=5.500000, up=1.000000
ITER 4: row=1, varin=85, theta=9.000000, up=1.000000
ITER 5: row=1, varin=57, theta=4.000000, up=1.000000
ITER 6: row=1, varin=64, theta=2.000000, up=1.000000
ITER 7: row=1, varin=50, theta=1.500000, up=1.000000
ITER 8: row=1, varin=63, theta=0.333333, up=1.000000
ITER 9: row=11, varin=89, theta=20.723694, up=1.000000
ITER 10: row=11, varin=90, theta=19.723694, up=1.000000
LP PHASE: Switching to primal (iter=88)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28228201.546165
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 48 rows, 60 cols, 271 nonzeros, 0 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 6 at  28.22820154616468002473
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabd9c70
% @LO 0.04  28.22193999976436629140 99.9000000000
% @LN 0.04  28.22818243828989537292 99.9000000000
% Resuming node 31 at  28.22818243828989537292
DEBUG CONSTRNT: LP rows=48, pool->nlprows=48, pool->npend=0
DEBUG CONSTRNT: Checking 48 LP rows (pool tracks 48, total LP rows 48)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=47, expected 47
 % @PAP adding 46 rows, 213 nz to LP
DEBUG BB: Processing node 31, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 31 LP 2 Solution, length = 28228182.438290, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.170578 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.170578 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.097653 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.097653 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.097653 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.097653 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.097653 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.170578 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.170578 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.170578 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.829422 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.902347 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.829422 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.829422 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.902347 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.829422 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.902347 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.902347 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.902347 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.902347 (terminal 19)
 % 10 fractional variables
DEBUG CG: LP optimal, z=28228182.438290, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28228182.438290, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 3 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 31 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 31
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.170578
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.170578)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.170578
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.170578)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.097653
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.097653)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.097653
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.097653)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=1.000000
DEBUG CAREFUL: Skipping var 13: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.097653
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.097653)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.097653
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.097653)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.097653
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.097653)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.170578
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.170578)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.170578
DEBUG CAREFUL: Adding var 30 to fractional list (xi=0.170578)
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.170578
DEBUG CAREFUL: Adding var 33 to fractional list (xi=0.170578)
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 10 fractional variables

  %  Carefully choosing branching variable, nfrac = 10
DEBUG CAREFUL: Testing fvar[0] = var 33
DEBUG CAREFUL: Calling compare_branch_vars for var 33
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 33
DEBUG CAREFUL: New best var: 33
DEBUG CAREFUL: Testing fvar[1] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 29
DEBUG CAREFUL: New best var: 29
DEBUG CAREFUL: Testing fvar[2] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[3] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
DEBUG CAREFUL: Testing fvar[4] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 4
DEBUG CAREFUL: New best var: 4
DEBUG CAREFUL: Testing fvar[5] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[6] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 18
DEBUG CAREFUL: Testing fvar[7] = var 30
DEBUG CAREFUL: Calling compare_branch_vars for var 30
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 30
DEBUG CAREFUL: Testing fvar[8] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[9] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 22
  % Initial guess is x4, Z0 = 28228182.4382899        , Z1 = 28568987.8342888        

DEBUG EVAL: Testing var 33 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=42, varin=40, theta=0.446278, up=999999999999999983222784.000000
ITER 2: row=33, varin=45, theta=0.676856, up=999999999999999983222784.000000
ITER 3: row=32, varin=39, theta=0.632562, up=999999999999999983222784.000000
ITER 4: row=40, varin=42, theta=1.169471, up=999999999999999983222784.000000
ITER 5: row=32, varin=33, theta=0.210677, up=999999999999999983222784.000000
ITER 6: row=23, varin=31, theta=0.566149, up=999999999999999983222784.000000
ITER 7: row=24, varin=39, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=25, varin=23, theta=0.500000, up=999999999999999983222784.000000
ITER 9: row=46, varin=32, theta=0.250000, up=999999999999999983222784.000000
ITER 10: row=4, varin=38, theta=0.250000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 33 = 1 gives z=28321085.080985
  % 	x33 = 1,	Z1 = 28321085.0809855        
DEBUG EVAL: First branch cutoff check: z=28321085.080985, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 33 = 0
ITER 1: row=42, varin=44, theta=0.658944, up=999999999999999983222784.000000
ITER 2: row=3, varin=23, theta=0.032871, up=999999999999999983222784.000000
ITER 3: row=22, varin=41, theta=0.067651, up=999999999999999983222784.000000
  % 	x33 = 0,	Z0 = 28228814.917144         
DEBUG EVAL: Second branch cutoff check: z=28228814.917144, best_z=INF, threshold=INF
  %   New best:  x33, Z = 28228814.917144         
DEBUG EVAL: Testing var 29 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=29, varin=44, theta=1.119125, up=999999999999999983222784.000000
ITER 2: row=3, varin=23, theta=0.350347, up=999999999999999983222784.000000
ITER 3: row=42, varin=40, theta=0.324638, up=999999999999999983222784.000000
ITER 4: row=35, varin=39, theta=1.160534, up=999999999999999983222784.000000
ITER 5: row=25, varin=36, theta=0.715924, up=999999999999999983222784.000000
ITER 6: row=19, varin=6, theta=0.702933, up=999999999999999983222784.000000
ITER 7: row=6, varin=42, theta=5.409100, up=999999999999999983222784.000000
ITER 8: row=40, varin=38, theta=0.555322, up=999999999999999983222784.000000
ITER 9: row=42, varin=77, theta=0.635343, up=1.000000
ITER 10: row=6, varin=41, theta=0.345036, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 29 = 1 gives z=28410711.522742
  % 	x29 = 1,	Z1 = 28410711.5227416        
DEBUG EVAL: First branch cutoff check: z=28410711.522742, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 29 = 0
ITER 1: row=29, varin=23, theta=0.151990, up=999999999999999983222784.000000
ITER 2: row=37, varin=41, theta=0.245618, up=999999999999999983222784.000000
  % 	x29 = 0,	Z0 = 28230077.31174          
DEBUG EVAL: Second branch cutoff check: z=28230077.311740, best_z=INF, threshold=INF
  %   New best:  x29, Z = 28230077.31174          
DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=39, theta=0.075747, up=999999999999999983222784.000000
ITER 2: row=25, varin=23, theta=0.151990, up=999999999999999983222784.000000
ITER 3: row=37, varin=41, theta=0.245618, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 0 gives z=28230077.311740
  % 	x1 = 0,	Z0 = 28230077.31174          
DEBUG EVAL: First branch cutoff check: z=28230077.311740, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 1
ITER 1: row=2, varin=44, theta=1.119125, up=999999999999999983222784.000000
ITER 2: row=3, varin=23, theta=0.350347, up=999999999999999983222784.000000
ITER 3: row=42, varin=40, theta=0.324638, up=999999999999999983222784.000000
ITER 4: row=35, varin=36, theta=0.715924, up=999999999999999983222784.000000
ITER 5: row=19, varin=6, theta=0.702933, up=999999999999999983222784.000000
ITER 6: row=6, varin=42, theta=5.409100, up=999999999999999983222784.000000
ITER 7: row=40, varin=32, theta=0.686113, up=999999999999999983222784.000000
ITER 8: row=42, varin=77, theta=1.992271, up=1.000000
ITER 9: row=42, varin=41, theta=1.165402, up=999999999999999983222784.000000
ITER 10: row=4, varin=35, theta=0.518155, up=999999999999999983222784.000000
  % 	x1 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: Second branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=2, varin=39, theta=0.075747, up=999999999999999983222784.000000
ITER 2: row=25, varin=23, theta=0.151990, up=999999999999999983222784.000000
ITER 3: row=37, varin=41, theta=0.245618, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28230077.311740
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 46 rows, 60 cols, 273 nonzeros, 2 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 31 at  28.23007731173962753246
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabbed00
% @LO 0.04  28.22818243828989537292 99.9000000000
% @LN 0.04  28.22820154616468002473 99.9000000000
% Resuming node 6 at  28.22820154616468002473
DEBUG CONSTRNT: LP rows=44, pool->nlprows=44, pool->npend=0
DEBUG CONSTRNT: Checking 44 LP rows (pool tracks 44, total LP rows 44)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=43, expected 43
 % @PAP adding 48 rows, 211 nz to LP
DEBUG BB: Processing node 6, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 6 LP 7 Solution, length = 28228201.546165, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.099178 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.099178 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.099178 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.099178 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.152876 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 1.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.099178 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.152876 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.099178 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.152876 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.900822 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.900822 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.900822 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.900822 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.847124 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.847124 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.900822 (terminal 19)
 % 9 fractional variables
DEBUG CG: LP optimal, z=28228201.546165, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28228201.546165, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 6 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 6
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.099178
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.099178)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.099178
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.099178)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.099178
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.099178)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.099178
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.099178)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.152876
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.152876)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=1.000000
DEBUG CAREFUL: Skipping var 16: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.099178
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.099178)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.152876
DEBUG CAREFUL: Adding var 21 to fractional list (xi=0.152876)
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.099178
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.099178)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.152876
DEBUG CAREFUL: Adding var 25 to fractional list (xi=0.152876)
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 9 fractional variables

  %  Carefully choosing branching variable, nfrac = 9
DEBUG CAREFUL: Testing fvar[0] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[1] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[2] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 22
DEBUG CAREFUL: New best var: 22
DEBUG CAREFUL: Testing fvar[3] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 4
DEBUG CAREFUL: New best var: 4
DEBUG CAREFUL: Testing fvar[4] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[5] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 11
DEBUG CAREFUL: Testing fvar[6] = var 21
DEBUG CAREFUL: Calling compare_branch_vars for var 21
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 21
DEBUG CAREFUL: Testing fvar[7] = var 25
DEBUG CAREFUL: Calling compare_branch_vars for var 25
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 25
DEBUG CAREFUL: Testing fvar[8] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
  % Initial guess is x4, Z0 = 28228201.5461647        , Z1 = 28568987.8342888        

DEBUG EVAL: Testing var 3 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=5, varin=82, theta=1.560936, up=1.000000
ITER 2: row=5, varin=29, theta=0.052230, up=999999999999999983222784.000000
ITER 3: row=22, varin=82, theta=0.217425, up=1.000000
DEBUG EVAL: Branch var 3 = 0 gives z=28255160.382198
  % 	x3 = 0,	Z0 = 28255160.3821983        
DEBUG EVAL: First branch cutoff check: z=28255160.382198, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 1
ITER 1: row=5, varin=23, theta=2.327291, up=999999999999999983222784.000000
ITER 2: row=30, varin=42, theta=3.971325, up=999999999999999983222784.000000
ITER 3: row=11, varin=40, theta=3.165629, up=999999999999999983222784.000000
ITER 4: row=29, varin=47, theta=18.733429, up=999999999999999983222784.000000
ITER 5: row=47, varin=4, theta=3.380309, up=999999999999999983222784.000000
ITER 6: row=48, varin=37, theta=6.058701, up=999999999999999983222784.000000
ITER 7: row=1, varin=24, theta=1.587606, up=999999999999999983222784.000000
ITER 8: row=41, varin=76, theta=9.076649, up=1.000000
ITER 9: row=41, varin=77, theta=8.607014, up=1.000000
ITER 10: row=41, varin=20, theta=1.449173, up=999999999999999983222784.000000
  % 	x3 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: Second branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=5, varin=82, theta=1.560936, up=1.000000
ITER 2: row=5, varin=29, theta=0.052230, up=999999999999999983222784.000000
ITER 3: row=22, varin=82, theta=0.217425, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28255160.382198
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 48 rows, 60 cols, 271 nonzeros, 5 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 5 slack rows
   % @PAP adding 6 rows, 24 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=107, theta=0.281986, up=1.000000
ITER 2: row=48, varin=29, theta=0.107227, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28292278.815659
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 49 rows, 60 cols, 285 nonzeros, 2 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 6 at  28.29227881565863711444
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabd9c70
% @LO 0.04  28.22820154616468002473 99.9000000000
% @LN 0.04  28.23007731173962753246 99.9000000000
% Resuming node 31 at  28.23007731173962753246
DEBUG CONSTRNT: LP rows=47, pool->nlprows=47, pool->npend=0
DEBUG CONSTRNT: Checking 47 LP rows (pool tracks 47, total LP rows 47)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=46, expected 46
 % @PAP adding 44 rows, 201 nz to LP
DEBUG BB: Processing node 31, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 31 LP 3 Solution, length = 28230077.311740, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.167251 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.167251 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.081873 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.167251 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.167251 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.081873 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.167251 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.081873 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.832749 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.832749 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.832749 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.832749 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.832749 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.918127 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.918127 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.832749 (terminal 19)
 % 8 fractional variables
DEBUG CG: LP optimal, z=28230077.311740, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28230077.311740, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 31 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 31
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.167251
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.167251)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.167251
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.167251)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.081873
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.081873)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=1.000000
DEBUG CAREFUL: Skipping var 13: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.167251
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.167251)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.167251
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.167251)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.081873
DEBUG CAREFUL: Adding var 21 to fractional list (xi=0.081873)
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.167251
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.167251)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.081873
DEBUG CAREFUL: Adding var 25 to fractional list (xi=0.081873)
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 8 fractional variables

  %  Carefully choosing branching variable, nfrac = 8
DEBUG CAREFUL: Testing fvar[0] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 12
DEBUG CAREFUL: New best var: 12
DEBUG CAREFUL: Testing fvar[1] = var 21
DEBUG CAREFUL: Calling compare_branch_vars for var 21
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 21
DEBUG CAREFUL: Testing fvar[2] = var 25
DEBUG CAREFUL: Calling compare_branch_vars for var 25
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 25
DEBUG CAREFUL: New best var: 25
DEBUG CAREFUL: Testing fvar[3] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 4
DEBUG CAREFUL: New best var: 4
DEBUG CAREFUL: Testing fvar[4] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[5] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 18
DEBUG CAREFUL: Testing fvar[6] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[7] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 22
  % Initial guess is x4, Z0 = 28230077.3117396        , Z1 = 28568987.8342888        

DEBUG EVAL: Testing var 12 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=10, varin=72, theta=0.152848, up=1.000000
DEBUG EVAL: Branch var 12 = 0 gives z=28239878.522022
  % 	x12 = 0,	Z0 = 28239878.5220217        
DEBUG EVAL: First branch cutoff check: z=28239878.522022, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 1
ITER 1: row=10, varin=36, theta=1.704431, up=999999999999999983222784.000000
ITER 2: row=22, varin=24, theta=0.849435, up=999999999999999983222784.000000
ITER 3: row=42, varin=39, theta=1.643297, up=999999999999999983222784.000000
ITER 4: row=32, varin=43, theta=0.611087, up=999999999999999983222784.000000
ITER 5: row=31, varin=40, theta=0.557468, up=999999999999999983222784.000000
ITER 6: row=40, varin=30, theta=1.085597, up=999999999999999983222784.000000
ITER 7: row=17, varin=32, theta=0.038161, up=999999999999999983222784.000000
  % 	x12 = 1,	Z1 = 28290568.3482312        
DEBUG EVAL: Second branch cutoff check: z=28290568.348231, best_z=INF, threshold=INF
  %   New best:  x12, Z = 28239878.5220217        
DEBUG EVAL: Testing var 21 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=25, varin=72, theta=0.152848, up=1.000000
DEBUG EVAL: Branch var 21 = 0 gives z=28239878.522022
  % 	x21 = 0,	Z0 = 28239878.5220217        
DEBUG EVAL: First branch cutoff check: z=28239878.522022, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 21 = 1
ITER 1: row=25, varin=36, theta=1.704431, up=999999999999999983222784.000000
ITER 2: row=22, varin=24, theta=0.849435, up=999999999999999983222784.000000
ITER 3: row=42, varin=39, theta=1.643297, up=999999999999999983222784.000000
ITER 4: row=32, varin=43, theta=0.611087, up=999999999999999983222784.000000
ITER 5: row=31, varin=40, theta=0.557468, up=999999999999999983222784.000000
ITER 6: row=40, varin=30, theta=1.085597, up=999999999999999983222784.000000
ITER 7: row=17, varin=31, theta=0.036378, up=999999999999999983222784.000000
ITER 8: row=4, varin=26, theta=0.026027, up=999999999999999983222784.000000
ITER 9: row=26, varin=28, theta=0.022785, up=999999999999999983222784.000000
ITER 10: row=28, varin=29, theta=0.032810, up=999999999999999983222784.000000
  % 	x21 = 1,	Z1 = 28322784.0000871        
DEBUG EVAL: Second branch cutoff check: z=28322784.000087, best_z=INF, threshold=INF
  %   New best:  x21, Z = 28239878.5220217        
DEBUG EVAL: Testing var 25 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=32, varin=36, theta=1.704431, up=999999999999999983222784.000000
ITER 2: row=22, varin=24, theta=0.849435, up=999999999999999983222784.000000
ITER 3: row=42, varin=43, theta=1.561018, up=999999999999999983222784.000000
ITER 4: row=31, varin=40, theta=1.652113, up=999999999999999983222784.000000
ITER 5: row=40, varin=30, theta=3.217273, up=999999999999999983222784.000000
ITER 6: row=17, varin=32, theta=0.988515, up=999999999999999983222784.000000
ITER 7: row=42, varin=81, theta=0.025762, up=1.000000
DEBUG EVAL: Branch var 25 = 1 gives z=28350354.018519
  % 	x25 = 1,	Z1 = 28350354.0185191        
DEBUG EVAL: First branch cutoff check: z=28350354.018519, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 25 = 0
ITER 1: row=32, varin=39, theta=0.185531, up=999999999999999983222784.000000
  % 	x25 = 0,	Z0 = 28234087.9597183        
DEBUG EVAL: Second branch cutoff check: z=28234087.959718, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 4 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=4, varin=24, theta=2.265043, up=999999999999999983222784.000000
ITER 2: row=42, varin=35, theta=1.256691, up=999999999999999983222784.000000
ITER 3: row=31, varin=40, theta=1.950747, up=999999999999999983222784.000000
ITER 4: row=40, varin=6, theta=0.638590, up=999999999999999983222784.000000
ITER 5: row=6, varin=21, theta=0.267566, up=999999999999999983222784.000000
ITER 6: row=44, varin=37, theta=0.822931, up=999999999999999983222784.000000
ITER 7: row=2, varin=25, theta=0.481490, up=999999999999999983222784.000000
ITER 8: row=21, varin=29, theta=2.460789, up=999999999999999983222784.000000
ITER 9: row=1, varin=36, theta=0.458449, up=999999999999999983222784.000000
ITER 10: row=19, varin=72, theta=7.081580, up=1.000000
DEBUG EVAL: Branch var 4 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x4 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=4, varin=36, theta=0.402560, up=999999999999999983222784.000000
ITER 2: row=22, varin=30, theta=1.262928, up=999999999999999983222784.000000
ITER 3: row=17, varin=31, theta=0.043855, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28275405.724063
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 44 rows, 60 cols, 261 nonzeros, 2 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 31 at  28.27540572406317664900
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabbe180
% @LO 0.04  28.23007731173962753246 99.9000000000
% @LN 0.04  28.25120294704031564947 99.9000000000
% Resuming node 20 at  28.25120294704031564947
DEBUG CONSTRNT: LP rows=42, pool->nlprows=42, pool->npend=0
DEBUG CONSTRNT: Checking 42 LP rows (pool tracks 42, total LP rows 42)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=41, expected 41
 % @PAP adding 35 rows, 195 nz to LP
DEBUG BB: Processing node 20, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=15, varin=20, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=26, varin=22, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=12, varin=34, theta=0.144076, up=999999999999999983222784.000000
ITER 4: row=16, varin=35, theta=0.209494, up=999999999999999983222784.000000
ITER 5: row=27, varin=29, theta=0.521199, up=999999999999999983222784.000000
ITER 6: row=29, varin=7, theta=0.273170, up=999999999999999983222784.000000
ITER 7: row=7, varin=60, theta=0.839384, up=1.000000
ITER 8: row=9, varin=65, theta=1.079767, up=1.000000
ITER 9: row=9, varin=42, theta=0.025088, up=1.000000
ITER 10: row=1, varin=65, theta=0.135256, up=1.000000
LP PHASE: Switching to primal (iter=16)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=35)
DEBUG SOLUTION: LP solution array indices: FST[36-75], not_covered[76-95]
DEBUG SOLUTION: lp->best_solution[0] = 28251202.947040
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 35 rows, 60 cols, 255 nonzeros, 2 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 8 rows, 30 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=59, theta=0.090275, up=1.000000
ITER 2: row=40, varin=46, theta=0.731764, up=1.000000
ITER 3: row=32, varin=65, theta=0.752180, up=1.000000
ITER 4: row=15, varin=80, theta=0.228353, up=1.000000
ITER 5: row=14, varin=47, theta=0.168146, up=1.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28360244.565661
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 285 nonzeros, 3 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 7 rows, 28 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=70, theta=0.709387, up=1.000000
ITER 2: row=42, varin=104, theta=1.186864, up=1.000000
ITER 3: row=42, varin=25, theta=0.028133, up=999999999999999983222784.000000
ITER 4: row=45, varin=54, theta=0.155707, up=1.000000
ITER 5: row=1, varin=14, theta=0.254196, up=999999999999999983222784.000000
ITER 6: row=14, varin=104, theta=0.933827, up=1.000000
ITER 7: row=15, varin=75, theta=0.964572, up=1.000000
ITER 8: row=31, varin=76, theta=1.003839, up=1.000000
ITER 9: row=31, varin=26, theta=0.000546, up=999999999999999983222784.000000
ITER 10: row=14, varin=15, theta=0.000890, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=11)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28580405.332095
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 307 nonzeros, 4 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 3 rows, 9 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=103, theta=0.309863, up=1.000000
ITER 2: row=45, varin=18, theta=0.234581, up=999999999999999983222784.000000
ITER 3: row=8, varin=100, theta=0.197700, up=1.000000
ITER 4: row=18, varin=28, theta=1.607775, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 308 nonzeros, 1 slack, 45 tight.
  % Node 20 LP 1 Solution, length = 999999999999999983222784.000000, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 1.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.012231 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.991555 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.997962 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.998253 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 20 is INFEASIBLE
 %      20    14    infeasible               28260545.8227   x14 U    16     3
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabad4e0
% @LO 0.04  28.25120294704031564947 99.9000000000
% @LN 0.04  28.26054582267325798739 99.9000000000
% Resuming node 29 at  28.26054582267325798739
DEBUG CONSTRNT: LP rows=46, pool->nlprows=46, pool->npend=0
DEBUG CONSTRNT: Checking 46 LP rows (pool tracks 46, total LP rows 46)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=45, expected 45
 % @PAP adding 39 rows, 201 nz to LP
DEBUG BB: Processing node 29, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=23, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=32, varin=31, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=34, varin=38, theta=0.021931, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 28260545.822673
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 3.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 39 rows, 60 cols, 261 nonzeros, 5 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 20 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=77, theta=1.000000, up=1.000000
ITER 2: row=40, varin=36, theta=1.210746, up=999999999999999983222784.000000
ITER 3: row=1, varin=84, theta=1.831143, up=1.000000
ITER 4: row=1, varin=45, theta=0.178858, up=1.000000
ITER 5: row=35, varin=84, theta=0.682465, up=1.000000
ITER 6: row=8, varin=46, theta=0.313843, up=1.000000
ITER 7: row=40, varin=35, theta=0.134226, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=7)
ITER 8: row=8, varin=29, theta=0.439638, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28327589.503067
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 3.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 281 nonzeros, 7 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 7 slack rows
  % @PAP adding 4 rows, 15 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=76, theta=17.000000, up=1.000000
ITER 2: row=1, varin=50, theta=8.000000, up=1.000000
ITER 3: row=1, varin=41, theta=7.000000, up=1.000000
ITER 4: row=1, varin=54, theta=4.000000, up=1.000000
ITER 5: row=1, varin=80, theta=9.000000, up=1.000000
ITER 6: row=1, varin=81, theta=8.000000, up=1.000000
ITER 7: row=1, varin=82, theta=7.000000, up=1.000000
ITER 8: row=1, varin=83, theta=6.000000, up=1.000000
ITER 9: row=1, varin=84, theta=5.000000, up=1.000000
ITER 10: row=1, varin=85, theta=4.000000, up=1.000000
LP PHASE: Switching to primal (iter=60)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 28329017.053411
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 3.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1000000.000000
  % @PL 39 rows, 60 cols, 277 nonzeros, 2 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 8 rows, 28 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=82, theta=0.431508, up=1.000000
ITER 2: row=45, varin=15, theta=0.046512, up=999999999999999983222784.000000
ITER 3: row=40, varin=100, theta=0.214286, up=1.000000
ITER 4: row=43, varin=69, theta=2.000000, up=1.000000
ITER 5: row=43, varin=40, theta=0.750000, up=999999999999999983222784.000000
ITER 6: row=45, varin=45, theta=0.750000, up=999999999999999983222784.000000
ITER 7: row=10, varin=69, theta=1.000000, up=1.000000
ITER 8: row=21, varin=15, theta=0.124021, up=999999999999999983222784.000000
ITER 9: row=43, varin=72, theta=0.092516, up=1.000000
LP PHASE: Switching to primal (iter=9)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28401790.833333
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 3.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1000000.000000
  % @PL 45 rows, 60 cols, 287 nonzeros, 2 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 29 LP 1 Solution, length = 28401790.833333, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.226871 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.226871 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.226871 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.226871 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.092516 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.773129 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.773129 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.773129 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.773129 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.773129 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.773129 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28401790.833333, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 29 at  28.40179083333260834365
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabbe0c0
% @LO 0.04  28.26054582267325798739 99.9000000000
% @LN 0.04  28.26220652295067026216 99.9000000000
% Resuming node 30 at  28.26220652295067026216
DEBUG CONSTRNT: LP rows=43, pool->nlprows=43, pool->npend=0
DEBUG CONSTRNT: Checking 43 LP rows (pool tracks 43, total LP rows 43)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 62
DEBUG CONSTRNT: Pool row 62 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=42, expected 42
 % @PAP adding 39 rows, 201 nz to LP
DEBUG BB: Processing node 30, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=24, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=33, varin=31, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 28262206.522951
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 3.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 39 rows, 60 cols, 261 nonzeros, 3 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 24 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=28, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=31, varin=26, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=42, varin=38, theta=0.327046, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28340119.379241
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 3.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 285 nonzeros, 6 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=32, theta=1.335200, up=999999999999999983222784.000000
ITER 2: row=39, varin=84, theta=0.082573, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 28359315.104907
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 3.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 39 rows, 60 cols, 256 nonzeros, 1 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 30 LP 1 Solution, length = 28359315.104907, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.082573 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.729357 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.500000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.270643 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.270643 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.729357 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.917427 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.917427 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.729357 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.917427 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.270643 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.270643 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.729357 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.270643 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28359315.104907, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 30 at  28.35931510490689433368
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabd9c70
% @LO 0.04  28.26220652295067026216 99.9000000000
% @LN 0.04  28.27540572406317664900 99.9000000000
% Resuming node 31 at  28.27540572406317664900
DEBUG CONSTRNT: LP rows=38, pool->nlprows=38, pool->npend=0
DEBUG CONSTRNT: Checking 38 LP rows (pool tracks 38, total LP rows 38)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 85
DEBUG CONSTRNT: Pool row 85 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=37, expected 37
 % @PAP adding 42 rows, 197 nz to LP
DEBUG BB: Processing node 31, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 31 LP 4 Solution, length = 28275405.724063, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.043855 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.434217 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.043855 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.043855 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.434217 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.043855 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.434217 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 1.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.956145 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.956145 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.956145 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.956145 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.956145 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.565783 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.565783 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.956145 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=28275405.724063, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28275405.724063, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 31 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 31
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.043855
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.043855)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.434217
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.434217)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=1.000000
DEBUG CAREFUL: Skipping var 13: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.043855
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.043855)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.043855
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.043855)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.434217
DEBUG CAREFUL: Adding var 21 to fractional list (xi=0.434217)
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.043855
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.043855)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.434217
DEBUG CAREFUL: Adding var 25 to fractional list (xi=0.434217)
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=1.000000
DEBUG CAREFUL: Skipping var 36: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 7 fractional variables

  %  Carefully choosing branching variable, nfrac = 7
DEBUG CAREFUL: Testing fvar[0] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 12
DEBUG CAREFUL: New best var: 12
DEBUG CAREFUL: Testing fvar[1] = var 21
DEBUG CAREFUL: Calling compare_branch_vars for var 21
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 21
DEBUG CAREFUL: New best var: 21
DEBUG CAREFUL: Testing fvar[2] = var 25
DEBUG CAREFUL: Calling compare_branch_vars for var 25
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 25
DEBUG CAREFUL: New best var: 25
DEBUG CAREFUL: Testing fvar[3] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 2
DEBUG CAREFUL: New best var: 2
DEBUG CAREFUL: Testing fvar[4] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 18
DEBUG CAREFUL: Testing fvar[5] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[6] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 22
  % Initial guess is x2, Z0 = 28275405.7240632        , Z1 = 28502636.0151518        

DEBUG EVAL: Testing var 12 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=4, varin=37, theta=1.039341, up=999999999999999983222784.000000
ITER 2: row=30, varin=41, theta=0.037795, up=999999999999999983222784.000000
ITER 3: row=22, varin=40, theta=0.031761, up=999999999999999983222784.000000
ITER 4: row=40, varin=38, theta=0.028898, up=999999999999999983222784.000000
ITER 5: row=38, varin=30, theta=0.025032, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 12 = 1 gives z=28292440.462860
  % 	x12 = 1,	Z1 = 28292440.4628603        
DEBUG EVAL: First branch cutoff check: z=28292440.462860, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 0
ITER 1: row=4, varin=80, theta=1.378365, up=1.000000
ITER 2: row=4, varin=35, theta=0.081395, up=999999999999999983222784.000000
ITER 3: row=22, varin=70, theta=0.741066, up=1.000000
ITER 4: row=40, varin=79, theta=0.476406, up=1.000000
  % 	x12 = 0,	Z0 = 28315936.2802005        
DEBUG EVAL: Second branch cutoff check: z=28315936.280200, best_z=INF, threshold=INF
  %   New best:  x12, Z = 28292440.4628603        
DEBUG EVAL: Testing var 21 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=21, varin=37, theta=1.039341, up=999999999999999983222784.000000
ITER 2: row=30, varin=41, theta=0.037795, up=999999999999999983222784.000000
ITER 3: row=22, varin=40, theta=0.031761, up=999999999999999983222784.000000
ITER 4: row=40, varin=38, theta=0.028898, up=999999999999999983222784.000000
ITER 5: row=38, varin=24, theta=0.051503, up=999999999999999983222784.000000
ITER 6: row=22, varin=26, theta=0.026027, up=999999999999999983222784.000000
ITER 7: row=26, varin=28, theta=0.022785, up=999999999999999983222784.000000
ITER 8: row=28, varin=29, theta=0.032810, up=999999999999999983222784.000000
ITER 9: row=29, varin=6, theta=0.014943, up=999999999999999983222784.000000
ITER 10: row=6, varin=10, theta=22165.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 21 = 1 gives z=28322784.000087
  % 	x21 = 1,	Z1 = 28322784.0000873        
DEBUG EVAL: First branch cutoff check: z=28322784.000087, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 21 = 0
ITER 1: row=21, varin=80, theta=1.378365, up=1.000000
ITER 2: row=21, varin=35, theta=0.081395, up=999999999999999983222784.000000
ITER 3: row=22, varin=70, theta=0.741066, up=1.000000
ITER 4: row=40, varin=79, theta=0.476406, up=1.000000
  % 	x21 = 0,	Z0 = 28315936.2802005        
DEBUG EVAL: Second branch cutoff check: z=28315936.280200, best_z=INF, threshold=INF
  %   New best:  x21, Z = 28315936.2802005        
DEBUG EVAL: Testing var 25 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=30, varin=40, theta=1.447123, up=999999999999999983222784.000000
ITER 2: row=40, varin=41, theta=0.998520, up=999999999999999983222784.000000
ITER 3: row=22, varin=38, theta=1.145758, up=999999999999999983222784.000000
ITER 4: row=38, varin=30, theta=0.992466, up=999999999999999983222784.000000
ITER 5: row=40, varin=22, theta=0.007520, up=999999999999999983222784.000000
ITER 6: row=34, varin=24, theta=0.014658, up=999999999999999983222784.000000
ITER 7: row=30, varin=79, theta=0.025762, up=1.000000
DEBUG EVAL: Branch var 25 = 1 gives z=28350354.018519
  % 	x25 = 1,	Z1 = 28350354.0185191        
DEBUG EVAL: First branch cutoff check: z=28350354.018519, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 25 = 0
ITER 1: row=30, varin=37, theta=0.952998, up=999999999999999983222784.000000
  % 	x25 = 0,	Z0 = 28289510.3081606        
DEBUG EVAL: Second branch cutoff check: z=28289510.308161, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 2 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=22, theta=1.827219, up=999999999999999983222784.000000
ITER 2: row=42, varin=79, theta=5.732428, up=1.000000
ITER 3: row=42, varin=24, theta=1.704653, up=999999999999999983222784.000000
ITER 4: row=40, varin=41, theta=1.648377, up=999999999999999983222784.000000
ITER 5: row=34, varin=33, theta=0.945776, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 1 gives z=28616039.981670
  % 	x2 = 1,	Z1 = 28616039.9816704        
DEBUG EVAL: First branch cutoff check: z=28616039.981670, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 0
ITER 1: row=1, varin=29, theta=0.048037, up=999999999999999983222784.000000
  % 	x2 = 0,	Z0 = 28285263.6242132        
DEBUG EVAL: Second branch cutoff check: z=28285263.624213, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 18 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=19, varin=33, theta=3.071202, up=999999999999999983222784.000000
ITER 2: row=22, varin=79, theta=3.865919, up=1.000000
ITER 3: row=22, varin=24, theta=1.032324, up=999999999999999983222784.000000
ITER 4: row=40, varin=38, theta=4.352692, up=999999999999999983222784.000000
ITER 5: row=38, varin=35, theta=1.836201, up=999999999999999983222784.000000
ITER 6: row=2, varin=29, theta=5.490746, up=999999999999999983222784.000000
ITER 7: row=1, varin=21, theta=1.409361, up=999999999999999983222784.000000
ITER 8: row=10, varin=70, theta=21.770144, up=1.000000
ITER 9: row=10, varin=71, theta=22.134047, up=1.000000
ITER 10: row=10, varin=2, theta=3.046284, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 18 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x18 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=19, varin=22, theta=0.091994, up=999999999999999983222784.000000
ITER 2: row=42, varin=41, theta=0.084153, up=999999999999999983222784.000000
ITER 3: row=34, varin=80, theta=0.355628, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28289273.847338
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 42 rows, 60 cols, 257 nonzeros, 0 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 4 rows, 20 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=38, theta=0.984862, up=999999999999999983222784.000000
ITER 2: row=38, varin=37, theta=1.482693, up=999999999999999983222784.000000
ITER 3: row=19, varin=35, theta=0.059797, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28297382.072261
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 46 rows, 60 cols, 277 nonzeros, 4 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 4 slack rows
   % @PAP adding 6 rows, 17 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=74, theta=0.130993, up=1.000000
ITER 2: row=43, varin=79, theta=0.590108, up=1.000000
ITER 3: row=35, varin=10, theta=68084.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28301917.253835
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 931915.500000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 48 rows, 60 cols, 286 nonzeros, 1 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 31 at  28.30191725383521017534
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabd7f60
% @LO 0.04  28.27540572406317664900 99.9000000000
% @LN 0.04  28.27901954201224299368 99.9000000000
% Resuming node 27 at  28.27901954201224299368
DEBUG CONSTRNT: LP rows=47, pool->nlprows=47, pool->npend=0
DEBUG CONSTRNT: Checking 47 LP rows (pool tracks 47, total LP rows 47)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=46, expected 46
 % @PAP adding 45 rows, 223 nz to LP
DEBUG BB: Processing node 27, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=14, varin=32, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=34, varin=46, theta=0.553922, up=1.000000
ITER 3: row=41, varin=10, theta=0.470472, up=999999999999999983222784.000000
ITER 4: row=10, varin=44, theta=0.443048, up=999999999999999983222784.000000
ITER 5: row=44, varin=36, theta=0.430456, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28279019.542012
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 3.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1000000.000000
  % @PL 45 rows, 60 cols, 283 nonzeros, 4 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 3 rows, 10 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=18, theta=1.221624, up=999999999999999983222784.000000
ITER 2: row=18, varin=19, theta=0.025789, up=999999999999999983222784.000000
ITER 3: row=43, varin=36, theta=0.315653, up=999999999999999983222784.000000
ITER 4: row=42, varin=44, theta=0.086900, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28316328.390673
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 3.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1000000.000000
  % @PL 44 rows, 60 cols, 271 nonzeros, 4 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 7 rows, 37 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=90, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28358048.805462
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 3.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1000000.000000
  % @PL 47 rows, 60 cols, 296 nonzeros, 5 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=32, theta=0.056692, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28359504.664171
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 3.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1000000.000000
  % @PL 43 rows, 60 cols, 272 nonzeros, 2 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 27 LP 1 Solution, length = 28359504.664171, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.221654 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.278346 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.278346 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.278346 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.721654 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.721654 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.721654 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.721654 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.721654 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.721654 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28359504.664171, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 27 at  28.35950466417066806457
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabbed00
% @LO 0.04  28.27901954201224299368 99.9000000000
% @LN 0.04  28.29227881565863711444 99.9000000000
% Resuming node 6 at  28.29227881565863711444
DEBUG CONSTRNT: LP rows=41, pool->nlprows=41, pool->npend=0
DEBUG CONSTRNT: Checking 41 LP rows (pool tracks 41, total LP rows 41)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 150
DEBUG CONSTRNT: Pool row 150 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 85
DEBUG CONSTRNT: Pool row 85 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=40, expected 40
 % @PAP adding 47 rows, 215 nz to LP
DEBUG BB: Processing node 6, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 6 LP 8 Solution, length = 28292278.815659, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.107227 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.107227 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.107227 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.231933 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 1.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.107227 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.231933 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.107227 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.231933 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.892773 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.892773 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.892773 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.892773 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.768067 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.768067 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.892773 (terminal 19)
 % 8 fractional variables
DEBUG CG: LP optimal, z=28292278.815659, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28292278.815659, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 6 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 6
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.107227
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.107227)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.107227
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.107227)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.107227
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.107227)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.231933
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.231933)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=1.000000
DEBUG CAREFUL: Skipping var 16: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.107227
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.107227)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.231933
DEBUG CAREFUL: Adding var 21 to fractional list (xi=0.231933)
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.107227
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.107227)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.231933
DEBUG CAREFUL: Adding var 25 to fractional list (xi=0.231933)
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 8 fractional variables

  %  Carefully choosing branching variable, nfrac = 8
DEBUG CAREFUL: Testing fvar[0] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
DEBUG CAREFUL: Testing fvar[1] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 4
DEBUG CAREFUL: New best var: 4
DEBUG CAREFUL: Testing fvar[2] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[3] = var 21
DEBUG CAREFUL: Calling compare_branch_vars for var 21
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 21
DEBUG CAREFUL: Testing fvar[4] = var 25
DEBUG CAREFUL: Calling compare_branch_vars for var 25
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 25
DEBUG CAREFUL: Testing fvar[5] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
DEBUG CAREFUL: Testing fvar[6] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 22
DEBUG CAREFUL: Testing fvar[7] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 11
  % Initial guess is x4, Z0 = 28292278.8156586        , Z1 = 28568987.8342888        

DEBUG EVAL: Testing var 17 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=23, varin=85, theta=0.920046, up=1.000000
DEBUG EVAL: Branch var 17 = 0 gives z=28321150.036601
  % 	x17 = 0,	Z0 = 28321150.0366014        
DEBUG EVAL: First branch cutoff check: z=28321150.036601, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 1
ITER 1: row=23, varin=43, theta=12.996371, up=999999999999999983222784.000000
ITER 2: row=43, varin=36, theta=3.640407, up=999999999999999983222784.000000
ITER 3: row=5, varin=35, theta=2.813071, up=999999999999999983222784.000000
ITER 4: row=11, varin=41, theta=15.683683, up=999999999999999983222784.000000
ITER 5: row=41, varin=4, theta=2.830005, up=999999999999999983222784.000000
ITER 6: row=46, varin=33, theta=5.072363, up=999999999999999983222784.000000
ITER 7: row=1, varin=75, theta=19.741916, up=1.000000
ITER 8: row=1, varin=76, theta=19.972633, up=1.000000
ITER 9: row=1, varin=39, theta=1.759322, up=999999999999999983222784.000000
ITER 10: row=15, varin=20, theta=3.614378, up=999999999999999983222784.000000
  % 	x17 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: Second branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=23, varin=85, theta=0.920046, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28321150.036601
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 47 rows, 60 cols, 275 nonzeros, 0 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 4 rows, 20 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=32, theta=3.835876, up=999999999999999983222784.000000
ITER 2: row=11, varin=11, theta=130222.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28350779.371811
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 869778.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 51 rows, 60 cols, 295 nonzeros, 2 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
   % @PAP adding 1 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=72, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28353859.810272
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 50 rows, 60 cols, 257 nonzeros, 0 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 6 at  28.35385981027157242806
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabd9c70
% @LO 0.05  28.29227881565863711444 99.9000000000
% @LN 0.05  28.30191725383521017534 99.9000000000
% Resuming node 31 at  28.30191725383521017534
DEBUG CONSTRNT: LP rows=50, pool->nlprows=50, pool->npend=0
DEBUG CONSTRNT: Checking 50 LP rows (pool tracks 50, total LP rows 50)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=49, expected 49
 % @PAP adding 47 rows, 186 nz to LP
DEBUG BB: Processing node 31, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 31 LP 5 Solution, length = 28301917.253835, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.500000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.500000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 1.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28301917.253835, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28301917.253835, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 31 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 31
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.500000
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=1.000000
DEBUG CAREFUL: Skipping var 13: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.500000
DEBUG CAREFUL: Adding var 21 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.500000
DEBUG CAREFUL: Adding var 25 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=1.000000
DEBUG CAREFUL: Skipping var 36: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 3 fractional variables

  %  Carefully choosing branching variable, nfrac = 3
DEBUG CAREFUL: Testing fvar[0] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 12
DEBUG CAREFUL: New best var: 12
DEBUG CAREFUL: Testing fvar[1] = var 21
DEBUG CAREFUL: Calling compare_branch_vars for var 21
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 21
DEBUG CAREFUL: New best var: 21
DEBUG CAREFUL: Testing fvar[2] = var 25
DEBUG CAREFUL: Calling compare_branch_vars for var 25
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 25
  % Initial guess is x21, Z0 = 28315936.2802005        , Z1 = 28322784.0000873        

DEBUG EVAL: Testing var 12 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=18, varin=29, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 12 = 1 gives z=28347673.411690
  % 	x12 = 1,	Z1 = 28347673.4116903        
DEBUG EVAL: First branch cutoff check: z=28347673.411690, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 0
ITER 1: row=18, varin=47, theta=1.000000, up=999999999999999983222784.000000
  % 	x12 = 0,	Z0 = 28315936.2802005        
DEBUG EVAL: Second branch cutoff check: z=28315936.280200, best_z=INF, threshold=INF
  %   New best:  x12, Z = 28315936.2802005        
DEBUG EVAL: Testing var 21 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=29, varin=47, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 21 = 0 gives z=28304997.692296
  % 	x21 = 0,	Z0 = 28315936.2802005        
DEBUG EVAL: First branch cutoff check: z=28315936.280200, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 21 = 1
ITER 1: row=29, varin=62, theta=1.000000, up=1.000000
ITER 2: row=10, varin=18, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=30, varin=19, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=1, varin=3, theta=0.500000, up=999999999999999983222784.000000
ITER 5: row=45, varin=75, theta=1.000000, up=1.000000
  % 	x21 = 1,	Z1 = 29367591.5379681        
DEBUG EVAL: Second branch cutoff check: z=29367591.537968, best_z=INF, threshold=INF
  %   New best:  x21, Z = 28315936.2802005        
DEBUG EVAL: Testing var 25 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=37, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=37, varin=47, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 25 = 1 gives z=28304997.692296
  % 	x25 = 1,	Z1 = 28350354.0185191        
DEBUG EVAL: First branch cutoff check: z=28350354.018519, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 25 = 0
ITER 1: row=1, varin=3, theta=0.250000, up=999999999999999983222784.000000
ITER 2: row=45, varin=75, theta=0.500000, up=1.000000
  % 	x25 = 0,	Z0 = 28339936.6291704        
DEBUG EVAL: Second branch cutoff check: z=28339936.629170, best_z=INF, threshold=INF
  %   New best:  x25, Z = 28339936.6291704        
  % Best branch is x25, Z0 = 28339936.6291704        , Z1 = 28350354.0185191        

DEBUG CAREFUL: Final result - returning best.var = 25
DEBUG BB: Branching variable chosen: j=25
 % @NC   33   31	x25 = 0	28339936.629170
 % @NC   34   31	x25 = 1	28350354.018519
 %      31    15 28301917.2538               28310086.9133   x24 D     7     5
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595daba2600
% @LO 0.05  28.30191725383521017534 99.9000000000
% @LN 0.05  28.31008691326767134910 99.9000000000
% Resuming node 25 at  28.31008691326767134910
DEBUG CONSTRNT: LP rows=47, pool->nlprows=47, pool->npend=0
DEBUG CONSTRNT: Checking 47 LP rows (pool tracks 47, total LP rows 47)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=46, expected 46
 % @PAP adding 38 rows, 199 nz to LP
DEBUG BB: Processing node 25, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=14, varin=30, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=32, varin=24, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=34, varin=27, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=38, varin=29, theta=0.075000, up=999999999999999983222784.000000
ITER 5: row=5, varin=45, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 28310086.913268
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 3.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1000000.000000
  % @PL 38 rows, 60 cols, 259 nonzeros, 2 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 24 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=46, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28319759.923809
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 3.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1000000.000000
  % @PL 42 rows, 60 cols, 283 nonzeros, 3 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 7 rows, 33 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=35, theta=3.500000, up=999999999999999983222784.000000
ITER 2: row=45, varin=70, theta=2.000000, up=1.000000
ITER 3: row=45, varin=76, theta=0.500000, up=1.000000
ITER 4: row=10, varin=70, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28379646.812154
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 3.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1000000.000000
  % @PL 46 rows, 60 cols, 297 nonzeros, 0 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 5 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=8, theta=0.924324, up=999999999999999983222784.000000
ITER 2: row=35, varin=62, theta=0.048939, up=1.000000
ITER 3: row=47, varin=51, theta=0.580075, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28404434.510922
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.308717
DEBUG SOLUTION: lp->best_solution[7] = 0.308717
DEBUG SOLUTION: lp->best_solution[8] = 1.617435
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1000000.000000
  % @PL 51 rows, 60 cols, 309 nonzeros, 8 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 8 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=71, theta=0.416079, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28412367.721284
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 273 nonzeros, 0 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 22 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=62, theta=0.286413, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28416388.233777
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 295 nonzeros, 2 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 4 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=32, theta=0.293524, up=999999999999999983222784.000000
ITER 2: row=45, varin=57, theta=0.243746, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28423488.830201
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 304 nonzeros, 1 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 4 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=48, theta=0.492818, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 28429560.727325
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 55 rows, 60 cols, 309 nonzeros, 3 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % Node 25 LP 1 Solution, length = 28429560.727325, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.137568 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.137568 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.123205 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.123205 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.123205 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.123205 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.123205 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.123205 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.123205 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.137568 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.862432 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.876795 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.862432 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.862432 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.876795 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.862432 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.876795 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.876795 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.876795 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.876795 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.876795 (terminal 19)
 % 10 fractional variables
DEBUG CG: LP optimal, z=28429560.727325, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 25 at  28.42956072732462757813
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabb5780
% @LO 0.05  28.31008691326767134910 99.9000000000
% @LN 0.05  28.31602178509723088951 99.9000000000
% Resuming node 11 at  28.31602178509723088951
DEBUG CONSTRNT: LP rows=52, pool->nlprows=52, pool->npend=0
DEBUG CONSTRNT: Checking 52 LP rows (pool tracks 52, total LP rows 52)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 60
DEBUG CONSTRNT: Pool row 60 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 73
DEBUG CONSTRNT: Pool row 73 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=51, expected 51
 % @PAP adding 45 rows, 203 nz to LP
DEBUG BB: Processing node 11, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 11 LP 5 Solution, length = 28316021.785097, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.183690 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.183690 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.183690 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.183690 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.081552 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.816310 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.816310 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.816310 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.816310 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.816310 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28316021.785097, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28316021.785097, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 11 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 11
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.183690
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.183690)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.183690
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.183690)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=1.000000
DEBUG CAREFUL: Skipping var 9: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.183690
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.183690)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.183690
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.183690)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.081552
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.081552)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 22
DEBUG CAREFUL: New best var: 22
DEBUG CAREFUL: Testing fvar[1] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[2] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
DEBUG CAREFUL: Testing fvar[3] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[4] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
  % Initial guess is x18, Z0 = 28316021.7850972        , Z1 = 28523074.7357445        

DEBUG EVAL: Testing var 22 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=29, varin=39, theta=0.905169, up=999999999999999983222784.000000
ITER 2: row=39, varin=3, theta=1.169781, up=999999999999999983222784.000000
ITER 3: row=3, varin=41, theta=1.897545, up=999999999999999983222784.000000
ITER 4: row=4, varin=30, theta=0.874613, up=999999999999999983222784.000000
ITER 5: row=30, varin=13, theta=1.403059, up=999999999999999983222784.000000
ITER 6: row=13, varin=26, theta=0.289408, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 22 = 1 gives z=28513801.439689
  % 	x22 = 1,	Z1 = 28513801.4396887        
DEBUG EVAL: First branch cutoff check: z=28513801.439689, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 22 = 0
ITER 1: row=29, varin=57, theta=0.117258, up=1.000000
  % 	x22 = 0,	Z0 = 28316219.0609624        
DEBUG EVAL: Second branch cutoff check: z=28316219.060962, best_z=INF, threshold=INF
  %   New best:  x22, Z = 28316219.0609624        
DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=11, varin=45, theta=2.923275, up=999999999999999983222784.000000
ITER 2: row=1, varin=12, theta=3.293834, up=999999999999999983222784.000000
ITER 3: row=44, varin=38, theta=1.563327, up=999999999999999983222784.000000
ITER 4: row=34, varin=41, theta=7.910274, up=999999999999999983222784.000000
ITER 5: row=4, varin=3, theta=16.595244, up=999999999999999983222784.000000
ITER 6: row=3, varin=29, theta=1.817588, up=999999999999999983222784.000000
ITER 7: row=29, varin=70, theta=2.163700, up=1.000000
ITER 8: row=29, varin=71, theta=0.857713, up=1.000000
ITER 9: row=4, varin=70, theta=1.000000, up=1.000000
ITER 10: row=42, varin=103, theta=0.990386, up=1.000000
DEBUG EVAL: Branch var 17 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x17 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=11, varin=57, theta=0.704060, up=1.000000
ITER 2: row=29, varin=39, theta=0.399142, up=999999999999999983222784.000000
ITER 3: row=39, varin=3, theta=0.608593, up=999999999999999983222784.000000
ITER 4: row=3, varin=75, theta=0.416734, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28364435.023122
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.791633
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 45 rows, 60 cols, 263 nonzeros, 3 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 3 slack rows
   % @PAP adding 8 rows, 38 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=75, theta=0.346204, up=1.000000
ITER 2: row=43, varin=36, theta=0.220630, up=999999999999999983222784.000000
ITER 3: row=48, varin=35, theta=0.069177, up=999999999999999983222784.000000
ITER 4: row=47, varin=45, theta=0.215663, up=999999999999999983222784.000000
ITER 5: row=31, varin=47, theta=0.488797, up=999999999999999983222784.000000
ITER 6: row=3, varin=12, theta=1.074838, up=999999999999999983222784.000000
ITER 7: row=12, varin=55, theta=0.052266, up=1.000000
ITER 8: row=46, varin=34, theta=0.000784, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28383445.839933
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 50 rows, 60 cols, 292 nonzeros, 10 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 10 slack rows
   % @PAP adding 7 rows, 21 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=90, theta=0.784982, up=1.000000
ITER 2: row=43, varin=59, theta=0.471154, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28401978.959219
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 47 rows, 60 cols, 285 nonzeros, 3 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 3 slack rows
   % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=39, theta=1.615385, up=999999999999999983222784.000000
ITER 2: row=18, varin=69, theta=0.163030, up=1.000000
ITER 3: row=32, varin=96, theta=0.468998, up=1.000000
ITER 4: row=46, varin=21, theta=0.450798, up=999999999999999983222784.000000
ITER 5: row=26, varin=45, theta=0.056511, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28423213.676324
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 47 rows, 60 cols, 285 nonzeros, 5 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 5 slack rows
   % @PAP adding 5 rows, 10 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=25, theta=2.435469, up=999999999999999983222784.000000
ITER 2: row=46, varin=31, theta=0.282935, up=999999999999999983222784.000000
ITER 3: row=31, varin=21, theta=0.703705, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28433186.466930
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 47 rows, 60 cols, 272 nonzeros, 4 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 4 slack rows
   % @PAP adding 4 rows, 21 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=84, theta=0.166028, up=1.000000
ITER 2: row=46, varin=69, theta=0.307296, up=1.000000
ITER 3: row=28, varin=78, theta=0.395145, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28452431.252306
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 47 rows, 60 cols, 275 nonzeros, 1 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=74, theta=0.070005, up=1.000000
ITER 2: row=31, varin=71, theta=0.074758, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28454165.425682
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 48 rows, 60 cols, 273 nonzeros, 0 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=108, theta=0.040026, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28455735.937213
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 50 rows, 60 cols, 277 nonzeros, 0 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 11 at  28.45573593721267968704
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabbe180
% @LO 0.05  28.31602178509723088951 99.9000000000
% @LN 0.05  28.33993662917041689298 99.9000000000
% Resuming node 33 at  28.33993662917041689298
DEBUG CONSTRNT: LP rows=50, pool->nlprows=50, pool->npend=0
DEBUG CONSTRNT: Checking 50 LP rows (pool tracks 50, total LP rows 50)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=49, expected 49
 % @PAP adding 47 rows, 186 nz to LP
DEBUG BB: Processing node 33, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=3, theta=0.250000, up=999999999999999983222784.000000
ITER 2: row=45, varin=75, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28339936.629170
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 246 nonzeros, 0 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=78, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28340795.620082
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 252 nonzeros, 0 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=83, theta=0.500000, up=1.000000
ITER 2: row=49, varin=82, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28378279.344649
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 257 nonzeros, 0 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=24, theta=0.125000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28390888.589025
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 269 nonzeros, 5 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 3 rows, 47 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=30, theta=0.195684, up=999999999999999983222784.000000
ITER 2: row=48, varin=25, theta=0.090931, up=999999999999999983222784.000000
ITER 3: row=18, varin=87, theta=0.248634, up=1.000000
ITER 4: row=40, varin=45, theta=0.250000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28433065.615679
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 290 nonzeros, 2 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 33 LP 1 Solution, length = 28433065.615679, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.250000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.500000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.250000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.250000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.906159 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.093841 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.750000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.750000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28433065.615679, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 33 at  28.43306561567896295628
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabbedc0
% @LO 0.05  28.33993662917041689298 99.9000000000
% @LN 0.05  28.34787846669222943774 99.9000000000
% Resuming node 23 at  28.34787846669222943774
DEBUG CONSTRNT: LP rows=48, pool->nlprows=48, pool->npend=0
DEBUG CONSTRNT: Checking 48 LP rows (pool tracks 48, total LP rows 48)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=47, expected 47
 % @PAP adding 51 rows, 226 nz to LP
DEBUG BB: Processing node 23, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 23 LP 3 Solution, length = 28347878.466692, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.200000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.200000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.200000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.200000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.200000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.200000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.021650 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.021650 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.200000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.978350 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.800000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.800000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.978350 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.800000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.800000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.800000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.800000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.800000 (terminal 19)
 % 9 fractional variables
DEBUG CG: LP optimal, z=28347878.466692, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28347878.466692, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 23 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 23
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.200000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.200000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.200000
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.200000)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.200000
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.200000)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.200000
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.200000)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.200000
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.200000)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.200000
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.200000)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.021650
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.021650)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.021650
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.021650)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.200000
DEBUG CAREFUL: Adding var 37 to fractional list (xi=0.200000)
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 9 fractional variables

  %  Carefully choosing branching variable, nfrac = 9
DEBUG CAREFUL: Testing fvar[0] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 26
DEBUG CAREFUL: New best var: 26
DEBUG CAREFUL: Testing fvar[1] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 11
DEBUG CAREFUL: New best var: 11
DEBUG CAREFUL: Testing fvar[2] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 4
DEBUG CAREFUL: Testing fvar[3] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[4] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[5] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[6] = var 37
DEBUG CAREFUL: Calling compare_branch_vars for var 37
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 37
DEBUG CAREFUL: Testing fvar[7] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 36
DEBUG CAREFUL: Testing fvar[8] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 34
  % Initial guess is x11, Z0 = 28347878.4666922        , Z1 = 29132727.9340704        

DEBUG EVAL: Testing var 26 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=35, varin=50, theta=4.000000, up=999999999999999983222784.000000
ITER 2: row=37, varin=49, theta=6.000000, up=999999999999999983222784.000000
ITER 3: row=49, varin=38, theta=1.500000, up=999999999999999983222784.000000
ITER 4: row=24, varin=81, theta=2.182481, up=1.000000
ITER 5: row=24, varin=74, theta=0.388159, up=1.000000
ITER 6: row=37, varin=81, theta=1.000000, up=1.000000
ITER 7: row=8, varin=49, theta=9.994194, up=999999999999999983222784.000000
ITER 8: row=37, varin=41, theta=0.960481, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 1 gives z=28531114.295727
  % 	x26 = 1,	Z1 = 28531114.2957273        
DEBUG EVAL: First branch cutoff check: z=28531114.295727, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 0
ITER 1: row=35, varin=74, theta=1.000000, up=1.000000
  % 	x26 = 0,	Z0 = 28360797.8621811        
DEBUG EVAL: Second branch cutoff check: z=28360797.862181, best_z=INF, threshold=INF
  %   New best:  x26, Z = 28360797.8621811        
DEBUG EVAL: Testing var 11 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=29, varin=50, theta=4.000000, up=999999999999999983222784.000000
ITER 2: row=37, varin=49, theta=6.000000, up=999999999999999983222784.000000
ITER 3: row=49, varin=23, theta=3.000000, up=999999999999999983222784.000000
ITER 4: row=24, varin=41, theta=2.071335, up=999999999999999983222784.000000
ITER 5: row=34, varin=45, theta=8.933939, up=999999999999999983222784.000000
ITER 6: row=45, varin=46, theta=14.147263, up=999999999999999983222784.000000
ITER 7: row=46, varin=65, theta=11.107416, up=1.000000
ITER 8: row=46, varin=43, theta=4.625997, up=999999999999999983222784.000000
ITER 9: row=8, varin=40, theta=2.164192, up=999999999999999983222784.000000
ITER 10: row=49, varin=74, theta=2.378356, up=1.000000
DEBUG EVAL: Branch var 11 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x11 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=29, varin=74, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28360797.862181
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 51 rows, 60 cols, 286 nonzeros, 0 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 4 rows, 19 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=38, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=53, varin=52, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=24, varin=31, theta=0.299684, up=999999999999999983222784.000000
ITER 4: row=1, varin=37, theta=0.054828, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 28390028.984863
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 55 rows, 60 cols, 305 nonzeros, 11 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 11 slack rows
   % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=84, theta=0.360173, up=1.000000
ITER 2: row=46, varin=70, theta=0.571429, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28414226.790700
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 47 rows, 60 cols, 280 nonzeros, 0 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=41, theta=2.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28443450.149433
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 49 rows, 60 cols, 284 nonzeros, 1 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 2 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=78, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28443828.902434
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 50 rows, 60 cols, 283 nonzeros, 0 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=81, theta=0.500000, up=1.000000
ITER 2: row=18, varin=43, theta=0.300000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28447865.235095
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 52 rows, 60 cols, 289 nonzeros, 2 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 23 at  28.44786523509532827347
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595daba91d0
% @LO 0.05  28.34787846669222943774 99.9000000000
% @LN 0.05  28.35035401851907366222 99.9000000000
% Resuming node 34 at  28.35035401851907366222
DEBUG CONSTRNT: LP rows=50, pool->nlprows=50, pool->npend=0
DEBUG CONSTRNT: Checking 50 LP rows (pool tracks 50, total LP rows 50)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 143
DEBUG CONSTRNT: Pool row 143 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=49, expected 49
 % @PAP adding 47 rows, 186 nz to LP
DEBUG BB: Processing node 34, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=37, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=37, varin=47, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28304997.692296
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 246 nonzeros, 1 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 9 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=34, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=34, varin=42, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=42, varin=38, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=38, varin=29, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28347673.411690
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 255 nonzeros, 3 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 45 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=33, theta=0.007548, up=999999999999999983222784.000000
ITER 2: row=50, varin=61, theta=1.000000, up=1.000000
ITER 3: row=41, varin=19, theta=0.803516, up=999999999999999983222784.000000
ITER 4: row=29, varin=57, theta=4.355290, up=1.000000
ITER 5: row=29, varin=88, theta=0.816928, up=1.000000
ITER 6: row=10, varin=74, theta=1.000000, up=1.000000
ITER 7: row=36, varin=82, theta=1.000000, up=1.000000
ITER 8: row=34, varin=89, theta=0.800000, up=1.000000
ITER 9: row=17, varin=57, theta=1.000000, up=1.000000
ITER 10: row=38, varin=85, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=17)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28898732.288625
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 300 nonzeros, 5 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=77, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28900450.270448
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 251 nonzeros, 0 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=82, theta=1.000000, up=1.000000
ITER 2: row=48, varin=81, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28975417.719581
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 256 nonzeros, 0 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 52 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=33, theta=0.286450, up=999999999999999983222784.000000
ITER 2: row=50, varin=58, theta=7.142513, up=1.000000
ITER 3: row=50, varin=95, theta=1.495545, up=1.000000
ITER 4: row=50, varin=30, theta=0.129230, up=999999999999999983222784.000000
ITER 5: row=52, varin=95, theta=0.782654, up=1.000000
ITER 6: row=10, varin=58, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 29079613.022191
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 308 nonzeros, 3 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 2 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=46, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 29124313.329288
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 301 nonzeros, 1 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 34 LP 1 Solution, length = 29124313.329288, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 1.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.500000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.500000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.434404 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.565596 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=29124313.329288, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 34 at  29.12431332928787242054
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabbed00
% @LO 0.05  28.35035401851907366222 99.9000000000
% @LN 0.05  28.35385981027157242806 99.9000000000
% Resuming node 6 at  28.35385981027157242806
DEBUG CONSTRNT: LP rows=50, pool->nlprows=50, pool->npend=0
DEBUG CONSTRNT: Checking 50 LP rows (pool tracks 50, total LP rows 50)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=49, expected 49
 % @PAP adding 50 rows, 197 nz to LP
DEBUG BB: Processing node 6, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 6 LP 9 Solution, length = 28353859.810272, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 1.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.500000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.500000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28353859.810272, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28353859.810272, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 6 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 6
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.500000
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=1.000000
DEBUG CAREFUL: Skipping var 16: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.500000
DEBUG CAREFUL: Adding var 21 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.500000
DEBUG CAREFUL: Adding var 25 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 3 fractional variables

  %  Carefully choosing branching variable, nfrac = 3
DEBUG CAREFUL: Testing fvar[0] = var 25
DEBUG CAREFUL: Calling compare_branch_vars for var 25
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 25
DEBUG CAREFUL: New best var: 25
DEBUG CAREFUL: Testing fvar[1] = var 21
DEBUG CAREFUL: Calling compare_branch_vars for var 21
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 21
DEBUG CAREFUL: Testing fvar[2] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
  % Initial guess is x25, Z0 = 28353859.8102716        , Z1 = 28371460.7680632        

DEBUG EVAL: Testing var 25 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=28, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=28, varin=50, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 25 = 1 gives z=28356940.248732
  % 	x25 = 1,	Z1 = 28371460.7680632        
DEBUG EVAL: First branch cutoff check: z=28371460.768063, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 25 = 0
ITER 1: row=1, varin=45, theta=0.250000, up=999999999999999983222784.000000
ITER 2: row=49, varin=24, theta=0.029412, up=999999999999999983222784.000000
  % 	x25 = 0,	Z0 = 28378252.4665378        
DEBUG EVAL: Second branch cutoff check: z=28378252.466538, best_z=INF, threshold=INF
  %   New best:  x25, Z = 28371460.7680632        
DEBUG EVAL: Testing var 21 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=29, varin=65, theta=1.000000, up=1.000000
ITER 2: row=12, varin=20, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=30, varin=21, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=1, varin=45, theta=0.500000, up=999999999999999983222784.000000
ITER 5: row=49, varin=24, theta=0.058824, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 21 = 1 gives z=29392280.656266
  % 	x21 = 1,	Z1 = 29392280.6562665        
DEBUG EVAL: First branch cutoff check: z=29392280.656266, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 21 = 0
ITER 1: row=29, varin=50, theta=1.000000, up=999999999999999983222784.000000
  % 	x21 = 0,	Z0 = 28356940.2487321        
DEBUG EVAL: Second branch cutoff check: z=28356940.248732, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 12 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=20, varin=50, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 12 = 0 gives z=28356940.248732
  % 	x12 = 0,	Z0 = 28356940.2487321        
DEBUG EVAL: First branch cutoff check: z=28356940.248732, best_z=INF, threshold=INF
  % Best branch is x25, Z0 = 28378252.4665378        , Z1 = 28371460.7680632        

DEBUG CAREFUL: Final result - returning best.var = 25
DEBUG BB: Branching variable chosen: j=25
 % @NC   35    6	x25 = 1	28371460.768063
 % @NC   36    6	x25 = 0	28378252.466538
 %       6    16 28353859.8103               28359315.1049   x16 U     4     3
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabbe0c0
% @LO 0.05  28.35385981027157242806 99.9000000000
% @LN 0.05  28.35931510490689433368 99.9000000000
% Resuming node 30 at  28.35931510490689433368
DEBUG CONSTRNT: LP rows=50, pool->nlprows=50, pool->npend=0
DEBUG CONSTRNT: Checking 50 LP rows (pool tracks 50, total LP rows 50)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=49, expected 49
 % @PAP adding 38 rows, 188 nz to LP
DEBUG BB: Processing node 30, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 30 LP 2 Solution, length = 28359315.104907, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.082573 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.729357 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.500000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.270643 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.270643 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.729357 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.917427 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.917427 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.729357 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.917427 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.270643 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.270643 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.729357 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.270643 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28359315.104907, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28359315.104907, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 3 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 30 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 30
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.082573
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.082573)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.729357
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.729357)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.500000
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.500000
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.270643
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.270643)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.270643
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.270643)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 12
DEBUG CAREFUL: New best var: 12
DEBUG CAREFUL: Testing fvar[1] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 14
DEBUG CAREFUL: Testing fvar[2] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[3] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
DEBUG CAREFUL: Testing fvar[4] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
DEBUG CAREFUL: Testing fvar[5] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
  % Initial guess is x18, Z0 = 28359315.1049069        , Z1 = 28523074.7357445        

DEBUG EVAL: Testing var 12 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=12, varin=23, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=29, varin=21, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=1, varin=38, theta=0.167347, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 12 = 1 gives z=28556818.551214
  % 	x12 = 1,	Z1 = 28556818.5512139        
DEBUG EVAL: First branch cutoff check: z=28556818.551214, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 0
ITER 1: row=12, varin=28, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=30, theta=0.564383, up=999999999999999983222784.000000
  % 	x12 = 0,	Z0 = 28387578.1347642        
DEBUG EVAL: Second branch cutoff check: z=28387578.134764, best_z=INF, threshold=INF
  %   New best:  x12, Z = 28387578.1347642        
DEBUG EVAL: Testing var 14 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=17, varin=28, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=38, theta=0.588466, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 14 = 1 gives z=28402238.191256
  % 	x14 = 1,	Z1 = 28402238.1912556        
DEBUG EVAL: First branch cutoff check: z=28402238.191256, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 14 = 0
ITER 1: row=17, varin=30, theta=1.000000, up=999999999999999983222784.000000
  % 	x14 = 0,	Z0 = 28394486.787665         
DEBUG EVAL: Second branch cutoff check: z=28394486.787665, best_z=INF, threshold=INF
  %   New best:  x14, Z = 28394486.787665         
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=37, theta=0.657374, up=999999999999999983222784.000000
ITER 2: row=1, varin=80, theta=1.165067, up=1.000000
ITER 3: row=1, varin=41, theta=0.052376, up=1.000000
ITER 4: row=6, varin=30, theta=0.170934, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28376357.825358
  % 	x10 = 1,	Z1 = 28376357.8253583        
DEBUG EVAL: First branch cutoff check: z=28376357.825358, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=20, varin=37, theta=1.239777, up=999999999999999983222784.000000
ITER 2: row=1, varin=35, theta=6.215137, up=999999999999999983222784.000000
ITER 3: row=35, varin=38, theta=0.566591, up=999999999999999983222784.000000
ITER 4: row=32, varin=30, theta=1.206473, up=999999999999999983222784.000000
ITER 5: row=12, varin=32, theta=0.026393, up=999999999999999983222784.000000
ITER 6: row=27, varin=2, theta=0.047218, up=999999999999999983222784.000000
ITER 7: row=2, varin=25, theta=0.449386, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 1 gives z=28449485.318015
  % 	x17 = 1,	Z1 = 28449485.3180145        
DEBUG EVAL: First branch cutoff check: z=28449485.318015, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 0
ITER 1: row=20, varin=80, theta=0.931234, up=1.000000
ITER 2: row=7, varin=38, theta=0.058183, up=999999999999999983222784.000000
  % 	x17 = 0,	Z0 = 28372038.463951         
DEBUG EVAL: Second branch cutoff check: z=28372038.463951, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 18 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=27, varin=35, theta=3.333515, up=999999999999999983222784.000000
ITER 2: row=35, varin=33, theta=1.385015, up=999999999999999983222784.000000
ITER 3: row=20, varin=25, theta=237.050206, up=999999999999999983222784.000000
ITER 4: row=1, varin=28, theta=4.015729, up=999999999999999983222784.000000
ITER 5: row=36, varin=2, theta=0.499952, up=999999999999999983222784.000000
ITER 6: row=2, varin=30, theta=1.296787, up=999999999999999983222784.000000
ITER 7: row=28, varin=40, theta=2.304674, up=1.000000
ITER 8: row=28, varin=27, theta=0.207058, up=999999999999999983222784.000000
ITER 9: row=17, varin=40, theta=0.606684, up=1.000000
ITER 10: row=12, varin=26, theta=0.753405, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 18 = 1 gives z=28549099.612022
  % 	x18 = 1,	Z1 = 28549099.6120223        
DEBUG EVAL: First branch cutoff check: z=28549099.612022, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 18 = 0
ITER 1: row=27, varin=37, theta=0.657374, up=999999999999999983222784.000000
ITER 2: row=1, varin=80, theta=1.165067, up=1.000000
ITER 3: row=1, varin=38, theta=0.043020, up=999999999999999983222784.000000
ITER 4: row=31, varin=80, theta=0.058183, up=1.000000
  % 	x18 = 0,	Z0 = 28372038.463951         
DEBUG EVAL: Second branch cutoff check: z=28372038.463951, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=25, theta=0.094720, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 0 gives z=28359712.624157
  % 	x1 = 0,	Z0 = 28359712.6241568        
DEBUG EVAL: First branch cutoff check: z=28359712.624157, best_z=INF, threshold=INF
  % Best branch is x14, Z0 = 28394486.787665         , Z1 = 28402238.1912556        

DEBUG CAREFUL: Final result - returning best.var = 14
DEBUG BB: Branching variable chosen: j=14
 % @NC   37   30	x14 = 0	28394486.787665
 % @NC   38   30	x14 = 1	28402238.191256
 %      30    17 28359315.1049               28359504.6642    x8 D    18     8
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabd7f60
% @LO 0.05  28.35931510490689433368 99.9000000000
% @LN 0.05  28.35950466417066806457 99.9000000000
% Resuming node 27 at  28.35950466417066806457
DEBUG CONSTRNT: LP rows=38, pool->nlprows=38, pool->npend=0
DEBUG CONSTRNT: Checking 38 LP rows (pool tracks 38, total LP rows 38)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 85
DEBUG CONSTRNT: Pool row 85 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=37, expected 37
 % @PAP adding 41 rows, 208 nz to LP
DEBUG BB: Processing node 27, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 27 LP 2 Solution, length = 28359504.664171, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.221654 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.278346 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.278346 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.278346 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.721654 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.721654 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.721654 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.721654 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.721654 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.721654 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28359504.664171, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28359504.664171, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 27 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 27
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.221654
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.221654)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.278346
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.278346)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=1.000000
DEBUG CAREFUL: Skipping var 15: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.278346
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.278346)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.278346
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.278346)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
DEBUG CAREFUL: Testing fvar[1] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 18
DEBUG CAREFUL: Testing fvar[2] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[3] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x17, Z0 = 28359504.6641707        , Z1 = 29012121.5394857        

DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=14, varin=41, theta=1.032713, up=999999999999999983222784.000000
ITER 2: row=29, varin=37, theta=0.096756, up=999999999999999983222784.000000
ITER 3: row=9, varin=32, theta=0.174905, up=999999999999999983222784.000000
ITER 4: row=2, varin=39, theta=0.142330, up=999999999999999983222784.000000
ITER 5: row=28, varin=3, theta=0.141271, up=999999999999999983222784.000000
ITER 6: row=35, varin=65, theta=1.156802, up=1.000000
ITER 7: row=35, varin=68, theta=0.046443, up=1.000000
ITER 8: row=10, varin=65, theta=1.000000, up=1.000000
ITER 9: row=5, varin=36, theta=0.237493, up=999999999999999983222784.000000
ITER 10: row=36, varin=10, theta=0.840559, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x17 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=14, varin=31, theta=0.341291, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28422487.307952
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 3.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1000000.000000
   % @PL 41 rows, 60 cols, 268 nonzeros, 1 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 4 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=74, theta=1.000000, up=1.000000
ITER 2: row=34, varin=68, theta=2.000000, up=1.000000
ITER 3: row=34, varin=89, theta=0.166667, up=1.000000
ITER 4: row=10, varin=68, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28492714.211993
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 3.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1000000.000000
   % @PL 44 rows, 60 cols, 279 nonzeros, 3 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 3 slack rows
   % @PAP adding 4 rows, 9 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=33, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=45, varin=8, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28508562.117998
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.500000
DEBUG SOLUTION: lp->best_solution[7] = 0.500000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1000000.000000
   % @PL 45 rows, 60 cols, 279 nonzeros, 4 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 4 slack rows
   % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=54, theta=0.210242, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28519326.098068
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 42 rows, 60 cols, 267 nonzeros, 0 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=72, theta=0.168992, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28522807.227221
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 45 rows, 60 cols, 273 nonzeros, 0 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 3 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=53, theta=0.058291, up=1.000000
ITER 2: row=37, varin=26, theta=0.010813, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28523432.933219
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 48 rows, 60 cols, 280 nonzeros, 1 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=36, theta=0.167624, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28525051.742281
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 48 rows, 60 cols, 280 nonzeros, 1 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 27 at  28.52505174228138784542
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabaf550
% @LO 0.06  28.35950466417066806457 99.9000000000
% @LN 0.06  28.36069864650832528241 99.9000000000
% Resuming node 28 at  28.36069864650832528241
DEBUG CONSTRNT: LP rows=47, pool->nlprows=47, pool->npend=0
DEBUG CONSTRNT: Checking 47 LP rows (pool tracks 47, total LP rows 47)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 150
DEBUG CONSTRNT: Pool row 150 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 85
DEBUG CONSTRNT: Pool row 85 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 143
DEBUG CONSTRNT: Pool row 143 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=46, expected 46
 % @PAP adding 45 rows, 223 nz to LP
DEBUG BB: Processing node 28, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=14, varin=45, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=34, varin=4, theta=0.020100, up=999999999999999983222784.000000
ITER 3: row=31, varin=72, theta=-0.576552, up=1.000000
ITER 4: row=44, varin=35, theta=0.024974, up=999999999999999983222784.000000
ITER 5: row=31, varin=75, theta=0.151042, up=1.000000
ITER 6: row=19, varin=15, theta=0.109775, up=999999999999999983222784.000000
ITER 7: row=9, varin=67, theta=0.338190, up=1.000000
ITER 8: row=31, varin=32, theta=0.146457, up=999999999999999983222784.000000
ITER 9: row=32, varin=37, theta=0.097888, up=999999999999999983222784.000000
ITER 10: row=5, varin=3, theta=0.123925, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=15)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28360698.646508
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 3.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1000000.000000
  % @PL 45 rows, 60 cols, 283 nonzeros, 1 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 5 rows, 21 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=17, theta=0.239441, up=999999999999999983222784.000000
ITER 2: row=46, varin=73, theta=0.996142, up=1.000000
ITER 3: row=3, varin=74, theta=0.009904, up=1.000000
ITER 4: row=10, varin=53, theta=0.002106, up=1.000000
ITER 5: row=5, varin=59, theta=0.001015, up=1.000000
ITER 6: row=33, varin=87, theta=0.001726, up=1.000000
ITER 7: row=30, varin=80, theta=0.005851, up=1.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28430649.828609
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.998830
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 3.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1000000.000000
  % @PL 50 rows, 60 cols, 304 nonzeros, 3 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 7 rows, 26 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=29, theta=0.581323, up=999999999999999983222784.000000
ITER 2: row=51, varin=69, theta=1.368722, up=1.000000
ITER 3: row=51, varin=61, theta=0.364193, up=1.000000
ITER 4: row=25, varin=79, theta=1.713207, up=1.000000
ITER 5: row=25, varin=58, theta=0.611993, up=1.000000
ITER 6: row=29, varin=32, theta=2.180006, up=999999999999999983222784.000000
ITER 7: row=36, varin=15, theta=0.228433, up=999999999999999983222784.000000
ITER 8: row=32, varin=36, theta=18.056147, up=999999999999999983222784.000000
ITER 9: row=29, varin=82, theta=1.434961, up=1.000000
ITER 10: row=29, varin=83, theta=0.475338, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.998830
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 3.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1000000.000000
  % @PL 54 rows, 60 cols, 324 nonzeros, 3 slack, 51 tight.
  % Node 28 LP 1 Solution, length = 999999999999999983222784.000000, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.995319 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.005851 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.998830 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 28 is INFEASIBLE
 %      28    16    infeasible               28371460.7681    x9 U    13     7
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabd9c70
% @LO 0.06  28.36069864650832528241 99.9000000000
% @LN 0.06  28.37146076806318717445 99.9000000000
% Resuming node 35 at  28.37146076806318717445
DEBUG CONSTRNT: LP rows=54, pool->nlprows=54, pool->npend=0
DEBUG CONSTRNT: Checking 54 LP rows (pool tracks 54, total LP rows 54)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 150
DEBUG CONSTRNT: Pool row 150 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=53, expected 53
 % @PAP adding 50 rows, 197 nz to LP
DEBUG BB: Processing node 35, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=28, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=28, varin=50, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28356940.248732
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 257 nonzeros, 1 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 9 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=46, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=46, varin=29, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28399615.968127
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 266 nonzeros, 3 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 1 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=60, theta=1.000000, up=1.000000
ITER 2: row=12, varin=21, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28825799.498075
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 260 nonzeros, 1 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 2 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=89, theta=1.000000, up=1.000000
ITER 2: row=43, varin=74, theta=1.000000, up=1.000000
ITER 3: row=27, varin=42, theta=0.500000, up=999999999999999983222784.000000
ITER 4: row=46, varin=23, theta=0.058824, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28923421.406923
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 265 nonzeros, 5 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 6 rows, 63 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=80, theta=0.512249, up=1.000000
ITER 2: row=47, varin=97, theta=0.294694, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28943148.604563
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 316 nonzeros, 3 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=80, theta=0.708100, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28944436.454826
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 312 nonzeros, 0 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=86, theta=0.877209, up=1.000000
ITER 2: row=51, varin=85, theta=0.856062, up=1.000000
ITER 3: row=47, varin=22, theta=0.090360, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 29032752.535206
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 53 rows, 60 cols, 320 nonzeros, 3 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=21, theta=0.761221, up=999999999999999983222784.000000
ITER 2: row=14, varin=44, theta=2.475596, up=999999999999999983222784.000000
ITER 3: row=43, varin=42, theta=0.028088, up=999999999999999983222784.000000
ITER 4: row=25, varin=35, theta=0.106676, up=999999999999999983222784.000000
ITER 5: row=35, varin=67, theta=0.072594, up=1.000000
ITER 6: row=41, varin=28, theta=0.038457, up=999999999999999983222784.000000
ITER 7: row=28, varin=58, theta=0.045184, up=1.000000
ITER 8: row=11, varin=41, theta=0.359006, up=999999999999999983222784.000000
ITER 9: row=35, varin=27, theta=0.062402, up=999999999999999983222784.000000
ITER 10: row=27, varin=4, theta=0.086345, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 316 nonzeros, 2 slack, 49 tight.
  % Node 35 LP 1 Solution, length = 999999999999999983222784.000000, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.096403 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.090360 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 1.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 1.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.090360 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.096403 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.096403 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.722877 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.090360 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.903597 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.903597 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.909640 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.903597 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.909640 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 35 is INFEASIBLE
 %      35    15    infeasible               28378252.4665   x25 U     6     4
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabc3990
% @LO 0.06  28.37146076806318717445 99.9000000000
% @LN 0.06  28.37825246653778421546 99.9000000000
% Resuming node 36 at  28.37825246653778421546
DEBUG CONSTRNT: LP rows=51, pool->nlprows=51, pool->npend=0
DEBUG CONSTRNT: Checking 51 LP rows (pool tracks 51, total LP rows 51)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=50, expected 50
 % @PAP adding 50 rows, 197 nz to LP
DEBUG BB: Processing node 36, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=45, theta=0.250000, up=999999999999999983222784.000000
ITER 2: row=49, varin=24, theta=0.029412, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28378252.466538
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 257 nonzeros, 4 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 5 rows, 23 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=96, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28379109.584660
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 272 nonzeros, 3 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 1 rows, 40 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=77, theta=0.116216, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28382077.660093
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 302 nonzeros, 0 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=80, theta=0.116677, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28382289.864885
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 308 nonzeros, 0 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=86, theta=0.144542, up=1.000000
ITER 2: row=51, varin=85, theta=0.141057, up=1.000000
ITER 3: row=47, varin=68, theta=0.378999, up=1.000000
ITER 4: row=12, varin=23, theta=0.014889, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28396842.096622
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 53 rows, 60 cols, 316 nonzeros, 3 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=22, theta=0.125430, up=999999999999999983222784.000000
ITER 2: row=45, varin=44, theta=0.399120, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28406216.198931
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 312 nonzeros, 1 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 36 LP 1 Solution, length = 28406216.198931, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.328948 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.057017 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 1.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.500000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.057017 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.328948 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.328948 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.057017 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.057017 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.671052 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.671052 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.942983 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.671052 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.942983 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 9 fractional variables
DEBUG CG: LP optimal, z=28406216.198931, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 36 at  28.40621619893071070351
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabdaef0
% @LO 0.06  28.37825246653778421546 99.9000000000
% @LN 0.06  28.38255149807160648834 99.9000000000
% Resuming node 26 at  28.38255149807160648834
DEBUG CONSTRNT: LP rows=50, pool->nlprows=50, pool->npend=0
DEBUG CONSTRNT: Checking 50 LP rows (pool tracks 50, total LP rows 50)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=49, expected 49
 % @PAP adding 38 rows, 199 nz to LP
DEBUG BB: Processing node 26, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=14, varin=33, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=38, varin=29, theta=0.075000, up=999999999999999983222784.000000
ITER 3: row=5, varin=42, theta=0.500000, up=1.000000
ITER 4: row=1, varin=37, theta=0.306256, up=999999999999999983222784.000000
ITER 5: row=28, varin=3, theta=0.500520, up=999999999999999983222784.000000
ITER 6: row=36, varin=68, theta=1.355013, up=1.000000
ITER 7: row=36, varin=45, theta=0.339873, up=1.000000
ITER 8: row=20, varin=62, theta=0.914818, up=1.000000
ITER 9: row=10, varin=28, theta=0.115055, up=999999999999999983222784.000000
ITER 10: row=31, varin=65, theta=0.288363, up=1.000000
LP PHASE: Switching to primal (iter=19)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 28382551.498072
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 3.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1000000.000000
  % @PL 38 rows, 60 cols, 259 nonzeros, 3 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 6 rows, 24 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=71, theta=0.390356, up=1.000000
ITER 2: row=38, varin=64, theta=0.679956, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28435626.943312
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 3.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1000000.000000
  % @PL 41 rows, 60 cols, 277 nonzeros, 0 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 8 rows, 32 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=78, theta=4.546445, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 3.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1000000.000000
  % @PL 49 rows, 60 cols, 309 nonzeros, 4 slack, 45 tight.
  % Node 26 LP 1 Solution, length = 999999999999999983222784.000000, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 1.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.679956 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.320044 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 26 is INFEASIBLE
 %      26    14    infeasible               28384724.2938   x14 U    17     8
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabda810
% @LO 0.06  28.38255149807160648834 99.9000000000
% @LN 0.06  28.38472429377033279252 99.9000000000
% Resuming node 24 at  28.38472429377033279252
DEBUG CONSTRNT: LP rows=49, pool->nlprows=49, pool->npend=0
DEBUG CONSTRNT: Checking 49 LP rows (pool tracks 49, total LP rows 49)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=48, expected 48
 % @PAP adding 50 rows, 226 nz to LP
DEBUG BB: Processing node 24, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=28, varin=49, theta=2.921568, up=999999999999999983222784.000000
ITER 2: row=4, varin=47, theta=3.156900, up=999999999999999983222784.000000
ITER 3: row=28, varin=64, theta=4.674392, up=1.000000
ITER 4: row=28, varin=72, theta=1.885710, up=1.000000
ITER 5: row=28, varin=73, theta=0.903544, up=1.000000
ITER 6: row=41, varin=46, theta=2.613479, up=999999999999999983222784.000000
ITER 7: row=16, varin=36, theta=3.455762, up=999999999999999983222784.000000
ITER 8: row=44, varin=40, theta=1.527867, up=999999999999999983222784.000000
ITER 9: row=17, varin=64, theta=1.000000, up=1.000000
ITER 10: row=25, varin=72, theta=1.000000, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 3.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1000000.000000
  % @PL 50 rows, 60 cols, 286 nonzeros, 10 slack, 40 tight.
  % Node 24 LP 1 Solution, length = 999999999999999983222784.000000, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.256523 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.256523 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.106211 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.106211 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.106211 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.106211 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.106211 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.106211 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.106211 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.256523 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.747441 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.875426 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.747441 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.747441 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.875426 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.747441 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.875426 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.875426 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.875426 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 24 is INFEASIBLE
 %      24    13    infeasible               28394486.7877   x18 U     3     3
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabbed00
% @LO 0.06  28.38472429377033279252 99.9000000000
% @LN 0.06  28.39448678766499511994 99.9000000000
% Resuming node 37 at  28.39448678766499511994
DEBUG CONSTRNT: LP rows=50, pool->nlprows=50, pool->npend=0
DEBUG CONSTRNT: Checking 50 LP rows (pool tracks 50, total LP rows 50)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 85
DEBUG CONSTRNT: Pool row 85 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=49, expected 49
 % @PAP adding 38 rows, 188 nz to LP
DEBUG BB: Processing node 37, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=17, varin=30, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 28394486.787665
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 3.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 38 rows, 60 cols, 248 nonzeros, 1 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 37 LP 1 Solution, length = 28394486.787665, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.550250 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.612437 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.387563 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.387563 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.612437 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.449750 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.449750 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.612437 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.449750 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.387563 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.387563 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.612437 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.387563 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28394486.787665, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.06  28.39448678766499511994 99.9000000000
 % @LN 0.06  28.39448678766499867265 99.9000000000
DEBUG CG: Second cutoff check: z=28394486.787665, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 37 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 37
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.550250
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.550250)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.612437
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.612437)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.387563
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.387563)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.387563
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.387563)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
DEBUG CAREFUL: Testing fvar[1] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
DEBUG CAREFUL: Testing fvar[2] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[3] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
  % Initial guess is x18, Z0 = 28394486.787665         , Z1 = 28549099.6120223        

DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=12, varin=36, theta=1.041035, up=999999999999999983222784.000000
ITER 2: row=1, varin=34, theta=1.063643, up=999999999999999983222784.000000
ITER 3: row=34, varin=37, theta=0.096965, up=999999999999999983222784.000000
ITER 4: row=17, varin=2, theta=0.047218, up=999999999999999983222784.000000
ITER 5: row=2, varin=28, theta=0.109276, up=999999999999999983222784.000000
ITER 6: row=27, varin=27, theta=0.062109, up=999999999999999983222784.000000
ITER 7: row=28, varin=39, theta=0.456656, up=1.000000
DEBUG EVAL: Branch var 17 = 1 gives z=28441719.259191
  % 	x17 = 1,	Z1 = 28449485.3180145        
DEBUG EVAL: First branch cutoff check: z=28449485.318015, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 0
ITER 1: row=12, varin=79, theta=1.333532, up=1.000000
ITER 2: row=12, varin=32, theta=0.204764, up=999999999999999983222784.000000
  % 	x17 = 0,	Z0 = 28421108.2770201        
DEBUG EVAL: Second branch cutoff check: z=28421108.277020, best_z=INF, threshold=INF
  %   New best:  x17, Z = 28421108.2770201        
DEBUG EVAL: Testing var 18 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=17, varin=34, theta=2.799136, up=999999999999999983222784.000000
ITER 2: row=34, varin=32, theta=1.162990, up=999999999999999983222784.000000
ITER 3: row=12, varin=25, theta=100.351699, up=999999999999999983222784.000000
ITER 4: row=24, varin=2, theta=0.209543, up=999999999999999983222784.000000
ITER 5: row=1, varin=80, theta=0.420862, up=1.000000
ITER 6: row=2, varin=28, theta=0.508245, up=999999999999999983222784.000000
ITER 7: row=27, varin=27, theta=0.302146, up=999999999999999983222784.000000
ITER 8: row=28, varin=11, theta=2.235295, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 18 = 1 gives z=28553470.841687
  % 	x18 = 1,	Z1 = 28553470.8416871        
DEBUG EVAL: First branch cutoff check: z=28553470.841687, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 18 = 0
ITER 1: row=17, varin=79, theta=1.333532, up=1.000000
ITER 2: row=17, varin=36, theta=0.235446, up=999999999999999983222784.000000
  % 	x18 = 0,	Z0 = 28412324.2732762        
DEBUG EVAL: Second branch cutoff check: z=28412324.273276, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=79, theta=1.333532, up=1.000000
ITER 2: row=6, varin=36, theta=0.235446, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28412324.273276
  % 	x10 = 1,	Z1 = 28412324.2732762        
DEBUG EVAL: First branch cutoff check: z=28412324.273276, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 1 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=37, theta=0.371247, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 1 gives z=28409382.229839
  % 	x1 = 1,	Z1 = 28409382.2298389        
DEBUG EVAL: First branch cutoff check: z=28409382.229839, best_z=INF, threshold=INF
  % Best branch is x17, Z0 = 28421108.2770201        , Z1 = 28449485.3180145        

DEBUG CAREFUL: Final result - returning best.var = 17
DEBUG BB: Branching variable chosen: j=17
 % @NC   39   37	x17 = 0	28421108.277020
 % @NC   40   37	x17 = 1	28449485.318015
 %      37    14 28394486.7877               28401790.8333   x14 D    30     9
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabad4e0
% @LO 0.06  28.39448678766499867265 99.9000000000
% @LN 0.06  28.40179083333260834365 99.9000000000
% Resuming node 29 at  28.40179083333260834365
DEBUG CONSTRNT: LP rows=37, pool->nlprows=37, pool->npend=0
DEBUG CONSTRNT: Checking 37 LP rows (pool tracks 37, total LP rows 37)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 85
DEBUG CONSTRNT: Pool row 85 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=36, expected 36
 % @PAP adding 43 rows, 211 nz to LP
DEBUG BB: Processing node 29, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 29 LP 2 Solution, length = 28401790.833333, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.226871 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.226871 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.226871 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.226871 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.092516 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.773129 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.773129 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.773129 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.773129 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.773129 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.773129 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28401790.833333, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28401790.833333, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 29 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 29
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.226871
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.226871)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=1.000000
DEBUG CAREFUL: Skipping var 8: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.226871
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.226871)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.226871
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.226871)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.226871
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.226871)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.092516
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.092516)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 26
DEBUG CAREFUL: New best var: 26
DEBUG CAREFUL: Testing fvar[1] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
DEBUG CAREFUL: Testing fvar[2] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[3] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[4] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 10
DEBUG CAREFUL: New best var: 10
  % Initial guess is x10, Z0 = 28401790.8333326        , Z1 = 28560889.552519         

DEBUG EVAL: Testing var 26 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=28, varin=40, theta=1.216514, up=999999999999999983222784.000000
ITER 2: row=15, varin=86, theta=1.789524, up=1.000000
ITER 3: row=15, varin=10, theta=0.437984, up=999999999999999983222784.000000
ITER 4: row=10, varin=35, theta=1.617631, up=999999999999999983222784.000000
ITER 5: row=4, varin=38, theta=0.253612, up=999999999999999983222784.000000
ITER 6: row=3, varin=5, theta=0.118038, up=999999999999999983222784.000000
ITER 7: row=5, varin=42, theta=0.148653, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 1 gives z=28486258.452658
  % 	x26 = 1,	Z1 = 28486258.4526578        
DEBUG EVAL: First branch cutoff check: z=28486258.452658, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 0
ITER 1: row=28, varin=73, theta=0.127649, up=1.000000
  % 	x26 = 0,	Z0 = 28402038.5428098        
DEBUG EVAL: Second branch cutoff check: z=28402038.542810, best_z=INF, threshold=INF
  %   New best:  x26, Z = 28402038.5428098        
DEBUG EVAL: Testing var 18 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=27, varin=30, theta=1.953597, up=999999999999999983222784.000000
ITER 2: row=15, varin=19, theta=1.424524, up=999999999999999983222784.000000
ITER 3: row=28, varin=73, theta=2.567476, up=1.000000
ITER 4: row=28, varin=65, theta=0.923883, up=1.000000
ITER 5: row=43, varin=3, theta=5.678063, up=999999999999999983222784.000000
ITER 6: row=1, varin=42, theta=2.062585, up=999999999999999983222784.000000
ITER 7: row=28, varin=66, theta=2.518068, up=1.000000
ITER 8: row=28, varin=68, theta=2.550631, up=1.000000
ITER 9: row=28, varin=69, theta=1.036621, up=1.000000
ITER 10: row=28, varin=15, theta=0.057857, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 18 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x18 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=27, varin=40, theta=1.216514, up=999999999999999983222784.000000
ITER 2: row=15, varin=85, theta=1.085807, up=1.000000
ITER 3: row=15, varin=73, theta=0.953289, up=1.000000
ITER 4: row=34, varin=85, theta=1.000000, up=1.000000
ITER 5: row=15, varin=86, theta=1.641175, up=1.000000
ITER 6: row=15, varin=35, theta=0.543064, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28434964.127371
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.962919
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 3.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1000000.000000
   % @PL 43 rows, 60 cols, 271 nonzeros, 3 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 3 slack rows
   % @PAP adding 8 rows, 26 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=78, theta=0.685408, up=1.000000
ITER 2: row=44, varin=102, theta=0.901518, up=1.000000
ITER 3: row=41, varin=42, theta=0.031209, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28438083.313857
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.062418
DEBUG SOLUTION: lp->best_solution[6] = 0.062418
DEBUG SOLUTION: lp->best_solution[7] = 1.124836
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 48 rows, 60 cols, 288 nonzeros, 6 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 6 slack rows
   % @PAP adding 4 rows, 16 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=89, theta=1.645976, up=1.000000
ITER 2: row=45, varin=71, theta=0.291562, up=1.000000
ITER 3: row=44, varin=31, theta=1.300189, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
ITER 4: row=25, varin=27, theta=0.000000, up=999999999999999983222784.000000
ITER 5: row=42, varin=58, theta=0.000000, up=1.000000
ITER 6: row=3, varin=24, theta=0.036792, up=999999999999999983222784.000000
ITER 7: row=1, varin=89, theta=0.685972, up=1.000000
ITER 8: row=1, varin=70, theta=0.355389, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28499527.488493
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 46 rows, 60 cols, 289 nonzeros, 4 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 4 slack rows
   % @PAP adding 6 rows, 20 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=85, theta=17.000000, up=1.000000
ITER 2: row=1, varin=59, theta=8.000000, up=1.000000
ITER 3: row=1, varin=50, theta=7.000000, up=1.000000
ITER 4: row=1, varin=63, theta=4.000000, up=1.000000
ITER 5: row=1, varin=89, theta=9.000000, up=1.000000
ITER 6: row=1, varin=90, theta=8.000000, up=1.000000
ITER 7: row=1, varin=91, theta=7.000000, up=1.000000
ITER 8: row=1, varin=92, theta=6.000000, up=1.000000
ITER 9: row=1, varin=93, theta=5.000000, up=1.000000
ITER 10: row=1, varin=94, theta=4.000000, up=1.000000
LP PHASE: Switching to primal (iter=83)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28514547.760687
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 48 rows, 60 cols, 301 nonzeros, 1 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 4 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=53, theta=1.500000, up=1.000000
ITER 2: row=48, varin=42, theta=0.190476, up=999999999999999983222784.000000
ITER 3: row=40, varin=53, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28533319.990483
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 51 rows, 60 cols, 306 nonzeros, 3 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 3 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 29 at  28.53331999048349132408
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabbca20
% @LO 0.06  28.40179083333260834365 99.9000000000
% @LN 0.06  28.40223819125555593246 99.9000000000
% Resuming node 38 at  28.40223819125555593246
DEBUG CONSTRNT: LP rows=48, pool->nlprows=48, pool->npend=0
DEBUG CONSTRNT: Checking 48 LP rows (pool tracks 48, total LP rows 48)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 62
DEBUG CONSTRNT: Pool row 62 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=47, expected 47
 % @PAP adding 38 rows, 188 nz to LP
DEBUG BB: Processing node 38, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=17, varin=28, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=38, theta=0.588466, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 28402238.191256
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 3.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 38 rows, 60 cols, 248 nonzeros, 3 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 5 rows, 22 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=82, theta=0.679639, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28413393.161752
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.320361
DEBUG SOLUTION: lp->best_solution[4] = 0.320361
DEBUG SOLUTION: lp->best_solution[5] = 1.640723
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 3.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 262 nonzeros, 5 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 4 rows, 15 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=42, theta=0.288930, up=1.000000
ITER 2: row=5, varin=46, theta=0.244624, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 28434058.541337
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 3.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1000000.000000
  % @PL 39 rows, 60 cols, 253 nonzeros, 0 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 17 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=46, theta=0.250992, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28436683.681714
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 3.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1000000.000000
  % @PL 42 rows, 60 cols, 270 nonzeros, 0 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=32, theta=0.002210, up=999999999999999983222784.000000
ITER 2: row=34, varin=75, theta=0.003274, up=1.000000
ITER 3: row=39, varin=69, theta=0.006850, up=1.000000
ITER 4: row=10, varin=23, theta=0.006174, up=999999999999999983222784.000000
ITER 5: row=21, varin=72, theta=0.003131, up=1.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28437087.462708
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 3.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1000000.000000
  % @PL 45 rows, 60 cols, 276 nonzeros, 0 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 38 LP 1 Solution, length = 28437087.462708, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.249217 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.249217 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 1.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.249217 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.249217 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.003131 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.750783 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.750783 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.750783 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.750783 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.750783 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.750783 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28437087.462708, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 38 at  28.43708746270764464725
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabc3990
% @LO 0.06  28.40223819125555593246 99.9000000000
% @LN 0.06  28.40621619893071070351 99.9000000000
% Resuming node 36 at  28.40621619893071070351
DEBUG CONSTRNT: LP rows=45, pool->nlprows=45, pool->npend=0
DEBUG CONSTRNT: Checking 45 LP rows (pool tracks 45, total LP rows 45)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 85
DEBUG CONSTRNT: Pool row 85 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=44, expected 44
 % @PAP adding 50 rows, 242 nz to LP
DEBUG BB: Processing node 36, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 36 LP 2 Solution, length = 28406216.198931, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.328948 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.057017 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 1.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.500000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.057017 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.328948 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.328948 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.057017 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.057017 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.671052 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.671052 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.942983 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.671052 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.942983 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 9 fractional variables
DEBUG CG: LP optimal, z=28406216.198931, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28406216.198931, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 36 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 36
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.328948
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.328948)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.057017
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.057017)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.500000
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=1.000000
DEBUG CAREFUL: Skipping var 16: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.500000
DEBUG CAREFUL: Adding var 21 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.057017
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.057017)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.328948
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.328948)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.328948
DEBUG CAREFUL: Adding var 30 to fractional list (xi=0.328948)
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.057017
DEBUG CAREFUL: Adding var 31 to fractional list (xi=0.057017)
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.057017
DEBUG CAREFUL: Adding var 32 to fractional list (xi=0.057017)
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 9 fractional variables

  %  Carefully choosing branching variable, nfrac = 9
DEBUG CAREFUL: Testing fvar[0] = var 21
DEBUG CAREFUL: Calling compare_branch_vars for var 21
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 21
DEBUG CAREFUL: New best var: 21
DEBUG CAREFUL: Testing fvar[1] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
DEBUG CAREFUL: Testing fvar[2] = var 32
DEBUG CAREFUL: Calling compare_branch_vars for var 32
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 32
DEBUG CAREFUL: Testing fvar[3] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[4] = var 30
DEBUG CAREFUL: Calling compare_branch_vars for var 30
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 30
DEBUG CAREFUL: Testing fvar[5] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 29
DEBUG CAREFUL: Testing fvar[6] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[7] = var 31
DEBUG CAREFUL: Calling compare_branch_vars for var 31
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 31
DEBUG CAREFUL: Testing fvar[8] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 27
  % Initial guess is x21, Z0 = 28406216.1989307        , Z1 = 29392280.6562665        

DEBUG EVAL: Testing var 21 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=27, varin=20, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=28, varin=21, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=1, varin=44, theta=0.249746, up=999999999999999983222784.000000
ITER 4: row=43, varin=42, theta=0.537710, up=999999999999999983222784.000000
ITER 5: row=26, varin=38, theta=2.042150, up=999999999999999983222784.000000
ITER 6: row=38, varin=31, theta=0.736202, up=999999999999999983222784.000000
ITER 7: row=5, varin=30, theta=1.194599, up=999999999999999983222784.000000
ITER 8: row=30, varin=5, theta=14.586736, up=999999999999999983222784.000000
ITER 9: row=46, varin=19, theta=9.676005, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 21 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x21 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=27, varin=66, theta=1.000000, up=1.000000
ITER 2: row=12, varin=41, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28531403.112965
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 50 rows, 60 cols, 302 nonzeros, 1 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=43, theta=0.015908, up=999999999999999983222784.000000
ITER 2: row=42, varin=41, theta=0.045393, up=999999999999999983222784.000000
ITER 3: row=41, varin=46, theta=0.101863, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28541249.260366
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 50 rows, 60 cols, 300 nonzeros, 1 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 36 at  28.54124926036630682802
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabda810
% @LO 0.06  28.40621619893071070351 99.9000000000
% @LN 0.06  28.42110827702006758955 99.9000000000
% Resuming node 39 at  28.42110827702006758955
DEBUG CONSTRNT: LP rows=49, pool->nlprows=49, pool->npend=0
DEBUG CONSTRNT: Checking 49 LP rows (pool tracks 49, total LP rows 49)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=48, expected 48
 % @PAP adding 37 rows, 183 nz to LP
DEBUG BB: Processing node 39, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=12, varin=79, theta=1.333532, up=1.000000
ITER 2: row=12, varin=32, theta=0.204764, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
ITER 3: row=1, varin=25, theta=0.444774, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 28407384.105310
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 3.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 37 rows, 60 cols, 243 nonzeros, 5 slack, 32 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 31 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=85, theta=1.000000, up=1.000000
ITER 2: row=42, varin=45, theta=0.519100, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28438283.048589
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.480900
DEBUG SOLUTION: lp->best_solution[4] = 0.480900
DEBUG SOLUTION: lp->best_solution[5] = 1.961799
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 3.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 274 nonzeros, 6 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 1 rows, 3 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=14, theta=12604.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 28438896.539283
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 3.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 987396.000000
  % @PL 38 rows, 60 cols, 256 nonzeros, 1 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 39 LP 1 Solution, length = 28438896.539283, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.500000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.500000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.500000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.500000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28438896.539283, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 39 at  28.43889653928331995303
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595daba2600
% @LO 0.06  28.42110827702006758955 99.9000000000
% @LN 0.06  28.42956072732462757813 99.9000000000
% Resuming node 25 at  28.42956072732462757813
DEBUG CONSTRNT: LP rows=37, pool->nlprows=37, pool->npend=0
DEBUG CONSTRNT: Checking 37 LP rows (pool tracks 37, total LP rows 37)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 85
DEBUG CONSTRNT: Pool row 85 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 73
DEBUG CONSTRNT: Pool row 73 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=36, expected 36
 % @PAP adding 52 rows, 222 nz to LP
DEBUG BB: Processing node 25, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 25 LP 2 Solution, length = 28429560.727325, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.137568 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.137568 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.123205 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.123205 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.123205 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.123205 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.123205 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.123205 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.123205 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.137568 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.862432 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.876795 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.862432 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.862432 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.876795 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.862432 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.876795 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.876795 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.876795 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.876795 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.876795 (terminal 19)
 % 10 fractional variables
DEBUG CG: LP optimal, z=28429560.727325, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28429560.727325, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 3 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 25 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 25
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.137568
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.137568)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.137568
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.137568)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.123205
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.123205)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.123205
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.123205)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.123205
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.123205)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.123205
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.123205)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.123205
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.123205)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.123205
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.123205)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.123205
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.123205)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.137568
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.137568)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 10 fractional variables

  %  Carefully choosing branching variable, nfrac = 10
DEBUG CAREFUL: Testing fvar[0] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 1
DEBUG CAREFUL: New best var: 1
DEBUG CAREFUL: Testing fvar[1] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
DEBUG CAREFUL: Testing fvar[2] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 29
DEBUG CAREFUL: Testing fvar[3] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[4] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[5] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 4
DEBUG CAREFUL: New best var: 4
DEBUG CAREFUL: Testing fvar[6] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[7] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 11
DEBUG CAREFUL: Testing fvar[8] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[9] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
  % Initial guess is x4, Z0 = 28429560.7273246        , Z1 = 28844744.714354         

DEBUG EVAL: Testing var 1 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=24, theta=1.018650, up=999999999999999983222784.000000
ITER 2: row=37, varin=77, theta=0.958565, up=1.000000
ITER 3: row=3, varin=37, theta=0.465552, up=999999999999999983222784.000000
ITER 4: row=2, varin=50, theta=0.765503, up=999999999999999983222784.000000
ITER 5: row=11, varin=31, theta=0.258240, up=999999999999999983222784.000000
ITER 6: row=12, varin=47, theta=0.820202, up=999999999999999983222784.000000
ITER 7: row=36, varin=6, theta=0.278704, up=999999999999999983222784.000000
ITER 8: row=2, varin=24, theta=0.364116, up=999999999999999983222784.000000
ITER 9: row=38, varin=29, theta=1.086069, up=999999999999999983222784.000000
ITER 10: row=1, varin=28, theta=0.102749, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 1 gives z=28663301.600354
  % 	x1 = 1,	Z1 = 28663301.6003539        
DEBUG EVAL: First branch cutoff check: z=28663301.600354, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 0
ITER 1: row=2, varin=44, theta=0.128237, up=999999999999999983222784.000000
  % 	x1 = 0,	Z0 = 28434859.6812756        
DEBUG EVAL: Second branch cutoff check: z=28434859.681276, best_z=INF, threshold=INF
  %   New best:  x1, Z = 28434859.6812756        
DEBUG EVAL: Testing var 0 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=44, theta=0.128237, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 0 = 0 gives z=28434859.681276
  % 	x0 = 0,	Z0 = 28434859.6812756        
DEBUG EVAL: First branch cutoff check: z=28434859.681276, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 0 = 1
ITER 1: row=1, varin=24, theta=1.018650, up=999999999999999983222784.000000
ITER 2: row=37, varin=77, theta=0.958565, up=1.000000
ITER 3: row=3, varin=37, theta=0.465552, up=999999999999999983222784.000000
ITER 4: row=1, varin=50, theta=0.765503, up=999999999999999983222784.000000
ITER 5: row=11, varin=31, theta=0.258240, up=999999999999999983222784.000000
ITER 6: row=12, varin=47, theta=0.820202, up=999999999999999983222784.000000
ITER 7: row=36, varin=6, theta=0.278704, up=999999999999999983222784.000000
ITER 8: row=1, varin=3, theta=1.254708, up=999999999999999983222784.000000
ITER 9: row=30, varin=24, theta=0.364116, up=999999999999999983222784.000000
ITER 10: row=38, varin=28, theta=1.296548, up=999999999999999983222784.000000
  % 	x0 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: Second branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=44, theta=0.128237, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28434859.681276
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 52 rows, 60 cols, 282 nonzeros, 3 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 3 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 25 at  28.43485968127564333940
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabbe180
% @LO 0.06  28.42956072732462757813 99.9000000000
% @LN 0.06  28.43306561567896295628 99.9000000000
% Resuming node 33 at  28.43306561567896295628
DEBUG CONSTRNT: LP rows=49, pool->nlprows=49, pool->npend=0
DEBUG CONSTRNT: Checking 49 LP rows (pool tracks 49, total LP rows 49)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 60
DEBUG CONSTRNT: Pool row 60 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 73
DEBUG CONSTRNT: Pool row 73 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=48, expected 48
 % @PAP adding 48 rows, 224 nz to LP
DEBUG BB: Processing node 33, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 33 LP 2 Solution, length = 28433065.615679, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.250000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.500000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.250000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.250000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.906159 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.093841 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.750000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.750000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28433065.615679, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28433065.615679, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 33 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 33
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.250000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.500000
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=1.000000
DEBUG CAREFUL: Skipping var 13: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.500000
DEBUG CAREFUL: Adding var 21 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.250000
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.250000
DEBUG CAREFUL: Adding var 31 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.906159
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.906159)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 12
DEBUG CAREFUL: New best var: 12
DEBUG CAREFUL: Testing fvar[1] = var 21
DEBUG CAREFUL: Calling compare_branch_vars for var 21
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 21
DEBUG CAREFUL: New best var: 21
DEBUG CAREFUL: Testing fvar[2] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[3] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 27
DEBUG CAREFUL: Testing fvar[4] = var 31
DEBUG CAREFUL: Calling compare_branch_vars for var 31
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 31
DEBUG CAREFUL: Testing fvar[5] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 36
  % Initial guess is x21, Z0 = 28433065.615679         , Z1 = 29367591.5379681        

DEBUG EVAL: Testing var 12 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=4, varin=42, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 12 = 0 gives z=28576200.974274
  % 	x12 = 0,	Z0 = 28576200.9742744        
DEBUG EVAL: First branch cutoff check: z=28576200.974274, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 1
ITER 1: row=4, varin=63, theta=1.000000, up=1.000000
ITER 2: row=10, varin=27, theta=1.000000, up=999999999999999983222784.000000
  % 	x12 = 1,	Z1 = 28667367.5089985        
DEBUG EVAL: Second branch cutoff check: z=28667367.508999, best_z=INF, threshold=INF
  %   New best:  x12, Z = 28576200.9742744        
DEBUG EVAL: Testing var 21 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=18, varin=63, theta=1.000000, up=1.000000
ITER 2: row=10, varin=18, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=28, varin=19, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=48, varin=39, theta=0.135105, up=999999999999999983222784.000000
ITER 5: row=26, varin=87, theta=1.278101, up=1.000000
ITER 6: row=26, varin=88, theta=0.322989, up=1.000000
DEBUG EVAL: Branch var 21 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x21 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=18, varin=42, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28576200.974274
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 48 rows, 60 cols, 284 nonzeros, 1 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 33 at  28.57620097427440342130
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595daba2600
% @LO 0.07  28.43306561567896295628 99.9000000000
% @LN 0.07  28.43485968127564333940 99.9000000000
% Resuming node 25 at  28.43485968127564333940
DEBUG CONSTRNT: LP rows=47, pool->nlprows=47, pool->npend=0
DEBUG CONSTRNT: Checking 47 LP rows (pool tracks 47, total LP rows 47)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=46, expected 46
 % @PAP adding 49 rows, 215 nz to LP
DEBUG BB: Processing node 25, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 25 LP 3 Solution, length = 28434859.681276, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.161177 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.161177 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.161177 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.161177 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.161177 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.161177 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.032939 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.838823 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.838823 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.838823 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.838823 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.838823 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.838823 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.838823 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=28434859.681276, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28434859.681276, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 25 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 25
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.161177
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.161177)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.161177
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.161177)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.161177
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.161177)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.161177
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.161177)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.161177
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.161177)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.161177
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.161177)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.032939
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.032939)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 7 fractional variables

  %  Carefully choosing branching variable, nfrac = 7
DEBUG CAREFUL: Testing fvar[0] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 10
DEBUG CAREFUL: New best var: 10
DEBUG CAREFUL: Testing fvar[1] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[2] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 4
DEBUG CAREFUL: New best var: 4
DEBUG CAREFUL: Testing fvar[3] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[4] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 11
DEBUG CAREFUL: Testing fvar[5] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[6] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
  % Initial guess is x4, Z0 = 28434859.6812756        , Z1 = 28844744.714354         

DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=47, theta=4.277118, up=999999999999999983222784.000000
ITER 2: row=11, varin=44, theta=3.453296, up=999999999999999983222784.000000
ITER 3: row=44, varin=39, theta=1.781700, up=999999999999999983222784.000000
ITER 4: row=11, varin=74, theta=1.484756, up=1.000000
ITER 5: row=11, varin=71, theta=0.354867, up=1.000000
ITER 6: row=36, varin=74, theta=1.324390, up=1.000000
ITER 7: row=36, varin=43, theta=0.140310, up=999999999999999983222784.000000
ITER 8: row=43, varin=31, theta=0.032371, up=999999999999999983222784.000000
ITER 9: row=11, varin=74, theta=0.138608, up=1.000000
ITER 10: row=45, varin=3, theta=0.130201, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x10 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=6, varin=24, theta=0.510334, up=999999999999999983222784.000000
ITER 2: row=44, varin=12, theta=0.260960, up=999999999999999983222784.000000
ITER 3: row=6, varin=11, theta=49918.833333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28461748.252785
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 950081.166667
DEBUG SOLUTION: lp->best_solution[12] = 0.833333
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 49 rows, 60 cols, 275 nonzeros, 2 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 25 at  28.46174825278480824409
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabbca20
% @LO 0.07  28.43485968127564333940 99.9000000000
% @LN 0.07  28.43708746270764464725 99.9000000000
% Resuming node 38 at  28.43708746270764464725
DEBUG CONSTRNT: LP rows=47, pool->nlprows=47, pool->npend=0
DEBUG CONSTRNT: Checking 47 LP rows (pool tracks 47, total LP rows 47)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 60
DEBUG CONSTRNT: Pool row 60 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 73
DEBUG CONSTRNT: Pool row 73 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=46, expected 46
 % @PAP adding 45 rows, 216 nz to LP
DEBUG BB: Processing node 38, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 38 LP 2 Solution, length = 28437087.462708, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.249217 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.249217 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 1.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.249217 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.249217 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.003131 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.750783 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.750783 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.750783 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.750783 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.750783 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.750783 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28437087.462708, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28437087.462708, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 38 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 38
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.249217
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.249217)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.249217
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.249217)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=1.000000
DEBUG CAREFUL: Skipping var 14: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.249217
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.249217)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.249217
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.249217)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.003131
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.003131)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 26
DEBUG CAREFUL: New best var: 26
DEBUG CAREFUL: Testing fvar[1] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[2] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[3] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 18
DEBUG CAREFUL: Testing fvar[4] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x26, Z0 = 28437087.4627076        , Z1 = 28608979.1327187        

DEBUG EVAL: Testing var 26 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=27, varin=88, theta=1.965788, up=1.000000
ITER 2: row=27, varin=10, theta=0.535765, up=999999999999999983222784.000000
ITER 3: row=10, varin=39, theta=0.512098, up=999999999999999983222784.000000
ITER 4: row=23, varin=88, theta=1.000000, up=1.000000
ITER 5: row=39, varin=34, theta=0.703500, up=999999999999999983222784.000000
ITER 6: row=32, varin=43, theta=0.631453, up=999999999999999983222784.000000
ITER 7: row=5, varin=40, theta=0.307717, up=999999999999999983222784.000000
ITER 8: row=40, varin=5, theta=0.242300, up=999999999999999983222784.000000
ITER 9: row=1, varin=36, theta=0.854929, up=999999999999999983222784.000000
ITER 10: row=2, varin=33, theta=0.370121, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 1 gives z=28608979.132719
  % 	x26 = 1,	Z1 = 28608979.1327187        
DEBUG EVAL: First branch cutoff check: z=28608979.132719, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 0
ITER 1: row=27, varin=4, theta=0.000864, up=999999999999999983222784.000000
  % 	x26 = 0,	Z0 = 28437095.845664         
DEBUG EVAL: Second branch cutoff check: z=28437095.845664, best_z=INF, threshold=INF
  %   New best:  x26, Z = 28437095.845664         
DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=5, varin=26, theta=0.877943, up=999999999999999983222784.000000
ITER 2: row=44, varin=27, theta=0.920472, up=999999999999999983222784.000000
ITER 3: row=45, varin=15, theta=1.429433, up=999999999999999983222784.000000
ITER 4: row=9, varin=28, theta=0.898942, up=999999999999999983222784.000000
ITER 5: row=27, varin=36, theta=0.690687, up=999999999999999983222784.000000
ITER 6: row=36, varin=4, theta=0.245470, up=999999999999999983222784.000000
ITER 7: row=39, varin=67, theta=0.130555, up=1.000000
DEBUG EVAL: Branch var 3 = 1 gives z=29312818.231516
  % 	x3 = 1,	Z1 = 29312818.2315157        
DEBUG EVAL: First branch cutoff check: z=29312818.231516, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=5, varin=4, theta=2.650216, up=999999999999999983222784.000000
ITER 2: row=39, varin=88, theta=1.817439, up=1.000000
ITER 3: row=39, varin=47, theta=0.346178, up=1.000000
ITER 4: row=23, varin=88, theta=1.000000, up=1.000000
ITER 5: row=27, varin=75, theta=0.343434, up=1.000000
ITER 6: row=5, varin=43, theta=0.198671, up=999999999999999983222784.000000
  % 	x3 = 0,	Z0 = 28490396.736932         
DEBUG EVAL: Second branch cutoff check: z=28490396.736932, best_z=INF, threshold=INF
  %   New best:  x3, Z = 28490396.736932         
DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=14, varin=15, theta=1.329425, up=999999999999999983222784.000000
ITER 2: row=44, varin=43, theta=1.120455, up=999999999999999983222784.000000
ITER 3: row=27, varin=36, theta=0.556930, up=999999999999999983222784.000000
ITER 4: row=36, varin=4, theta=0.140119, up=999999999999999983222784.000000
ITER 5: row=5, varin=27, theta=0.177507, up=999999999999999983222784.000000
ITER 6: row=9, varin=33, theta=0.300931, up=999999999999999983222784.000000
ITER 7: row=26, varin=67, theta=2.013859, up=1.000000
ITER 8: row=26, varin=30, theta=0.774442, up=999999999999999983222784.000000
ITER 9: row=30, varin=68, theta=1.091212, up=1.000000
ITER 10: row=30, varin=21, theta=0.053273, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x17 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=14, varin=4, theta=2.650216, up=999999999999999983222784.000000
ITER 2: row=39, varin=88, theta=1.817439, up=1.000000
ITER 3: row=39, varin=47, theta=0.346178, up=1.000000
ITER 4: row=23, varin=88, theta=1.000000, up=1.000000
ITER 5: row=27, varin=75, theta=0.343434, up=1.000000
ITER 6: row=14, varin=34, theta=0.268959, up=999999999999999983222784.000000
ITER 7: row=32, varin=28, theta=0.202904, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28563254.872144
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 3.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1000000.000000
   % @PL 45 rows, 60 cols, 276 nonzeros, 5 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 5 slack rows
   % @PAP adding 4 rows, 9 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=36, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=44, varin=8, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28579102.778149
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.500000
DEBUG SOLUTION: lp->best_solution[7] = 0.500000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1000000.000000
   % @PL 44 rows, 60 cols, 272 nonzeros, 4 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 4 slack rows
   % @PAP adding 2 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=54, theta=0.228997, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28590826.970537
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 42 rows, 60 cols, 270 nonzeros, 1 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=71, theta=0.241727, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28595806.381351
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 44 rows, 60 cols, 266 nonzeros, 0 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 3 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=52, theta=0.154667, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28595972.925781
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 47 rows, 60 cols, 273 nonzeros, 0 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 4 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=23, theta=0.111191, up=999999999999999983222784.000000
ITER 2: row=50, varin=76, theta=0.081455, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28602903.610687
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 51 rows, 60 cols, 286 nonzeros, 2 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
   % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=39, theta=0.185962, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28603100.687302
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 51 rows, 60 cols, 285 nonzeros, 1 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 38 at  28.60310068730203880705
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabda810
% @LO 0.07  28.43708746270764464725 99.9000000000
% @LN 0.07  28.43889653928331995303 99.9000000000
% Resuming node 39 at  28.43889653928331995303
DEBUG CONSTRNT: LP rows=50, pool->nlprows=50, pool->npend=0
DEBUG CONSTRNT: Checking 50 LP rows (pool tracks 50, total LP rows 50)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 85
DEBUG CONSTRNT: Pool row 85 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=49, expected 49
 % @PAP adding 37 rows, 156 nz to LP
DEBUG BB: Processing node 39, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 39 LP 2 Solution, length = 28438896.539283, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.500000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.500000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.500000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.500000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28438896.539283, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28438896.539283, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 39 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 39
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.500000
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.500000
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.500000
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.500000
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
DEBUG CAREFUL: Testing fvar[1] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[2] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
DEBUG CAREFUL: Testing fvar[3] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
  % Initial guess is x18, Z0 = 28438896.5392833        , Z1 = 28553470.8416871        

DEBUG EVAL: Testing var 18 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=9, varin=33, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 18 = 1 gives z=28457883.733842
  % 	x18 = 1,	Z1 = 28553470.8416871        
DEBUG EVAL: First branch cutoff check: z=28553470.841687, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 18 = 0
ITER 1: row=9, varin=40, theta=0.600000, up=1.000000
ITER 2: row=5, varin=44, theta=0.500000, up=1.000000
ITER 3: row=36, varin=19, theta=0.045455, up=999999999999999983222784.000000
ITER 4: row=25, varin=41, theta=0.500000, up=1.000000
  % 	x18 = 0,	Z0 = 28482129.4288387        
DEBUG EVAL: Second branch cutoff check: z=28482129.428839, best_z=INF, threshold=INF
  %   New best:  x18, Z = 28482129.4288387        
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=33, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28457883.733842
  % 	x10 = 0,	Z0 = 28457883.7338417        
DEBUG EVAL: First branch cutoff check: z=28457883.733842, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 0 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=37, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 0 = 0 gives z=28454956.133047
  % 	x0 = 0,	Z0 = 28454956.1330468        
DEBUG EVAL: First branch cutoff check: z=28454956.133047, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 1 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=33, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 1 gives z=28457883.733842
  % 	x1 = 1,	Z1 = 28457883.7338417        
DEBUG EVAL: First branch cutoff check: z=28457883.733842, best_z=INF, threshold=INF
  % Best branch is x18, Z0 = 28482129.4288387        , Z1 = 28553470.8416871        

DEBUG CAREFUL: Final result - returning best.var = 18
DEBUG BB: Branching variable chosen: j=18
 % @NC   41   39	x18 = 0	28482129.428839
 % @NC   42   39	x18 = 1	28553470.841687
 %      39    15 28438896.5393               28447865.2351   x17 D    37    10
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabbedc0
% @LO 0.07  28.43889653928331995303 99.9000000000
% @LN 0.07  28.44786523509532827347 99.9000000000
% Resuming node 23 at  28.44786523509532827347
DEBUG CONSTRNT: LP rows=37, pool->nlprows=37, pool->npend=0
DEBUG CONSTRNT: Checking 37 LP rows (pool tracks 37, total LP rows 37)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 85
DEBUG CONSTRNT: Pool row 85 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 73
DEBUG CONSTRNT: Pool row 73 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=36, expected 36
 % @PAP adding 50 rows, 218 nz to LP
DEBUG BB: Processing node 23, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 23 LP 4 Solution, length = 28447865.235095, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.100000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.100000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.100000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.100000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.100000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.100000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.100000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.500000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.500000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.123589 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.123589 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.100000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.876411 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.900000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.900000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.876411 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.900000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.900000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.900000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.900000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.900000 (terminal 19)
 % 13 fractional variables
DEBUG CG: LP optimal, z=28447865.235095, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28447865.235095, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 3 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 23 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 23
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.500000
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.100000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.100000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.100000
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.100000)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.100000
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.100000)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.100000
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.100000)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.100000
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.100000)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.100000
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.100000)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.100000
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.100000)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.500000
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.500000
DEBUG CAREFUL: Adding var 30 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.123589
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.123589)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.123589
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.123589)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.100000
DEBUG CAREFUL: Adding var 37 to fractional list (xi=0.100000)
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 13 fractional variables

  %  Carefully choosing branching variable, nfrac = 13
DEBUG CAREFUL: Testing fvar[0] = var 30
DEBUG CAREFUL: Calling compare_branch_vars for var 30
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 30
DEBUG CAREFUL: New best var: 30
DEBUG CAREFUL: Testing fvar[1] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 1
DEBUG CAREFUL: New best var: 1
DEBUG CAREFUL: Testing fvar[2] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 29
DEBUG CAREFUL: Testing fvar[3] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[4] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[5] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 4
DEBUG CAREFUL: Testing fvar[6] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[7] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[8] = var 37
DEBUG CAREFUL: Calling compare_branch_vars for var 37
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 37
DEBUG CAREFUL: Testing fvar[9] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 27
DEBUG CAREFUL: Testing fvar[10] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 22
DEBUG CAREFUL: Testing fvar[11] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 36
DEBUG CAREFUL: Testing fvar[12] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 34
  % Initial guess is x1, Z0 = 28447865.2350953        , Z1 = 28813465.2023231        

DEBUG EVAL: Testing var 30 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=39, varin=48, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 30 = 0 gives z=28452280.320758
  % 	x30 = 0,	Z0 = 28452280.3207581        
DEBUG EVAL: First branch cutoff check: z=28452280.320758, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 30 = 1
ITER 1: row=39, varin=3, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=40, varin=4, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=24, varin=83, theta=1.465929, up=1.000000
ITER 4: row=24, varin=2, theta=0.444482, up=999999999999999983222784.000000
ITER 5: row=45, varin=44, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=38, varin=82, theta=0.377787, up=1.000000
ITER 7: row=20, varin=84, theta=0.766793, up=1.000000
  % 	x30 = 1,	Z1 = 29645608.5993569        
DEBUG EVAL: Second branch cutoff check: z=29645608.599357, best_z=INF, threshold=INF
  %   New best:  x30, Z = 28452280.3207581        
DEBUG EVAL: Testing var 1 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=39, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=49, varin=44, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=24, varin=83, theta=1.437522, up=1.000000
ITER 4: row=24, varin=2, theta=0.417383, up=999999999999999983222784.000000
ITER 5: row=3, varin=82, theta=0.344707, up=1.000000
DEBUG EVAL: Branch var 1 = 1 gives z=28741437.962007
  % 	x1 = 1,	Z1 = 28813465.2023231        
DEBUG EVAL: First branch cutoff check: z=28813465.202323, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 0
ITER 1: row=1, varin=48, theta=1.000000, up=999999999999999983222784.000000
  % 	x1 = 0,	Z0 = 28452280.3207581        
DEBUG EVAL: Second branch cutoff check: z=28452280.320758, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 29 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=26, varin=48, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 29 = 0 gives z=28452280.320758
  % 	x29 = 0,	Z0 = 28452280.3207581        
DEBUG EVAL: First branch cutoff check: z=28452280.320758, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 29 = 1
ITER 1: row=26, varin=39, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=49, varin=4, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=26, varin=48, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=45, varin=26, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=24, varin=83, theta=1.675566, up=1.000000
ITER 6: row=24, varin=2, theta=0.644470, up=999999999999999983222784.000000
ITER 7: row=38, varin=82, theta=0.146584, up=1.000000
ITER 8: row=34, varin=84, theta=0.297520, up=1.000000
  % 	x29 = 1,	Z1 = 29414312.9447817        
DEBUG EVAL: Second branch cutoff check: z=29414312.944782, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 3 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=8, varin=2, theta=0.250000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 0 gives z=28465817.387442
  % 	x3 = 0,	Z0 = 28465817.3874419        
DEBUG EVAL: First branch cutoff check: z=28465817.387442, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 1
ITER 1: row=8, varin=18, theta=4.500000, up=999999999999999983222784.000000
ITER 2: row=18, varin=50, theta=4.500000, up=999999999999999983222784.000000
ITER 3: row=34, varin=48, theta=7.000000, up=999999999999999983222784.000000
ITER 4: row=1, varin=43, theta=1.000000, up=999999999999999983222784.000000
  % 	x3 = 1,	Z1 = 28718768.1285687        
DEBUG EVAL: Second branch cutoff check: z=28718768.128569, best_z=INF, threshold=INF
  %   New best:  x3, Z = 28465817.3874419        
DEBUG EVAL: Testing var 26 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=31, varin=18, theta=4.500000, up=999999999999999983222784.000000
ITER 2: row=18, varin=50, theta=4.500000, up=999999999999999983222784.000000
ITER 3: row=34, varin=48, theta=7.000000, up=999999999999999983222784.000000
ITER 4: row=1, varin=35, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=25, varin=78, theta=0.653417, up=1.000000
ITER 6: row=18, varin=79, theta=0.876958, up=1.000000
ITER 7: row=31, varin=83, theta=1.290358, up=1.000000
ITER 8: row=31, varin=82, theta=0.276858, up=1.000000
ITER 9: row=30, varin=9, theta=0.453685, up=999999999999999983222784.000000
ITER 10: row=31, varin=83, theta=0.555491, up=1.000000
DEBUG EVAL: Branch var 26 = 1 gives z=29050496.192335
  % 	x26 = 1,	Z1 = 29050496.1923355        
DEBUG EVAL: First branch cutoff check: z=29050496.192335, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 0
ITER 1: row=31, varin=2, theta=0.250000, up=999999999999999983222784.000000
  % 	x26 = 0,	Z0 = 28465817.3874419        
DEBUG EVAL: Second branch cutoff check: z=28465817.387442, best_z=INF, threshold=INF
  %   New best:  x26, Z = 28465817.3874419        
DEBUG EVAL: Testing var 4 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=16, varin=18, theta=4.500000, up=999999999999999983222784.000000
ITER 2: row=18, varin=50, theta=4.500000, up=999999999999999983222784.000000
ITER 3: row=34, varin=48, theta=7.000000, up=999999999999999983222784.000000
ITER 4: row=4, varin=46, theta=3.000000, up=999999999999999983222784.000000
ITER 5: row=24, varin=41, theta=5.387679, up=999999999999999983222784.000000
ITER 6: row=41, varin=44, theta=14.906923, up=999999999999999983222784.000000
ITER 7: row=26, varin=64, theta=7.572112, up=1.000000
ITER 8: row=26, varin=38, theta=5.454828, up=999999999999999983222784.000000
ITER 9: row=38, varin=28, theta=3.061841, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 4 = 1 gives z=29279921.487261
  % 	x4 = 1,	Z1 = 29279921.4872605        
DEBUG EVAL: First branch cutoff check: z=29279921.487261, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 4 = 0
ITER 1: row=16, varin=2, theta=0.250000, up=999999999999999983222784.000000
  % 	x4 = 0,	Z0 = 28465817.3874419        
DEBUG EVAL: Second branch cutoff check: z=28465817.387442, best_z=INF, threshold=INF
  %   New best:  x4, Z = 28465817.3874419        
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=2, theta=0.250000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28465817.387442
  % 	x2 = 0,	Z0 = 28465817.3874419        
DEBUG EVAL: First branch cutoff check: z=28465817.387442, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 1
ITER 1: row=3, varin=18, theta=4.500000, up=999999999999999983222784.000000
  % 	x2 = 1,	Z1 = 28476021.3445309        
DEBUG EVAL: Second branch cutoff check: z=28476021.344531, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=9, varin=2, theta=0.250000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28465817.387442
  % 	x10 = 0,	Z0 = 28465817.3874419        
DEBUG EVAL: First branch cutoff check: z=28465817.387442, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 1
ITER 1: row=9, varin=18, theta=4.500000, up=999999999999999983222784.000000
  % 	x10 = 1,	Z1 = 28476021.3445309        
DEBUG EVAL: Second branch cutoff check: z=28476021.344531, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 37 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=41, varin=41, theta=0.125000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 37 = 0 gives z=28461648.021266
  % 	x37 = 0,	Z0 = 28461648.0212662        
DEBUG EVAL: First branch cutoff check: z=28461648.021266, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 27 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=34, varin=50, theta=0.125000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 27 = 0 gives z=28448874.318261
  % 	x27 = 0,	Z0 = 28448874.3182608        
DEBUG EVAL: First branch cutoff check: z=28448874.318261, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 22 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=28, varin=46, theta=0.125000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 22 = 0 gives z=28459300.542417
  % 	x22 = 0,	Z0 = 28459300.5424175        
DEBUG EVAL: First branch cutoff check: z=28459300.542417, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 36 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=24, varin=18, theta=0.177449, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 36 = 0 gives z=28448975.518774
  % 	x36 = 0,	Z0 = 28448975.5187738        
DEBUG EVAL: First branch cutoff check: z=28448975.518774, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 34 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=27, varin=18, theta=0.177449, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 34 = 0 gives z=28448975.518774
  % 	x34 = 0,	Z0 = 28448975.5187738        
DEBUG EVAL: First branch cutoff check: z=28448975.518774, best_z=INF, threshold=INF
  % Best branch is x4, Z0 = 28465817.3874419        , Z1 = 29279921.4872605        

DEBUG CAREFUL: Final result - returning best.var = 4
DEBUG BB: Branching variable chosen: j=4
 % @NC   43   23	x4 = 0	28465817.387442
 % @NC   44   23	x4 = 1	29279921.487261
 %      23    16 28447865.2351               28449485.3180   x18 D     3     3
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabdaef0
% @LO 0.07  28.44786523509532827347 99.9000000000
% @LN 0.07  28.44948531801450641865 99.9000000000
% Resuming node 40 at  28.44948531801450641865
DEBUG CONSTRNT: LP rows=50, pool->nlprows=50, pool->npend=0
DEBUG CONSTRNT: Checking 50 LP rows (pool tracks 50, total LP rows 50)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 143
DEBUG CONSTRNT: Pool row 143 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=49, expected 49
 % @PAP adding 37 rows, 183 nz to LP
DEBUG BB: Processing node 40, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=12, varin=36, theta=1.041035, up=999999999999999983222784.000000
ITER 2: row=1, varin=34, theta=1.063643, up=999999999999999983222784.000000
ITER 3: row=34, varin=37, theta=0.096965, up=999999999999999983222784.000000
ITER 4: row=31, varin=31, theta=0.026393, up=999999999999999983222784.000000
ITER 5: row=17, varin=2, theta=0.047218, up=999999999999999983222784.000000
ITER 6: row=2, varin=28, theta=0.109276, up=999999999999999983222784.000000
ITER 7: row=27, varin=27, theta=0.062109, up=999999999999999983222784.000000
ITER 8: row=28, varin=39, theta=0.456656, up=1.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 28441719.259191
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 3.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 37 rows, 60 cols, 243 nonzeros, 2 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=87, theta=1.000000, up=1.000000
ITER 2: row=7, varin=53, theta=0.369521, up=1.000000
ITER 3: row=27, varin=98, theta=0.650141, up=1.000000
ITER 4: row=28, varin=41, theta=0.280926, up=1.000000
ITER 5: row=40, varin=26, theta=0.982083, up=999999999999999983222784.000000
ITER 6: row=26, varin=18, theta=0.667617, up=999999999999999983222784.000000
ITER 7: row=2, varin=59, theta=0.333333, up=1.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28609962.254292
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 3.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 257 nonzeros, 5 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 5 rows, 23 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=75, theta=1.000000, up=1.000000
ITER 2: row=32, varin=43, theta=0.600000, up=1.000000
ITER 3: row=8, varin=47, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28686268.893073
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 3.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 260 nonzeros, 2 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 6 rows, 37 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=86, theta=1.000000, up=1.000000
ITER 2: row=12, varin=6, theta=0.279372, up=999999999999999983222784.000000
ITER 3: row=7, varin=74, theta=0.246221, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28716815.575972
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.246221
DEBUG SOLUTION: lp->best_solution[4] = 0.246221
DEBUG SOLUTION: lp->best_solution[5] = 1.492443
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 3.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 289 nonzeros, 3 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 7 rows, 22 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=94, theta=0.250000, up=1.000000
ITER 2: row=43, varin=59, theta=0.608819, up=1.000000
ITER 3: row=45, varin=72, theta=2.000000, up=1.000000
ITER 4: row=45, varin=75, theta=0.500000, up=1.000000
ITER 5: row=10, varin=72, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28800023.911240
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 3.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1000000.000000
  % @PL 48 rows, 60 cols, 303 nonzeros, 0 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=96, theta=0.099697, up=1.000000
ITER 2: row=49, varin=8, theta=1.251159, up=999999999999999983222784.000000
ITER 3: row=1, varin=51, theta=0.323079, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28810400.924073
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.338461
DEBUG SOLUTION: lp->best_solution[7] = 0.338461
DEBUG SOLUTION: lp->best_solution[8] = 1.676921
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1000000.000000
  % @PL 51 rows, 60 cols, 310 nonzeros, 4 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % Node 40 LP 1 Solution, length = 28810400.924073, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.661539 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.338461 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.338461 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.661539 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.338461 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.661539 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28810400.924073, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 40 at  28.81040092407258512708
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabb5780
% @LO 0.07  28.44948531801450641865 99.9000000000
% @LN 0.07  28.45573593721267968704 99.9000000000
% Resuming node 11 at  28.45573593721267968704
DEBUG CONSTRNT: LP rows=47, pool->nlprows=47, pool->npend=0
DEBUG CONSTRNT: Checking 47 LP rows (pool tracks 47, total LP rows 47)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 85
DEBUG CONSTRNT: Pool row 85 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 145
DEBUG CONSTRNT: Pool row 145 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 159
DEBUG CONSTRNT: Pool row 159 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 60
DEBUG CONSTRNT: Pool row 60 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 73
DEBUG CONSTRNT: Pool row 73 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=46, expected 46
 % @PAP adding 50 rows, 217 nz to LP
DEBUG BB: Processing node 11, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 11 LP 6 Solution, length = 28455735.937213, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.306649 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.306649 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.040026 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.040026 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.306649 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.306649 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.040026 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.306649 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.306649 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.306649 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.693351 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.693351 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.693351 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.693351 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.693351 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.693351 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.959974 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.959974 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 10 fractional variables
DEBUG CG: LP optimal, z=28455735.937213, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28455735.937213, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 11 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 11
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.306649
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.306649)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.306649
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.306649)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=1.000000
DEBUG CAREFUL: Skipping var 9: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.040026
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.040026)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.040026
DEBUG CAREFUL: Adding var 21 to fractional list (xi=0.040026)
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.306649
DEBUG CAREFUL: Adding var 23 to fractional list (xi=0.306649)
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.306649
DEBUG CAREFUL: Adding var 24 to fractional list (xi=0.306649)
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.040026
DEBUG CAREFUL: Adding var 25 to fractional list (xi=0.040026)
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.306649
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.306649)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.306649
DEBUG CAREFUL: Adding var 30 to fractional list (xi=0.306649)
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.306649
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.306649)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 10 fractional variables

  %  Carefully choosing branching variable, nfrac = 10
DEBUG CAREFUL: Testing fvar[0] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 12
DEBUG CAREFUL: New best var: 12
DEBUG CAREFUL: Testing fvar[1] = var 30
DEBUG CAREFUL: Calling compare_branch_vars for var 30
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 30
DEBUG CAREFUL: New best var: 30
DEBUG CAREFUL: Testing fvar[2] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
DEBUG CAREFUL: Testing fvar[3] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[4] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 29
DEBUG CAREFUL: Testing fvar[5] = var 21
DEBUG CAREFUL: Calling compare_branch_vars for var 21
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 21
DEBUG CAREFUL: Testing fvar[6] = var 25
DEBUG CAREFUL: Calling compare_branch_vars for var 25
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 25
DEBUG CAREFUL: Testing fvar[7] = var 24
DEBUG CAREFUL: Calling compare_branch_vars for var 24
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 24
DEBUG CAREFUL: Testing fvar[8] = var 23
DEBUG CAREFUL: Calling compare_branch_vars for var 23
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 23
DEBUG CAREFUL: Testing fvar[9] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 36
  % Initial guess is x30, Z0 = 28455735.9372127        , Z1 = 28537679.6033586        

DEBUG EVAL: Testing var 12 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=18, varin=84, theta=0.123662, up=1.000000
DEBUG EVAL: Branch var 12 = 0 gives z=28456328.314521
  % 	x12 = 0,	Z0 = 28456328.3145214        
DEBUG EVAL: First branch cutoff check: z=28456328.314521, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 1
ITER 1: row=18, varin=49, theta=1.344740, up=999999999999999983222784.000000
ITER 2: row=35, varin=31, theta=1.679000, up=999999999999999983222784.000000
ITER 3: row=31, varin=48, theta=0.899293, up=999999999999999983222784.000000
ITER 4: row=37, varin=28, theta=0.466241, up=999999999999999983222784.000000
  % 	x12 = 1,	Z1 = 28535229.4361652        
DEBUG EVAL: Second branch cutoff check: z=28535229.436165, best_z=INF, threshold=INF
  %   New best:  x12, Z = 28456328.3145214        
DEBUG EVAL: Testing var 30 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=37, varin=42, theta=0.409273, up=999999999999999983222784.000000
ITER 2: row=27, varin=49, theta=3.275628, up=999999999999999983222784.000000
ITER 3: row=35, varin=41, theta=0.748438, up=999999999999999983222784.000000
ITER 4: row=41, varin=45, theta=3.125350, up=999999999999999983222784.000000
ITER 5: row=22, varin=36, theta=2.420395, up=999999999999999983222784.000000
ITER 6: row=44, varin=38, theta=0.846497, up=999999999999999983222784.000000
ITER 7: row=26, varin=37, theta=0.969554, up=999999999999999983222784.000000
ITER 8: row=10, varin=23, theta=0.551572, up=999999999999999983222784.000000
ITER 9: row=43, varin=73, theta=7.572646, up=1.000000
ITER 10: row=43, varin=32, theta=1.222203, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 30 = 1 gives z=29425987.325603
  % 	x30 = 1,	Z1 = 29425987.3256033        
DEBUG EVAL: First branch cutoff check: z=29425987.325603, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 30 = 0
ITER 1: row=37, varin=35, theta=0.433718, up=999999999999999983222784.000000
ITER 2: row=18, varin=48, theta=0.010442, up=999999999999999983222784.000000
  % 	x30 = 0,	Z0 = 28464134.5431881        
DEBUG EVAL: Second branch cutoff check: z=28464134.543188, best_z=INF, threshold=INF
  %   New best:  x30, Z = 28464134.5431881        
DEBUG EVAL: Testing var 0 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=35, theta=0.433718, up=999999999999999983222784.000000
ITER 2: row=19, varin=31, theta=0.010371, up=999999999999999983222784.000000
ITER 3: row=31, varin=49, theta=0.009707, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 0 = 0 gives z=28464470.692009
  % 	x0 = 0,	Z0 = 28464470.6920085        
DEBUG EVAL: First branch cutoff check: z=28464470.692009, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 0 = 1
ITER 1: row=1, varin=42, theta=0.409273, up=999999999999999983222784.000000
ITER 2: row=27, varin=49, theta=3.275628, up=999999999999999983222784.000000
ITER 3: row=35, varin=41, theta=0.748438, up=999999999999999983222784.000000
ITER 4: row=41, varin=45, theta=3.125350, up=999999999999999983222784.000000
ITER 5: row=22, varin=36, theta=2.420395, up=999999999999999983222784.000000
ITER 6: row=6, varin=38, theta=0.846497, up=999999999999999983222784.000000
ITER 7: row=26, varin=37, theta=0.969554, up=999999999999999983222784.000000
ITER 8: row=10, varin=23, theta=0.551572, up=999999999999999983222784.000000
ITER 9: row=43, varin=73, theta=7.572646, up=1.000000
ITER 10: row=43, varin=48, theta=7.755459, up=999999999999999983222784.000000
  % 	x0 = 1,	Z1 = 29397523.3778496        
DEBUG EVAL: Second branch cutoff check: z=29397523.377850, best_z=INF, threshold=INF
  %   New best:  x0, Z = 28464470.6920085        
DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=35, theta=0.433718, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 0 gives z=28464031.997481
  % 	x1 = 0,	Z0 = 28464031.9974814        
DEBUG EVAL: First branch cutoff check: z=28464031.997481, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 29 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=21, varin=35, theta=0.433718, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 29 = 0 gives z=28464031.997481
  % 	x29 = 0,	Z0 = 28464031.9974814        
DEBUG EVAL: First branch cutoff check: z=28464031.997481, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 21 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=28, varin=49, theta=1.344740, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 21 = 1 gives z=28493402.830705
  % 	x21 = 1,	Z1 = 28493402.8307047        
DEBUG EVAL: First branch cutoff check: z=28493402.830705, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 21 = 0
ITER 1: row=28, varin=84, theta=0.123662, up=1.000000
  % 	x21 = 0,	Z0 = 28456328.3145214        
DEBUG EVAL: Second branch cutoff check: z=28456328.314521, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 25 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=31, varin=49, theta=1.344740, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 25 = 1 gives z=28493402.830705
  % 	x25 = 1,	Z1 = 28517538.7245588        
DEBUG EVAL: First branch cutoff check: z=28517538.724559, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 25 = 0
ITER 1: row=31, varin=84, theta=0.123662, up=1.000000
  % 	x25 = 0,	Z0 = 28456328.3145214        
DEBUG EVAL: Second branch cutoff check: z=28456328.314521, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 24 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=35, theta=0.433718, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 24 = 0 gives z=28464031.997481
  % 	x24 = 0,	Z0 = 28464031.9974814        
DEBUG EVAL: First branch cutoff check: z=28464031.997481, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 23 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=35, theta=0.433718, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 23 = 0 gives z=28464031.997481
  % 	x23 = 0,	Z0 = 28464031.9974814        
DEBUG EVAL: First branch cutoff check: z=28464031.997481, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 36 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=17, varin=35, theta=0.433718, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 36 = 0 gives z=28464031.997481
  % 	x36 = 0,	Z0 = 28464031.9974814        
DEBUG EVAL: First branch cutoff check: z=28464031.997481, best_z=INF, threshold=INF
  % Best branch is x0, Z0 = 28464470.6920085        , Z1 = 29397523.3778496        

DEBUG CAREFUL: Final result - returning best.var = 0
DEBUG BB: Branching variable chosen: j=0
 % @NC   45   11	x0 = 0	28464470.692009
 % @NC   46   11	x0 = 1	29397523.377850
 %      11    17 28455735.9372               28461748.2528    x9 U     9     6
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595daba2600
% @LO 0.07  28.45573593721267968704 99.9000000000
% @LN 0.07  28.46174825278480824409 99.9000000000
% Resuming node 25 at  28.46174825278480824409
DEBUG CONSTRNT: LP rows=50, pool->nlprows=50, pool->npend=0
DEBUG CONSTRNT: Checking 50 LP rows (pool tracks 50, total LP rows 50)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=49, expected 49
 % @PAP adding 47 rows, 173 nz to LP
DEBUG BB: Processing node 25, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 25 LP 4 Solution, length = 28461748.252785, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.166667 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.166667 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.166667 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.166667 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.166667 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.833333 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.833333 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.833333 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.833333 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.833333 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28461748.252785, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28461748.252785, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 25 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 25
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.166667
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.166667
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.166667
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.166667
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.166667
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
DEBUG CAREFUL: Testing fvar[1] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 4
DEBUG CAREFUL: New best var: 4
DEBUG CAREFUL: Testing fvar[2] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[3] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 11
DEBUG CAREFUL: Testing fvar[4] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
  % Initial guess is x4, Z0 = 28461748.2527848        , Z1 = 28844744.714354         

DEBUG EVAL: Testing var 17 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=22, varin=22, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=35, varin=74, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 17 = 0 gives z=28477676.032874
  % 	x17 = 0,	Z0 = 28477676.0328739        
DEBUG EVAL: First branch cutoff check: z=28477676.032874, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 1
ITER 1: row=22, varin=45, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=34, varin=42, theta=1.500000, up=999999999999999983222784.000000
ITER 3: row=42, varin=41, theta=1.000000, up=999999999999999983222784.000000
  % 	x17 = 1,	Z1 = 28584409.1178462        
DEBUG EVAL: Second branch cutoff check: z=28584409.117846, best_z=INF, threshold=INF
  %   New best:  x17, Z = 28477676.0328739        
DEBUG EVAL: Testing var 4 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=34, varin=22, theta=1.666667, up=999999999999999983222784.000000
ITER 2: row=35, varin=42, theta=2.500000, up=999999999999999983222784.000000
ITER 3: row=42, varin=41, theta=3.000000, up=999999999999999983222784.000000
ITER 4: row=1, varin=38, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=38, varin=7, theta=2.000000, up=999999999999999983222784.000000
ITER 6: row=7, varin=34, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=46, varin=35, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 4 = 1 gives z=28829952.023454
  % 	x4 = 1,	Z1 = 28844744.714354         
DEBUG EVAL: First branch cutoff check: z=28844744.714354, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 4 = 0
ITER 1: row=34, varin=45, theta=0.250000, up=999999999999999983222784.000000
  % 	x4 = 0,	Z0 = 28468114.75375          
DEBUG EVAL: Second branch cutoff check: z=28468114.753750, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 3 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=5, varin=74, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 3 = 0 gives z=28477676.032874
  % 	x3 = 0,	Z0 = 28477676.0328739        
DEBUG EVAL: First branch cutoff check: z=28477676.032874, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 1
ITER 1: row=5, varin=22, theta=1.666667, up=999999999999999983222784.000000
ITER 2: row=35, varin=45, theta=2.500000, up=999999999999999983222784.000000
ITER 3: row=34, varin=42, theta=1.500000, up=999999999999999983222784.000000
ITER 4: row=42, varin=41, theta=1.000000, up=999999999999999983222784.000000
  % 	x3 = 1,	Z1 = 28584409.1178462        
DEBUG EVAL: Second branch cutoff check: z=28584409.117846, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 11 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=42, varin=45, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=34, varin=41, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=1, varin=38, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=38, varin=7, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=7, varin=29, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=43, varin=34, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 11 = 1 gives z=28805225.342176
  % 	x11 = 1,	Z1 = 28805225.3421756        
DEBUG EVAL: First branch cutoff check: z=28805225.342176, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 11 = 0
ITER 1: row=42, varin=22, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=35, varin=42, theta=0.250000, up=999999999999999983222784.000000
  % 	x11 = 0,	Z0 = 28474296.4240696        
DEBUG EVAL: Second branch cutoff check: z=28474296.424070, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=22, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=35, varin=41, theta=0.200000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28471148.687997
  % 	x2 = 0,	Z0 = 28471148.6879971        
DEBUG EVAL: First branch cutoff check: z=28471148.687997, best_z=INF, threshold=INF
  % Best branch is x17, Z0 = 28477676.0328739        , Z1 = 28584409.1178462        

DEBUG CAREFUL: Final result - returning best.var = 17
DEBUG BB: Branching variable chosen: j=17
 % @NC   47   25	x17 = 0	28477676.032874
 % @NC   48   25	x17 = 1	28584409.117846
 %      25    18 28461748.2528               28464470.6920   x14 D    17     8
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabbedc0
% @LO 0.07  28.46174825278480824409 99.9000000000
% @LN 0.07  28.46447069200851132109 99.9000000000
% Resuming node 45 at  28.46447069200851132109
DEBUG CONSTRNT: LP rows=47, pool->nlprows=47, pool->npend=0
DEBUG CONSTRNT: Checking 47 LP rows (pool tracks 47, total LP rows 47)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 60
DEBUG CONSTRNT: Pool row 60 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 73
DEBUG CONSTRNT: Pool row 73 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=46, expected 46
 % @PAP adding 50 rows, 217 nz to LP
DEBUG BB: Processing node 45, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=35, theta=0.433718, up=999999999999999983222784.000000
ITER 2: row=19, varin=31, theta=0.010371, up=999999999999999983222784.000000
ITER 3: row=31, varin=49, theta=0.009707, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28464470.692008
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 277 nonzeros, 3 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 45 LP 1 Solution, length = 28464470.692008, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.144244 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.144244 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.144244 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.144244 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.144244 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.134537 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.855756 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.855756 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.855756 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.855756 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.855756 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28464470.692008, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28464470.692008, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 45 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 45
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.144244
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.144244)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.144244
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.144244)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.144244
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.144244)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=1.000000
DEBUG CAREFUL: Skipping var 9: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.144244
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.144244)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.144244
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.144244)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.134537
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.134537)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
DEBUG CAREFUL: Testing fvar[1] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[2] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 4
DEBUG CAREFUL: New best var: 4
DEBUG CAREFUL: Testing fvar[3] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[4] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 22
DEBUG CAREFUL: Testing fvar[5] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 11
  % Initial guess is x4, Z0 = 28464470.6920085        , Z1 = 28844744.714354         

DEBUG EVAL: Testing var 18 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=23, varin=48, theta=19.131576, up=999999999999999983222784.000000
ITER 2: row=48, varin=45, theta=7.645830, up=999999999999999983222784.000000
ITER 3: row=45, varin=41, theta=2.492901, up=999999999999999983222784.000000
ITER 4: row=49, varin=36, theta=6.718622, up=999999999999999983222784.000000
ITER 5: row=6, varin=76, theta=4.445270, up=1.000000
ITER 6: row=6, varin=81, theta=6.429058, up=1.000000
ITER 7: row=6, varin=37, theta=5.181450, up=999999999999999983222784.000000
ITER 8: row=10, varin=78, theta=6.443089, up=1.000000
ITER 9: row=10, varin=79, theta=5.521572, up=1.000000
ITER 10: row=10, varin=38, theta=2.803704, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 18 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x18 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=23, varin=42, theta=0.253478, up=999999999999999983222784.000000
ITER 2: row=39, varin=84, theta=1.998493, up=1.000000
ITER 3: row=39, varin=76, theta=7.880953, up=1.000000
ITER 4: row=39, varin=11, theta=1.033903, up=999999999999999983222784.000000
ITER 5: row=34, varin=44, theta=0.612052, up=999999999999999983222784.000000
ITER 6: row=37, varin=34, theta=2.000000, up=999999999999999983222784.000000
ITER 7: row=21, varin=76, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=7)
ITER 8: row=1, varin=73, theta=0.000000, up=1.000000
ITER 9: row=35, varin=84, theta=0.000000, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28506538.029521
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 50 rows, 60 cols, 277 nonzeros, 1 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 4 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=79, theta=1.000000, up=1.000000
ITER 2: row=31, varin=83, theta=2.000000, up=1.000000
ITER 3: row=31, varin=111, theta=0.250000, up=1.000000
ITER 4: row=34, varin=83, theta=1.000000, up=1.000000
ITER 5: row=17, varin=23, theta=0.033116, up=999999999999999983222784.000000
ITER 6: row=48, varin=35, theta=0.105307, up=999999999999999983222784.000000
ITER 7: row=43, varin=91, theta=0.185003, up=1.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28538006.000878
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 53 rows, 60 cols, 289 nonzeros, 0 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 2 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=54, varin=31, theta=0.771317, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 28542207.280916
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 55 rows, 60 cols, 301 nonzeros, 1 slack, 54 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 1 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=55, varin=10, theta=35418.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 28544583.276073
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 964581.500000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 55 rows, 60 cols, 303 nonzeros, 1 slack, 54 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 45 at  28.54458327607292744688
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabda810
% @LO 0.07  28.46447069200851132109 99.9000000000
% @LN 0.07  28.46581738744194467472 99.9000000000
% Resuming node 43 at  28.46581738744194467472
DEBUG CONSTRNT: LP rows=54, pool->nlprows=54, pool->npend=0
DEBUG CONSTRNT: Checking 54 LP rows (pool tracks 54, total LP rows 54)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=53, expected 53
 % @PAP adding 50 rows, 218 nz to LP
DEBUG BB: Processing node 43, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=16, varin=2, theta=0.250000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28465817.387442
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 0.750000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 278 nonzeros, 1 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=83, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28478924.613416
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 50 rows, 60 cols, 278 nonzeros, 0 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=34, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=23, varin=84, theta=0.175648, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28481970.549747
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 52 rows, 60 cols, 284 nonzeros, 1 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 2 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=33, theta=0.065353, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28493850.023471
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 53 rows, 60 cols, 294 nonzeros, 2 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 43 LP 1 Solution, length = 28493850.023471, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.065353 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.303940 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.303940 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.065353 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.500000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.500000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.065353 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.065353 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.303940 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.934647 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.696060 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.934647 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.696060 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.696060 (terminal 19)
 % 10 fractional variables
DEBUG CG: LP optimal, z=28493850.023471, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 43 at  28.49385002347063888806
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabb5780
% @LO 0.07  28.46581738744194467472 99.9000000000
% @LN 0.07  28.47767603287394777567 99.9000000000
% Resuming node 47 at  28.47767603287394777567
DEBUG CONSTRNT: LP rows=51, pool->nlprows=51, pool->npend=0
DEBUG CONSTRNT: Checking 51 LP rows (pool tracks 51, total LP rows 51)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 143
DEBUG CONSTRNT: Pool row 143 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=50, expected 50
 % @PAP adding 47 rows, 173 nz to LP
DEBUG BB: Processing node 47, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=22, varin=22, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=35, varin=74, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28477676.032874
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 233 nonzeros, 0 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 17 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=15, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=32, varin=29, theta=0.200000, up=999999999999999983222784.000000
ITER 3: row=51, varin=76, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28518628.351727
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 250 nonzeros, 0 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=37, theta=0.046512, up=999999999999999983222784.000000
ITER 2: row=36, varin=24, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28568439.914716
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 53 rows, 60 cols, 256 nonzeros, 5 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 2 rows, 52 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=81, theta=0.225698, up=1.000000
ITER 2: row=50, varin=84, theta=1.607535, up=1.000000
ITER 3: row=50, varin=30, theta=0.074224, up=999999999999999983222784.000000
ITER 4: row=48, varin=84, theta=1.000000, up=1.000000
ITER 5: row=38, varin=49, theta=111130.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28588370.429700
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 282 nonzeros, 1 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 4 rows, 15 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=21, theta=0.132353, up=999999999999999983222784.000000
ITER 2: row=39, varin=75, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28597636.091915
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 53 rows, 60 cols, 257 nonzeros, 0 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 16 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=54, varin=38, theta=0.205882, up=999999999999999983222784.000000
ITER 2: row=30, varin=95, theta=0.350000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 28617516.394304
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 57 rows, 60 cols, 273 nonzeros, 5 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 4 rows, 50 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=56, varin=79, theta=0.030334, up=1.000000
ITER 2: row=53, varin=15, theta=1.457823, up=999999999999999983222784.000000
ITER 3: row=56, varin=56, theta=110027.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 28618973.951612
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 56 rows, 60 cols, 313 nonzeros, 4 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % Node 47 LP 1 Solution, length = 28618973.951612, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.500000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.500000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.500000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28618973.951612, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 47 at  28.61897395161189905366
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabbed00
% @LO 0.07  28.47767603287394777567 99.9000000000
% @LN 0.07  28.48212942883874276845 99.9000000000
% Resuming node 41 at  28.48212942883874276845
DEBUG CONSTRNT: LP rows=52, pool->nlprows=52, pool->npend=0
DEBUG CONSTRNT: Checking 52 LP rows (pool tracks 52, total LP rows 52)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 60
DEBUG CONSTRNT: Pool row 60 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=51, expected 51
 % @PAP adding 37 rows, 156 nz to LP
DEBUG BB: Processing node 41, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=9, varin=40, theta=0.600000, up=1.000000
ITER 2: row=5, varin=44, theta=0.500000, up=1.000000
ITER 3: row=36, varin=19, theta=0.045455, up=999999999999999983222784.000000
ITER 4: row=25, varin=41, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 28482129.428839
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 3.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 37 rows, 60 cols, 216 nonzeros, 0 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 31 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=32, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28483940.406237
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 3.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 247 nonzeros, 1 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 41 LP 1 Solution, length = 28483940.406237, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.500000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.500000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 2 fractional variables
DEBUG CG: LP optimal, z=28483940.406237, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.07  28.48212942883874276845 99.9000000000
 % @LN 0.07  28.48394040623654177580 99.9000000000
DEBUG CG: Second cutoff check: z=28483940.406237, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 41 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 41
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.500000
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.500000
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 2 fractional variables

  %  Carefully choosing branching variable, nfrac = 2
DEBUG CAREFUL: Testing fvar[0] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 0
DEBUG CAREFUL: New best var: 0
DEBUG CAREFUL: Testing fvar[1] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
  % Initial guess is x0, Z0 = 28483940.4062365        , Z1 = 28483940.4062365        

DEBUG EVAL: Testing var 0 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=36, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 0 = 0 gives z=28500000.000000
  % 	x0 = 0,	Z0 = 28500000                
DEBUG EVAL: First branch cutoff check: z=28500000.000000, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 0 = 1
ITER 1: row=1, varin=3, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=33, varin=4, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=5, varin=24, theta=0.043478, up=999999999999999983222784.000000
  % 	x0 = 1,	Z1 = 28763327.6771456        
DEBUG EVAL: Second branch cutoff check: z=28763327.677146, best_z=INF, threshold=INF
  %   New best:  x0, Z = 28500000                
DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=36, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 0 gives z=28500000.000000
  % 	x1 = 0,	Z0 = 28500000                
DEBUG EVAL: First branch cutoff check: z=28500000.000000, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 1
ITER 1: row=2, varin=32, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=5, varin=24, theta=0.043478, up=999999999999999983222784.000000
  % 	x1 = 1,	Z1 = 28551226.2888127        
DEBUG EVAL: Second branch cutoff check: z=28551226.288813, best_z=INF, threshold=INF
  % Best branch is x0, Z0 = 28500000                , Z1 = 28763327.6771456        

DEBUG CAREFUL: Final result - returning best.var = 0
DEBUG BB: Branching variable chosen: j=0
 % @NC   49   41	x0 = 0	28500000.000000
 % @NC   50   41	x0 = 1	28763327.677146
 %      41    19 28483940.4062               28493850.0235   x18 D    39    11
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabda810
% @LO 0.07  28.48394040623654177580 99.9000000000
% @LN 0.07  28.49385002347063888806 99.9000000000
% Resuming node 43 at  28.49385002347063888806
DEBUG CONSTRNT: LP rows=42, pool->nlprows=42, pool->npend=0
DEBUG CONSTRNT: Checking 42 LP rows (pool tracks 42, total LP rows 42)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 85
DEBUG CONSTRNT: Pool row 85 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 73
DEBUG CONSTRNT: Pool row 73 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=41, expected 41
 % @PAP adding 51 rows, 222 nz to LP
DEBUG BB: Processing node 43, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 43 LP 2 Solution, length = 28493850.023471, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.065353 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.303940 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.303940 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.065353 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.500000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.500000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.065353 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.065353 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.303940 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.934647 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.696060 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.934647 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.696060 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.696060 (terminal 19)
 % 10 fractional variables
DEBUG CG: LP optimal, z=28493850.023471, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28493850.023471, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 3 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 43 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 43
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.500000
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.065353
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.065353)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.303940
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.303940)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.303940
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.303940)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.065353
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.065353)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.500000
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.500000
DEBUG CAREFUL: Adding var 30 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.065353
DEBUG CAREFUL: Adding var 31 to fractional list (xi=0.065353)
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.065353
DEBUG CAREFUL: Adding var 32 to fractional list (xi=0.065353)
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.303940
DEBUG CAREFUL: Adding var 37 to fractional list (xi=0.303940)
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 10 fractional variables

  %  Carefully choosing branching variable, nfrac = 10
DEBUG CAREFUL: Testing fvar[0] = var 30
DEBUG CAREFUL: Calling compare_branch_vars for var 30
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 30
DEBUG CAREFUL: New best var: 30
DEBUG CAREFUL: Testing fvar[1] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[2] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 29
DEBUG CAREFUL: Testing fvar[3] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[4] = var 31
DEBUG CAREFUL: Calling compare_branch_vars for var 31
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 31
DEBUG CAREFUL: Testing fvar[5] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 27
DEBUG CAREFUL: Testing fvar[6] = var 32
DEBUG CAREFUL: Calling compare_branch_vars for var 32
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 32
DEBUG CAREFUL: Testing fvar[7] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[8] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[9] = var 37
DEBUG CAREFUL: Calling compare_branch_vars for var 37
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 37
  % Initial guess is x30, Z0 = 28493850.0234706        , Z1 = 29645608.5993569        

DEBUG EVAL: Testing var 30 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=30, varin=2, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=37, varin=3, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=42, varin=41, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=7, varin=48, theta=0.616056, up=999999999999999983222784.000000
ITER 5: row=35, varin=27, theta=0.601848, up=999999999999999983222784.000000
ITER 6: row=27, varin=38, theta=1.081010, up=999999999999999983222784.000000
ITER 7: row=38, varin=65, theta=6.624904, up=1.000000
ITER 8: row=38, varin=60, theta=5.626201, up=1.000000
ITER 9: row=38, varin=26, theta=23.514263, up=999999999999999983222784.000000
ITER 10: row=26, varin=16, theta=26.767349, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 30 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x30 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=30, varin=45, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28546310.693879
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
   % @PL 51 rows, 60 cols, 282 nonzeros, 2 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
   % @PAP adding 4 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=53, varin=90, theta=0.084458, up=1.000000
ITER 2: row=50, varin=92, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28565575.042712
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
   % @PL 53 rows, 60 cols, 290 nonzeros, 0 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 2 rows, 10 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=54, varin=47, theta=0.250000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 28569167.608597
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
   % @PL 55 rows, 60 cols, 300 nonzeros, 2 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 43 at  28.56916760859700232800
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595daba2600
% @LO 0.08  28.49385002347063888806 99.9000000000
% @LN 0.08  28.50000000000000000000 99.9000000000
% Resuming node 49 at  28.50000000000000000000
DEBUG CONSTRNT: LP rows=53, pool->nlprows=53, pool->npend=0
DEBUG CONSTRNT: Checking 53 LP rows (pool tracks 53, total LP rows 53)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 158
DEBUG CONSTRNT: Pool row 158 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 105
DEBUG CONSTRNT: Pool row 105 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=52, expected 52
 % @PAP adding 42 rows, 183 nz to LP
DEBUG BB: Processing node 49, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=36, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28500000.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 3.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 243 nonzeros, 1 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 40 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=24, theta=0.027027, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28502023.267148
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 3.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 283 nonzeros, 5 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 5 rows, 23 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=67, theta=0.666667, up=1.000000
ITER 2: row=10, varin=73, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28534948.000887
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 3.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 288 nonzeros, 0 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=8, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=35, varin=17, theta=0.923077, up=999999999999999983222784.000000
ITER 3: row=14, varin=24, theta=0.008264, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28551095.365596
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.925620
DEBUG SOLUTION: lp->best_solution[7] = 0.925620
DEBUG SOLUTION: lp->best_solution[8] = 2.851240
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 301 nonzeros, 7 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 7 slack rows
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=97, theta=0.470588, up=1.000000
ITER 2: row=41, varin=23, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28558933.734761
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 289 nonzeros, 3 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % Node 49 LP 1 Solution, length = 28558933.734761, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.500000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 2 fractional variables
DEBUG CG: LP optimal, z=28558933.734761, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 49 at  28.55893373476142471645
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabd7f60
% @LO 0.08  28.50000000000000000000 99.9000000000
% @LN 0.08  28.52505174228138784542 99.9000000000
% Resuming node 27 at  28.52505174228138784542
DEBUG CONSTRNT: LP rows=39, pool->nlprows=39, pool->npend=0
DEBUG CONSTRNT: Checking 39 LP rows (pool tracks 39, total LP rows 39)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 73
DEBUG CONSTRNT: Pool row 73 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 162
DEBUG CONSTRNT: Pool row 162 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=38, expected 38
 % @PAP adding 47 rows, 213 nz to LP
DEBUG BB: Processing node 27, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 27 LP 3 Solution, length = 28525051.742281, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.500000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.093570 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.041906 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.041906 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.093570 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.093570 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.093570 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.093570 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.500000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.500000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.958094 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.906430 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.906430 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.906430 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.906430 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.906430 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.906430 (terminal 19)
 % 10 fractional variables
DEBUG CG: LP optimal, z=28525051.742281, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28525051.742281, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 3 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 27 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 27
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.500000
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.500000
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.093570
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.093570)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.041906
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.041906)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.041906
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.041906)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.093570
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.093570)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.093570
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.093570)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=1.000000
DEBUG CAREFUL: Skipping var 15: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.093570
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.093570)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.093570
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.093570)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.500000
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 10 fractional variables

  %  Carefully choosing branching variable, nfrac = 10
DEBUG CAREFUL: Testing fvar[0] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 1
DEBUG CAREFUL: New best var: 1
DEBUG CAREFUL: Testing fvar[1] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
DEBUG CAREFUL: Testing fvar[2] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 29
DEBUG CAREFUL: Testing fvar[3] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 4
DEBUG CAREFUL: New best var: 4
DEBUG CAREFUL: Testing fvar[4] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[5] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 11
DEBUG CAREFUL: Testing fvar[6] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 18
DEBUG CAREFUL: Testing fvar[7] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[8] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[9] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
  % Initial guess is x4, Z0 = 28525051.7422814        , Z1 = 28844744.714354         

DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=39, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=11, varin=44, theta=0.140654, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 0 gives z=28537633.427552
  % 	x1 = 0,	Z0 = 28537633.4275523        
DEBUG EVAL: First branch cutoff check: z=28537633.427552, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 1
ITER 1: row=2, varin=36, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=3, varin=72, theta=1.789761, up=1.000000
ITER 3: row=3, varin=32, theta=0.619803, up=999999999999999983222784.000000
ITER 4: row=25, varin=26, theta=0.224827, up=999999999999999983222784.000000
ITER 5: row=6, varin=69, theta=0.545875, up=1.000000
ITER 6: row=11, varin=41, theta=0.304178, up=999999999999999983222784.000000
ITER 7: row=35, varin=31, theta=0.191004, up=999999999999999983222784.000000
ITER 8: row=26, varin=27, theta=0.455784, up=999999999999999983222784.000000
  % 	x1 = 1,	Z1 = 28786180.6968174        
DEBUG EVAL: Second branch cutoff check: z=28786180.696817, best_z=INF, threshold=INF
  %   New best:  x1, Z = 28537633.4275523        
DEBUG EVAL: Testing var 0 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=39, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=11, varin=44, theta=0.140654, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 0 = 0 gives z=28537633.427552
  % 	x0 = 0,	Z0 = 28537633.4275523        
DEBUG EVAL: First branch cutoff check: z=28537633.427552, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 0 = 1
ITER 1: row=1, varin=3, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=28, varin=36, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=3, varin=72, theta=1.789761, up=1.000000
ITER 4: row=3, varin=32, theta=0.619803, up=999999999999999983222784.000000
ITER 5: row=25, varin=26, theta=0.224827, up=999999999999999983222784.000000
ITER 6: row=6, varin=69, theta=0.545875, up=1.000000
ITER 7: row=11, varin=41, theta=0.304178, up=999999999999999983222784.000000
ITER 8: row=35, varin=31, theta=0.191004, up=999999999999999983222784.000000
ITER 9: row=26, varin=72, theta=1.767674, up=1.000000
ITER 10: row=26, varin=29, theta=0.368726, up=999999999999999983222784.000000
  % 	x0 = 1,	Z1 = 28881525.2674043        
DEBUG EVAL: Second branch cutoff check: z=28881525.267404, best_z=INF, threshold=INF
  %   New best:  x0, Z = 28537633.4275523        
DEBUG EVAL: Testing var 29 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=36, varin=39, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=11, varin=44, theta=0.140654, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 29 = 0 gives z=28537633.427552
  % 	x29 = 0,	Z0 = 28537633.4275523        
DEBUG EVAL: First branch cutoff check: z=28537633.427552, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 29 = 1
ITER 1: row=36, varin=4, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=37, varin=14, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=3, varin=72, theta=0.726741, up=1.000000
  % 	x29 = 1,	Z1 = 29176926.3673997        
DEBUG EVAL: Second branch cutoff check: z=29176926.367400, best_z=INF, threshold=INF
  %   New best:  x29, Z = 28537633.4275523        
DEBUG EVAL: Testing var 4 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=11, varin=44, theta=1.341051, up=999999999999999983222784.000000
ITER 2: row=41, varin=41, theta=1.261516, up=999999999999999983222784.000000
ITER 3: row=35, varin=40, theta=2.404873, up=999999999999999983222784.000000
ITER 4: row=3, varin=39, theta=5.000000, up=999999999999999983222784.000000
ITER 5: row=1, varin=7, theta=2.000000, up=999999999999999983222784.000000
ITER 6: row=7, varin=36, theta=2.000000, up=999999999999999983222784.000000
ITER 7: row=36, varin=35, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=41, varin=26, theta=0.008029, up=999999999999999983222784.000000
ITER 9: row=42, varin=3, theta=0.034674, up=999999999999999983222784.000000
ITER 10: row=2, varin=32, theta=0.034934, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 4 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x4 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=11, varin=72, theta=0.066411, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28525982.615729
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 47 rows, 60 cols, 273 nonzeros, 0 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=39, theta=0.294296, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28527170.518747
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 49 rows, 60 cols, 281 nonzeros, 1 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 27 at  28.52717051874692799629
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabd7f60
% @LO 0.08  28.52505174228138784542 99.9000000000
% @LN 0.08  28.52717051874692799629 99.9000000000
% Resuming node 27 at  28.52717051874692799629
DEBUG CONSTRNT: LP rows=48, pool->nlprows=48, pool->npend=0
DEBUG CONSTRNT: Checking 48 LP rows (pool tracks 48, total LP rows 48)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 150
DEBUG CONSTRNT: Pool row 150 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 85
DEBUG CONSTRNT: Pool row 85 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=47, expected 47
 % @PAP adding 48 rows, 219 nz to LP
DEBUG BB: Processing node 27, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 27 LP 4 Solution, length = 28527170.518747, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.352852 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.352852 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.161787 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.161787 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.161787 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.161787 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.161787 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.352852 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.647148 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.647148 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.647148 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.838213 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.647148 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.838213 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.838213 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.838213 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.838213 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.838213 (terminal 19)
 % 8 fractional variables
DEBUG CG: LP optimal, z=28527170.518747, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28527170.518747, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 3 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 27 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 27
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.352852
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.352852)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.352852
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.352852)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.161787
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.161787)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.161787
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.161787)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.161787
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.161787)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=1.000000
DEBUG CAREFUL: Skipping var 15: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.161787
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.161787)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.161787
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.161787)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.352852
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.352852)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 8 fractional variables

  %  Carefully choosing branching variable, nfrac = 8
DEBUG CAREFUL: Testing fvar[0] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 26
DEBUG CAREFUL: New best var: 26
DEBUG CAREFUL: Testing fvar[1] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 11
DEBUG CAREFUL: New best var: 11
DEBUG CAREFUL: Testing fvar[2] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 18
DEBUG CAREFUL: Testing fvar[3] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[4] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 1
DEBUG CAREFUL: New best var: 1
DEBUG CAREFUL: Testing fvar[5] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 0
DEBUG CAREFUL: New best var: 0
DEBUG CAREFUL: Testing fvar[6] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[7] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 29
DEBUG CAREFUL: New best var: 29
  % Initial guess is x29, Z0 = 28537633.4275523        , Z1 = 29176926.3673997        

DEBUG EVAL: Testing var 26 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=26, varin=47, theta=1.042644, up=999999999999999983222784.000000
ITER 2: row=1, varin=32, theta=4.725851, up=999999999999999983222784.000000
ITER 3: row=48, varin=31, theta=1.026905, up=999999999999999983222784.000000
ITER 4: row=26, varin=6, theta=0.728803, up=999999999999999983222784.000000
ITER 5: row=45, varin=48, theta=14.758852, up=999999999999999983222784.000000
ITER 6: row=1, varin=70, theta=0.683489, up=1.000000
DEBUG EVAL: Branch var 26 = 1 gives z=28825794.081882
  % 	x26 = 1,	Z1 = 28825794.081882         
DEBUG EVAL: First branch cutoff check: z=28825794.081882, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 0
ITER 1: row=26, varin=46, theta=0.325689, up=999999999999999983222784.000000
  % 	x26 = 0,	Z0 = 28534731.8993521        
DEBUG EVAL: Second branch cutoff check: z=28534731.899352, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 11 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=47, theta=1.042644, up=999999999999999983222784.000000
ITER 2: row=1, varin=32, theta=4.725851, up=999999999999999983222784.000000
ITER 3: row=48, varin=26, theta=1.039059, up=999999999999999983222784.000000
ITER 4: row=41, varin=30, theta=3.971507, up=999999999999999983222784.000000
ITER 5: row=42, varin=70, theta=6.619451, up=1.000000
ITER 6: row=42, varin=34, theta=1.651516, up=999999999999999983222784.000000
ITER 7: row=41, varin=71, theta=5.837242, up=1.000000
ITER 8: row=41, varin=3, theta=4.485358, up=999999999999999983222784.000000
ITER 9: row=2, varin=39, theta=13.318210, up=999999999999999983222784.000000
ITER 10: row=3, varin=12, theta=1.143059, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 11 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x11 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=6, varin=46, theta=0.325689, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28534731.899352
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 48 rows, 60 cols, 279 nonzeros, 1 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 6 rows, 27 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=53, varin=40, theta=0.074879, up=999999999999999983222784.000000
ITER 2: row=48, varin=75, theta=0.131139, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28551559.858157
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 53 rows, 60 cols, 304 nonzeros, 5 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 5 slack rows
   % @PAP adding 1 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=80, theta=0.161542, up=1.000000
ITER 2: row=47, varin=48, theta=0.148930, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28557209.554951
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 49 rows, 60 cols, 284 nonzeros, 1 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 27 at  28.55720955495148416503
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabad4e0
% @LO 0.08  28.52717051874692799629 99.9000000000
% @LN 0.08  28.53331999048349132408 99.9000000000
% Resuming node 29 at  28.53331999048349132408
DEBUG CONSTRNT: LP rows=48, pool->nlprows=48, pool->npend=0
DEBUG CONSTRNT: Checking 48 LP rows (pool tracks 48, total LP rows 48)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 150
DEBUG CONSTRNT: Pool row 150 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 85
DEBUG CONSTRNT: Pool row 85 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=47, expected 47
 % @PAP adding 48 rows, 219 nz to LP
DEBUG BB: Processing node 29, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 29 LP 3 Solution, length = 28533319.990483, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.142857 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.142857 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.142857 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.142857 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.142857 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.142857 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.142857 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.426119 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.573881 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.857143 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.857143 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.857143 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.857143 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.857143 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.857143 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.857143 (terminal 19)
 % 8 fractional variables
DEBUG CG: LP optimal, z=28533319.990483, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28533319.990483, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 29 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 29
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.142857
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.142857)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.142857
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.142857)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.142857
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.142857)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=1.000000
DEBUG CAREFUL: Skipping var 8: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.142857
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.142857)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.142857
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.142857)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.142857
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.142857)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.142857
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.142857)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.426119
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.426119)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 8 fractional variables

  %  Carefully choosing branching variable, nfrac = 8
DEBUG CAREFUL: Testing fvar[0] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 26
DEBUG CAREFUL: New best var: 26
DEBUG CAREFUL: Testing fvar[1] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[2] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[3] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 11
DEBUG CAREFUL: New best var: 11
DEBUG CAREFUL: Testing fvar[4] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[5] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 4
DEBUG CAREFUL: New best var: 4
DEBUG CAREFUL: Testing fvar[6] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[7] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 36
  % Initial guess is x4, Z0 = 28533319.9904835        , Z1 = 28901535.7863583        

DEBUG EVAL: Testing var 26 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=36, varin=29, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 0 gives z=28542454.959178
  % 	x26 = 0,	Z0 = 28542454.959178         
DEBUG EVAL: First branch cutoff check: z=28542454.959178, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 1
ITER 1: row=36, varin=39, theta=6.000000, up=999999999999999983222784.000000
ITER 2: row=2, varin=5, theta=0.461538, up=999999999999999983222784.000000
ITER 3: row=37, varin=30, theta=3.000000, up=999999999999999983222784.000000
ITER 4: row=24, varin=46, theta=3.000000, up=999999999999999983222784.000000
ITER 5: row=17, varin=33, theta=1.638428, up=999999999999999983222784.000000
ITER 6: row=44, varin=70, theta=2.005638, up=1.000000
ITER 7: row=44, varin=45, theta=0.886343, up=999999999999999983222784.000000
ITER 8: row=10, varin=70, theta=0.105104, up=1.000000
  % 	x26 = 1,	Z1 = 28891184.6946048        
DEBUG EVAL: Second branch cutoff check: z=28891184.694605, best_z=INF, threshold=INF
  %   New best:  x26, Z = 28542454.959178         
DEBUG EVAL: Testing var 17 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=23, varin=29, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 0 gives z=28542454.959178
  % 	x17 = 0,	Z0 = 28542454.959178         
DEBUG EVAL: First branch cutoff check: z=28542454.959178, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 1
ITER 1: row=23, varin=39, theta=6.000000, up=999999999999999983222784.000000
ITER 2: row=2, varin=30, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=24, varin=46, theta=3.000000, up=999999999999999983222784.000000
ITER 4: row=17, varin=70, theta=2.005638, up=1.000000
ITER 5: row=17, varin=71, theta=1.027221, up=1.000000
ITER 6: row=17, varin=24, theta=0.576351, up=999999999999999983222784.000000
ITER 7: row=10, varin=74, theta=0.189532, up=1.000000
ITER 8: row=17, varin=11, theta=3.864580, up=999999999999999983222784.000000
ITER 9: row=5, varin=45, theta=2.352327, up=999999999999999983222784.000000
ITER 10: row=30, varin=38, theta=1.159763, up=999999999999999983222784.000000
  % 	x17 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: Second branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=23, varin=29, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28542454.959178
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 48 rows, 60 cols, 279 nonzeros, 2 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
   % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=69, theta=0.066872, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28543959.946787
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 47 rows, 60 cols, 271 nonzeros, 0 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 4 rows, 16 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=38, theta=0.136587, up=999999999999999983222784.000000
ITER 2: row=28, varin=82, theta=0.085989, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28546890.115487
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 51 rows, 60 cols, 287 nonzeros, 0 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 29 at  28.54689011548698829301
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabc3990
% @LO 0.08  28.53331999048349132408 99.9000000000
% @LN 0.08  28.54124926036630682802 99.9000000000
% Resuming node 36 at  28.54124926036630682802
DEBUG CONSTRNT: LP rows=51, pool->nlprows=51, pool->npend=0
DEBUG CONSTRNT: Checking 51 LP rows (pool tracks 51, total LP rows 51)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 62
DEBUG CONSTRNT: Pool row 62 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=50, expected 50
 % @PAP adding 49 rows, 236 nz to LP
DEBUG BB: Processing node 36, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 36 LP 3 Solution, length = 28541249.260366, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.199069 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.300931 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 1.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.300931 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.199069 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.199069 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.300931 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.199069 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.800931 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.800931 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.699069 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.800931 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.699069 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=28541249.260366, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28541249.260366, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 36 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 36
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.199069
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.199069)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.300931
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.300931)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=1.000000
DEBUG CAREFUL: Skipping var 16: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.300931
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.300931)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.199069
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.199069)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.199069
DEBUG CAREFUL: Adding var 30 to fractional list (xi=0.199069)
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.300931
DEBUG CAREFUL: Adding var 31 to fractional list (xi=0.300931)
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.199069
DEBUG CAREFUL: Adding var 32 to fractional list (xi=0.199069)
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 7 fractional variables

  %  Carefully choosing branching variable, nfrac = 7
DEBUG CAREFUL: Testing fvar[0] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 2
DEBUG CAREFUL: New best var: 2
DEBUG CAREFUL: Testing fvar[1] = var 31
DEBUG CAREFUL: Calling compare_branch_vars for var 31
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 31
DEBUG CAREFUL: Testing fvar[2] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 27
DEBUG CAREFUL: Testing fvar[3] = var 32
DEBUG CAREFUL: Calling compare_branch_vars for var 32
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 32
DEBUG CAREFUL: Testing fvar[4] = var 30
DEBUG CAREFUL: Calling compare_branch_vars for var 30
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 30
DEBUG CAREFUL: Testing fvar[5] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 29
DEBUG CAREFUL: Testing fvar[6] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
  % Initial guess is x2, Z0 = 28541249.2603663        , Z1 = 28541249.2603663        

DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=4, varin=91, theta=1.272746, up=1.000000
ITER 2: row=4, varin=31, theta=0.278171, up=999999999999999983222784.000000
ITER 3: row=8, varin=91, theta=1.000000, up=1.000000
ITER 4: row=5, varin=4, theta=5.790960, up=999999999999999983222784.000000
ITER 5: row=35, varin=88, theta=99.935986, up=1.000000
DEBUG EVAL: Branch var 2 = 0 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x2 = 0,	Z0 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=4, varin=105, theta=1.835072, up=1.000000
ITER 2: row=4, varin=48, theta=0.324395, up=999999999999999983222784.000000
ITER 3: row=45, varin=105, theta=1.116956, up=1.000000
ITER 4: row=45, varin=38, theta=0.326473, up=999999999999999983222784.000000
ITER 5: row=38, varin=31, theta=0.124678, up=999999999999999983222784.000000
ITER 6: row=5, varin=30, theta=0.176158, up=999999999999999983222784.000000
ITER 7: row=30, varin=4, theta=0.272691, up=999999999999999983222784.000000
ITER 8: row=1, varin=36, theta=0.823745, up=999999999999999983222784.000000
ITER 9: row=36, varin=19, theta=0.595875, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 49 rows, 60 cols, 296 nonzeros, 2 slack, 47 tight.
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 36 at 1000000000000000000.00000000000000000000
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabbedc0
% @LO 0.08  28.54124926036630682802 99.9000000000
% @LN 0.08  28.54458327607292744688 99.9000000000
% Resuming node 45 at  28.54458327607292744688
DEBUG CONSTRNT: LP rows=49, pool->nlprows=49, pool->npend=0
DEBUG CONSTRNT: Checking 49 LP rows (pool tracks 49, total LP rows 49)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=48, expected 48
 % @PAP adding 54 rows, 203 nz to LP
DEBUG BB: Processing node 45, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 45 LP 2 Solution, length = 28544583.276073, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.500000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.500000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 1.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28544583.276073, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28544583.276073, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 45 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 45
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=1.000000
DEBUG CAREFUL: Skipping var 9: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.500000
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.500000
DEBUG CAREFUL: Adding var 21 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.500000
DEBUG CAREFUL: Adding var 25 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=1.000000
DEBUG CAREFUL: Skipping var 36: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 3 fractional variables

  %  Carefully choosing branching variable, nfrac = 3
DEBUG CAREFUL: Testing fvar[0] = var 25
DEBUG CAREFUL: Calling compare_branch_vars for var 25
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 25
DEBUG CAREFUL: New best var: 25
DEBUG CAREFUL: Testing fvar[1] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
DEBUG CAREFUL: Testing fvar[2] = var 21
DEBUG CAREFUL: Calling compare_branch_vars for var 21
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 21
  % Initial guess is x25, Z0 = 28544583.2760729        , Z1 = 28544583.2760729        

DEBUG EVAL: Testing var 25 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=26, theta=0.100000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 25 = 0 gives z=28558183.567140
  % 	x25 = 0,	Z0 = 28558183.5671397        
DEBUG EVAL: First branch cutoff check: z=28558183.567140, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 25 = 1
ITER 1: row=1, varin=46, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=46, varin=54, theta=1.000000, up=999999999999999983222784.000000
  % 	x25 = 1,	Z1 = 28547663.7145335        
DEBUG EVAL: Second branch cutoff check: z=28547663.714534, best_z=INF, threshold=INF
  %   New best:  x25, Z = 28547663.7145335        
DEBUG EVAL: Testing var 12 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=17, varin=54, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 12 = 0 gives z=28547663.714534
  % 	x12 = 0,	Z0 = 28547663.7145335        
DEBUG EVAL: First branch cutoff check: z=28547663.714534, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 1
ITER 1: row=17, varin=27, theta=1.000000, up=999999999999999983222784.000000
  % 	x12 = 1,	Z1 = 28590339.433928         
DEBUG EVAL: Second branch cutoff check: z=28590339.433928, best_z=INF, threshold=INF
  %   New best:  x12, Z = 28547663.7145335        
DEBUG EVAL: Testing var 21 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=27, varin=54, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 21 = 0 gives z=28547663.714534
  % 	x21 = 0,	Z0 = 28547663.7145335        
DEBUG EVAL: First branch cutoff check: z=28547663.714534, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 21 = 1
ITER 1: row=27, varin=17, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=28, varin=18, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=1, varin=26, theta=0.200000, up=999999999999999983222784.000000
  % 	x21 = 1,	Z1 = 29561419.3916689        
DEBUG EVAL: Second branch cutoff check: z=29561419.391669, best_z=INF, threshold=INF
  %   New best:  x21, Z = 28547663.7145335        
  % Best branch is x21, Z0 = 28547663.7145335        , Z1 = 29561419.3916689        

DEBUG CAREFUL: Final result - returning best.var = 21
DEBUG BB: Branching variable chosen: j=21
 % @NC   51   45	x21 = 0	28547663.714534
 % @NC   52   45	x21 = 1	29561419.391669
 %      45    20 28544583.2761               28546890.1155    x0 D    11     7
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabad4e0
% @LO 0.08  28.54458327607292744688 99.9000000000
% @LN 0.08  28.54689011548698829301 99.9000000000
% Resuming node 29 at  28.54689011548698829301
DEBUG CONSTRNT: LP rows=54, pool->nlprows=54, pool->npend=0
DEBUG CONSTRNT: Checking 54 LP rows (pool tracks 54, total LP rows 54)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=53, expected 53
 % @PAP adding 51 rows, 227 nz to LP
DEBUG BB: Processing node 29, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 29 LP 4 Solution, length = 28546890.115487, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.457006 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.457006 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.457006 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.457006 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.457006 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.085989 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.457006 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.542994 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.542994 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.542994 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.542994 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.542994 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.542994 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=28546890.115487, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28546890.115487, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 29 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 29
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.457006
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.457006)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.457006
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.457006)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=1.000000
DEBUG CAREFUL: Skipping var 8: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.457006
DEBUG CAREFUL: Adding var 23 to fractional list (xi=0.457006)
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.457006
DEBUG CAREFUL: Adding var 24 to fractional list (xi=0.457006)
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.457006
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.457006)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.085989
DEBUG CAREFUL: Adding var 30 to fractional list (xi=0.085989)
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.457006
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.457006)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 7 fractional variables

  %  Carefully choosing branching variable, nfrac = 7
DEBUG CAREFUL: Testing fvar[0] = var 30
DEBUG CAREFUL: Calling compare_branch_vars for var 30
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 30
DEBUG CAREFUL: New best var: 30
DEBUG CAREFUL: Testing fvar[1] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[2] = var 23
DEBUG CAREFUL: Calling compare_branch_vars for var 23
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 23
DEBUG CAREFUL: Testing fvar[3] = var 24
DEBUG CAREFUL: Calling compare_branch_vars for var 24
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 24
DEBUG CAREFUL: Testing fvar[4] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
DEBUG CAREFUL: Testing fvar[5] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 36
DEBUG CAREFUL: Testing fvar[6] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 29
  % Initial guess is x30, Z0 = 28546890.115487         , Z1 = 28667221.3660948        

DEBUG EVAL: Testing var 30 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=10, varin=28, theta=1.451836, up=999999999999999983222784.000000
ITER 2: row=38, varin=48, theta=0.710808, up=999999999999999983222784.000000
ITER 3: row=48, varin=47, theta=1.462724, up=999999999999999983222784.000000
ITER 4: row=17, varin=40, theta=0.383303, up=999999999999999983222784.000000
ITER 5: row=3, varin=29, theta=0.134268, up=999999999999999983222784.000000
ITER 6: row=24, varin=44, theta=0.136218, up=999999999999999983222784.000000
ITER 7: row=44, varin=35, theta=0.175651, up=999999999999999983222784.000000
ITER 8: row=35, varin=43, theta=0.132493, up=999999999999999983222784.000000
ITER 9: row=43, varin=39, theta=0.236761, up=999999999999999983222784.000000
ITER 10: row=39, varin=8, theta=0.174291, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 30 = 1 gives z=28636348.612115
  % 	x30 = 1,	Z1 = 28667221.3660948        
DEBUG EVAL: First branch cutoff check: z=28667221.366095, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 30 = 0
ITER 1: row=10, varin=74, theta=0.067608, up=1.000000
  % 	x30 = 0,	Z0 = 28547095.5998615        
DEBUG EVAL: Second branch cutoff check: z=28547095.599861, best_z=INF, threshold=INF
  %   New best:  x30, Z = 28547095.5998615        
DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=47, theta=1.462724, up=999999999999999983222784.000000
ITER 2: row=17, varin=32, theta=0.159268, up=999999999999999983222784.000000
ITER 3: row=41, varin=23, theta=0.078022, up=999999999999999983222784.000000
ITER 4: row=31, varin=48, theta=1.011421, up=999999999999999983222784.000000
ITER 5: row=10, varin=85, theta=0.638708, up=1.000000
ITER 6: row=48, varin=82, theta=1.733246, up=1.000000
ITER 7: row=48, varin=10, theta=50690.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 0 gives z=28637311.374444
  % 	x1 = 0,	Z0 = 28637311.3744441        
DEBUG EVAL: First branch cutoff check: z=28637311.374444, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 1
ITER 1: row=2, varin=28, theta=0.792435, up=999999999999999983222784.000000
ITER 2: row=38, varin=74, theta=3.994461, up=1.000000
ITER 3: row=38, varin=77, theta=3.763957, up=1.000000
ITER 4: row=38, varin=40, theta=1.071193, up=999999999999999983222784.000000
ITER 5: row=10, varin=77, theta=1.390074, up=1.000000
ITER 6: row=10, varin=74, theta=0.363951, up=1.000000
ITER 7: row=3, varin=29, theta=0.414330, up=999999999999999983222784.000000
ITER 8: row=24, varin=44, theta=0.404545, up=999999999999999983222784.000000
ITER 9: row=44, varin=11, theta=0.534924, up=999999999999999983222784.000000
ITER 10: row=5, varin=43, theta=0.423930, up=999999999999999983222784.000000
  % 	x1 = 1,	Z1 = 28770748.291023         
DEBUG EVAL: Second branch cutoff check: z=28770748.291023, best_z=INF, threshold=INF
  %   New best:  x1, Z = 28637311.3744441        
DEBUG EVAL: Testing var 23 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=28, theta=1.451836, up=999999999999999983222784.000000
ITER 2: row=38, varin=40, theta=0.633890, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 23 = 0 gives z=28592534.662879
  % 	x23 = 0,	Z0 = 28592534.6628793        
DEBUG EVAL: First branch cutoff check: z=28592534.662879, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 24 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=28, theta=1.451836, up=999999999999999983222784.000000
ITER 2: row=38, varin=40, theta=0.633890, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 24 = 0 gives z=28592534.662879
  % 	x24 = 0,	Z0 = 28592534.6628793        
DEBUG EVAL: First branch cutoff check: z=28592534.662879, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 0 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=74, theta=3.994461, up=1.000000
ITER 2: row=1, varin=77, theta=3.763957, up=1.000000
ITER 3: row=1, varin=40, theta=1.071193, up=999999999999999983222784.000000
ITER 4: row=10, varin=77, theta=1.390074, up=1.000000
ITER 5: row=10, varin=74, theta=0.363951, up=1.000000
ITER 6: row=3, varin=29, theta=0.414330, up=999999999999999983222784.000000
ITER 7: row=24, varin=44, theta=0.404545, up=999999999999999983222784.000000
ITER 8: row=44, varin=11, theta=0.534924, up=999999999999999983222784.000000
ITER 9: row=5, varin=43, theta=0.423930, up=999999999999999983222784.000000
ITER 10: row=43, varin=39, theta=1.071780, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 0 = 1 gives z=29467615.820176
  % 	x0 = 1,	Z1 = 29467615.8201758        
DEBUG EVAL: First branch cutoff check: z=29467615.820176, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 0 = 0
ITER 1: row=1, varin=28, theta=1.451836, up=999999999999999983222784.000000
  % 	x0 = 0,	Z0 = 28568949.351711         
DEBUG EVAL: Second branch cutoff check: z=28568949.351711, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 36 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=17, varin=28, theta=1.451836, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 36 = 0 gives z=28568949.351711
  % 	x36 = 0,	Z0 = 28568949.351711         
DEBUG EVAL: First branch cutoff check: z=28568949.351711, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 29 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=8, varin=28, theta=1.451836, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 29 = 0 gives z=28568949.351711
  % 	x29 = 0,	Z0 = 28568949.351711         
DEBUG EVAL: First branch cutoff check: z=28568949.351711, best_z=INF, threshold=INF
  % Best branch is x1, Z0 = 28637311.3744441        , Z1 = 28770748.291023         

DEBUG CAREFUL: Final result - returning best.var = 1
DEBUG BB: Branching variable chosen: j=1
 % @NC   53   29	x1 = 0	28637311.374444
 % @NC   54   29	x1 = 1	28770748.291023
 %      29    21 28546890.1155               28547663.7145    x8 U    18     8
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabbed00
% @LO 0.08  28.54689011548698829301 99.9000000000
% @LN 0.08  28.54766371453350259912 99.9000000000
% Resuming node 51 at  28.54766371453350259912
DEBUG CONSTRNT: LP rows=51, pool->nlprows=51, pool->npend=0
DEBUG CONSTRNT: Checking 51 LP rows (pool tracks 51, total LP rows 51)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 62
DEBUG CONSTRNT: Pool row 62 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=50, expected 50
 % @PAP adding 54 rows, 203 nz to LP
DEBUG BB: Processing node 51, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=27, varin=54, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 28547663.714534
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 54 rows, 60 cols, 263 nonzeros, 1 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 9 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=55, varin=26, theta=0.200000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 28574864.296667
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 56 rows, 60 cols, 272 nonzeros, 6 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 1 rows, 40 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=25, theta=1.153106, up=999999999999999983222784.000000
ITER 2: row=17, varin=79, theta=0.109403, up=1.000000
ITER 3: row=1, varin=32, theta=0.050976, up=999999999999999983222784.000000
ITER 4: row=24, varin=64, theta=0.383267, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28603126.385498
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 284 nonzeros, 3 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 3 rows, 11 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=80, theta=0.389792, up=1.000000
ITER 2: row=37, varin=94, theta=0.151911, up=1.000000
ITER 3: row=51, varin=13, theta=0.055556, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28629467.311213
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.944444
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 284 nonzeros, 1 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 3 rows, 10 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=56, theta=0.125000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28639014.231356
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 53 rows, 60 cols, 292 nonzeros, 3 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 2 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=57, theta=0.083333, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28642058.530717
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 296 nonzeros, 1 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 51 LP 1 Solution, length = 28642058.530717, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.083333 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.083333 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.083333 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.083333 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.083333 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.500000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.083333 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.467704 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.083333 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.532296 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.916667 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.916667 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.916667 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.916667 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.916667 (terminal 19)
 % 10 fractional variables
DEBUG CG: LP optimal, z=28642058.530717, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 51 at  28.64205853071726792791
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabd9c70
% @LO 0.08  28.54766371453350259912 99.9000000000
% @LN 0.08  28.55347084168707283425 99.9000000000
% Resuming node 42 at  28.55347084168707283425
DEBUG CONSTRNT: LP rows=51, pool->nlprows=51, pool->npend=0
DEBUG CONSTRNT: Checking 51 LP rows (pool tracks 51, total LP rows 51)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=50, expected 50
 % @PAP adding 37 rows, 156 nz to LP
DEBUG BB: Processing node 42, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=9, varin=33, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 28457883.733842
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 3.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 37 rows, 60 cols, 216 nonzeros, 2 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 5 rows, 60 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=37, theta=0.590662, up=999999999999999983222784.000000
ITER 2: row=38, varin=18, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=40, varin=14, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=33, varin=45, theta=0.600000, up=1.000000
ITER 5: row=5, varin=49, theta=0.500000, up=1.000000
ITER 6: row=36, varin=46, theta=0.500000, up=1.000000
ITER 7: row=3, varin=35, theta=0.227764, up=999999999999999983222784.000000
ITER 8: row=30, varin=19, theta=0.319298, up=999999999999999983222784.000000
ITER 9: row=36, varin=22, theta=0.309854, up=999999999999999983222784.000000
ITER 10: row=20, varin=2, theta=0.218042, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=25)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28964469.201404
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 3.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 42 rows, 60 cols, 276 nonzeros, 5 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 6 rows, 21 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=73, theta=0.341192, up=1.000000
ITER 2: row=40, varin=66, theta=0.734791, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 29020337.792449
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 3.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 274 nonzeros, 0 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 22 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=75, theta=1.688000, up=1.000000
ITER 2: row=44, varin=78, theta=2.002492, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 3.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 296 nonzeros, 7 slack, 42 tight.
  % Node 42 LP 1 Solution, length = 999999999999999983222784.000000, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 1.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.734791 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.265209 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 42 is INFEASIBLE
 %      42    20    infeasible               28557209.5550   x18 U    39    11
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabd7f60
% @LO 0.08  28.55347084168707283425 99.9000000000
% @LN 0.08  28.55720955495148416503 99.9000000000
% Resuming node 27 at  28.55720955495148416503
DEBUG CONSTRNT: LP rows=49, pool->nlprows=49, pool->npend=0
DEBUG CONSTRNT: Checking 49 LP rows (pool tracks 49, total LP rows 49)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 85
DEBUG CONSTRNT: Pool row 85 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 73
DEBUG CONSTRNT: Pool row 73 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=48, expected 48
 % @PAP adding 48 rows, 222 nz to LP
DEBUG BB: Processing node 27, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 27 LP 5 Solution, length = 28557209.554951, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.425535 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.425535 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.141845 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.141845 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.141845 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.141845 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.141845 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.425535 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.148930 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.574465 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.858155 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.574465 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.574465 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.858155 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.574465 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.858155 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.858155 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.858155 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.858155 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.858155 (terminal 19)
 % 9 fractional variables
DEBUG CG: LP optimal, z=28557209.554951, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28557209.554951, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 3 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 27 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 27
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.425535
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.425535)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.425535
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.425535)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.141845
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.141845)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.141845
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.141845)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.141845
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.141845)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=1.000000
DEBUG CAREFUL: Skipping var 15: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.141845
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.141845)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.141845
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.141845)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.425535
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.425535)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.148930
DEBUG CAREFUL: Adding var 30 to fractional list (xi=0.148930)
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 9 fractional variables

  %  Carefully choosing branching variable, nfrac = 9
DEBUG CAREFUL: Testing fvar[0] = var 30
DEBUG CAREFUL: Calling compare_branch_vars for var 30
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 30
DEBUG CAREFUL: New best var: 30
DEBUG CAREFUL: Testing fvar[1] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 1
DEBUG CAREFUL: New best var: 1
DEBUG CAREFUL: Testing fvar[2] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 0
DEBUG CAREFUL: New best var: 0
DEBUG CAREFUL: Testing fvar[3] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 29
DEBUG CAREFUL: New best var: 29
DEBUG CAREFUL: Testing fvar[4] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[5] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 18
DEBUG CAREFUL: Testing fvar[6] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[7] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[8] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
  % Initial guess is x29, Z0 = 28557209.5549515        , Z1 = 29176926.3673997        

DEBUG EVAL: Testing var 30 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=36, varin=48, theta=0.749401, up=999999999999999983222784.000000
ITER 2: row=48, varin=45, theta=1.573583, up=999999999999999983222784.000000
ITER 3: row=40, varin=43, theta=0.685089, up=999999999999999983222784.000000
ITER 4: row=9, varin=40, theta=0.632752, up=999999999999999983222784.000000
ITER 5: row=26, varin=39, theta=0.358740, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 30 = 1 gives z=28702972.541086
  % 	x30 = 1,	Z1 = 28707336.1255542        
DEBUG EVAL: First branch cutoff check: z=28707336.125554, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 30 = 0
ITER 1: row=36, varin=71, theta=0.132359, up=1.000000
  % 	x30 = 0,	Z0 = 28557594.9636634        
DEBUG EVAL: Second branch cutoff check: z=28557594.963663, best_z=INF, threshold=INF
  %   New best:  x30, Z = 28557594.9636634        
DEBUG EVAL: Testing var 1 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=71, theta=1.021092, up=1.000000
ITER 2: row=2, varin=82, theta=0.029770, up=1.000000
ITER 3: row=36, varin=27, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=2, varin=71, theta=0.353581, up=1.000000
DEBUG EVAL: Branch var 1 = 1 gives z=28831215.478009
  % 	x1 = 1,	Z1 = 28831215.4780094        
DEBUG EVAL: First branch cutoff check: z=28831215.478009, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 0
ITER 1: row=2, varin=47, theta=0.923145, up=999999999999999983222784.000000
  % 	x1 = 0,	Z0 = 28572800.5103856        
DEBUG EVAL: Second branch cutoff check: z=28572800.510386, best_z=INF, threshold=INF
  %   New best:  x1, Z = 28572800.5103856        
DEBUG EVAL: Testing var 0 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=71, theta=1.021092, up=1.000000
ITER 2: row=1, varin=82, theta=0.029770, up=1.000000
ITER 3: row=36, varin=3, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=28, varin=4, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=37, varin=36, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=1, varin=7, theta=0.093374, up=999999999999999983222784.000000
ITER 7: row=8, varin=76, theta=0.084235, up=1.000000
ITER 8: row=3, varin=26, theta=0.040618, up=999999999999999983222784.000000
ITER 9: row=6, varin=45, theta=0.173521, up=999999999999999983222784.000000
ITER 10: row=5, varin=82, theta=0.348718, up=1.000000
DEBUG EVAL: Branch var 0 = 1 gives z=29384780.981486
  % 	x0 = 1,	Z1 = 29384780.9814861        
DEBUG EVAL: First branch cutoff check: z=29384780.981486, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 0 = 0
ITER 1: row=1, varin=47, theta=0.923145, up=999999999999999983222784.000000
  % 	x0 = 0,	Z0 = 28572800.5103856        
DEBUG EVAL: Second branch cutoff check: z=28572800.510386, best_z=INF, threshold=INF
  %   New best:  x0, Z = 28572800.5103856        
DEBUG EVAL: Testing var 29 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=35, varin=71, theta=1.021092, up=1.000000
ITER 2: row=35, varin=82, theta=0.029770, up=1.000000
ITER 3: row=36, varin=4, theta=0.500000, up=999999999999999983222784.000000
ITER 4: row=35, varin=71, theta=0.785081, up=1.000000
ITER 5: row=37, varin=27, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 29 = 1 gives z=28831215.478009
  % 	x29 = 1,	Z1 = 29176926.3673997        
DEBUG EVAL: First branch cutoff check: z=29176926.367400, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 29 = 0
ITER 1: row=35, varin=47, theta=0.923145, up=999999999999999983222784.000000
  % 	x29 = 0,	Z0 = 28572800.5103856        
DEBUG EVAL: Second branch cutoff check: z=28572800.510386, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 26 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=26, varin=47, theta=4.776040, up=999999999999999983222784.000000
ITER 2: row=1, varin=45, theta=5.024463, up=999999999999999983222784.000000
ITER 3: row=40, varin=71, theta=7.544694, up=1.000000
ITER 4: row=40, varin=6, theta=0.594150, up=999999999999999983222784.000000
ITER 5: row=36, varin=71, theta=0.686970, up=1.000000
ITER 6: row=42, varin=31, theta=0.886908, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 1 gives z=28869375.723477
  % 	x26 = 1,	Z1 = 28869375.7234771        
DEBUG EVAL: First branch cutoff check: z=28869375.723477, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 0
ITER 1: row=26, varin=71, theta=0.972871, up=1.000000
ITER 2: row=36, varin=82, theta=1.261186, up=1.000000
ITER 3: row=36, varin=19, theta=0.081890, up=999999999999999983222784.000000
ITER 4: row=26, varin=82, theta=0.847660, up=1.000000
  % 	x26 = 0,	Z0 = 28572348.0925021        
DEBUG EVAL: Second branch cutoff check: z=28572348.092502, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 18 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=11, varin=71, theta=0.972871, up=1.000000
ITER 2: row=36, varin=82, theta=1.261186, up=1.000000
ITER 3: row=36, varin=19, theta=0.081890, up=999999999999999983222784.000000
ITER 4: row=11, varin=82, theta=0.847660, up=1.000000
DEBUG EVAL: Branch var 18 = 0 gives z=28572348.092502
  % 	x18 = 0,	Z0 = 28572348.0925021        
DEBUG EVAL: First branch cutoff check: z=28572348.092502, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=71, theta=0.972871, up=1.000000
ITER 2: row=36, varin=82, theta=1.261186, up=1.000000
ITER 3: row=36, varin=19, theta=0.081890, up=999999999999999983222784.000000
ITER 4: row=6, varin=82, theta=0.847660, up=1.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28572348.092502
  % 	x10 = 0,	Z0 = 28572348.0925021        
DEBUG EVAL: First branch cutoff check: z=28572348.092502, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=71, theta=0.972871, up=1.000000
ITER 2: row=36, varin=82, theta=1.261186, up=1.000000
ITER 3: row=36, varin=19, theta=0.081890, up=999999999999999983222784.000000
ITER 4: row=3, varin=82, theta=0.847660, up=1.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28572348.092502
  % 	x2 = 0,	Z0 = 28572348.0925021        
DEBUG EVAL: First branch cutoff check: z=28572348.092502, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 3 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=5, varin=71, theta=0.972871, up=1.000000
ITER 2: row=36, varin=82, theta=1.261186, up=1.000000
ITER 3: row=36, varin=45, theta=0.030692, up=999999999999999983222784.000000
ITER 4: row=5, varin=82, theta=0.733855, up=1.000000
DEBUG EVAL: Branch var 3 = 0 gives z=28564320.632706
  % 	x3 = 0,	Z0 = 28564320.6327056        
DEBUG EVAL: First branch cutoff check: z=28564320.632706, best_z=INF, threshold=INF
  % Best branch is x0, Z0 = 28572800.5103856        , Z1 = 29384780.9814861        

DEBUG CAREFUL: Final result - returning best.var = 0
DEBUG BB: Branching variable chosen: j=0
 % @NC   55   27	x0 = 0	28572800.510386
 % @NC   56   27	x0 = 1	29384780.981486
 %      27    21 28557209.5550               28558933.7348    x9 D    13     7
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595daba2600
% @LO 0.08  28.55720955495148416503 99.9000000000
% @LN 0.08  28.55893373476142471645 99.9000000000
% Resuming node 49 at  28.55893373476142471645
DEBUG CONSTRNT: LP rows=48, pool->nlprows=48, pool->npend=0
DEBUG CONSTRNT: Checking 48 LP rows (pool tracks 48, total LP rows 48)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 150
DEBUG CONSTRNT: Pool row 150 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 85
DEBUG CONSTRNT: Pool row 85 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=47, expected 47
 % @PAP adding 39 rows, 219 nz to LP
DEBUG BB: Processing node 49, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 49 LP 2 Solution, length = 28558933.734761, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.500000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 2 fractional variables
DEBUG CG: LP optimal, z=28558933.734761, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28558933.734761, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 49 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 49
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.500000
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.500000
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 2 fractional variables

  %  Carefully choosing branching variable, nfrac = 2
DEBUG CAREFUL: Testing fvar[0] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 1
DEBUG CAREFUL: New best var: 1
DEBUG CAREFUL: Testing fvar[1] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 29
DEBUG CAREFUL: New best var: 29
  % Initial guess is x29, Z0 = 28558933.7347614        , Z1 = 28569896.0017747        

DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=64, theta=0.333333, up=1.000000
DEBUG EVAL: Branch var 1 = 0 gives z=28563524.525426
  % 	x1 = 0,	Z0 = 28563524.5254261        
DEBUG EVAL: First branch cutoff check: z=28563524.525426, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 1
ITER 1: row=1, varin=38, theta=0.470588, up=999999999999999983222784.000000
ITER 2: row=3, varin=39, theta=0.846154, up=999999999999999983222784.000000
ITER 3: row=18, varin=35, theta=0.500000, up=999999999999999983222784.000000
ITER 4: row=11, varin=30, theta=1.000000, up=999999999999999983222784.000000
  % 	x1 = 1,	Z1 = 28617867.4695228        
DEBUG EVAL: Second branch cutoff check: z=28617867.469523, best_z=INF, threshold=INF
  %   New best:  x1, Z = 28563524.5254261        
DEBUG EVAL: Testing var 29 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=17, varin=38, theta=0.470588, up=999999999999999983222784.000000
ITER 2: row=3, varin=39, theta=0.846154, up=999999999999999983222784.000000
ITER 3: row=6, varin=7, theta=0.333333, up=999999999999999983222784.000000
ITER 4: row=7, varin=25, theta=0.346154, up=999999999999999983222784.000000
ITER 5: row=11, varin=30, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 29 = 1 gives z=28617867.469523
  % 	x29 = 1,	Z1 = 28617867.4695228        
DEBUG EVAL: First branch cutoff check: z=28617867.469523, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 29 = 0
ITER 1: row=17, varin=64, theta=0.333333, up=1.000000
  % 	x29 = 0,	Z0 = 28563524.5254261        
DEBUG EVAL: Second branch cutoff check: z=28563524.525426, best_z=INF, threshold=INF
  % Best branch is x1, Z0 = 28563524.5254261        , Z1 = 28617867.4695228        

DEBUG CAREFUL: Final result - returning best.var = 1
DEBUG BB: Branching variable chosen: j=1
 % @NC   57   49	x1 = 0	28563524.525426
 % @NC   58   49	x1 = 1	28617867.469523
 %      49    22 28558933.7348               28563524.5254    x0 D    41    12
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabd7f60
% @LO 0.08  28.55893373476142471645 99.9000000000
% @LN 0.08  28.56352452542611430886 99.9000000000
% Resuming node 57 at  28.56352452542611430886
DEBUG CONSTRNT: LP rows=39, pool->nlprows=39, pool->npend=0
DEBUG CONSTRNT: Checking 39 LP rows (pool tracks 39, total LP rows 39)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 73
DEBUG CONSTRNT: Pool row 73 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 162
DEBUG CONSTRNT: Pool row 162 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=38, expected 38
 % @PAP adding 39 rows, 219 nz to LP
DEBUG BB: Processing node 57, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=64, theta=0.333333, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 28563524.525426
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 39 rows, 60 cols, 279 nonzeros, 0 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=70, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28574810.628713
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 293 nonzeros, 0 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 57 LP 1 Solution, length = 28574810.628713, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.500000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 2 fractional variables
DEBUG CG: LP optimal, z=28574810.628713, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 57 at  28.57481062871278254534
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabda810
% @LO 0.08  28.56352452542611430886 99.9000000000
% @LN 0.08  28.56916760859700232800 99.9000000000
% Resuming node 43 at  28.56916760859700232800
DEBUG CONSTRNT: LP rows=43, pool->nlprows=43, pool->npend=0
DEBUG CONSTRNT: Checking 43 LP rows (pool tracks 43, total LP rows 43)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 73
DEBUG CONSTRNT: Pool row 73 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 162
DEBUG CONSTRNT: Pool row 162 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=42, expected 42
 % @PAP adding 53 rows, 234 nz to LP
DEBUG BB: Processing node 43, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 43 LP 3 Solution, length = 28569167.608597, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.250000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.500000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.250000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.250000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.057043 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.057043 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.500000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.942957 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.750000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.942957 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.750000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 8 fractional variables
DEBUG CG: LP optimal, z=28569167.608597, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28569167.608597, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 3 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 43 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 43
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.250000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.500000
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.500000
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.250000
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.250000
DEBUG CAREFUL: Adding var 31 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.057043
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.057043)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.057043
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.057043)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.500000
DEBUG CAREFUL: Adding var 37 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 8 fractional variables

  %  Carefully choosing branching variable, nfrac = 8
DEBUG CAREFUL: Testing fvar[0] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 26
DEBUG CAREFUL: New best var: 26
DEBUG CAREFUL: Testing fvar[1] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[2] = var 37
DEBUG CAREFUL: Calling compare_branch_vars for var 37
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 37
DEBUG CAREFUL: Testing fvar[3] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[4] = var 31
DEBUG CAREFUL: Calling compare_branch_vars for var 31
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 31
DEBUG CAREFUL: Testing fvar[5] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 27
DEBUG CAREFUL: Testing fvar[6] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 36
DEBUG CAREFUL: Testing fvar[7] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 34
  % Initial guess is x26, Z0 = 28569167.608597         , Z1 = 29050496.1923355        

DEBUG EVAL: Testing var 26 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=11, varin=8, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=32, varin=19, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=23, varin=52, theta=1.038573, up=999999999999999983222784.000000
ITER 4: row=52, varin=46, theta=0.651880, up=999999999999999983222784.000000
ITER 5: row=35, varin=27, theta=0.480963, up=999999999999999983222784.000000
ITER 6: row=53, varin=38, theta=1.061398, up=999999999999999983222784.000000
ITER 7: row=38, varin=2, theta=0.539919, up=999999999999999983222784.000000
ITER 8: row=2, varin=51, theta=0.463486, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x26 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=11, varin=51, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28620425.369636
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
   % @PL 53 rows, 60 cols, 294 nonzeros, 2 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 43 at  28.62042536963604533184
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabd9c70
% @LO 0.08  28.56916760859700232800 99.9000000000
% @LN 0.08  28.57280051038558710275 99.9000000000
% Resuming node 55 at  28.57280051038558710275
DEBUG CONSTRNT: LP rows=51, pool->nlprows=51, pool->npend=0
DEBUG CONSTRNT: Checking 51 LP rows (pool tracks 51, total LP rows 51)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 105
DEBUG CONSTRNT: Pool row 105 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=50, expected 50
 % @PAP adding 48 rows, 222 nz to LP
DEBUG BB: Processing node 55, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=47, theta=0.923145, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28572800.510386
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 282 nonzeros, 1 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 15 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=75, theta=0.062971, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28574281.876047
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 297 nonzeros, 1 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 55 LP 1 Solution, length = 28574281.876047, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.312343 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.312343 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.312343 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.312343 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.062971 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.312343 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.687657 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.687657 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.687657 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.687657 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.687657 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.687657 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.687657 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28574281.876047, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.08  28.57280051038558710275 99.9000000000
 % @LN 0.08  28.57428187604694969082 99.9000000000
DEBUG CG: Second cutoff check: z=28574281.876047, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 55 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 55
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.312343
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.312343)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.312343
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.312343)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.312343
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.312343)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=1.000000
DEBUG CAREFUL: Skipping var 15: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.312343
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.312343)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.062971
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.062971)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.312343
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.312343)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 22
DEBUG CAREFUL: New best var: 22
DEBUG CAREFUL: Testing fvar[1] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 26
DEBUG CAREFUL: New best var: 26
DEBUG CAREFUL: Testing fvar[2] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 18
DEBUG CAREFUL: Testing fvar[3] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[4] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[5] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
  % Initial guess is x26, Z0 = 28574281.8760469        , Z1 = 28869375.7234771        

DEBUG EVAL: Testing var 22 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=26, varin=48, theta=1.143632, up=999999999999999983222784.000000
ITER 2: row=48, varin=47, theta=0.928390, up=999999999999999983222784.000000
ITER 3: row=47, varin=45, theta=1.949423, up=999999999999999983222784.000000
ITER 4: row=40, varin=43, theta=0.848718, up=999999999999999983222784.000000
ITER 5: row=9, varin=40, theta=0.783881, up=999999999999999983222784.000000
ITER 6: row=35, varin=39, theta=0.444422, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 22 = 1 gives z=28757587.854894
  % 	x22 = 1,	Z1 = 28757587.8548941        
DEBUG EVAL: First branch cutoff check: z=28757587.854894, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 22 = 0
ITER 1: row=26, varin=85, theta=0.088880, up=1.000000
ITER 2: row=51, varin=7, theta=0.074725, up=999999999999999983222784.000000
ITER 3: row=8, varin=79, theta=0.067410, up=1.000000
  % 	x22 = 0,	Z0 = 28580805.1642759        
DEBUG EVAL: Second branch cutoff check: z=28580805.164276, best_z=INF, threshold=INF
  %   New best:  x22, Z = 28580805.1642759        
DEBUG EVAL: Testing var 26 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=35, varin=48, theta=11.419403, up=999999999999999983222784.000000
ITER 2: row=48, varin=45, theta=3.972369, up=999999999999999983222784.000000
ITER 3: row=40, varin=6, theta=0.656515, up=999999999999999983222784.000000
ITER 4: row=42, varin=31, theta=0.886908, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 1 gives z=28869375.723477
  % 	x26 = 1,	Z1 = 28869375.7234771        
DEBUG EVAL: First branch cutoff check: z=28869375.723477, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 0
ITER 1: row=35, varin=85, theta=3.214460, up=1.000000
ITER 2: row=35, varin=7, theta=4.103939, up=999999999999999983222784.000000
ITER 3: row=9, varin=19, theta=0.666059, up=999999999999999983222784.000000
ITER 4: row=51, varin=85, theta=1.000000, up=1.000000
ITER 5: row=29, varin=40, theta=0.002467, up=999999999999999983222784.000000
ITER 6: row=26, varin=76, theta=0.011043, up=1.000000
ITER 7: row=35, varin=51, theta=0.006146, up=999999999999999983222784.000000
ITER 8: row=51, varin=48, theta=0.005621, up=999999999999999983222784.000000
ITER 9: row=48, varin=86, theta=0.013307, up=1.000000
  % 	x26 = 0,	Z0 = 28616380.7734271        
DEBUG EVAL: Second branch cutoff check: z=28616380.773427, best_z=INF, threshold=INF
  %   New best:  x26, Z = 28616380.7734271        
DEBUG EVAL: Testing var 18 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=11, varin=85, theta=3.214460, up=1.000000
ITER 2: row=11, varin=7, theta=4.103939, up=999999999999999983222784.000000
ITER 3: row=9, varin=19, theta=0.666059, up=999999999999999983222784.000000
ITER 4: row=51, varin=85, theta=1.000000, up=1.000000
ITER 5: row=29, varin=89, theta=0.017458, up=1.000000
ITER 6: row=26, varin=48, theta=0.065759, up=999999999999999983222784.000000
ITER 7: row=48, varin=76, theta=0.056018, up=1.000000
ITER 8: row=11, varin=11, theta=4546.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 18 = 0 gives z=28617457.068246
  % 	x18 = 0,	Z0 = 28617457.0682458        
DEBUG EVAL: First branch cutoff check: z=28617457.068246, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 18 = 1
ITER 1: row=11, varin=48, theta=11.419403, up=999999999999999983222784.000000
ITER 2: row=48, varin=45, theta=3.972369, up=999999999999999983222784.000000
ITER 3: row=40, varin=32, theta=2.799008, up=999999999999999983222784.000000
ITER 4: row=44, varin=30, theta=2.353996, up=999999999999999983222784.000000
ITER 5: row=6, varin=43, theta=2.773661, up=999999999999999983222784.000000
ITER 6: row=7, varin=39, theta=2.712882, up=999999999999999983222784.000000
ITER 7: row=1, varin=3, theta=1.123437, up=999999999999999983222784.000000
ITER 8: row=51, varin=25, theta=1.290000, up=999999999999999983222784.000000
ITER 9: row=32, varin=29, theta=1.908093, up=999999999999999983222784.000000
ITER 10: row=29, varin=4, theta=1.120708, up=999999999999999983222784.000000
  % 	x18 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: Second branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=11, varin=85, theta=3.214460, up=1.000000
ITER 2: row=11, varin=7, theta=4.103939, up=999999999999999983222784.000000
ITER 3: row=9, varin=19, theta=0.666059, up=999999999999999983222784.000000
ITER 4: row=51, varin=85, theta=1.000000, up=1.000000
ITER 5: row=29, varin=89, theta=0.017458, up=1.000000
ITER 6: row=26, varin=48, theta=0.065759, up=999999999999999983222784.000000
ITER 7: row=48, varin=76, theta=0.056018, up=1.000000
ITER 8: row=11, varin=11, theta=4546.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28617457.068246
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 995454.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 51 rows, 60 cols, 294 nonzeros, 4 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 4 slack rows
   % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=40, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28735864.834097
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 49 rows, 60 cols, 243 nonzeros, 1 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 5 rows, 60 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=53, varin=88, theta=0.345291, up=1.000000
ITER 2: row=49, varin=25, theta=0.333333, up=999999999999999983222784.000000
ITER 3: row=48, varin=84, theta=1.000000, up=1.000000
ITER 4: row=43, varin=76, theta=1.000000, up=1.000000
ITER 5: row=23, varin=53, theta=89538.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28769463.920872
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 53 rows, 60 cols, 301 nonzeros, 1 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 4 rows, 19 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=53, varin=24, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=56, varin=46, theta=2.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 28824997.130725
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 56 rows, 60 cols, 280 nonzeros, 4 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 4 slack rows
   % @PAP adding 3 rows, 45 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=55, varin=98, theta=0.782060, up=1.000000
ITER 2: row=53, varin=83, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 28847399.410254
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 55 rows, 60 cols, 310 nonzeros, 0 slack, 55 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=56, varin=86, theta=0.500000, up=1.000000
ITER 2: row=19, varin=29, theta=0.052632, up=999999999999999983222784.000000
ITER 3: row=39, varin=2, theta=0.250000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 28869387.895262
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 0.750000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 57 rows, 60 cols, 316 nonzeros, 1 slack, 56 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=57, varin=90, theta=0.500000, up=1.000000
ITER 2: row=56, varin=26, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=22, varin=89, theta=0.024659, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 28884431.685059
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 57 rows, 60 cols, 316 nonzeros, 3 slack, 54 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 3 slack rows
   % @PAP adding 2 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=55, varin=11, theta=0.005684, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 28886031.528434
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.994316
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 56 rows, 60 cols, 310 nonzeros, 2 slack, 54 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
   % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=55, varin=34, theta=0.009175, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 28886099.428300
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 55 rows, 60 cols, 308 nonzeros, 3 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 3 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 55 at  28.88609942829976162670
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabd7f60
% @LO 0.09  28.57428187604694969082 99.9000000000
% @LN 0.09  28.57481062871278254534 99.9000000000
% Resuming node 57 at  28.57481062871278254534
DEBUG CONSTRNT: LP rows=52, pool->nlprows=52, pool->npend=0
DEBUG CONSTRNT: Checking 52 LP rows (pool tracks 52, total LP rows 52)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 150
DEBUG CONSTRNT: Pool row 150 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 143
DEBUG CONSTRNT: Pool row 143 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=51, expected 51
 % @PAP adding 43 rows, 233 nz to LP
DEBUG BB: Processing node 57, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 57 LP 2 Solution, length = 28574810.628713, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.500000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 2 fractional variables
DEBUG CG: LP optimal, z=28574810.628713, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28574810.628713, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 57 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 57
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.500000
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.500000
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 2 fractional variables

  %  Carefully choosing branching variable, nfrac = 2
DEBUG CAREFUL: Testing fvar[0] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 26
DEBUG CAREFUL: New best var: 26
DEBUG CAREFUL: Testing fvar[1] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x26, Z0 = 28574810.6287128        , Z1 = 28649621.2574256        

DEBUG EVAL: Testing var 26 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=17, varin=40, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=9, varin=38, theta=0.470588, up=999999999999999983222784.000000
ITER 3: row=1, varin=39, theta=0.846154, up=999999999999999983222784.000000
ITER 4: row=18, varin=9, theta=0.500000, up=999999999999999983222784.000000
ITER 5: row=40, varin=35, theta=0.500000, up=999999999999999983222784.000000
ITER 6: row=35, varin=25, theta=0.346154, up=999999999999999983222784.000000
ITER 7: row=25, varin=31, theta=0.324324, up=999999999999999983222784.000000
ITER 8: row=31, varin=30, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 1 gives z=28649621.257426
  % 	x26 = 1,	Z1 = 28649621.2574256        
DEBUG EVAL: First branch cutoff check: z=28649621.257426, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 0
ITER 1: row=17, varin=55, theta=0.320000, up=1.000000
ITER 2: row=29, varin=20, theta=0.458333, up=999999999999999983222784.000000
ITER 3: row=33, varin=48, theta=0.320000, up=1.000000
ITER 4: row=26, varin=19, theta=0.068376, up=999999999999999983222784.000000
ITER 5: row=17, varin=22, theta=0.008114, up=999999999999999983222784.000000
ITER 6: row=28, varin=55, theta=0.169014, up=1.000000
  % 	x26 = 0,	Z0 = 28591111.8736127        
DEBUG EVAL: Second branch cutoff check: z=28591111.873613, best_z=INF, threshold=INF
  %   New best:  x26, Z = 28591111.8736127        
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=5, varin=55, theta=1.142857, up=1.000000
ITER 2: row=5, varin=39, theta=0.091667, up=999999999999999983222784.000000
ITER 3: row=17, varin=55, theta=0.519313, up=1.000000
ITER 4: row=29, varin=70, theta=0.933333, up=1.000000
ITER 5: row=18, varin=40, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=9, varin=48, theta=1.142857, up=1.000000
ITER 7: row=9, varin=22, theta=0.024390, up=999999999999999983222784.000000
ITER 8: row=29, varin=30, theta=0.519231, up=999999999999999983222784.000000
ITER 9: row=26, varin=19, theta=0.200000, up=999999999999999983222784.000000
ITER 10: row=17, varin=48, theta=0.539474, up=1.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28647021.432421
  % 	x10 = 1,	Z1 = 28647021.4324206        
DEBUG EVAL: First branch cutoff check: z=28647021.432421, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=5, varin=24, theta=2.750000, up=999999999999999983222784.000000
  % 	x10 = 0,	Z0 = 28583554.4538312        
DEBUG EVAL: Second branch cutoff check: z=28583554.453831, best_z=INF, threshold=INF
  % Best branch is x26, Z0 = 28591111.8736127        , Z1 = 28649621.2574256        

DEBUG CAREFUL: Final result - returning best.var = 26
DEBUG BB: Branching variable chosen: j=26
 % @NC   59   57	x26 = 0	28591111.873613
 % @NC   60   57	x26 = 1	28649621.257426
 %      57    23 28574810.6287               28576200.9743    x1 D    49    13
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabbe180
% @LO 0.09  28.57481062871278254534 99.9000000000
% @LN 0.09  28.57620097427440342130 99.9000000000
% Resuming node 33 at  28.57620097427440342130
DEBUG CONSTRNT: LP rows=43, pool->nlprows=43, pool->npend=0
DEBUG CONSTRNT: Checking 43 LP rows (pool tracks 43, total LP rows 43)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 73
DEBUG CONSTRNT: Pool row 73 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 162
DEBUG CONSTRNT: Pool row 162 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=42, expected 42
 % @PAP adding 47 rows, 220 nz to LP
DEBUG BB: Processing node 33, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 33 LP 3 Solution, length = 28576200.974274, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.500000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.500000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.726722 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.273278 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28576200.974274, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28576200.974274, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 33 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 33
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.500000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=1.000000
DEBUG CAREFUL: Skipping var 13: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.500000
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.500000
DEBUG CAREFUL: Adding var 31 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.726722
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.726722)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 2
DEBUG CAREFUL: New best var: 2
DEBUG CAREFUL: Testing fvar[1] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 27
DEBUG CAREFUL: Testing fvar[2] = var 31
DEBUG CAREFUL: Calling compare_branch_vars for var 31
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 31
DEBUG CAREFUL: Testing fvar[3] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 36
  % Initial guess is x2, Z0 = 28576200.9742744        , Z1 = 28616039.9816704        

DEBUG EVAL: Testing var 2 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=39, theta=0.166667, up=999999999999999983222784.000000
ITER 2: row=32, varin=44, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 1 gives z=28702426.952014
  % 	x2 = 1,	Z1 = 28702426.9520138        
DEBUG EVAL: First branch cutoff check: z=28702426.952014, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 0
ITER 1: row=2, varin=86, theta=1.000000, up=1.000000
  % 	x2 = 0,	Z0 = 28587557.2147364        
DEBUG EVAL: Second branch cutoff check: z=28587557.214736, best_z=INF, threshold=INF
  %   New best:  x2, Z = 28587557.2147364        
DEBUG EVAL: Testing var 27 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=86, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 27 = 0 gives z=28587557.214736
  % 	x27 = 0,	Z0 = 28587557.2147364        
DEBUG EVAL: First branch cutoff check: z=28587557.214736, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 27 = 1
ITER 1: row=6, varin=39, theta=0.166667, up=999999999999999983222784.000000
ITER 2: row=32, varin=44, theta=1.000000, up=999999999999999983222784.000000
  % 	x27 = 1,	Z1 = 28702426.9520138        
DEBUG EVAL: Second branch cutoff check: z=28702426.952014, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 31 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=42, varin=86, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 31 = 0 gives z=28587557.214736
  % 	x31 = 0,	Z0 = 28587557.2147364        
DEBUG EVAL: First branch cutoff check: z=28587557.214736, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 31 = 1
ITER 1: row=42, varin=39, theta=0.166667, up=999999999999999983222784.000000
ITER 2: row=32, varin=45, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=44, varin=31, theta=1.250000, up=999999999999999983222784.000000
ITER 4: row=31, varin=43, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=43, varin=42, theta=1.000000, up=999999999999999983222784.000000
  % 	x31 = 1,	Z1 = 28809927.1056912        
DEBUG EVAL: Second branch cutoff check: z=28809927.105691, best_z=INF, threshold=INF
  %   New best:  x31, Z = 28587557.2147364        
DEBUG EVAL: Testing var 36 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=16, varin=39, theta=0.080247, up=999999999999999983222784.000000
ITER 2: row=32, varin=35, theta=1.345345, up=999999999999999983222784.000000
ITER 3: row=35, varin=2, theta=1.069242, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 36 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x36 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=16, varin=65, theta=0.403745, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28588064.114929
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 47 rows, 60 cols, 280 nonzeros, 0 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=47, theta=32818.333333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28599182.612457
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 48 rows, 60 cols, 282 nonzeros, 1 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 33 at  28.59918261245656623259
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabd86b0
% @LO 0.09  28.57620097427440342130 99.9000000000
% @LN 0.09  28.58440911784623494896 99.9000000000
% Resuming node 48 at  28.58440911784623494896
DEBUG CONSTRNT: LP rows=47, pool->nlprows=47, pool->npend=0
DEBUG CONSTRNT: Checking 47 LP rows (pool tracks 47, total LP rows 47)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=46, expected 46
 % @PAP adding 47 rows, 173 nz to LP
DEBUG BB: Processing node 48, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=22, varin=45, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=34, varin=42, theta=1.500000, up=999999999999999983222784.000000
ITER 3: row=42, varin=41, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28584409.117846
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 233 nonzeros, 7 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 54 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=78, theta=3.245346, up=1.000000
ITER 2: row=51, varin=76, theta=3.318849, up=1.000000
ITER 3: row=51, varin=73, theta=1.315867, up=1.000000
ITER 4: row=51, varin=74, theta=0.324848, up=1.000000
ITER 5: row=1, varin=3, theta=2.180685, up=999999999999999983222784.000000
ITER 6: row=3, varin=26, theta=2.233067, up=999999999999999983222784.000000
ITER 7: row=33, varin=76, theta=7.984728, up=1.000000
ITER 8: row=33, varin=25, theta=2.815401, up=999999999999999983222784.000000
ITER 9: row=25, varin=34, theta=2.188823, up=999999999999999983222784.000000
ITER 10: row=51, varin=77, theta=1.822297, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 287 nonzeros, 14 slack, 37 tight.
  % Node 48 LP 1 Solution, length = 999999999999999983222784.000000, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 1.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 1.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 48 is INFEASIBLE
 %      48    22    infeasible               28591111.8736   x17 U    25     9
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595daba2600
% @LO 0.09  28.58440911784623494896 99.9000000000
% @LN 0.09  28.59111187361274630803 99.9000000000
% Resuming node 59 at  28.59111187361274630803
DEBUG CONSTRNT: LP rows=51, pool->nlprows=51, pool->npend=0
DEBUG CONSTRNT: Checking 51 LP rows (pool tracks 51, total LP rows 51)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 60
DEBUG CONSTRNT: Pool row 60 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 73
DEBUG CONSTRNT: Pool row 73 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=50, expected 50
 % @PAP adding 43 rows, 233 nz to LP
DEBUG BB: Processing node 59, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=17, varin=55, theta=0.320000, up=1.000000
ITER 2: row=29, varin=20, theta=0.458333, up=999999999999999983222784.000000
ITER 3: row=33, varin=48, theta=0.320000, up=1.000000
ITER 4: row=26, varin=19, theta=0.068376, up=999999999999999983222784.000000
ITER 5: row=17, varin=22, theta=0.008114, up=999999999999999983222784.000000
ITER 6: row=28, varin=55, theta=0.169014, up=1.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28591111.873613
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 293 nonzeros, 2 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=24, theta=5.500000, up=999999999999999983222784.000000
ITER 2: row=6, varin=29, theta=0.113960, up=999999999999999983222784.000000
ITER 3: row=45, varin=27, theta=0.687500, up=999999999999999983222784.000000
ITER 4: row=44, varin=26, theta=0.250000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28611926.004091
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 301 nonzeros, 8 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 8 slack rows
  % @PAP adding 3 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=53, theta=0.016129, up=1.000000
ITER 2: row=40, varin=42, theta=0.428571, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28614729.964825
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 264 nonzeros, 1 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 59 LP 1 Solution, length = 28614729.964825, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.071429 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.071429 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.071429 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.071429 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.071429 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.214286 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.214286 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.214286 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.785714 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.928571 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.928571 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.785714 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.785714 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.928571 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.928571 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.928571 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.928571 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.785714 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.785714 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.928571 (terminal 19)
 % 8 fractional variables
DEBUG CG: LP optimal, z=28614729.964825, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 59 at  28.61472996482547515029
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabbe180
% @LO 0.09  28.59111187361274630803 99.9000000000
% @LN 0.09  28.59918261245656623259 99.9000000000
% Resuming node 33 at  28.59918261245656623259
DEBUG CONSTRNT: LP rows=41, pool->nlprows=41, pool->npend=0
DEBUG CONSTRNT: Checking 41 LP rows (pool tracks 41, total LP rows 41)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 162
DEBUG CONSTRNT: Pool row 162 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=40, expected 40
 % @PAP adding 47 rows, 182 nz to LP
DEBUG BB: Processing node 33, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 33 LP 4 Solution, length = 28599182.612457, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.333333 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.333333 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.333333 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.333333 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.333333 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.666667 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.666667 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.666667 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.666667 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.666667 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28599182.612457, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28599182.612457, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 33 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 33
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.333333
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=1.000000
DEBUG CAREFUL: Skipping var 13: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.333333
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.333333
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.333333
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.333333
DEBUG CAREFUL: Adding var 31 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 2
DEBUG CAREFUL: New best var: 2
DEBUG CAREFUL: Testing fvar[1] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[2] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 22
DEBUG CAREFUL: Testing fvar[3] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 27
DEBUG CAREFUL: Testing fvar[4] = var 31
DEBUG CAREFUL: Calling compare_branch_vars for var 31
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 31
DEBUG CAREFUL: New best var: 31
  % Initial guess is x31, Z0 = 28599182.6124566        , Z1 = 28809927.1056912        

DEBUG EVAL: Testing var 2 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=39, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=32, varin=44, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=42, varin=45, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=44, varin=47, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 1 gives z=28741862.130184
  % 	x2 = 1,	Z1 = 28741862.1301835        
DEBUG EVAL: First branch cutoff check: z=28741862.130184, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 0
ITER 1: row=2, varin=37, theta=0.250000, up=999999999999999983222784.000000
  % 	x2 = 0,	Z0 = 28602413.4397242        
DEBUG EVAL: Second branch cutoff check: z=28602413.439724, best_z=INF, threshold=INF
  %   New best:  x2, Z = 28602413.4397242        
DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=4, varin=39, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=32, varin=44, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=42, varin=45, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=44, varin=43, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=43, varin=42, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 1 gives z=28750684.259952
  % 	x17 = 1,	Z1 = 28750684.2599523        
DEBUG EVAL: First branch cutoff check: z=28750684.259952, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 0
ITER 1: row=4, varin=37, theta=0.250000, up=999999999999999983222784.000000
  % 	x17 = 0,	Z0 = 28602413.4397242        
DEBUG EVAL: Second branch cutoff check: z=28602413.439724, best_z=INF, threshold=INF
  %   New best:  x17, Z = 28602413.4397242        
DEBUG EVAL: Testing var 22 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=20, varin=37, theta=0.250000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 22 = 0 gives z=28602413.439724
  % 	x22 = 0,	Z0 = 28602413.4397242        
DEBUG EVAL: First branch cutoff check: z=28602413.439724, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 22 = 1
ITER 1: row=20, varin=39, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=32, varin=44, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=42, varin=45, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=44, varin=43, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=43, varin=42, theta=1.000000, up=999999999999999983222784.000000
  % 	x22 = 1,	Z1 = 28750684.2599523        
DEBUG EVAL: Second branch cutoff check: z=28750684.259952, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 27 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=34, varin=39, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=32, varin=44, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=42, varin=45, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=44, varin=47, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 27 = 1 gives z=28741862.130184
  % 	x27 = 1,	Z1 = 28741862.1301835        
DEBUG EVAL: First branch cutoff check: z=28741862.130184, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 27 = 0
ITER 1: row=34, varin=37, theta=0.250000, up=999999999999999983222784.000000
  % 	x27 = 0,	Z0 = 28602413.4397242        
DEBUG EVAL: Second branch cutoff check: z=28602413.439724, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 31 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=42, varin=39, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=32, varin=45, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=44, varin=47, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=4, varin=43, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=43, varin=42, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 31 = 1 gives z=28818547.561140
  % 	x31 = 1,	Z1 = 28818547.5611399        
DEBUG EVAL: First branch cutoff check: z=28818547.561140, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 31 = 0
ITER 1: row=42, varin=37, theta=0.250000, up=999999999999999983222784.000000
  % 	x31 = 0,	Z0 = 28602413.4397242        
DEBUG EVAL: Second branch cutoff check: z=28602413.439724, best_z=INF, threshold=INF
  %   New best:  x31, Z = 28602413.4397242        
  % Best branch is x31, Z0 = 28602413.4397242        , Z1 = 28818547.5611399        

DEBUG CAREFUL: Final result - returning best.var = 31
DEBUG BB: Branching variable chosen: j=31
 % @NC   61   33	x31 = 0	28602413.439724
 % @NC   62   33	x31 = 1	28818547.561140
 %      33    23 28599182.6125               28602413.4397   x25 D    31     6
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabd86b0
% @LO 0.09  28.59918261245656623259 99.9000000000
% @LN 0.09  28.60241343972415961616 99.9000000000
% Resuming node 61 at  28.60241343972415961616
DEBUG CONSTRNT: LP rows=47, pool->nlprows=47, pool->npend=0
DEBUG CONSTRNT: Checking 47 LP rows (pool tracks 47, total LP rows 47)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=46, expected 46
 % @PAP adding 47 rows, 182 nz to LP
DEBUG BB: Processing node 61, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=37, theta=0.250000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28602413.439724
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.500000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 242 nonzeros, 5 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 10 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=44, theta=0.250000, up=999999999999999983222784.000000
ITER 2: row=48, varin=50, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28617886.666591
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 252 nonzeros, 3 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 1 rows, 40 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=88, theta=0.400716, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28627378.546285
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 284 nonzeros, 0 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=91, theta=0.110660, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28633832.540971
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 288 nonzeros, 0 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 61 LP 1 Solution, length = 28633832.540971, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.296447 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.296447 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.296447 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.296447 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.296447 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.110660 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.703553 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.703553 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.703553 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.703553 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.703553 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28633832.540971, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 61 at  28.63383254097103858271
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabbca20
% @LO 0.09  28.60241343972415961616 99.9000000000
% @LN 0.09  28.60310068730203880705 99.9000000000
% Resuming node 38 at  28.60310068730203880705
DEBUG CONSTRNT: LP rows=51, pool->nlprows=51, pool->npend=0
DEBUG CONSTRNT: Checking 51 LP rows (pool tracks 51, total LP rows 51)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 105
DEBUG CONSTRNT: Pool row 105 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 130
DEBUG CONSTRNT: Pool row 130 has lprow=50, expected 50
 % @PAP adding 50 rows, 223 nz to LP
DEBUG BB: Processing node 38, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 38 LP 3 Solution, length = 28603100.687302, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.407019 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.407019 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.084712 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.084712 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.084712 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.084712 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.084712 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 1.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.084712 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.084712 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.407019 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.592981 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.915288 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.592981 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.592981 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.915288 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.592981 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.915288 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.915288 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.915288 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.915288 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.915288 (terminal 19)
 % 10 fractional variables
DEBUG CG: LP optimal, z=28603100.687302, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28603100.687302, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 3 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 38 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 38
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.407019
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.407019)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.407019
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.407019)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.084712
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.084712)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.084712
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.084712)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.084712
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.084712)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.084712
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.084712)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.084712
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.084712)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=1.000000
DEBUG CAREFUL: Skipping var 14: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.084712
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.084712)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.084712
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.084712)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.407019
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.407019)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 10 fractional variables

  %  Carefully choosing branching variable, nfrac = 10
DEBUG CAREFUL: Testing fvar[0] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 1
DEBUG CAREFUL: New best var: 1
DEBUG CAREFUL: Testing fvar[1] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
DEBUG CAREFUL: Testing fvar[2] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 29
DEBUG CAREFUL: Testing fvar[3] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[4] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 18
DEBUG CAREFUL: Testing fvar[5] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[6] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 4
DEBUG CAREFUL: Testing fvar[7] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 11
DEBUG CAREFUL: Testing fvar[8] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[9] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
  % Initial guess is x3, Z0 = 28603100.687302         , Z1 = 29312818.2315157        

DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=49, theta=0.356567, up=999999999999999983222784.000000
ITER 2: row=7, varin=47, theta=0.304605, up=999999999999999983222784.000000
ITER 3: row=11, varin=43, theta=0.043675, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 0 gives z=28610632.581682
  % 	x1 = 0,	Z0 = 28610632.5816821        
DEBUG EVAL: First branch cutoff check: z=28610632.581682, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 1
ITER 1: row=2, varin=72, theta=0.408250, up=1.000000
ITER 2: row=12, varin=47, theta=0.196269, up=999999999999999983222784.000000
ITER 3: row=11, varin=6, theta=0.086318, up=999999999999999983222784.000000
ITER 4: row=3, varin=20, theta=0.494991, up=999999999999999983222784.000000
ITER 5: row=50, varin=40, theta=0.328101, up=999999999999999983222784.000000
ITER 6: row=35, varin=23, theta=0.141762, up=999999999999999983222784.000000
ITER 7: row=41, varin=49, theta=0.834809, up=999999999999999983222784.000000
ITER 8: row=9, varin=30, theta=0.491631, up=999999999999999983222784.000000
  % 	x1 = 1,	Z1 = 28746384.5676527        
DEBUG EVAL: Second branch cutoff check: z=28746384.567653, best_z=INF, threshold=INF
  %   New best:  x1, Z = 28610632.5816821        
DEBUG EVAL: Testing var 0 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=49, theta=0.356567, up=999999999999999983222784.000000
ITER 2: row=7, varin=47, theta=0.304605, up=999999999999999983222784.000000
ITER 3: row=11, varin=43, theta=0.043675, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 0 = 0 gives z=28610632.581682
  % 	x0 = 0,	Z0 = 28610632.5816821        
DEBUG EVAL: First branch cutoff check: z=28610632.581682, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 0 = 1
ITER 1: row=1, varin=72, theta=0.408250, up=1.000000
ITER 2: row=12, varin=47, theta=0.196269, up=999999999999999983222784.000000
ITER 3: row=11, varin=6, theta=0.086318, up=999999999999999983222784.000000
ITER 4: row=3, varin=20, theta=0.494991, up=999999999999999983222784.000000
ITER 5: row=50, varin=40, theta=0.328101, up=999999999999999983222784.000000
ITER 6: row=35, varin=23, theta=0.141762, up=999999999999999983222784.000000
ITER 7: row=41, varin=49, theta=0.834809, up=999999999999999983222784.000000
ITER 8: row=9, varin=3, theta=0.546105, up=999999999999999983222784.000000
ITER 9: row=31, varin=27, theta=0.147419, up=999999999999999983222784.000000
ITER 10: row=6, varin=7, theta=0.835660, up=999999999999999983222784.000000
  % 	x0 = 1,	Z1 = 29103580.957774         
DEBUG EVAL: Second branch cutoff check: z=29103580.957774, best_z=INF, threshold=INF
  %   New best:  x0, Z = 28610632.5816821        
DEBUG EVAL: Testing var 29 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=36, varin=49, theta=0.356567, up=999999999999999983222784.000000
ITER 2: row=7, varin=47, theta=0.304605, up=999999999999999983222784.000000
ITER 3: row=11, varin=43, theta=0.043675, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 29 = 0 gives z=28610632.581682
  % 	x29 = 0,	Z0 = 28610632.5816821        
DEBUG EVAL: First branch cutoff check: z=28610632.581682, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 29 = 1
ITER 1: row=36, varin=72, theta=0.408250, up=1.000000
ITER 2: row=12, varin=47, theta=0.196269, up=999999999999999983222784.000000
ITER 3: row=11, varin=6, theta=0.086318, up=999999999999999983222784.000000
ITER 4: row=3, varin=20, theta=0.494991, up=999999999999999983222784.000000
ITER 5: row=50, varin=40, theta=0.328101, up=999999999999999983222784.000000
ITER 6: row=35, varin=4, theta=0.282403, up=999999999999999983222784.000000
ITER 7: row=37, varin=23, theta=0.141762, up=999999999999999983222784.000000
ITER 8: row=6, varin=49, theta=0.834809, up=999999999999999983222784.000000
ITER 9: row=7, varin=28, theta=0.206026, up=999999999999999983222784.000000
ITER 10: row=23, varin=30, theta=0.491631, up=999999999999999983222784.000000
  % 	x29 = 1,	Z1 = 28746384.5676527        
DEBUG EVAL: Second branch cutoff check: z=28746384.567653, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=5, varin=49, theta=2.991844, up=999999999999999983222784.000000
ITER 2: row=1, varin=46, theta=0.898182, up=999999999999999983222784.000000
ITER 3: row=7, varin=51, theta=0.771841, up=1.000000
ITER 4: row=3, varin=47, theta=0.242371, up=999999999999999983222784.000000
ITER 5: row=11, varin=43, theta=0.312535, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 1 gives z=28653848.932217
  % 	x3 = 1,	Z1 = 29312818.2315157        
DEBUG EVAL: First branch cutoff check: z=29312818.231516, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=5, varin=47, theta=0.222609, up=999999999999999983222784.000000
  % 	x3 = 0,	Z0 = 28607383.7102226        
DEBUG EVAL: Second branch cutoff check: z=28607383.710223, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 18 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=23, varin=46, theta=0.448128, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 18 = 0 gives z=28617787.692522
  % 	x18 = 0,	Z0 = 28617787.6925225        
DEBUG EVAL: First branch cutoff check: z=28617787.692522, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 18 = 1
ITER 1: row=23, varin=49, theta=2.991844, up=999999999999999983222784.000000
  % 	x18 = 1,	Z1 = 28610339.2811093        
DEBUG EVAL: Second branch cutoff check: z=28610339.281109, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=16, theta=0.099357, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28616317.533048
  % 	x10 = 0,	Z0 = 28616317.5330479        
DEBUG EVAL: First branch cutoff check: z=28616317.533048, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 1
ITER 1: row=6, varin=49, theta=2.991844, up=999999999999999983222784.000000
  % 	x10 = 1,	Z1 = 28610339.2811093        
DEBUG EVAL: Second branch cutoff check: z=28610339.281109, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 4 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=11, varin=49, theta=2.991844, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 4 = 1 gives z=28610339.281109
  % 	x4 = 1,	Z1 = 28901535.7863583        
DEBUG EVAL: First branch cutoff check: z=28901535.786358, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 4 = 0
ITER 1: row=11, varin=47, theta=0.222609, up=999999999999999983222784.000000
  % 	x4 = 0,	Z0 = 28607383.7102225        
DEBUG EVAL: Second branch cutoff check: z=28607383.710223, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 11 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=35, varin=49, theta=2.991844, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 11 = 1 gives z=28610339.281109
  % 	x11 = 1,	Z1 = 28866873.0587519        
DEBUG EVAL: First branch cutoff check: z=28866873.058752, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 11 = 0
ITER 1: row=35, varin=40, theta=0.151956, up=999999999999999983222784.000000
  % 	x11 = 0,	Z0 = 28615694.7562693        
DEBUG EVAL: Second branch cutoff check: z=28615694.756269, best_z=INF, threshold=INF
  %   New best:  x11, Z = 28615694.7562693        
DEBUG EVAL: Testing var 26 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=40, varin=49, theta=2.991844, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 1 gives z=28610339.281109
  % 	x26 = 1,	Z1 = 28637090.4988578        
DEBUG EVAL: First branch cutoff check: z=28637090.498858, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 0
ITER 1: row=40, varin=43, theta=0.127155, up=999999999999999983222784.000000
  % 	x26 = 0,	Z0 = 28610413.489882         
DEBUG EVAL: Second branch cutoff check: z=28610413.489882, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=39, theta=0.112594, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28611739.900589
  % 	x2 = 0,	Z0 = 28611739.900589         
DEBUG EVAL: First branch cutoff check: z=28611739.900589, best_z=INF, threshold=INF
  % Best branch is x11, Z0 = 28615694.7562693        , Z1 = 28866873.0587519        

DEBUG CAREFUL: Final result - returning best.var = 11
DEBUG BB: Branching variable chosen: j=11
 % @NC   63   38	x11 = 0	28615694.756269
 % @NC   64   38	x11 = 1	28866873.058752
 %      38    24 28603100.6873               28614729.9648   x14 U    30     9
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595daba2600
% @LO 0.09  28.60310068730203880705 99.9000000000
% @LN 0.09  28.61472996482547515029 99.9000000000
% Resuming node 59 at  28.61472996482547515029
DEBUG CONSTRNT: LP rows=50, pool->nlprows=50, pool->npend=0
DEBUG CONSTRNT: Checking 50 LP rows (pool tracks 50, total LP rows 50)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 85
DEBUG CONSTRNT: Pool row 85 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=49, expected 49
 % @PAP adding 41 rows, 194 nz to LP
DEBUG BB: Processing node 59, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 59 LP 2 Solution, length = 28614729.964825, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.071429 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.071429 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.071429 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.071429 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.071429 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.214286 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.214286 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.214286 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.785714 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.928571 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.928571 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.785714 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.785714 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.928571 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.928571 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.928571 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.928571 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.785714 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.785714 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.928571 (terminal 19)
 % 8 fractional variables
DEBUG CG: LP optimal, z=28614729.964825, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28614729.964825, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 59 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 59
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.071429
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.071429)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.071429
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.071429)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.071429
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.071429)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.071429
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.071429)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.071429
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.071429)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.214286
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.214286)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.214286
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.214286)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.214286
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.214286)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 8 fractional variables

  %  Carefully choosing branching variable, nfrac = 8
DEBUG CAREFUL: Testing fvar[0] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 2
DEBUG CAREFUL: New best var: 2
DEBUG CAREFUL: Testing fvar[1] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[2] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 4
DEBUG CAREFUL: New best var: 4
DEBUG CAREFUL: Testing fvar[3] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 11
DEBUG CAREFUL: Testing fvar[4] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 36
DEBUG CAREFUL: Testing fvar[5] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 34
DEBUG CAREFUL: Testing fvar[6] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
DEBUG CAREFUL: Testing fvar[7] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x4, Z0 = 28614729.9648255        , Z1 = 28901535.7863583        

DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=75, theta=0.250000, up=1.000000
ITER 2: row=35, varin=36, theta=0.125000, up=999999999999999983222784.000000
ITER 3: row=38, varin=72, theta=0.250000, up=1.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28616210.681784
  % 	x2 = 0,	Z0 = 28616210.6817835        
DEBUG EVAL: First branch cutoff check: z=28616210.681784, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 1
ITER 1: row=1, varin=37, theta=1.000000, up=999999999999999983222784.000000
  % 	x2 = 1,	Z1 = 28756773.056953         
DEBUG EVAL: Second branch cutoff check: z=28756773.056953, best_z=INF, threshold=INF
  %   New best:  x2, Z = 28616210.6817835        
DEBUG EVAL: Testing var 3 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=5, varin=75, theta=0.250000, up=1.000000
ITER 2: row=35, varin=72, theta=0.250000, up=1.000000
DEBUG EVAL: Branch var 3 = 0 gives z=28616210.681784
  % 	x3 = 0,	Z0 = 28616210.6817835        
DEBUG EVAL: First branch cutoff check: z=28616210.681784, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 1
ITER 1: row=5, varin=36, theta=2.166667, up=999999999999999983222784.000000
ITER 2: row=38, varin=39, theta=1.000000, up=999999999999999983222784.000000
  % 	x3 = 1,	Z1 = 28836541.5565605        
DEBUG EVAL: Second branch cutoff check: z=28836541.556560, best_z=INF, threshold=INF
  %   New best:  x3, Z = 28616210.6817835        
DEBUG EVAL: Testing var 4 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=22, varin=40, theta=6.500000, up=999999999999999983222784.000000
ITER 2: row=6, varin=27, theta=3.250000, up=999999999999999983222784.000000
ITER 3: row=26, varin=22, theta=1.181818, up=999999999999999983222784.000000
ITER 4: row=15, varin=52, theta=1.200000, up=1.000000
ITER 5: row=15, varin=20, theta=0.166667, up=999999999999999983222784.000000
ITER 6: row=22, varin=52, theta=1.000000, up=1.000000
ITER 7: row=17, varin=34, theta=1.500000, up=999999999999999983222784.000000
ITER 8: row=7, varin=24, theta=2.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 4 = 1 gives z=29168775.763443
  % 	x4 = 1,	Z1 = 29168775.763443         
DEBUG EVAL: First branch cutoff check: z=29168775.763443, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 4 = 0
ITER 1: row=22, varin=75, theta=0.250000, up=1.000000
ITER 2: row=35, varin=36, theta=0.125000, up=999999999999999983222784.000000
ITER 3: row=38, varin=72, theta=0.250000, up=1.000000
  % 	x4 = 0,	Z0 = 28616210.6817835        
DEBUG EVAL: Second branch cutoff check: z=28616210.681784, best_z=INF, threshold=INF
  %   New best:  x4, Z = 28616210.6817835        
DEBUG EVAL: Testing var 11 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=36, varin=36, theta=2.166667, up=999999999999999983222784.000000
ITER 2: row=38, varin=40, theta=6.500000, up=999999999999999983222784.000000
ITER 3: row=6, varin=23, theta=3.250000, up=999999999999999983222784.000000
ITER 4: row=36, varin=37, theta=1.181818, up=999999999999999983222784.000000
ITER 5: row=16, varin=27, theta=6.000000, up=999999999999999983222784.000000
ITER 6: row=26, varin=52, theta=1.200000, up=1.000000
ITER 7: row=26, varin=20, theta=0.166667, up=999999999999999983222784.000000
ITER 8: row=41, varin=52, theta=1.000000, up=1.000000
ITER 9: row=18, varin=34, theta=1.500000, up=999999999999999983222784.000000
ITER 10: row=7, varin=24, theta=2.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 11 = 1 gives z=29144049.082165
  % 	x11 = 1,	Z1 = 29144049.0821647        
DEBUG EVAL: First branch cutoff check: z=29144049.082165, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 11 = 0
ITER 1: row=36, varin=75, theta=0.250000, up=1.000000
ITER 2: row=35, varin=72, theta=0.250000, up=1.000000
  % 	x11 = 0,	Z0 = 28616210.6817835        
DEBUG EVAL: Second branch cutoff check: z=28616210.681784, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 36 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=15, varin=9, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 36 = 0 gives z=28619275.339140
  % 	x36 = 0,	Z0 = 28619275.33914          
DEBUG EVAL: First branch cutoff check: z=28619275.339140, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 36 = 1
ITER 1: row=15, varin=75, theta=5.500000, up=1.000000
ITER 2: row=15, varin=36, theta=2.250000, up=999999999999999983222784.000000
ITER 3: row=38, varin=72, theta=4.500000, up=1.000000
ITER 4: row=38, varin=63, theta=3.500000, up=1.000000
ITER 5: row=38, varin=79, theta=2.500000, up=1.000000
ITER 6: row=38, varin=20, theta=0.500000, up=999999999999999983222784.000000
ITER 7: row=23, varin=79, theta=3.000000, up=1.000000
ITER 8: row=23, varin=63, theta=2.000000, up=1.000000
ITER 9: row=23, varin=72, theta=1.000000, up=1.000000
ITER 10: row=35, varin=75, theta=1.000000, up=1.000000
  % 	x36 = 1,	Z1 = 28846275.2946485        
DEBUG EVAL: Second branch cutoff check: z=28846275.294649, best_z=INF, threshold=INF
  %   New best:  x36, Z = 28619275.33914          
DEBUG EVAL: Testing var 34 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=20, varin=9, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 34 = 0 gives z=28619275.339140
  % 	x34 = 0,	Z0 = 28619275.33914          
DEBUG EVAL: First branch cutoff check: z=28619275.339140, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 34 = 1
ITER 1: row=20, varin=75, theta=5.500000, up=1.000000
ITER 2: row=20, varin=36, theta=2.250000, up=999999999999999983222784.000000
ITER 3: row=38, varin=72, theta=4.500000, up=1.000000
ITER 4: row=38, varin=63, theta=3.500000, up=1.000000
ITER 5: row=38, varin=79, theta=2.500000, up=1.000000
ITER 6: row=38, varin=33, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=23, varin=79, theta=3.000000, up=1.000000
ITER 8: row=23, varin=63, theta=2.000000, up=1.000000
ITER 9: row=23, varin=72, theta=1.000000, up=1.000000
ITER 10: row=17, varin=24, theta=2.000000, up=999999999999999983222784.000000
  % 	x34 = 1,	Z1 = 28922167.0077395        
DEBUG EVAL: Second branch cutoff check: z=28922167.007739, best_z=INF, threshold=INF
  %   New best:  x34, Z = 28619275.33914          
DEBUG EVAL: Testing var 12 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=17, varin=9, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 12 = 0 gives z=28619275.339140
  % 	x12 = 0,	Z0 = 28619275.33914          
DEBUG EVAL: First branch cutoff check: z=28619275.339140, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 1
ITER 1: row=17, varin=75, theta=5.500000, up=1.000000
ITER 2: row=17, varin=36, theta=2.250000, up=999999999999999983222784.000000
ITER 3: row=38, varin=72, theta=4.500000, up=1.000000
ITER 4: row=38, varin=63, theta=3.500000, up=1.000000
ITER 5: row=38, varin=79, theta=2.500000, up=1.000000
ITER 6: row=38, varin=64, theta=1.500000, up=1.000000
ITER 7: row=38, varin=67, theta=0.500000, up=1.000000
ITER 8: row=1, varin=24, theta=3.000000, up=999999999999999983222784.000000
ITER 9: row=38, varin=64, theta=4.000000, up=1.000000
ITER 10: row=38, varin=79, theta=3.000000, up=1.000000
  % 	x12 = 1,	Z1 = 28964842.727134         
DEBUG EVAL: Second branch cutoff check: z=28964842.727134, best_z=INF, threshold=INF
  %   New best:  x12, Z = 28619275.33914          
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=40, theta=0.812500, up=999999999999999983222784.000000
ITER 2: row=15, varin=20, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=17, varin=24, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28763107.458465
  % 	x10 = 1,	Z1 = 28763107.4584648        
DEBUG EVAL: First branch cutoff check: z=28763107.458465, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=6, varin=75, theta=0.250000, up=1.000000
  % 	x10 = 0,	Z0 = 28614993.3219746        
DEBUG EVAL: Second branch cutoff check: z=28614993.321975, best_z=INF, threshold=INF
  % Best branch is x12, Z0 = 28619275.33914          , Z1 = 28964842.727134         

DEBUG CAREFUL: Final result - returning best.var = 12
DEBUG BB: Branching variable chosen: j=12
 % @NC   65   59	x12 = 0	28619275.339140
 % @NC   66   59	x12 = 1	28964842.727134
 %      59    25 28614729.9648               28615694.7563   x26 D    57    14
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabbe180
% @LO 0.09  28.61472996482547515029 99.9000000000
% @LN 0.09  28.61569475626928493739 99.9000000000
% Resuming node 63 at  28.61569475626928493739
DEBUG CONSTRNT: LP rows=41, pool->nlprows=41, pool->npend=0
DEBUG CONSTRNT: Checking 41 LP rows (pool tracks 41, total LP rows 41)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 162
DEBUG CONSTRNT: Pool row 162 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=40, expected 40
 % @PAP adding 50 rows, 223 nz to LP
DEBUG BB: Processing node 63, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=35, varin=40, theta=0.151956, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28615694.756269
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 283 nonzeros, 3 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 63 LP 1 Solution, length = 28615694.756269, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.240221 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.240221 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.151956 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.151956 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.151956 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.151956 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 1.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.151956 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.151956 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.240221 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.759779 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.848044 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.759779 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.759779 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.848044 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.759779 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.848044 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.848044 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.848044 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.848044 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.848044 (terminal 19)
 % 9 fractional variables
DEBUG CG: LP optimal, z=28615694.756269, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28615694.756269, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 3 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 63 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 63
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.240221
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.240221)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.240221
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.240221)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.151956
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.151956)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.151956
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.151956)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.151956
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.151956)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.151956
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.151956)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=1.000000
DEBUG CAREFUL: Skipping var 14: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.151956
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.151956)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.151956
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.151956)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.240221
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.240221)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 9 fractional variables

  %  Carefully choosing branching variable, nfrac = 9
DEBUG CAREFUL: Testing fvar[0] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 1
DEBUG CAREFUL: New best var: 1
DEBUG CAREFUL: Testing fvar[1] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 0
DEBUG CAREFUL: New best var: 0
DEBUG CAREFUL: Testing fvar[2] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 29
DEBUG CAREFUL: Testing fvar[3] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[4] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 18
DEBUG CAREFUL: Testing fvar[5] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[6] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 4
DEBUG CAREFUL: Testing fvar[7] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[8] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
  % Initial guess is x3, Z0 = 28615694.7562693        , Z1 = 29312818.2315157        

DEBUG EVAL: Testing var 1 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=46, theta=1.092498, up=999999999999999983222784.000000
ITER 2: row=12, varin=72, theta=0.525109, up=1.000000
ITER 3: row=5, varin=6, theta=0.085266, up=999999999999999983222784.000000
ITER 4: row=45, varin=28, theta=0.104958, up=999999999999999983222784.000000
ITER 5: row=27, varin=47, theta=0.313414, up=999999999999999983222784.000000
ITER 6: row=11, varin=20, theta=0.494991, up=999999999999999983222784.000000
ITER 7: row=50, varin=43, theta=0.417394, up=999999999999999983222784.000000
ITER 8: row=48, varin=49, theta=0.834809, up=999999999999999983222784.000000
ITER 9: row=9, varin=39, theta=0.824714, up=999999999999999983222784.000000
ITER 10: row=39, varin=23, theta=0.206026, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 1 gives z=28746384.567653
  % 	x1 = 1,	Z1 = 28746384.5676527        
DEBUG EVAL: First branch cutoff check: z=28746384.567653, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 0
ITER 1: row=2, varin=49, theta=0.137752, up=999999999999999983222784.000000
ITER 2: row=9, varin=47, theta=0.093985, up=999999999999999983222784.000000
  % 	x1 = 0,	Z0 = 28626158.6279261        
DEBUG EVAL: Second branch cutoff check: z=28626158.627926, best_z=INF, threshold=INF
  %   New best:  x1, Z = 28626158.6279261        
DEBUG EVAL: Testing var 0 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=46, theta=1.092498, up=999999999999999983222784.000000
ITER 2: row=12, varin=72, theta=0.525109, up=1.000000
ITER 3: row=5, varin=6, theta=0.085266, up=999999999999999983222784.000000
ITER 4: row=45, varin=28, theta=0.104958, up=999999999999999983222784.000000
ITER 5: row=27, varin=47, theta=0.313414, up=999999999999999983222784.000000
ITER 6: row=11, varin=20, theta=0.494991, up=999999999999999983222784.000000
ITER 7: row=50, varin=43, theta=0.417394, up=999999999999999983222784.000000
ITER 8: row=48, varin=49, theta=0.834809, up=999999999999999983222784.000000
ITER 9: row=9, varin=39, theta=0.824714, up=999999999999999983222784.000000
ITER 10: row=39, varin=23, theta=0.206026, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 0 = 1 gives z=29103580.957774
  % 	x0 = 1,	Z1 = 29103580.957774         
DEBUG EVAL: First branch cutoff check: z=29103580.957774, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 0 = 0
ITER 1: row=1, varin=49, theta=0.137752, up=999999999999999983222784.000000
ITER 2: row=9, varin=47, theta=0.093985, up=999999999999999983222784.000000
  % 	x0 = 0,	Z0 = 28626158.6279261        
DEBUG EVAL: Second branch cutoff check: z=28626158.627926, best_z=INF, threshold=INF
  %   New best:  x0, Z = 28626158.6279261        
DEBUG EVAL: Testing var 29 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=36, varin=46, theta=1.092498, up=999999999999999983222784.000000
ITER 2: row=12, varin=72, theta=0.525109, up=1.000000
ITER 3: row=5, varin=6, theta=0.085266, up=999999999999999983222784.000000
ITER 4: row=45, varin=28, theta=0.104958, up=999999999999999983222784.000000
ITER 5: row=27, varin=47, theta=0.313414, up=999999999999999983222784.000000
ITER 6: row=11, varin=20, theta=0.494991, up=999999999999999983222784.000000
ITER 7: row=50, varin=43, theta=0.417394, up=999999999999999983222784.000000
ITER 8: row=48, varin=4, theta=0.282403, up=999999999999999983222784.000000
ITER 9: row=37, varin=49, theta=0.834809, up=999999999999999983222784.000000
ITER 10: row=7, varin=39, theta=0.824714, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 29 = 1 gives z=28746384.567653
  % 	x29 = 1,	Z1 = 28746384.5676527        
DEBUG EVAL: First branch cutoff check: z=28746384.567653, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 29 = 0
ITER 1: row=36, varin=49, theta=0.137752, up=999999999999999983222784.000000
ITER 2: row=9, varin=47, theta=0.093985, up=999999999999999983222784.000000
  % 	x29 = 0,	Z0 = 28626158.6279261        
DEBUG EVAL: Second branch cutoff check: z=28626158.627926, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=5, varin=46, theta=1.283147, up=999999999999999983222784.000000
ITER 2: row=12, varin=49, theta=0.341004, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 1 gives z=28636699.860663
  % 	x3 = 1,	Z1 = 29312818.2315157        
DEBUG EVAL: First branch cutoff check: z=29312818.231516, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=5, varin=72, theta=0.241787, up=1.000000
  % 	x3 = 0,	Z0 = 28623227.8167694        
DEBUG EVAL: Second branch cutoff check: z=28623227.816769, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 18 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=23, varin=49, theta=1.545343, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 18 = 1 gives z=28689719.366651
  % 	x18 = 1,	Z1 = 28689719.3666506        
DEBUG EVAL: First branch cutoff check: z=28689719.366651, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 18 = 0
ITER 1: row=23, varin=46, theta=0.448128, up=999999999999999983222784.000000
  % 	x18 = 0,	Z0 = 28617787.6925225        
DEBUG EVAL: Second branch cutoff check: z=28617787.692522, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=49, theta=1.545343, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28689719.366651
  % 	x10 = 1,	Z1 = 28689719.3666506        
DEBUG EVAL: First branch cutoff check: z=28689719.366651, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=6, varin=46, theta=0.448128, up=999999999999999983222784.000000
  % 	x10 = 0,	Z0 = 28617787.6925225        
DEBUG EVAL: Second branch cutoff check: z=28617787.692522, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 4 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=11, varin=49, theta=1.545343, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 4 = 1 gives z=28689719.366651
  % 	x4 = 1,	Z1 = 28901535.7863583        
DEBUG EVAL: First branch cutoff check: z=28901535.786358, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 4 = 0
ITER 1: row=11, varin=46, theta=0.448128, up=999999999999999983222784.000000
  % 	x4 = 0,	Z0 = 28617787.6925225        
DEBUG EVAL: Second branch cutoff check: z=28617787.692522, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 26 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=35, varin=49, theta=1.545343, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 1 gives z=28689719.366651
  % 	x26 = 1,	Z1 = 28689719.3666506        
DEBUG EVAL: First branch cutoff check: z=28689719.366651, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 0
ITER 1: row=35, varin=46, theta=0.448128, up=999999999999999983222784.000000
  % 	x26 = 0,	Z0 = 28617787.6925225        
DEBUG EVAL: Second branch cutoff check: z=28617787.692522, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=46, theta=0.448128, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28617787.692522
  % 	x2 = 0,	Z0 = 28617787.6925225        
DEBUG EVAL: First branch cutoff check: z=28617787.692522, best_z=INF, threshold=INF
  % Best branch is x0, Z0 = 28626158.6279261        , Z1 = 29103580.957774         

DEBUG CAREFUL: Final result - returning best.var = 0
DEBUG BB: Branching variable chosen: j=0
 % @NC   67   63	x0 = 0	28626158.627926
 % @NC   68   63	x0 = 1	29103580.957774
 %      63    26 28615694.7563               28617867.4695   x11 D    38    10
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabe1490
% @LO 0.09  28.61569475626928493739 99.9000000000
% @LN 0.09  28.61786746952284943291 99.9000000000
% Resuming node 58 at  28.61786746952284943291
DEBUG CONSTRNT: LP rows=50, pool->nlprows=50, pool->npend=0
DEBUG CONSTRNT: Checking 50 LP rows (pool tracks 50, total LP rows 50)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 85
DEBUG CONSTRNT: Pool row 85 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=49, expected 49
 % @PAP adding 39 rows, 219 nz to LP
DEBUG BB: Processing node 58, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=38, theta=0.470588, up=999999999999999983222784.000000
ITER 2: row=3, varin=39, theta=0.846154, up=999999999999999983222784.000000
ITER 3: row=18, varin=35, theta=0.500000, up=999999999999999983222784.000000
ITER 4: row=11, varin=30, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 28617867.469523
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 39 rows, 60 cols, 279 nonzeros, 1 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=43, theta=1.125000, up=1.000000
ITER 2: row=40, varin=52, theta=0.058824, up=1.000000
ITER 3: row=38, varin=43, theta=0.937500, up=1.000000
ITER 4: row=29, varin=45, theta=0.500000, up=1.000000
ITER 5: row=26, varin=19, theta=0.111111, up=999999999999999983222784.000000
ITER 6: row=28, varin=22, theta=0.045455, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28694992.900169
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 281 nonzeros, 6 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 7 rows, 22 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=96, theta=0.066667, up=1.000000
ITER 2: row=38, varin=68, theta=1.142857, up=1.000000
ITER 3: row=38, varin=27, theta=0.055556, up=999999999999999983222784.000000
ITER 4: row=36, varin=66, theta=0.125000, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28721414.422208
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 41 rows, 60 cols, 252 nonzeros, 2 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 8 rows, 23 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=74, theta=1.000000, up=1.000000
ITER 2: row=40, varin=19, theta=1.090909, up=999999999999999983222784.000000
ITER 3: row=30, varin=21, theta=12.000000, up=999999999999999983222784.000000
ITER 4: row=43, varin=25, theta=2.750000, up=999999999999999983222784.000000
ITER 5: row=35, varin=24, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28821766.158886
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 271 nonzeros, 4 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=79, theta=1.000000, up=1.000000
ITER 2: row=38, varin=76, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28828217.636983
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 248 nonzeros, 0 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 3 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=32, theta=0.357143, up=999999999999999983222784.000000
ITER 2: row=34, varin=68, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28846748.961413
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 251 nonzeros, 0 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 16 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=36, theta=1.250000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28848484.240569
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 267 nonzeros, 1 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 58 LP 1 Solution, length = 28848484.240569, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 1.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.250000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.250000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.250000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.250000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.250000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.250000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.750000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.750000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.750000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.750000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.750000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.750000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.750000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28848484.240569, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 58 at  28.84848424056930937809
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabb5780
% @LO 0.09  28.61786746952284943291 99.9000000000
% @LN 0.09  28.61897395161189905366 99.9000000000
% Resuming node 47 at  28.61897395161189905366
DEBUG CONSTRNT: LP rows=49, pool->nlprows=49, pool->npend=0
DEBUG CONSTRNT: Checking 49 LP rows (pool tracks 49, total LP rows 49)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 73
DEBUG CONSTRNT: Pool row 73 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 143
DEBUG CONSTRNT: Pool row 143 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=48, expected 48
 % @PAP adding 52 rows, 199 nz to LP
DEBUG BB: Processing node 47, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 47 LP 2 Solution, length = 28618973.951612, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.500000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.500000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.500000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28618973.951612, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28618973.951612, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 47 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 47
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.500000
DEBUG CAREFUL: Adding var 6 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.500000
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.500000
DEBUG CAREFUL: Adding var 21 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.500000
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 12
DEBUG CAREFUL: New best var: 12
DEBUG CAREFUL: Testing fvar[1] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 34
DEBUG CAREFUL: Testing fvar[2] = var 6
DEBUG CAREFUL: Calling compare_branch_vars for var 6
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 6
DEBUG CAREFUL: Testing fvar[3] = var 21
DEBUG CAREFUL: Calling compare_branch_vars for var 21
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 21
DEBUG CAREFUL: New best var: 21
  % Initial guess is x21, Z0 = 28618973.9516119        , Z1 = 28626832.2691135        

DEBUG EVAL: Testing var 12 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=18, varin=75, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 12 = 0 gives z=28619537.559534
  % 	x12 = 0,	Z0 = 28619537.5595343        
DEBUG EVAL: First branch cutoff check: z=28619537.559534, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 1
ITER 1: row=18, varin=50, theta=0.350000, up=999999999999999983222784.000000
ITER 2: row=50, varin=26, theta=0.205882, up=999999999999999983222784.000000
ITER 3: row=26, varin=48, theta=0.500000, up=999999999999999983222784.000000
  % 	x12 = 1,	Z1 = 28640311.8113092        
DEBUG EVAL: Second branch cutoff check: z=28640311.811309, best_z=INF, threshold=INF
  %   New best:  x12, Z = 28619537.5595343        
DEBUG EVAL: Testing var 34 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=19, varin=43, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 34 = 0 gives z=28669507.988508
  % 	x34 = 0,	Z0 = 28669507.988508         
DEBUG EVAL: First branch cutoff check: z=28669507.988508, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 34 = 1
ITER 1: row=19, varin=24, theta=1.000000, up=999999999999999983222784.000000
  % 	x34 = 1,	Z1 = 28745399.701599         
DEBUG EVAL: Second branch cutoff check: z=28745399.701599, best_z=INF, threshold=INF
  %   New best:  x34, Z = 28669507.988508         
DEBUG EVAL: Testing var 6 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=23, varin=43, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 6 = 0 gives z=28669507.988508
  % 	x6 = 0,	Z0 = 28669507.988508         
DEBUG EVAL: First branch cutoff check: z=28669507.988508, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 6 = 1
ITER 1: row=23, varin=19, theta=1.000000, up=999999999999999983222784.000000
  % 	x6 = 1,	Z1 = 29004083.1703625        
DEBUG EVAL: Second branch cutoff check: z=29004083.170362, best_z=INF, threshold=INF
  %   New best:  x6, Z = 28669507.988508         
DEBUG EVAL: Testing var 21 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=35, varin=50, theta=0.350000, up=999999999999999983222784.000000
ITER 2: row=50, varin=26, theta=0.205882, up=999999999999999983222784.000000
ITER 3: row=26, varin=44, theta=0.500000, up=999999999999999983222784.000000
ITER 4: row=44, varin=42, theta=0.500000, up=999999999999999983222784.000000
ITER 5: row=42, varin=34, theta=0.235294, up=999999999999999983222784.000000
ITER 6: row=27, varin=43, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 21 = 1 gives z=28669507.988508
  % 	x21 = 1,	Z1 = 28669507.988508         
DEBUG EVAL: First branch cutoff check: z=28669507.988508, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 21 = 0
ITER 1: row=35, varin=75, theta=0.500000, up=1.000000
  % 	x21 = 0,	Z0 = 28619537.5595343        
DEBUG EVAL: Second branch cutoff check: z=28619537.559534, best_z=INF, threshold=INF
  % Best branch is x6, Z0 = 28669507.988508         , Z1 = 29004083.1703625        

DEBUG CAREFUL: Final result - returning best.var = 6
DEBUG BB: Branching variable chosen: j=6
 % @NC   69   47	x6 = 0	28669507.988508
 % @NC   70   47	x6 = 1	29004083.170362
 %      47    27 28618973.9516               28619275.3391   x17 D    25     9
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabbca20
% @LO 0.09  28.61897395161189905366 99.9000000000
% @LN 0.09  28.61927533913998900061 99.9000000000
% Resuming node 65 at  28.61927533913998900061
DEBUG CONSTRNT: LP rows=52, pool->nlprows=52, pool->npend=0
DEBUG CONSTRNT: Checking 52 LP rows (pool tracks 52, total LP rows 52)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 60
DEBUG CONSTRNT: Pool row 60 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=51, expected 51
 % @PAP adding 41 rows, 194 nz to LP
DEBUG BB: Processing node 65, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=17, varin=9, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28619275.339140
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 41 rows, 60 cols, 254 nonzeros, 2 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=33, theta=0.214286, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28631144.169057
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.785714
DEBUG SOLUTION: lp->best_solution[9] = 1.785714
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 262 nonzeros, 4 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % Node 65 LP 1 Solution, length = 28631144.169057, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.071429 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.071429 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.071429 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.071429 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.071429 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.214286 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.214286 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.214286 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.785714 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.928571 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.928571 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.785714 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.785714 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.928571 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.928571 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.928571 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.928571 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.785714 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.928571 (terminal 19)
 % 8 fractional variables
DEBUG CG: LP optimal, z=28631144.169057, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 65 at  28.63114416905663972557
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabda810
% @LO 0.09  28.61927533913998900061 99.9000000000
% @LN 0.09  28.62042536963604533184 99.9000000000
% Resuming node 43 at  28.62042536963604533184
DEBUG CONSTRNT: LP rows=39, pool->nlprows=39, pool->npend=0
DEBUG CONSTRNT: Checking 39 LP rows (pool tracks 39, total LP rows 39)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 162
DEBUG CONSTRNT: Pool row 162 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=38, expected 38
 % @PAP adding 51 rows, 228 nz to LP
DEBUG BB: Processing node 43, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 43 LP 4 Solution, length = 28620425.369636, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.500000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.500000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.576628 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.576628 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.423372 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.423372 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28620425.369636, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28620425.369636, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 43 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 43
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.500000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.500000
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.500000
DEBUG CAREFUL: Adding var 31 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.576628
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.576628)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.576628
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.576628)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 2
DEBUG CAREFUL: New best var: 2
DEBUG CAREFUL: Testing fvar[1] = var 31
DEBUG CAREFUL: Calling compare_branch_vars for var 31
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 31
DEBUG CAREFUL: Testing fvar[2] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 27
DEBUG CAREFUL: Testing fvar[3] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 36
DEBUG CAREFUL: Testing fvar[4] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 34
  % Initial guess is x2, Z0 = 28620425.369636         , Z1 = 28620425.369636         

DEBUG EVAL: Testing var 2 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=50, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=50, varin=47, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 1 gives z=28715593.501190
  % 	x2 = 1,	Z1 = 28715593.5011902        
DEBUG EVAL: First branch cutoff check: z=28715593.501190, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 0
ITER 1: row=1, varin=36, theta=1.000000, up=999999999999999983222784.000000
  % 	x2 = 0,	Z0 = 28652973.9305273        
DEBUG EVAL: Second branch cutoff check: z=28652973.930527, best_z=INF, threshold=INF
  %   New best:  x2, Z = 28652973.9305273        
DEBUG EVAL: Testing var 31 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=15, varin=50, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=50, varin=48, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=48, varin=46, theta=0.500000, up=999999999999999983222784.000000
ITER 4: row=35, varin=17, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=17, varin=45, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 31 = 1 gives z=28796643.083837
  % 	x31 = 1,	Z1 = 28796643.0838372        
DEBUG EVAL: First branch cutoff check: z=28796643.083837, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 31 = 0
ITER 1: row=15, varin=36, theta=1.000000, up=999999999999999983222784.000000
  % 	x31 = 0,	Z0 = 28652973.9305273        
DEBUG EVAL: Second branch cutoff check: z=28652973.930527, best_z=INF, threshold=INF
  %   New best:  x31, Z = 28652973.9305273        
DEBUG EVAL: Testing var 27 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=11, varin=50, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=50, varin=47, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 27 = 1 gives z=28715593.501190
  % 	x27 = 1,	Z1 = 28715593.5011901        
DEBUG EVAL: First branch cutoff check: z=28715593.501190, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 27 = 0
ITER 1: row=11, varin=36, theta=1.000000, up=999999999999999983222784.000000
  % 	x27 = 0,	Z0 = 28652973.9305273        
DEBUG EVAL: Second branch cutoff check: z=28652973.930527, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 36 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=23, varin=50, theta=3.897285, up=999999999999999983222784.000000
ITER 2: row=50, varin=8, theta=0.483257, up=999999999999999983222784.000000
ITER 3: row=8, varin=46, theta=2.446207, up=999999999999999983222784.000000
ITER 4: row=35, varin=27, theta=1.804833, up=999999999999999983222784.000000
ITER 5: row=51, varin=38, theta=3.982937, up=999999999999999983222784.000000
ITER 6: row=38, varin=2, theta=2.026068, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 36 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x36 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=23, varin=15, theta=285337.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28636663.746042
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
   % @PL 51 rows, 60 cols, 288 nonzeros, 1 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 43 at  28.63666374604197883968
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595daba2600
% @LO 0.09  28.62042536963604533184 99.9000000000
% @LN 0.09  28.62615862792613086185 99.9000000000
% Resuming node 67 at  28.62615862792613086185
DEBUG CONSTRNT: LP rows=50, pool->nlprows=50, pool->npend=0
DEBUG CONSTRNT: Checking 50 LP rows (pool tracks 50, total LP rows 50)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 105
DEBUG CONSTRNT: Pool row 105 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=49, expected 49
 % @PAP adding 50 rows, 223 nz to LP
DEBUG BB: Processing node 67, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=49, theta=0.137752, up=999999999999999983222784.000000
ITER 2: row=9, varin=47, theta=0.093985, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28626158.627926
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 283 nonzeros, 5 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 67 LP 1 Solution, length = 28626158.627926, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.256391 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.162406 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.162406 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.256391 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 1.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.256391 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.256391 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.837594 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.743609 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.743609 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.743609 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.743609 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.743609 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.743609 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28626158.627926, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28626158.627926, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 67 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 67
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.256391
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.256391)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.162406
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.162406)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.162406
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.162406)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.256391
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.256391)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=1.000000
DEBUG CAREFUL: Skipping var 14: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.256391
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.256391)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.256391
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.256391)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
DEBUG CAREFUL: Testing fvar[1] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[2] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[3] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[4] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 4
DEBUG CAREFUL: Testing fvar[5] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
  % Initial guess is x3, Z0 = 28626158.6279261        , Z1 = 29312818.2315157        

DEBUG EVAL: Testing var 18 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=23, varin=75, theta=3.551675, up=1.000000
ITER 2: row=23, varin=20, theta=2.002549, up=999999999999999983222784.000000
ITER 3: row=50, varin=72, theta=1.983874, up=1.000000
ITER 4: row=50, varin=73, theta=1.003684, up=1.000000
ITER 5: row=50, varin=81, theta=0.006048, up=1.000000
ITER 6: row=5, varin=46, theta=2.229508, up=999999999999999983222784.000000
ITER 7: row=11, varin=16, theta=2.373500, up=999999999999999983222784.000000
ITER 8: row=29, varin=3, theta=3.542144, up=999999999999999983222784.000000
ITER 9: row=3, varin=78, theta=9.822940, up=1.000000
ITER 10: row=3, varin=79, theta=9.039868, up=1.000000
DEBUG EVAL: Branch var 18 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x18 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=23, varin=19, theta=0.502918, up=999999999999999983222784.000000
ITER 2: row=47, varin=46, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28676671.328960
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 50 rows, 60 cols, 283 nonzeros, 5 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 5 slack rows
   % @PAP adding 4 rows, 22 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=74, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28687190.196486
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 49 rows, 60 cols, 284 nonzeros, 0 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 3 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=22, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=45, varin=86, theta=1.000000, up=1.000000
ITER 3: row=51, varin=83, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28778437.642345
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 52 rows, 60 cols, 292 nonzeros, 1 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 4 rows, 15 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=77, theta=1.000000, up=1.000000
ITER 2: row=11, varin=26, theta=0.030017, up=999999999999999983222784.000000
ITER 3: row=48, varin=46, theta=0.037805, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
ITER 4: row=47, varin=93, theta=0.180467, up=1.000000
ITER 5: row=47, varin=11, theta=48041.000000, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 28792961.010811
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 951959.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 55 rows, 60 cols, 305 nonzeros, 1 slack, 54 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 2 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=93, theta=16.000000, up=1.000000
ITER 2: row=1, varin=67, theta=7.500000, up=1.000000
ITER 3: row=1, varin=58, theta=6.500000, up=1.000000
ITER 4: row=1, varin=97, theta=11.000000, up=1.000000
ITER 5: row=1, varin=98, theta=10.000000, up=1.000000
ITER 6: row=1, varin=99, theta=9.000000, up=1.000000
ITER 7: row=1, varin=100, theta=8.000000, up=1.000000
ITER 8: row=1, varin=101, theta=7.000000, up=1.000000
ITER 9: row=1, varin=102, theta=6.000000, up=1.000000
ITER 10: row=1, varin=103, theta=5.000000, up=1.000000
LP PHASE: Switching to primal (iter=54)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 28803164.859275
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 56 rows, 60 cols, 272 nonzeros, 0 slack, 56 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 5 rows, 60 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=61, varin=91, theta=4.073663, up=1.000000
ITER 2: row=61, varin=96, theta=0.332651, up=1.000000
ITER 3: row=33, varin=91, theta=1.000000, up=1.000000
ITER 4: row=57, varin=88, theta=0.333333, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=61)
DEBUG SOLUTION: LP solution array indices: FST[62-101], not_covered[102-121]
DEBUG SOLUTION: lp->best_solution[0] = 28839704.285969
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 61 rows, 60 cols, 332 nonzeros, 9 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 9 slack rows
   % @PAP adding 2 rows, 9 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=53, varin=77, theta=0.666667, up=1.000000
ITER 2: row=54, varin=41, theta=0.285714, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 28887789.136740
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 54 rows, 60 cols, 303 nonzeros, 3 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 3 slack rows
   % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=55, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28917012.495473
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 53 rows, 60 cols, 295 nonzeros, 4 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 4 slack rows
   % @PAP adding 2 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=79, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28917391.248474
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 51 rows, 60 cols, 285 nonzeros, 0 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=53, varin=82, theta=0.500000, up=1.000000
ITER 2: row=24, varin=47, theta=0.250000, up=999999999999999983222784.000000
ITER 3: row=52, varin=53, theta=0.100000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28921427.581136
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 53 rows, 60 cols, 291 nonzeros, 2 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 67 at  28.92142758113568490330
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabbca20
% @LO 0.10  28.62615862792613086185 99.9000000000
% @LN 0.10  28.63114416905663972557 99.9000000000
% Resuming node 65 at  28.63114416905663972557
DEBUG CONSTRNT: LP rows=51, pool->nlprows=51, pool->npend=0
DEBUG CONSTRNT: Checking 51 LP rows (pool tracks 51, total LP rows 51)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 143
DEBUG CONSTRNT: Pool row 143 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=50, expected 50
 % @PAP adding 39 rows, 189 nz to LP
DEBUG BB: Processing node 65, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 65 LP 2 Solution, length = 28631144.169057, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.071429 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.071429 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.071429 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.071429 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.071429 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.214286 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.214286 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.214286 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.785714 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.928571 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.928571 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.785714 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.785714 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.928571 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.928571 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.928571 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.928571 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.785714 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.928571 (terminal 19)
 % 8 fractional variables
DEBUG CG: LP optimal, z=28631144.169057, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28631144.169057, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 65 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 65
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.071429
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.071429)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.071429
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.071429)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.071429
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.071429)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.071429
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.071429)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.071429
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.071429)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.214286
DEBUG CAREFUL: Adding var 23 to fractional list (xi=0.214286)
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.214286
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.214286)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.214286
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.214286)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 8 fractional variables

  %  Carefully choosing branching variable, nfrac = 8
DEBUG CAREFUL: Testing fvar[0] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 2
DEBUG CAREFUL: New best var: 2
DEBUG CAREFUL: Testing fvar[1] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[2] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 4
DEBUG CAREFUL: New best var: 4
DEBUG CAREFUL: Testing fvar[3] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 11
DEBUG CAREFUL: Testing fvar[4] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 36
DEBUG CAREFUL: Testing fvar[5] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 34
DEBUG CAREFUL: Testing fvar[6] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[7] = var 23
DEBUG CAREFUL: Calling compare_branch_vars for var 23
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 23
  % Initial guess is x4, Z0 = 28631144.1690566        , Z1 = 29168775.763443         

DEBUG EVAL: Testing var 2 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=37, theta=6.500000, up=999999999999999983222784.000000
ITER 2: row=6, varin=34, theta=0.866667, up=999999999999999983222784.000000
ITER 3: row=14, varin=39, theta=1.750000, up=999999999999999983222784.000000
ITER 4: row=37, varin=50, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 2 = 1 gives z=28756773.056953
  % 	x2 = 1,	Z1 = 28756773.056953         
DEBUG EVAL: First branch cutoff check: z=28756773.056953, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 0
ITER 1: row=1, varin=73, theta=0.250000, up=1.000000
ITER 2: row=32, varin=33, theta=0.125000, up=999999999999999983222784.000000
ITER 3: row=38, varin=70, theta=0.250000, up=1.000000
  % 	x2 = 0,	Z0 = 28635360.5867199        
DEBUG EVAL: Second branch cutoff check: z=28635360.586720, best_z=INF, threshold=INF
  %   New best:  x2, Z = 28635360.5867199        
DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=5, varin=37, theta=6.500000, up=999999999999999983222784.000000
ITER 2: row=6, varin=33, theta=1.625000, up=999999999999999983222784.000000
ITER 3: row=35, varin=39, theta=13.000000, up=999999999999999983222784.000000
ITER 4: row=7, varin=36, theta=0.909091, up=999999999999999983222784.000000
ITER 5: row=14, varin=50, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 3 = 1 gives z=28836541.556560
  % 	x3 = 1,	Z1 = 28836541.5565605        
DEBUG EVAL: First branch cutoff check: z=28836541.556560, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=5, varin=73, theta=0.250000, up=1.000000
ITER 2: row=32, varin=70, theta=0.250000, up=1.000000
  % 	x3 = 0,	Z0 = 28635360.5867199        
DEBUG EVAL: Second branch cutoff check: z=28635360.586720, best_z=INF, threshold=INF
  %   New best:  x3, Z = 28635360.5867199        
DEBUG EVAL: Testing var 4 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=20, varin=37, theta=6.500000, up=999999999999999983222784.000000
ITER 2: row=6, varin=39, theta=13.000000, up=999999999999999983222784.000000
ITER 3: row=7, varin=25, theta=3.333333, up=999999999999999983222784.000000
ITER 4: row=24, varin=20, theta=1.250000, up=999999999999999983222784.000000
ITER 5: row=6, varin=50, theta=1.200000, up=1.000000
ITER 6: row=6, varin=18, theta=0.333333, up=999999999999999983222784.000000
ITER 7: row=20, varin=50, theta=1.000000, up=1.000000
ITER 8: row=19, varin=22, theta=2.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 4 = 1 gives z=29168775.763443
  % 	x4 = 1,	Z1 = 29168775.763443         
DEBUG EVAL: First branch cutoff check: z=29168775.763443, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 4 = 0
ITER 1: row=20, varin=73, theta=0.250000, up=1.000000
ITER 2: row=32, varin=33, theta=0.125000, up=999999999999999983222784.000000
ITER 3: row=38, varin=70, theta=0.250000, up=1.000000
  % 	x4 = 0,	Z0 = 28635360.5867199        
DEBUG EVAL: Second branch cutoff check: z=28635360.586720, best_z=INF, threshold=INF
  %   New best:  x4, Z = 28635360.5867199        
DEBUG EVAL: Testing var 11 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=33, varin=37, theta=6.500000, up=999999999999999983222784.000000
ITER 2: row=6, varin=33, theta=1.625000, up=999999999999999983222784.000000
ITER 3: row=35, varin=39, theta=13.000000, up=999999999999999983222784.000000
ITER 4: row=7, varin=34, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=14, varin=21, theta=5.000000, up=999999999999999983222784.000000
ITER 6: row=6, varin=25, theta=6.000000, up=999999999999999983222784.000000
ITER 7: row=24, varin=50, theta=1.200000, up=1.000000
ITER 8: row=24, varin=18, theta=0.333333, up=999999999999999983222784.000000
ITER 9: row=38, varin=50, theta=1.000000, up=1.000000
ITER 10: row=18, varin=22, theta=2.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 11 = 1 gives z=29144049.082165
  % 	x11 = 1,	Z1 = 29144049.0821647        
DEBUG EVAL: First branch cutoff check: z=29144049.082165, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 11 = 0
ITER 1: row=33, varin=73, theta=0.250000, up=1.000000
ITER 2: row=32, varin=70, theta=0.250000, up=1.000000
  % 	x11 = 0,	Z0 = 28635360.5867199        
DEBUG EVAL: Second branch cutoff check: z=28635360.586720, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 36 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=13, varin=39, theta=3.666667, up=999999999999999983222784.000000
ITER 2: row=7, varin=73, theta=4.000000, up=1.000000
ITER 3: row=7, varin=33, theta=1.500000, up=999999999999999983222784.000000
ITER 4: row=38, varin=70, theta=3.000000, up=1.000000
ITER 5: row=38, varin=61, theta=2.000000, up=1.000000
ITER 6: row=38, varin=18, theta=0.666667, up=999999999999999983222784.000000
ITER 7: row=32, varin=73, theta=1.000000, up=1.000000
ITER 8: row=21, varin=61, theta=1.000000, up=1.000000
ITER 9: row=18, varin=22, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 36 = 1 gives z=28846275.294649
  % 	x36 = 1,	Z1 = 28846275.2946485        
DEBUG EVAL: First branch cutoff check: z=28846275.294649, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 36 = 0
ITER 1: row=13, varin=37, theta=0.375000, up=999999999999999983222784.000000
  % 	x36 = 0,	Z0 = 28631553.7292324        
DEBUG EVAL: Second branch cutoff check: z=28631553.729232, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 34 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=18, varin=39, theta=3.666667, up=999999999999999983222784.000000
ITER 2: row=7, varin=73, theta=4.000000, up=1.000000
ITER 3: row=7, varin=33, theta=1.500000, up=999999999999999983222784.000000
ITER 4: row=38, varin=70, theta=3.000000, up=1.000000
ITER 5: row=38, varin=61, theta=2.000000, up=1.000000
ITER 6: row=38, varin=77, theta=1.000000, up=1.000000
ITER 7: row=21, varin=22, theta=2.000000, up=999999999999999983222784.000000
ITER 8: row=38, varin=61, theta=2.000000, up=1.000000
ITER 9: row=38, varin=70, theta=1.000000, up=1.000000
ITER 10: row=32, varin=73, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 34 = 1 gives z=28922167.007739
  % 	x34 = 1,	Z1 = 28922167.0077395        
DEBUG EVAL: First branch cutoff check: z=28922167.007739, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 34 = 0
ITER 1: row=18, varin=37, theta=0.375000, up=999999999999999983222784.000000
  % 	x34 = 0,	Z0 = 28631553.7292324        
DEBUG EVAL: Second branch cutoff check: z=28631553.729232, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=37, theta=0.812500, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28632031.549437
  % 	x10 = 1,	Z1 = 28763107.4584648        
DEBUG EVAL: First branch cutoff check: z=28763107.458465, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=6, varin=73, theta=0.250000, up=1.000000
  % 	x10 = 0,	Z0 = 28634143.2269109        
DEBUG EVAL: Second branch cutoff check: z=28634143.226911, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 23 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=37, theta=0.375000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 23 = 0 gives z=28631553.729232
  % 	x23 = 0,	Z0 = 28631553.7292324        
DEBUG EVAL: First branch cutoff check: z=28631553.729232, best_z=INF, threshold=INF
  % Best branch is x4, Z0 = 28635360.5867199        , Z1 = 29168775.763443         

DEBUG CAREFUL: Final result - returning best.var = 4
DEBUG BB: Branching variable chosen: j=4
 % @NC   71   65	x4 = 0	28635360.586720
 % @NC   72   65	x4 = 1	29168775.763443
 %      65    28 28631144.1691               28633832.5410   x12 D    59    15
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabd86b0
% @LO 0.10  28.63114416905663972557 99.9000000000
% @LN 0.10  28.63383254097103858271 99.9000000000
% Resuming node 61 at  28.63383254097103858271
DEBUG CONSTRNT: LP rows=39, pool->nlprows=39, pool->npend=0
DEBUG CONSTRNT: Checking 39 LP rows (pool tracks 39, total LP rows 39)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 162
DEBUG CONSTRNT: Pool row 162 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=38, expected 38
 % @PAP adding 51 rows, 228 nz to LP
DEBUG BB: Processing node 61, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 61 LP 2 Solution, length = 28633832.540971, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.296447 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.296447 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.296447 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.296447 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.296447 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.110660 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.703553 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.703553 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.703553 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.703553 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.703553 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28633832.540971, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28633832.540971, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 61 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 61
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.296447
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.296447)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=1.000000
DEBUG CAREFUL: Skipping var 13: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.296447
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.296447)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.296447
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.296447)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.296447
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.296447)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.296447
DEBUG CAREFUL: Adding var 38 to fractional list (xi=0.296447)
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.110660
DEBUG CAREFUL: Adding var 39 to fractional list (xi=0.110660)
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 39
DEBUG CAREFUL: Calling compare_branch_vars for var 39
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 39
DEBUG CAREFUL: New best var: 39
DEBUG CAREFUL: Testing fvar[1] = var 38
DEBUG CAREFUL: Calling compare_branch_vars for var 38
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 38
DEBUG CAREFUL: Testing fvar[2] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 2
DEBUG CAREFUL: New best var: 2
DEBUG CAREFUL: Testing fvar[3] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
DEBUG CAREFUL: Testing fvar[4] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 22
DEBUG CAREFUL: Testing fvar[5] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 27
  % Initial guess is x17, Z0 = 28633832.540971         , Z1 = 28750684.2599523        

DEBUG EVAL: Testing var 39 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=49, varin=50, theta=0.812295, up=999999999999999983222784.000000
ITER 2: row=44, varin=49, theta=121472.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 39 = 1 gives z=28698528.746165
  % 	x39 = 1,	Z1 = 28698528.7461647        
DEBUG EVAL: First branch cutoff check: z=28698528.746165, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 39 = 0
ITER 1: row=49, varin=46, theta=0.133459, up=999999999999999983222784.000000
  % 	x39 = 0,	Z0 = 28641274.2656429        
DEBUG EVAL: Second branch cutoff check: z=28641274.265643, best_z=INF, threshold=INF
  %   New best:  x39, Z = 28641274.2656429        
DEBUG EVAL: Testing var 38 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=44, varin=47, theta=0.698819, up=999999999999999983222784.000000
ITER 2: row=38, varin=30, theta=0.779045, up=999999999999999983222784.000000
ITER 3: row=33, varin=39, theta=2.092250, up=999999999999999983222784.000000
ITER 4: row=32, varin=34, theta=3.017427, up=999999999999999983222784.000000
ITER 5: row=49, varin=46, theta=22.638830, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 38 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x38 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=50, theta=0.287361, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28652181.894551
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 51 rows, 60 cols, 288 nonzeros, 2 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
   % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=46, theta=0.165286, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28660815.761385
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 51 rows, 60 cols, 288 nonzeros, 2 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 61 at  28.66081576138495989881
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabb5780
% @LO 0.10  28.63383254097103858271 99.9000000000
% @LN 0.10  28.63536058671986950230 99.9000000000
% Resuming node 71 at  28.63536058671986950230
DEBUG CONSTRNT: LP rows=49, pool->nlprows=49, pool->npend=0
DEBUG CONSTRNT: Checking 49 LP rows (pool tracks 49, total LP rows 49)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=48, expected 48
 % @PAP adding 39 rows, 189 nz to LP
DEBUG BB: Processing node 71, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=20, varin=73, theta=0.250000, up=1.000000
ITER 2: row=32, varin=33, theta=0.125000, up=999999999999999983222784.000000
ITER 3: row=38, varin=70, theta=0.250000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 28635360.586720
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 39 rows, 60 cols, 249 nonzeros, 0 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 15 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=37, theta=0.166667, up=999999999999999983222784.000000
ITER 2: row=35, varin=65, theta=0.250000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28639993.417827
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 264 nonzeros, 0 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 16 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=85, theta=0.250000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28642544.379944
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 280 nonzeros, 0 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 20 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=2, theta=0.111111, up=999999999999999983222784.000000
ITER 2: row=43, varin=34, theta=0.090909, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28649262.052770
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 300 nonzeros, 5 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % Node 71 LP 1 Solution, length = 28649262.052770, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.090909 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.090909 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.090909 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.090909 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.181818 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.181818 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.181818 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.090909 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.818182 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.909091 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.909091 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.818182 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.818182 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.909091 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.909091 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.909091 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.909091 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.818182 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.909091 (terminal 19)
 % 8 fractional variables
DEBUG CG: LP optimal, z=28649262.052770, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 71 at  28.64926205276965021085
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabda810
% @LO 0.10  28.63536058671986950230 99.9000000000
% @LN 0.10  28.63666374604197883968 99.9000000000
% Resuming node 43 at  28.63666374604197883968
DEBUG CONSTRNT: LP rows=46, pool->nlprows=46, pool->npend=0
DEBUG CONSTRNT: Checking 46 LP rows (pool tracks 46, total LP rows 46)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 162
DEBUG CONSTRNT: Pool row 162 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=45, expected 45
 % @PAP adding 50 rows, 188 nz to LP
DEBUG BB: Processing node 43, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 43 LP 5 Solution, length = 28636663.746042, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.500000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.500000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28636663.746042, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28636663.746042, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 43 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 43
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.500000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.500000
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.500000
DEBUG CAREFUL: Adding var 31 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 3 fractional variables

  %  Carefully choosing branching variable, nfrac = 3
DEBUG CAREFUL: Testing fvar[0] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 2
DEBUG CAREFUL: New best var: 2
DEBUG CAREFUL: Testing fvar[1] = var 31
DEBUG CAREFUL: Calling compare_branch_vars for var 31
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 31
DEBUG CAREFUL: New best var: 31
DEBUG CAREFUL: Testing fvar[2] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 27
  % Initial guess is x31, Z0 = 28652973.9305273        , Z1 = 28796643.0838372        

DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=35, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28653137.032772
  % 	x2 = 0,	Z0 = 28653137.0327721        
DEBUG EVAL: First branch cutoff check: z=28653137.032772, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 1
ITER 1: row=1, varin=49, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=49, varin=46, theta=1.000000, up=999999999999999983222784.000000
  % 	x2 = 1,	Z1 = 28726707.5590403        
DEBUG EVAL: Second branch cutoff check: z=28726707.559040, best_z=INF, threshold=INF
  %   New best:  x2, Z = 28653137.0327721        
DEBUG EVAL: Testing var 31 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=44, varin=35, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 31 = 0 gives z=28653137.032772
  % 	x31 = 0,	Z0 = 28653137.0327721        
DEBUG EVAL: First branch cutoff check: z=28653137.032772, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 31 = 1
ITER 1: row=44, varin=49, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=49, varin=47, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=47, varin=45, theta=0.500000, up=999999999999999983222784.000000
ITER 4: row=34, varin=16, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=16, varin=44, theta=1.000000, up=999999999999999983222784.000000
  % 	x31 = 1,	Z1 = 28803392.9899966        
DEBUG EVAL: Second branch cutoff check: z=28803392.989997, best_z=INF, threshold=INF
  %   New best:  x31, Z = 28653137.0327721        
DEBUG EVAL: Testing var 27 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=11, varin=35, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 27 = 0 gives z=28653137.032772
  % 	x27 = 0,	Z0 = 28653137.0327721        
DEBUG EVAL: First branch cutoff check: z=28653137.032772, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 27 = 1
ITER 1: row=11, varin=49, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=49, varin=46, theta=1.000000, up=999999999999999983222784.000000
  % 	x27 = 1,	Z1 = 28726707.5590403        
DEBUG EVAL: Second branch cutoff check: z=28726707.559040, best_z=INF, threshold=INF
  % Best branch is x31, Z0 = 28653137.0327721        , Z1 = 28803392.9899966        

DEBUG CAREFUL: Final result - returning best.var = 31
DEBUG BB: Branching variable chosen: j=31
 % @NC   73   43	x31 = 0	28653137.032772
 % @NC   74   43	x31 = 1	28803392.989997
 %      43    29 28636663.7460               28637311.3744    x4 D    23     4
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabbedc0
% @LO 0.10  28.63666374604197883968 99.9000000000
% @LN 0.10  28.63731137444405305814 99.9000000000
% Resuming node 53 at  28.63731137444405305814
DEBUG CONSTRNT: LP rows=50, pool->nlprows=50, pool->npend=0
DEBUG CONSTRNT: Checking 50 LP rows (pool tracks 50, total LP rows 50)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 105
DEBUG CONSTRNT: Pool row 105 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=49, expected 49
 % @PAP adding 51 rows, 227 nz to LP
DEBUG BB: Processing node 53, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=2, varin=47, theta=1.462724, up=999999999999999983222784.000000
ITER 2: row=17, varin=32, theta=0.159268, up=999999999999999983222784.000000
ITER 3: row=41, varin=23, theta=0.078022, up=999999999999999983222784.000000
ITER 4: row=31, varin=48, theta=1.011421, up=999999999999999983222784.000000
ITER 5: row=10, varin=85, theta=0.638708, up=1.000000
ITER 6: row=48, varin=82, theta=1.733246, up=1.000000
ITER 7: row=48, varin=10, theta=50690.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28637311.374444
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 949310.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 287 nonzeros, 2 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=86, theta=1.000000, up=1.000000
ITER 2: row=55, varin=77, theta=1.000000, up=1.000000
ITER 3: row=48, varin=25, theta=0.250000, up=999999999999999983222784.000000
ITER 4: row=10, varin=93, theta=1.100583, up=1.000000
ITER 5: row=10, varin=52, theta=0.403799, up=999999999999999983222784.000000
ITER 6: row=1, varin=78, theta=0.051893, up=1.000000
ITER 7: row=4, varin=93, theta=0.107200, up=1.000000
LP PHASE: Switching to primal (iter=7)
ITER 8: row=23, varin=30, theta=0.000000, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 28674517.810329
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 55 rows, 60 cols, 301 nonzeros, 1 slack, 54 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 8 rows, 39 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=57, varin=23, theta=0.253446, up=999999999999999983222784.000000
ITER 2: row=62, varin=57, theta=0.353914, up=999999999999999983222784.000000
ITER 3: row=10, varin=116, theta=0.034503, up=1.000000
ITER 4: row=55, varin=88, theta=0.332694, up=1.000000
ITER 5: row=50, varin=14, theta=0.070675, up=999999999999999983222784.000000
ITER 6: row=30, varin=100, theta=0.314313, up=1.000000
ITER 7: row=61, varin=62, theta=0.353252, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=62)
DEBUG SOLUTION: LP solution array indices: FST[63-102], not_covered[103-122]
DEBUG SOLUTION: lp->best_solution[0] = 28688474.492274
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.905976
  % @PL 62 rows, 60 cols, 338 nonzeros, 10 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 10 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=53, varin=44, theta=0.763515, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28688989.953447
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 53 rows, 60 cols, 294 nonzeros, 1 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 53 LP 1 Solution, length = 28688989.953447, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.081832 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.081832 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.081832 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.081832 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.081832 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.254505 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.254505 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.081832 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.254505 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.081832 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 1.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.081832 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.918168 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.918168 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.918168 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.918168 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.918168 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.918168 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.745495 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.745495 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.918168 (terminal 19)
 % 11 fractional variables
DEBUG CG: LP optimal, z=28688989.953447, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 53 at  28.68898995344694569098
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabbed00
% @LO 0.10  28.63731137444405305814 99.9000000000
% @LN 0.10  28.64205853071726792791 99.9000000000
% Resuming node 51 at  28.64205853071726792791
DEBUG CONSTRNT: LP rows=52, pool->nlprows=52, pool->npend=0
DEBUG CONSTRNT: Checking 52 LP rows (pool tracks 52, total LP rows 52)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 62
DEBUG CONSTRNT: Pool row 62 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=51, expected 51
 % @PAP adding 51 rows, 226 nz to LP
DEBUG BB: Processing node 51, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 51 LP 2 Solution, length = 28642058.530717, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.083333 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.083333 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.083333 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.083333 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.083333 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.500000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.083333 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.467704 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.083333 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.532296 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.916667 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.916667 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.916667 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.916667 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.916667 (terminal 19)
 % 10 fractional variables
DEBUG CG: LP optimal, z=28642058.530717, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28642058.530717, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 51 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 51
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.083333
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.083333)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.083333
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.083333)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.083333
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.083333)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=1.000000
DEBUG CAREFUL: Skipping var 9: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.083333
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.083333)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.500000
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.083333
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.083333)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.500000
DEBUG CAREFUL: Adding var 25 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.083333
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.083333)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.467704
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.467704)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.083333
DEBUG CAREFUL: Adding var 37 to fractional list (xi=0.083333)
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 10 fractional variables

  %  Carefully choosing branching variable, nfrac = 10
DEBUG CAREFUL: Testing fvar[0] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 12
DEBUG CAREFUL: New best var: 12
DEBUG CAREFUL: Testing fvar[1] = var 25
DEBUG CAREFUL: Calling compare_branch_vars for var 25
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 25
DEBUG CAREFUL: Testing fvar[2] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 4
DEBUG CAREFUL: New best var: 4
DEBUG CAREFUL: Testing fvar[3] = var 37
DEBUG CAREFUL: Calling compare_branch_vars for var 37
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 37
DEBUG CAREFUL: Testing fvar[4] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 22
DEBUG CAREFUL: Testing fvar[5] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[6] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[7] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 11
DEBUG CAREFUL: Testing fvar[8] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 27
DEBUG CAREFUL: Testing fvar[9] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 36
  % Initial guess is x4, Z0 = 28642058.5307173        , Z1 = 28844744.714354         

DEBUG EVAL: Testing var 12 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=16, varin=47, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 12 = 0 gives z=28677970.847290
  % 	x12 = 0,	Z0 = 28677970.8472901        
DEBUG EVAL: First branch cutoff check: z=28677970.847290, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 1
ITER 1: row=16, varin=44, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=15, varin=84, theta=0.457601, up=1.000000
  % 	x12 = 1,	Z1 = 28778253.4450047        
DEBUG EVAL: Second branch cutoff check: z=28778253.445005, best_z=INF, threshold=INF
  %   New best:  x12, Z = 28677970.8472901        
DEBUG EVAL: Testing var 25 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=37, varin=47, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 25 = 0 gives z=28677970.847290
  % 	x25 = 0,	Z0 = 28677970.8472901        
DEBUG EVAL: First branch cutoff check: z=28677970.847290, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 25 = 1
ITER 1: row=37, varin=17, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=15, varin=84, theta=0.247709, up=1.000000
  % 	x25 = 1,	Z1 = 29231017.9091051        
DEBUG EVAL: Second branch cutoff check: z=29231017.909105, best_z=INF, threshold=INF
  %   New best:  x25, Z = 28677970.8472901        
DEBUG EVAL: Testing var 4 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=23, varin=51, theta=1.375000, up=999999999999999983222784.000000
ITER 2: row=15, varin=84, theta=0.677298, up=1.000000
ITER 3: row=1, varin=30, theta=0.726106, up=999999999999999983222784.000000
ITER 4: row=4, varin=83, theta=43.097294, up=1.000000
ITER 5: row=4, varin=43, theta=2.717282, up=999999999999999983222784.000000
ITER 6: row=43, varin=33, theta=1.231329, up=999999999999999983222784.000000
ITER 7: row=50, varin=26, theta=1.342862, up=999999999999999983222784.000000
ITER 8: row=3, varin=29, theta=0.874198, up=999999999999999983222784.000000
ITER 9: row=29, varin=39, theta=4.154354, up=999999999999999983222784.000000
ITER 10: row=39, varin=47, theta=26.600254, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 4 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x4 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=23, varin=84, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28652019.231376
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 51 rows, 60 cols, 286 nonzeros, 0 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 4 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=87, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 28655956.703152
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 55 rows, 60 cols, 299 nonzeros, 0 slack, 55 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 2 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=56, varin=25, theta=0.250000, up=999999999999999983222784.000000
ITER 2: row=54, varin=52, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 28676927.234410
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 57 rows, 60 cols, 311 nonzeros, 5 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 5 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 51 at  28.67692723441034274856
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabb5780
% @LO 0.10  28.64205853071726792791 99.9000000000
% @LN 0.10  28.64926205276965021085 99.9000000000
% Resuming node 71 at  28.64926205276965021085
DEBUG CONSTRNT: LP rows=52, pool->nlprows=52, pool->npend=0
DEBUG CONSTRNT: Checking 52 LP rows (pool tracks 52, total LP rows 52)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=51, expected 51
 % @PAP adding 46 rows, 218 nz to LP
DEBUG BB: Processing node 71, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 71 LP 2 Solution, length = 28649262.052770, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.090909 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.090909 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.090909 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.090909 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.181818 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.181818 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.181818 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.090909 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.818182 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.909091 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.909091 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.818182 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.818182 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.909091 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.909091 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.909091 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.909091 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.818182 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.909091 (terminal 19)
 % 8 fractional variables
DEBUG CG: LP optimal, z=28649262.052770, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28649262.052770, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 71 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 71
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.090909
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.090909)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.090909
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.090909)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.090909
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.090909)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.090909
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.090909)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.181818
DEBUG CAREFUL: Adding var 23 to fractional list (xi=0.181818)
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.181818
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.181818)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.181818
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.181818)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.090909
DEBUG CAREFUL: Adding var 37 to fractional list (xi=0.090909)
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 8 fractional variables

  %  Carefully choosing branching variable, nfrac = 8
DEBUG CAREFUL: Testing fvar[0] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 2
DEBUG CAREFUL: New best var: 2
DEBUG CAREFUL: Testing fvar[1] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[2] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 11
DEBUG CAREFUL: New best var: 11
DEBUG CAREFUL: Testing fvar[3] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 36
DEBUG CAREFUL: Testing fvar[4] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 34
DEBUG CAREFUL: Testing fvar[5] = var 37
DEBUG CAREFUL: Calling compare_branch_vars for var 37
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 37
DEBUG CAREFUL: Testing fvar[6] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[7] = var 23
DEBUG CAREFUL: Calling compare_branch_vars for var 23
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 23
  % Initial guess is x11, Z0 = 28649262.0527696        , Z1 = 29144049.0821647        

DEBUG EVAL: Testing var 2 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=40, theta=2.222222, up=999999999999999983222784.000000
ITER 2: row=40, varin=45, theta=2.500000, up=999999999999999983222784.000000
ITER 3: row=31, varin=41, theta=1.500000, up=999999999999999983222784.000000
ITER 4: row=41, varin=33, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 1 gives z=28756773.056953
  % 	x2 = 1,	Z1 = 28756773.056953         
DEBUG EVAL: First branch cutoff check: z=28756773.056953, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 0
ITER 1: row=1, varin=69, theta=0.250000, up=1.000000
  % 	x2 = 0,	Z0 = 28650944.1516373        
DEBUG EVAL: Second branch cutoff check: z=28650944.151637, best_z=INF, threshold=INF
  %   New best:  x2, Z = 28650944.1516373        
DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=5, varin=40, theta=2.222222, up=999999999999999983222784.000000
ITER 2: row=40, varin=45, theta=2.500000, up=999999999999999983222784.000000
ITER 3: row=31, varin=41, theta=1.500000, up=999999999999999983222784.000000
ITER 4: row=41, varin=37, theta=1.500000, up=999999999999999983222784.000000
ITER 5: row=37, varin=35, theta=3.000000, up=999999999999999983222784.000000
ITER 6: row=6, varin=34, theta=0.750000, up=999999999999999983222784.000000
ITER 7: row=7, varin=57, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 3 = 1 gives z=28836541.556560
  % 	x3 = 1,	Z1 = 28836541.5565605        
DEBUG EVAL: First branch cutoff check: z=28836541.556560, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=5, varin=69, theta=0.250000, up=1.000000
  % 	x3 = 0,	Z0 = 28650944.1516373        
DEBUG EVAL: Second branch cutoff check: z=28650944.151637, best_z=INF, threshold=INF
  %   New best:  x3, Z = 28650944.1516373        
DEBUG EVAL: Testing var 11 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=20, varin=40, theta=2.222222, up=999999999999999983222784.000000
ITER 2: row=40, varin=45, theta=2.500000, up=999999999999999983222784.000000
ITER 3: row=31, varin=41, theta=1.500000, up=999999999999999983222784.000000
ITER 4: row=41, varin=37, theta=1.500000, up=999999999999999983222784.000000
ITER 5: row=37, varin=35, theta=3.000000, up=999999999999999983222784.000000
ITER 6: row=6, varin=36, theta=6.000000, up=999999999999999983222784.000000
ITER 7: row=7, varin=21, theta=1.666667, up=999999999999999983222784.000000
ITER 8: row=6, varin=57, theta=1.000000, up=1.000000
ITER 9: row=37, varin=18, theta=2.000000, up=999999999999999983222784.000000
ITER 10: row=18, varin=31, theta=4.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 11 = 1 gives z=29144049.082165
  % 	x11 = 1,	Z1 = 29144049.0821647        
DEBUG EVAL: First branch cutoff check: z=29144049.082165, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 11 = 0
ITER 1: row=20, varin=69, theta=0.250000, up=1.000000
  % 	x11 = 0,	Z0 = 28650944.1516373        
DEBUG EVAL: Second branch cutoff check: z=28650944.151637, best_z=INF, threshold=INF
  %   New best:  x11, Z = 28650944.1516373        
DEBUG EVAL: Testing var 36 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=13, varin=69, theta=3.000000, up=1.000000
ITER 2: row=13, varin=72, theta=2.000000, up=1.000000
ITER 3: row=13, varin=4, theta=0.500000, up=999999999999999983222784.000000
ITER 4: row=1, varin=36, theta=2.250000, up=999999999999999983222784.000000
ITER 5: row=7, varin=18, theta=1.250000, up=999999999999999983222784.000000
ITER 6: row=44, varin=72, theta=1.000000, up=1.000000
ITER 7: row=18, varin=74, theta=1.333333, up=1.000000
ITER 8: row=18, varin=75, theta=0.333333, up=1.000000
ITER 9: row=40, varin=33, theta=0.500000, up=999999999999999983222784.000000
ITER 10: row=5, varin=22, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 36 = 1 gives z=28908609.554318
  % 	x36 = 1,	Z1 = 28908609.5543181        
DEBUG EVAL: First branch cutoff check: z=28908609.554318, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 36 = 0
ITER 1: row=13, varin=35, theta=0.500000, up=999999999999999983222784.000000
  % 	x36 = 0,	Z0 = 28654490.6710649        
DEBUG EVAL: Second branch cutoff check: z=28654490.671065, best_z=INF, threshold=INF
  %   New best:  x36, Z = 28654490.6710649        
DEBUG EVAL: Testing var 34 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=18, varin=69, theta=3.000000, up=1.000000
ITER 2: row=18, varin=72, theta=2.000000, up=1.000000
ITER 3: row=18, varin=4, theta=0.500000, up=999999999999999983222784.000000
ITER 4: row=1, varin=36, theta=2.250000, up=999999999999999983222784.000000
ITER 5: row=7, varin=74, theta=1.666667, up=1.000000
ITER 6: row=7, varin=75, theta=0.666667, up=1.000000
ITER 7: row=40, varin=33, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=5, varin=22, theta=2.000000, up=999999999999999983222784.000000
ITER 9: row=7, varin=74, theta=2.000000, up=1.000000
ITER 10: row=7, varin=72, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 34 = 1 gives z=28984501.267409
  % 	x34 = 1,	Z1 = 28984501.2674091        
DEBUG EVAL: First branch cutoff check: z=28984501.267409, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 34 = 0
ITER 1: row=18, varin=35, theta=0.500000, up=999999999999999983222784.000000
  % 	x34 = 0,	Z0 = 28654490.6710649        
DEBUG EVAL: Second branch cutoff check: z=28654490.671065, best_z=INF, threshold=INF
  %   New best:  x34, Z = 28654490.6710649        
DEBUG EVAL: Testing var 37 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=31, varin=35, theta=1.111111, up=999999999999999983222784.000000
ITER 2: row=14, varin=69, theta=2.000000, up=1.000000
ITER 3: row=14, varin=36, theta=0.500000, up=999999999999999983222784.000000
ITER 4: row=7, varin=72, theta=1.000000, up=1.000000
ITER 5: row=44, varin=18, theta=0.500000, up=999999999999999983222784.000000
ITER 6: row=19, varin=22, theta=0.500000, up=999999999999999983222784.000000
ITER 7: row=21, varin=40, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=40, varin=44, theta=1.000000, up=999999999999999983222784.000000
ITER 9: row=7, varin=69, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 37 = 1 gives z=28808981.342130
  % 	x37 = 1,	Z1 = 28837965.6153195        
DEBUG EVAL: First branch cutoff check: z=28837965.615320, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 37 = 0
ITER 1: row=31, varin=69, theta=0.250000, up=1.000000
  % 	x37 = 0,	Z0 = 28650944.1516373        
DEBUG EVAL: Second branch cutoff check: z=28650944.151637, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=35, theta=1.111111, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28660881.204537
  % 	x10 = 1,	Z1 = 28763107.4584648        
DEBUG EVAL: First branch cutoff check: z=28763107.458465, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=6, varin=69, theta=0.250000, up=1.000000
  % 	x10 = 0,	Z0 = 28650944.1516373        
DEBUG EVAL: Second branch cutoff check: z=28650944.151637, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 23 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=35, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 23 = 0 gives z=28654490.671065
  % 	x23 = 0,	Z0 = 28654490.6710649        
DEBUG EVAL: First branch cutoff check: z=28654490.671065, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 23 = 1
ITER 1: row=7, varin=69, theta=3.000000, up=1.000000
  % 	x23 = 1,	Z1 = 28655990.4482401        
DEBUG EVAL: Second branch cutoff check: z=28655990.448240, best_z=INF, threshold=INF
  % Best branch is x34, Z0 = 28654490.6710649        , Z1 = 28984501.2674091        

DEBUG CAREFUL: Final result - returning best.var = 34
DEBUG BB: Branching variable chosen: j=34
 % @NC   75   71	x34 = 0	28654490.671065
 % @NC   76   71	x34 = 1	28984501.267409
 %      71    30 28649262.0528               28649621.2574    x4 D    65    16
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabde7c0
% @LO 0.10  28.64926205276965021085 99.9000000000
% @LN 0.10  28.64962125742557219610 99.9000000000
% Resuming node 60 at  28.64962125742557219610
DEBUG CONSTRNT: LP rows=46, pool->nlprows=46, pool->npend=0
DEBUG CONSTRNT: Checking 46 LP rows (pool tracks 46, total LP rows 46)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 162
DEBUG CONSTRNT: Pool row 162 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=45, expected 45
 % @PAP adding 43 rows, 233 nz to LP
DEBUG BB: Processing node 60, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=17, varin=40, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=9, varin=38, theta=0.470588, up=999999999999999983222784.000000
ITER 3: row=1, varin=39, theta=0.846154, up=999999999999999983222784.000000
ITER 4: row=18, varin=9, theta=0.500000, up=999999999999999983222784.000000
ITER 5: row=40, varin=35, theta=0.500000, up=999999999999999983222784.000000
ITER 6: row=35, varin=25, theta=0.346154, up=999999999999999983222784.000000
ITER 7: row=25, varin=31, theta=0.324324, up=999999999999999983222784.000000
ITER 8: row=31, varin=30, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28649621.257426
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 293 nonzeros, 1 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=7, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=7, varin=21, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28715650.382839
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 295 nonzeros, 4 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 4 rows, 17 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=6, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=43, varin=11, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=15, varin=68, theta=1.000000, up=1.000000
ITER 4: row=7, varin=51, theta=0.500000, up=1.000000
ITER 5: row=29, varin=48, theta=0.529412, up=1.000000
ITER 6: row=24, varin=74, theta=1.000000, up=1.000000
ITER 7: row=33, varin=69, theta=1.000000, up=1.000000
ITER 8: row=8, varin=47, theta=1.125000, up=1.000000
ITER 9: row=8, varin=56, theta=0.058824, up=1.000000
ITER 10: row=36, varin=47, theta=0.937500, up=1.000000
LP PHASE: Switching to primal (iter=14)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 29136806.201202
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 262 nonzeros, 6 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 4 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=20, theta=0.090909, up=999999999999999983222784.000000
ITER 2: row=40, varin=24, theta=1.489362, up=999999999999999983222784.000000
ITER 3: row=42, varin=17, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=27, varin=99, theta=1.000000, up=1.000000
ITER 5: row=34, varin=22, theta=2.750000, up=999999999999999983222784.000000
ITER 6: row=39, varin=21, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 29252892.227246
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 249 nonzeros, 3 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % Node 60 LP 1 Solution, length = 29252892.227246, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.250000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.250000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.250000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.250000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 1.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.750000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.750000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.750000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.750000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=29252892.227246, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 60 at  29.25289222724643423135
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabbca20
% @LO 0.10  28.64962125742557219610 99.9000000000
% @LN 0.10  28.65313703277212553644 99.9000000000
% Resuming node 73 at  28.65313703277212553644
DEBUG CONSTRNT: LP rows=39, pool->nlprows=39, pool->npend=0
DEBUG CONSTRNT: Checking 39 LP rows (pool tracks 39, total LP rows 39)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 73
DEBUG CONSTRNT: Pool row 73 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 158
DEBUG CONSTRNT: Pool row 158 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=38, expected 38
 % @PAP adding 50 rows, 188 nz to LP
DEBUG BB: Processing node 73, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=35, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28653137.032772
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 50 rows, 60 cols, 248 nonzeros, 3 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=39, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28675911.534857
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 53 rows, 60 cols, 256 nonzeros, 3 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 4 rows, 24 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=34, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 28682313.723392
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 54 rows, 60 cols, 268 nonzeros, 1 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 4 rows, 16 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=54, varin=44, theta=0.250000, up=999999999999999983222784.000000
ITER 2: row=52, varin=97, theta=1.000000, up=1.000000
ITER 3: row=51, varin=50, theta=0.100000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 28684683.799198
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 57 rows, 60 cols, 280 nonzeros, 7 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 7 slack rows
  % @PAP adding 3 rows, 11 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=46, theta=4.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28689922.295906
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 53 rows, 60 cols, 270 nonzeros, 2 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 73 LP 1 Solution, length = 28689922.295906, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.500000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.500000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.500000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28689922.295906, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 73 at  28.68992229590621434454
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabda810
% @LO 0.10  28.65313703277212553644 99.9000000000
% @LN 0.10  28.65449067106486680245 99.9000000000
% Resuming node 75 at  28.65449067106486680245
DEBUG CONSTRNT: LP rows=51, pool->nlprows=51, pool->npend=0
DEBUG CONSTRNT: Checking 51 LP rows (pool tracks 51, total LP rows 51)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 105
DEBUG CONSTRNT: Pool row 105 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 130
DEBUG CONSTRNT: Pool row 130 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=50, expected 50
 % @PAP adding 46 rows, 218 nz to LP
DEBUG BB: Processing node 75, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=18, varin=35, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28654490.671065
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 278 nonzeros, 1 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 75 LP 1 Solution, length = 28654490.671065, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.500000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 2 fractional variables
DEBUG CG: LP optimal, z=28654490.671065, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28654490.671065, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 75 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 75
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.500000
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.500000
DEBUG CAREFUL: Adding var 37 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 2 fractional variables

  %  Carefully choosing branching variable, nfrac = 2
DEBUG CAREFUL: Testing fvar[0] = var 37
DEBUG CAREFUL: Calling compare_branch_vars for var 37
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 37
DEBUG CAREFUL: New best var: 37
DEBUG CAREFUL: Testing fvar[1] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x37, Z0 = 28654490.6710649        , Z1 = 28837965.6153195        

DEBUG EVAL: Testing var 37 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=31, varin=69, theta=2.000000, up=1.000000
ITER 2: row=31, varin=36, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=1, varin=69, theta=1.000000, up=1.000000
ITER 4: row=7, varin=40, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=40, varin=22, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 37 = 1 gives z=28808981.342130
  % 	x37 = 1,	Z1 = 28837965.6153195        
DEBUG EVAL: First branch cutoff check: z=28837965.615320, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 37 = 0
ITER 1: row=31, varin=45, theta=0.400000, up=999999999999999983222784.000000
  % 	x37 = 0,	Z0 = 28662101.7766094        
DEBUG EVAL: Second branch cutoff check: z=28662101.776609, best_z=INF, threshold=INF
  %   New best:  x37, Z = 28662101.7766094        
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=69, theta=2.000000, up=1.000000
ITER 2: row=6, varin=36, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=1, varin=69, theta=1.000000, up=1.000000
ITER 4: row=7, varin=40, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=40, varin=22, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28808981.342130
  % 	x10 = 1,	Z1 = 28808981.3421297        
DEBUG EVAL: First branch cutoff check: z=28808981.342130, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=6, varin=18, theta=0.285714, up=999999999999999983222784.000000
ITER 2: row=35, varin=4, theta=0.066667, up=999999999999999983222784.000000
ITER 3: row=28, varin=69, theta=0.333333, up=1.000000
  % 	x10 = 0,	Z0 = 28675961.6311527        
DEBUG EVAL: Second branch cutoff check: z=28675961.631153, best_z=INF, threshold=INF
  %   New best:  x10, Z = 28675961.6311527        
  % Best branch is x10, Z0 = 28675961.6311527        , Z1 = 28808981.3421297        

DEBUG CAREFUL: Final result - returning best.var = 10
DEBUG BB: Branching variable chosen: j=10
 % @NC   77   75	x10 = 0	28675961.631153
 % @NC   78   75	x10 = 1	28808981.342130
 %      75    31 28654490.6711               28660815.7614   x34 D    71    17
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabd86b0
% @LO 0.10  28.65449067106486680245 99.9000000000
% @LN 0.10  28.66081576138495989881 99.9000000000
% Resuming node 61 at  28.66081576138495989881
DEBUG CONSTRNT: LP rows=46, pool->nlprows=46, pool->npend=0
DEBUG CONSTRNT: Checking 46 LP rows (pool tracks 46, total LP rows 46)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 162
DEBUG CONSTRNT: Pool row 162 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=45, expected 45
 % @PAP adding 49 rows, 224 nz to LP
DEBUG BB: Processing node 61, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 61 LP 3 Solution, length = 28660815.761385, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.443524 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.278238 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.278238 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.443524 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.278238 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.721762 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.556476 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.556476 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.721762 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.721762 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28660815.761385, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28660815.761385, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 61 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 61
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.443524
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.443524)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=1.000000
DEBUG CAREFUL: Skipping var 13: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.278238
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.278238)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.278238
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.278238)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.443524
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.443524)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.278238
DEBUG CAREFUL: Adding var 39 to fractional list (xi=0.278238)
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 2
DEBUG CAREFUL: New best var: 2
DEBUG CAREFUL: Testing fvar[1] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 27
DEBUG CAREFUL: Testing fvar[2] = var 39
DEBUG CAREFUL: Calling compare_branch_vars for var 39
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 39
DEBUG CAREFUL: Testing fvar[3] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
DEBUG CAREFUL: Testing fvar[4] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 22
  % Initial guess is x17, Z0 = 28660815.761385         , Z1 = 28750684.2599523        

DEBUG EVAL: Testing var 2 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=49, theta=0.491454, up=999999999999999983222784.000000
ITER 2: row=44, varin=46, theta=0.082818, up=999999999999999983222784.000000
ITER 3: row=38, varin=39, theta=0.105841, up=999999999999999983222784.000000
ITER 4: row=32, varin=44, theta=0.179254, up=999999999999999983222784.000000
ITER 5: row=42, varin=48, theta=98139.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 1 gives z=28741862.130184
  % 	x2 = 1,	Z1 = 28741862.1301835        
DEBUG EVAL: First branch cutoff check: z=28741862.130184, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 0
ITER 1: row=2, varin=22, theta=0.354877, up=999999999999999983222784.000000
ITER 2: row=47, varin=32, theta=2.061514, up=999999999999999983222784.000000
  % 	x2 = 0,	Z0 = 1.79769313486232e+308   
DEBUG EVAL: Second branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=2, varin=49, theta=0.491454, up=999999999999999983222784.000000
ITER 2: row=44, varin=46, theta=0.082818, up=999999999999999983222784.000000
ITER 3: row=38, varin=39, theta=0.105841, up=999999999999999983222784.000000
ITER 4: row=32, varin=44, theta=0.179254, up=999999999999999983222784.000000
ITER 5: row=42, varin=48, theta=98139.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28741862.130184
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 49 rows, 60 cols, 284 nonzeros, 1 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=42, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28750684.259952
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 49 rows, 60 cols, 246 nonzeros, 2 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
   % @PAP adding 2 rows, 44 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=82, theta=0.976613, up=1.000000
ITER 2: row=43, varin=83, theta=0.961076, up=1.000000
ITER 3: row=39, varin=38, theta=1.353637, up=999999999999999983222784.000000
ITER 4: row=2, varin=89, theta=2.311895, up=1.000000
ITER 5: row=2, varin=22, theta=4.956534, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 49 rows, 60 cols, 286 nonzeros, 5 slack, 44 tight.
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 61 at 1000000000000000000.00000000000000000000
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabbe180
% @LO 0.10  28.66081576138495989881 99.9000000000
% @LN 0.10  28.66950798850798776130 99.9000000000
% Resuming node 69 at  28.66950798850798776130
DEBUG CONSTRNT: LP rows=49, pool->nlprows=49, pool->npend=0
DEBUG CONSTRNT: Checking 49 LP rows (pool tracks 49, total LP rows 49)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=48, expected 48
 % @PAP adding 52 rows, 199 nz to LP
DEBUG BB: Processing node 69, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=23, varin=43, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28669507.988508
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 259 nonzeros, 1 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 20 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=53, varin=78, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 28670635.204353
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 55 rows, 60 cols, 279 nonzeros, 2 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 4 rows, 19 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=54, varin=83, theta=1.000000, up=1.000000
ITER 2: row=53, varin=24, theta=0.083333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 28681479.768443
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 57 rows, 60 cols, 282 nonzeros, 1 slack, 56 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 3 rows, 11 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=57, varin=24, theta=0.388889, up=999999999999999983222784.000000
ITER 2: row=35, varin=52, theta=5.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=59)
DEBUG SOLUTION: LP solution array indices: FST[60-99], not_covered[100-119]
DEBUG SOLUTION: lp->best_solution[0] = 28710534.283514
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 59 rows, 60 cols, 291 nonzeros, 2 slack, 57 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 69 LP 1 Solution, length = 28710534.283514, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.500000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.500000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.500000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28710534.283514, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 69 at  28.71053428351405756302
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabb5780
% @LO 0.10  28.66950798850798776130 99.9000000000
% @LN 0.10  28.67596163115269902733 99.9000000000
% Resuming node 77 at  28.67596163115269902733
DEBUG CONSTRNT: LP rows=57, pool->nlprows=57, pool->npend=0
DEBUG CONSTRNT: Checking 57 LP rows (pool tracks 57, total LP rows 57)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 70
DEBUG CONSTRNT: Pool row 70 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=56, expected 56
 % @PAP adding 46 rows, 218 nz to LP
DEBUG BB: Processing node 77, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=6, varin=18, theta=0.285714, up=999999999999999983222784.000000
ITER 2: row=35, varin=4, theta=0.066667, up=999999999999999983222784.000000
ITER 3: row=28, varin=69, theta=0.333333, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28675961.631153
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 278 nonzeros, 1 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 19 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=76, theta=0.333333, up=1.000000
ITER 2: row=44, varin=27, theta=0.064516, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28686556.983608
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 0.838710
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.935484
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 297 nonzeros, 5 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=14, theta=0.062500, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28698893.038646
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.937500
  % @PL 47 rows, 60 cols, 291 nonzeros, 2 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 3 rows, 18 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=76, theta=0.333333, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28702985.768402
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 305 nonzeros, 0 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=79, theta=0.333333, up=1.000000
ITER 2: row=20, varin=9, theta=0.035714, up=999999999999999983222784.000000
ITER 3: row=22, varin=7, theta=0.090909, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28709339.754722
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.909091
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 311 nonzeros, 5 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % Node 77 LP 1 Solution, length = 28709339.754722, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.090909 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.090909 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.090909 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.090909 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.272727 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.090909 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.272727 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.727273 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.909091 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.909091 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.727273 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.909091 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.909091 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.727273 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.909091 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=28709339.754722, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 77 at  28.70933975472197019485
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabbed00
% @LO 0.10  28.67596163115269902733 99.9000000000
% @LN 0.10  28.67692723441034274856 99.9000000000
% Resuming node 51 at  28.67692723441034274856
DEBUG CONSTRNT: LP rows=45, pool->nlprows=45, pool->npend=0
DEBUG CONSTRNT: Checking 45 LP rows (pool tracks 45, total LP rows 45)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 162
DEBUG CONSTRNT: Pool row 162 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 70
DEBUG CONSTRNT: Pool row 70 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 73
DEBUG CONSTRNT: Pool row 73 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=44, expected 44
 % @PAP adding 52 rows, 234 nz to LP
DEBUG BB: Processing node 51, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 51 LP 3 Solution, length = 28676927.234410, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.500000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.500000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.500000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.205442 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.794558 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28676927.234410, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28676927.234410, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 51 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 51
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.500000
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=1.000000
DEBUG CAREFUL: Skipping var 9: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.500000
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.500000
DEBUG CAREFUL: Adding var 25 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.500000
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.500000
DEBUG CAREFUL: Adding var 30 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.205442
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.205442)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 12
DEBUG CAREFUL: New best var: 12
DEBUG CAREFUL: Testing fvar[1] = var 25
DEBUG CAREFUL: Calling compare_branch_vars for var 25
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 25
DEBUG CAREFUL: New best var: 25
DEBUG CAREFUL: Testing fvar[2] = var 30
DEBUG CAREFUL: Calling compare_branch_vars for var 30
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 30
DEBUG CAREFUL: Testing fvar[3] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[4] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 29
DEBUG CAREFUL: Testing fvar[5] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 36
  % Initial guess is x25, Z0 = 28677970.8472901        , Z1 = 29231017.9091051        

DEBUG EVAL: Testing var 12 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=16, varin=44, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=15, varin=29, theta=0.127552, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 12 = 0 gives z=28762855.544247
  % 	x12 = 0,	Z0 = 28762855.5442474        
DEBUG EVAL: First branch cutoff check: z=28762855.544247, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 1
ITER 1: row=16, varin=41, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=15, varin=29, theta=0.263511, up=999999999999999983222784.000000
  % 	x12 = 1,	Z1 = 28870167.7439481        
DEBUG EVAL: Second branch cutoff check: z=28870167.743948, best_z=INF, threshold=INF
  %   New best:  x12, Z = 28762855.5442474        
DEBUG EVAL: Testing var 25 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=20, varin=44, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=15, varin=29, theta=0.127552, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 25 = 0 gives z=28762855.544247
  % 	x25 = 0,	Z0 = 28762855.5442474        
DEBUG EVAL: First branch cutoff check: z=28762855.544247, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 25 = 1
ITER 1: row=20, varin=17, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=15, varin=29, theta=0.212834, up=999999999999999983222784.000000
  % 	x25 = 1,	Z1 = 29321095.482525         
DEBUG EVAL: Second branch cutoff check: z=29321095.482525, best_z=INF, threshold=INF
  %   New best:  x25, Z = 28762855.5442474        
DEBUG EVAL: Testing var 30 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=35, varin=51, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=51, varin=49, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=49, varin=48, theta=0.125000, up=999999999999999983222784.000000
ITER 4: row=52, varin=45, theta=0.444444, up=999999999999999983222784.000000
ITER 5: row=15, varin=29, theta=0.153876, up=999999999999999983222784.000000
ITER 6: row=23, varin=40, theta=0.804077, up=999999999999999983222784.000000
ITER 7: row=40, varin=32, theta=0.606736, up=999999999999999983222784.000000
ITER 8: row=47, varin=44, theta=7.091014, up=999999999999999983222784.000000
ITER 9: row=16, varin=23, theta=0.199271, up=999999999999999983222784.000000
ITER 10: row=52, varin=65, theta=0.822544, up=1.000000
DEBUG EVAL: Branch var 30 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x30 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=35, varin=31, theta=0.083333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28694410.572610
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 52 rows, 60 cols, 294 nonzeros, 2 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
   % @PAP adding 2 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=48, theta=0.100000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28702888.840857
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 52 rows, 60 cols, 289 nonzeros, 2 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 51 at  28.70288884085734082419
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabbedc0
% @LO 0.10  28.67692723441034274856 99.9000000000
% @LN 0.10  28.68898995344694569098 99.9000000000
% Resuming node 53 at  28.68898995344694569098
DEBUG CONSTRNT: LP rows=50, pool->nlprows=50, pool->npend=0
DEBUG CONSTRNT: Checking 50 LP rows (pool tracks 50, total LP rows 50)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=49, expected 49
 % @PAP adding 52 rows, 227 nz to LP
DEBUG BB: Processing node 53, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 53 LP 2 Solution, length = 28688989.953447, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.081832 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.081832 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.081832 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.081832 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.081832 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.254505 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.254505 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.081832 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.254505 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.081832 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 1.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.081832 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.918168 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.918168 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.918168 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.918168 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.918168 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.918168 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.745495 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.745495 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.918168 (terminal 19)
 % 11 fractional variables
DEBUG CG: LP optimal, z=28688989.953447, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28688989.953447, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 53 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 53
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.081832
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.081832)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.081832
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.081832)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.081832
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.081832)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=1.000000
DEBUG CAREFUL: Skipping var 8: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.081832
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.081832)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.081832
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.081832)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.254505
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.254505)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.254505
DEBUG CAREFUL: Adding var 21 to fractional list (xi=0.254505)
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.081832
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.081832)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.254505
DEBUG CAREFUL: Adding var 25 to fractional list (xi=0.254505)
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.081832
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.081832)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=1.000000
DEBUG CAREFUL: Skipping var 36: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.081832
DEBUG CAREFUL: Adding var 37 to fractional list (xi=0.081832)
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 11 fractional variables

  %  Carefully choosing branching variable, nfrac = 11
DEBUG CAREFUL: Testing fvar[0] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 22
DEBUG CAREFUL: New best var: 22
DEBUG CAREFUL: Testing fvar[1] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 26
DEBUG CAREFUL: New best var: 26
DEBUG CAREFUL: Testing fvar[2] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[3] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 11
DEBUG CAREFUL: Testing fvar[4] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[5] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 4
DEBUG CAREFUL: New best var: 4
DEBUG CAREFUL: Testing fvar[6] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[7] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
DEBUG CAREFUL: Testing fvar[8] = var 21
DEBUG CAREFUL: Calling compare_branch_vars for var 21
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 21
DEBUG CAREFUL: Testing fvar[9] = var 25
DEBUG CAREFUL: Calling compare_branch_vars for var 25
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 25
DEBUG CAREFUL: Testing fvar[10] = var 37
DEBUG CAREFUL: Calling compare_branch_vars for var 37
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 37
  % Initial guess is x4, Z0 = 28688989.9534469        , Z1 = 28901535.7863583        

DEBUG EVAL: Testing var 22 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=39, varin=25, theta=1.189244, up=999999999999999983222784.000000
ITER 2: row=50, varin=51, theta=9.584199, up=999999999999999983222784.000000
ITER 3: row=48, varin=36, theta=1.957051, up=999999999999999983222784.000000
ITER 4: row=41, varin=89, theta=6.346596, up=1.000000
ITER 5: row=41, varin=39, theta=1.114180, up=999999999999999983222784.000000
ITER 6: row=11, varin=5, theta=0.117958, up=999999999999999983222784.000000
ITER 7: row=31, varin=24, theta=0.268953, up=999999999999999983222784.000000
ITER 8: row=47, varin=41, theta=0.352189, up=999999999999999983222784.000000
ITER 9: row=10, varin=27, theta=0.363718, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 22 = 1 gives z=29560432.957366
  % 	x22 = 1,	Z1 = 29560432.9573659        
DEBUG EVAL: First branch cutoff check: z=29560432.957366, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 22 = 0
ITER 1: row=39, varin=48, theta=0.079102, up=999999999999999983222784.000000
  % 	x22 = 0,	Z0 = 28689727.4098888        
DEBUG EVAL: Second branch cutoff check: z=28689727.409889, best_z=INF, threshold=INF
  %   New best:  x22, Z = 28689727.4098888        
DEBUG EVAL: Testing var 26 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=30, varin=5, theta=0.463701, up=999999999999999983222784.000000
ITER 2: row=31, varin=26, theta=2.582725, up=999999999999999983222784.000000
ITER 3: row=37, varin=51, theta=9.584199, up=999999999999999983222784.000000
ITER 4: row=48, varin=38, theta=1.221570, up=999999999999999983222784.000000
ITER 5: row=4, varin=37, theta=0.469502, up=999999999999999983222784.000000
ITER 6: row=31, varin=89, theta=1.151153, up=1.000000
ITER 7: row=31, varin=24, theta=0.074196, up=999999999999999983222784.000000
ITER 8: row=47, varin=39, theta=0.097158, up=999999999999999983222784.000000
ITER 9: row=10, varin=36, theta=0.103511, up=999999999999999983222784.000000
ITER 10: row=25, varin=11, theta=0.122272, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 1 gives z=29063493.620499
  % 	x26 = 1,	Z1 = 29063493.6204987        
DEBUG EVAL: First branch cutoff check: z=29063493.620499, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 0
ITER 1: row=30, varin=52, theta=3.561308, up=999999999999999983222784.000000
ITER 2: row=20, varin=86, theta=1.701321, up=1.000000
ITER 3: row=20, varin=32, theta=0.105054, up=999999999999999983222784.000000
ITER 4: row=44, varin=86, theta=1.000000, up=1.000000
ITER 5: row=42, varin=65, theta=4.996930, up=1.000000
ITER 6: row=42, varin=48, theta=0.679700, up=999999999999999983222784.000000
ITER 7: row=39, varin=3, theta=0.213593, up=999999999999999983222784.000000
  % 	x26 = 0,	Z0 = 28701203.2066263        
DEBUG EVAL: Second branch cutoff check: z=28701203.206626, best_z=INF, threshold=INF
  %   New best:  x26, Z = 28701203.2066263        
DEBUG EVAL: Testing var 3 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=4, varin=26, theta=0.126970, up=999999999999999983222784.000000
ITER 2: row=37, varin=52, theta=3.561308, up=999999999999999983222784.000000
ITER 3: row=20, varin=86, theta=1.701321, up=1.000000
ITER 4: row=20, varin=32, theta=0.105054, up=999999999999999983222784.000000
ITER 5: row=44, varin=86, theta=1.000000, up=1.000000
ITER 6: row=42, varin=65, theta=4.996930, up=1.000000
ITER 7: row=42, varin=48, theta=0.679700, up=999999999999999983222784.000000
ITER 8: row=39, varin=3, theta=0.213593, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 0 gives z=28701203.206626
  % 	x3 = 0,	Z0 = 28701203.2066263        
DEBUG EVAL: First branch cutoff check: z=28701203.206626, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 1
ITER 1: row=4, varin=51, theta=9.584199, up=999999999999999983222784.000000
ITER 2: row=48, varin=36, theta=1.957051, up=999999999999999983222784.000000
ITER 3: row=41, varin=89, theta=6.346596, up=1.000000
ITER 4: row=41, varin=39, theta=1.114180, up=999999999999999983222784.000000
ITER 5: row=5, varin=41, theta=0.352189, up=999999999999999983222784.000000
ITER 6: row=10, varin=24, theta=0.268953, up=999999999999999983222784.000000
ITER 7: row=47, varin=38, theta=0.375220, up=999999999999999983222784.000000
ITER 8: row=25, varin=32, theta=0.333409, up=999999999999999983222784.000000
ITER 9: row=2, varin=34, theta=1.049738, up=999999999999999983222784.000000
ITER 10: row=1, varin=80, theta=0.241118, up=1.000000
  % 	x3 = 1,	Z1 = 29678801.7552631        
DEBUG EVAL: Second branch cutoff check: z=29678801.755263, best_z=INF, threshold=INF
  %   New best:  x3, Z = 28701203.2066263        
DEBUG EVAL: Testing var 11 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=25, varin=26, theta=2.582725, up=999999999999999983222784.000000
ITER 2: row=37, varin=51, theta=9.584199, up=999999999999999983222784.000000
ITER 3: row=48, varin=89, theta=6.346596, up=1.000000
ITER 4: row=48, varin=24, theta=2.624464, up=999999999999999983222784.000000
ITER 5: row=47, varin=27, theta=2.351251, up=999999999999999983222784.000000
ITER 6: row=36, varin=11, theta=2.599810, up=999999999999999983222784.000000
ITER 7: row=49, varin=83, theta=4.437896, up=1.000000
ITER 8: row=49, varin=39, theta=2.203423, up=999999999999999983222784.000000
ITER 9: row=10, varin=83, theta=18.381241, up=1.000000
ITER 10: row=10, varin=80, theta=3.000496, up=1.000000
DEBUG EVAL: Branch var 11 = 1 gives z=30534815.591258
  % 	x11 = 1,	Z1 = 30534815.5912584        
DEBUG EVAL: First branch cutoff check: z=30534815.591258, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 11 = 0
ITER 1: row=25, varin=52, theta=3.561308, up=999999999999999983222784.000000
  % 	x11 = 0,	Z0 = 28695497.9046719        
DEBUG EVAL: Second branch cutoff check: z=28695497.904672, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=5, varin=52, theta=3.561308, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28695497.904672
  % 	x10 = 0,	Z0 = 28695497.9046719        
DEBUG EVAL: First branch cutoff check: z=28695497.904672, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 4 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=10, varin=25, theta=1.189244, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 4 = 1 gives z=28824802.961646
  % 	x4 = 1,	Z1 = 28901535.7863583        
DEBUG EVAL: First branch cutoff check: z=28901535.786358, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 4 = 0
ITER 1: row=10, varin=26, theta=0.126970, up=999999999999999983222784.000000
  % 	x4 = 0,	Z0 = 28693640.3952468        
DEBUG EVAL: Second branch cutoff check: z=28693640.395247, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=52, theta=3.561308, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28695497.904672
  % 	x2 = 0,	Z0 = 28695497.9046719        
DEBUG EVAL: First branch cutoff check: z=28695497.904672, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 12 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=20, varin=32, theta=0.160781, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 12 = 0 gives z=28691003.218989
  % 	x12 = 0,	Z0 = 28691003.2189889        
DEBUG EVAL: First branch cutoff check: z=28691003.218989, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 21 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=36, varin=32, theta=0.160781, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 21 = 0 gives z=28691003.218989
  % 	x21 = 0,	Z0 = 28691003.218989         
DEBUG EVAL: First branch cutoff check: z=28691003.218989, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 25 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=42, varin=48, theta=1.235264, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 25 = 1 gives z=28700506.088210
  % 	x25 = 1,	Z1 = 28709548.7344257        
DEBUG EVAL: First branch cutoff check: z=28709548.734426, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 25 = 0
ITER 1: row=42, varin=52, theta=0.590408, up=999999999999999983222784.000000
  % 	x25 = 0,	Z0 = 28690068.8686063        
DEBUG EVAL: Second branch cutoff check: z=28690068.868606, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 37 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=48, varin=26, theta=2.582725, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 37 = 1 gives z=28783585.706281
  % 	x37 = 1,	Z1 = 28783585.7062807        
DEBUG EVAL: First branch cutoff check: z=28783585.706281, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 37 = 0
ITER 1: row=48, varin=51, theta=0.090502, up=999999999999999983222784.000000
  % 	x37 = 0,	Z0 = 28690355.6636003        
DEBUG EVAL: Second branch cutoff check: z=28690355.663600, best_z=INF, threshold=INF
  % Best branch is x3, Z0 = 28701203.2066263        , Z1 = 29678801.7552631        

DEBUG CAREFUL: Final result - returning best.var = 3
DEBUG BB: Branching variable chosen: j=3
 % @NC   79   53	x3 = 0	28701203.206626
 % @NC   80   53	x3 = 1	29678801.755263
 %      53    32 28688989.9534               28689922.2959    x1 D    29     9
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabbca20
% @LO 0.11  28.68898995344694569098 99.9000000000
% @LN 0.11  28.68992229590621434454 99.9000000000
% Resuming node 73 at  28.68992229590621434454
DEBUG CONSTRNT: LP rows=52, pool->nlprows=52, pool->npend=0
DEBUG CONSTRNT: Checking 52 LP rows (pool tracks 52, total LP rows 52)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 62
DEBUG CONSTRNT: Pool row 62 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=51, expected 51
 % @PAP adding 51 rows, 198 nz to LP
DEBUG BB: Processing node 73, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 73 LP 2 Solution, length = 28689922.295906, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.500000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.500000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.500000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28689922.295906, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28689922.295906, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 73 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 73
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.500000
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.500000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.500000
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.500000
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.500000
DEBUG CAREFUL: Adding var 32 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 2
DEBUG CAREFUL: New best var: 2
DEBUG CAREFUL: Testing fvar[1] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 27
DEBUG CAREFUL: Testing fvar[2] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 1
DEBUG CAREFUL: New best var: 1
DEBUG CAREFUL: Testing fvar[3] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 29
DEBUG CAREFUL: New best var: 29
DEBUG CAREFUL: Testing fvar[4] = var 32
DEBUG CAREFUL: Calling compare_branch_vars for var 32
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 32
  % Initial guess is x29, Z0 = 28689922.2959062        , Z1 = 29414312.9447817        

DEBUG EVAL: Testing var 2 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=50, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=50, varin=48, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=9, varin=46, theta=0.500000, up=999999999999999983222784.000000
ITER 4: row=51, varin=44, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 1 gives z=28726707.559040
  % 	x2 = 1,	Z1 = 28726707.5590403        
DEBUG EVAL: First branch cutoff check: z=28726707.559040, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 0
ITER 1: row=2, varin=43, theta=0.500000, up=999999999999999983222784.000000
  % 	x2 = 0,	Z0 = 28704388.9109613        
DEBUG EVAL: Second branch cutoff check: z=28704388.910961, best_z=INF, threshold=INF
  %   New best:  x2, Z = 28704388.9109613        
DEBUG EVAL: Testing var 27 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=50, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=50, varin=48, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=9, varin=46, theta=0.500000, up=999999999999999983222784.000000
ITER 4: row=51, varin=44, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 27 = 1 gives z=28726707.559040
  % 	x27 = 1,	Z1 = 28726707.5590403        
DEBUG EVAL: First branch cutoff check: z=28726707.559040, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 27 = 0
ITER 1: row=7, varin=43, theta=0.500000, up=999999999999999983222784.000000
  % 	x27 = 0,	Z0 = 28704388.9109613        
DEBUG EVAL: Second branch cutoff check: z=28704388.910961, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 1 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=50, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=50, varin=48, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=9, varin=46, theta=0.500000, up=999999999999999983222784.000000
ITER 4: row=51, varin=42, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 1 gives z=28748856.030668
  % 	x1 = 1,	Z1 = 28813465.2023231        
DEBUG EVAL: First branch cutoff check: z=28813465.202323, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 0
ITER 1: row=1, varin=43, theta=0.500000, up=999999999999999983222784.000000
  % 	x1 = 0,	Z0 = 28704388.9109613        
DEBUG EVAL: Second branch cutoff check: z=28704388.910961, best_z=INF, threshold=INF
  %   New best:  x1, Z = 28704388.9109613        
DEBUG EVAL: Testing var 29 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=24, varin=50, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=50, varin=48, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=9, varin=46, theta=0.500000, up=999999999999999983222784.000000
ITER 4: row=51, varin=42, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 29 = 1 gives z=28748856.030668
  % 	x29 = 1,	Z1 = 29414312.9447817        
DEBUG EVAL: First branch cutoff check: z=29414312.944782, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 29 = 0
ITER 1: row=24, varin=43, theta=0.500000, up=999999999999999983222784.000000
  % 	x29 = 0,	Z0 = 28704388.9109613        
DEBUG EVAL: Second branch cutoff check: z=28704388.910961, best_z=INF, threshold=INF
  %   New best:  x29, Z = 28704388.9109613        
DEBUG EVAL: Testing var 32 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=40, varin=43, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 32 = 0 gives z=28704388.910961
  % 	x32 = 0,	Z0 = 28704388.9109613        
DEBUG EVAL: First branch cutoff check: z=28704388.910961, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 32 = 1
ITER 1: row=40, varin=50, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=50, varin=48, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=9, varin=46, theta=0.500000, up=999999999999999983222784.000000
ITER 4: row=51, varin=43, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=46, varin=11, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=11, varin=16, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=16, varin=40, theta=1.000000, up=999999999999999983222784.000000
  % 	x32 = 1,	Z1 = 28909910.0897251        
DEBUG EVAL: Second branch cutoff check: z=28909910.089725, best_z=INF, threshold=INF
  % Best branch is x29, Z0 = 28704388.9109613        , Z1 = 29414312.9447817        

DEBUG CAREFUL: Final result - returning best.var = 29
DEBUG BB: Branching variable chosen: j=29
 % @NC   81   73	x29 = 0	28704388.910961
 % @NC   82   73	x29 = 1	29414312.944782
 %      73    33 28689922.2959               28701203.2066   x31 D    43     5
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabda810
% @LO 0.11  28.68992229590621434454 99.9000000000
% @LN 0.11  28.70120320662624990860 99.9000000000
% Resuming node 79 at  28.70120320662624990860
DEBUG CONSTRNT: LP rows=51, pool->nlprows=51, pool->npend=0
DEBUG CONSTRNT: Checking 51 LP rows (pool tracks 51, total LP rows 51)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 105
DEBUG CONSTRNT: Pool row 105 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 130
DEBUG CONSTRNT: Pool row 130 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=50, expected 50
 % @PAP adding 52 rows, 227 nz to LP
DEBUG BB: Processing node 79, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=4, varin=26, theta=0.126970, up=999999999999999983222784.000000
ITER 2: row=37, varin=52, theta=3.561308, up=999999999999999983222784.000000
ITER 3: row=20, varin=86, theta=1.701321, up=1.000000
ITER 4: row=20, varin=32, theta=0.105054, up=999999999999999983222784.000000
ITER 5: row=44, varin=86, theta=1.000000, up=1.000000
ITER 6: row=42, varin=65, theta=4.996930, up=1.000000
ITER 7: row=42, varin=48, theta=0.679700, up=999999999999999983222784.000000
ITER 8: row=39, varin=3, theta=0.213593, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28701203.206626
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.786407
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 287 nonzeros, 4 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 4 rows, 9 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=75, theta=0.184905, up=1.000000
ITER 2: row=51, varin=49, theta=1.583516, up=999999999999999983222784.000000
ITER 3: row=9, varin=65, theta=2.023870, up=1.000000
ITER 4: row=9, varin=9, theta=117614.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28703387.857505
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 2.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 882386.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 288 nonzeros, 2 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 1 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=64, theta=0.500000, up=1.000000
ITER 2: row=43, varin=77, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28706468.295965
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 2.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 250 nonzeros, 0 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 79 LP 1 Solution, length = 28706468.295965, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.500000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.500000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 1.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28706468.295965, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 79 at  28.70646829596516624861
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabbed00
% @LO 0.11  28.70120320662624990860 99.9000000000
% @LN 0.11  28.70288884085734082419 99.9000000000
% Resuming node 51 at  28.70288884085734082419
DEBUG CONSTRNT: LP rows=51, pool->nlprows=51, pool->npend=0
DEBUG CONSTRNT: Checking 51 LP rows (pool tracks 51, total LP rows 51)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 62
DEBUG CONSTRNT: Pool row 62 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=50, expected 50
 % @PAP adding 50 rows, 223 nz to LP
DEBUG BB: Processing node 51, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 51 LP 4 Solution, length = 28702888.840857, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.100000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.100000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.100000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.100000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.500000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.100000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.100000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.499484 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.100000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500516 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.900000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.900000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.900000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.900000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.900000 (terminal 19)
 % 10 fractional variables
DEBUG CG: LP optimal, z=28702888.840857, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28702888.840857, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 51 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 51
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.100000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.100000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.100000
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.100000)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=1.000000
DEBUG CAREFUL: Skipping var 9: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.100000
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.100000)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.500000
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.100000
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.100000)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.500000
DEBUG CAREFUL: Adding var 25 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.100000
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.100000)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.100000
DEBUG CAREFUL: Adding var 31 to fractional list (xi=0.100000)
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.499484
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.499484)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.100000
DEBUG CAREFUL: Adding var 37 to fractional list (xi=0.100000)
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 10 fractional variables

  %  Carefully choosing branching variable, nfrac = 10
DEBUG CAREFUL: Testing fvar[0] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 12
DEBUG CAREFUL: New best var: 12
DEBUG CAREFUL: Testing fvar[1] = var 25
DEBUG CAREFUL: Calling compare_branch_vars for var 25
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 25
DEBUG CAREFUL: New best var: 25
DEBUG CAREFUL: Testing fvar[2] = var 37
DEBUG CAREFUL: Calling compare_branch_vars for var 37
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 37
DEBUG CAREFUL: Testing fvar[3] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 22
DEBUG CAREFUL: Testing fvar[4] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[5] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[6] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 11
DEBUG CAREFUL: Testing fvar[7] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 27
DEBUG CAREFUL: Testing fvar[8] = var 31
DEBUG CAREFUL: Calling compare_branch_vars for var 31
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 31
DEBUG CAREFUL: Testing fvar[9] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 36
  % Initial guess is x25, Z0 = 28762855.5442474        , Z1 = 29321095.482525         

DEBUG EVAL: Testing var 12 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=16, varin=43, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 12 = 0 gives z=28799631.467570
  % 	x12 = 0,	Z0 = 28799631.4675702        
DEBUG EVAL: First branch cutoff check: z=28799631.467570, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 1
ITER 1: row=16, varin=40, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=42, varin=29, theta=0.350397, up=999999999999999983222784.000000
  % 	x12 = 1,	Z1 = 28913476.8867486        
DEBUG EVAL: Second branch cutoff check: z=28913476.886749, best_z=INF, threshold=INF
  %   New best:  x12, Z = 28799631.4675702        
DEBUG EVAL: Testing var 25 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=35, varin=43, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 25 = 0 gives z=28799631.467570
  % 	x25 = 0,	Z0 = 28799631.4675702        
DEBUG EVAL: First branch cutoff check: z=28799631.467570, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 25 = 1
ITER 1: row=35, varin=17, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=42, varin=29, theta=0.157261, up=999999999999999983222784.000000
  % 	x25 = 1,	Z1 = 29357922.2937942        
DEBUG EVAL: Second branch cutoff check: z=29357922.293794, best_z=INF, threshold=INF
  %   New best:  x25, Z = 28799631.4675702        
DEBUG EVAL: Testing var 37 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=39, varin=29, theta=0.250000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 37 = 0 gives z=28719069.692022
  % 	x37 = 0,	Z0 = 28719069.6920221        
DEBUG EVAL: First branch cutoff check: z=28719069.692022, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 22 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=28, varin=29, theta=0.250000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 22 = 0 gives z=28719069.692022
  % 	x22 = 0,	Z0 = 28719069.6920221        
DEBUG EVAL: First branch cutoff check: z=28719069.692022, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 2 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=29, theta=1.500000, up=999999999999999983222784.000000
ITER 2: row=15, varin=48, theta=0.773376, up=999999999999999983222784.000000
ITER 3: row=4, varin=87, theta=0.797264, up=1.000000
ITER 4: row=41, varin=49, theta=0.500000, up=999999999999999983222784.000000
ITER 5: row=49, varin=28, theta=0.250000, up=999999999999999983222784.000000
ITER 6: row=23, varin=44, theta=0.444444, up=999999999999999983222784.000000
ITER 7: row=32, varin=43, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 1 gives z=28958219.147639
  % 	x2 = 1,	Z1 = 28958219.1476392        
DEBUG EVAL: First branch cutoff check: z=28958219.147639, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 0
ITER 1: row=1, varin=86, theta=0.444444, up=1.000000
  % 	x2 = 0,	Z0 = 28721059.9252728        
DEBUG EVAL: Second branch cutoff check: z=28721059.925273, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 3 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=4, varin=29, theta=0.250000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 0 gives z=28719069.692022
  % 	x3 = 0,	Z0 = 28719069.6920221        
DEBUG EVAL: First branch cutoff check: z=28719069.692022, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 11 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=23, varin=48, theta=4.500000, up=999999999999999983222784.000000
ITER 2: row=41, varin=49, theta=3.500000, up=999999999999999983222784.000000
ITER 3: row=49, varin=44, theta=3.111111, up=999999999999999983222784.000000
ITER 4: row=42, varin=30, theta=2.441251, up=999999999999999983222784.000000
ITER 5: row=45, varin=83, theta=6.020627, up=1.000000
ITER 6: row=45, varin=82, theta=4.535359, up=1.000000
ITER 7: row=45, varin=39, theta=5.951047, up=999999999999999983222784.000000
ITER 8: row=39, varin=25, theta=2.010091, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 11 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x11 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=23, varin=29, theta=0.250000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28719069.692022
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 50 rows, 60 cols, 283 nonzeros, 1 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 51 at  28.71906969202213844028
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabbedc0
% @LO 0.11  28.70288884085734082419 99.9000000000
% @LN 0.11  28.70438891096127065339 99.9000000000
% Resuming node 81 at  28.70438891096127065339
DEBUG CONSTRNT: LP rows=49, pool->nlprows=49, pool->npend=0
DEBUG CONSTRNT: Checking 49 LP rows (pool tracks 49, total LP rows 49)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=48, expected 48
 % @PAP adding 51 rows, 198 nz to LP
DEBUG BB: Processing node 81, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=24, varin=43, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28704388.910961
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 51 rows, 60 cols, 258 nonzeros, 2 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=54, varin=44, theta=0.111111, up=999999999999999983222784.000000
ITER 2: row=52, varin=54, theta=2.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 28711828.460321
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 54 rows, 60 cols, 272 nonzeros, 5 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % Node 81 LP 1 Solution, length = 28711828.460321, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.333333 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.333333 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.333333 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.333333 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.333333 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.666667 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.666667 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.666667 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.666667 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28711828.460321, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 81 at  28.71182846032094815314
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabda810
% @LO 0.11  28.70438891096127065339 99.9000000000
% @LN 0.11  28.70646829596516624861 99.9000000000
% Resuming node 79 at  28.70646829596516624861
DEBUG CONSTRNT: LP rows=49, pool->nlprows=49, pool->npend=0
DEBUG CONSTRNT: Checking 49 LP rows (pool tracks 49, total LP rows 49)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 130
DEBUG CONSTRNT: Pool row 130 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=48, expected 48
 % @PAP adding 51 rows, 190 nz to LP
DEBUG BB: Processing node 79, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 79 LP 2 Solution, length = 28706468.295965, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.500000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.500000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 1.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28706468.295965, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28706468.295965, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 79 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 79
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=1.000000
DEBUG CAREFUL: Skipping var 8: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.500000
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.500000
DEBUG CAREFUL: Adding var 21 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.500000
DEBUG CAREFUL: Adding var 25 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=1.000000
DEBUG CAREFUL: Skipping var 36: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 3 fractional variables

  %  Carefully choosing branching variable, nfrac = 3
DEBUG CAREFUL: Testing fvar[0] = var 25
DEBUG CAREFUL: Calling compare_branch_vars for var 25
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 25
DEBUG CAREFUL: New best var: 25
DEBUG CAREFUL: Testing fvar[1] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
DEBUG CAREFUL: Testing fvar[2] = var 21
DEBUG CAREFUL: Calling compare_branch_vars for var 21
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 21
  % Initial guess is x25, Z0 = 28706468.2959652        , Z1 = 28709548.7344257        

DEBUG EVAL: Testing var 25 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=43, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=43, varin=51, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 25 = 1 gives z=28709548.734426
  % 	x25 = 1,	Z1 = 28709548.7344257        
DEBUG EVAL: First branch cutoff check: z=28709548.734426, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 25 = 0
ITER 1: row=1, varin=23, theta=0.250000, up=999999999999999983222784.000000
ITER 2: row=36, varin=26, theta=0.125000, up=999999999999999983222784.000000
  % 	x25 = 0,	Z0 = 28727653.1600222        
DEBUG EVAL: Second branch cutoff check: z=28727653.160022, best_z=INF, threshold=INF
  %   New best:  x25, Z = 28709548.7344257        
DEBUG EVAL: Testing var 12 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=18, varin=51, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 12 = 0 gives z=28709548.734426
  % 	x12 = 0,	Z0 = 28709548.7344257        
DEBUG EVAL: First branch cutoff check: z=28709548.734426, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 1
ITER 1: row=18, varin=38, theta=1.000000, up=999999999999999983222784.000000
  % 	x12 = 1,	Z1 = 28752224.4538203        
DEBUG EVAL: Second branch cutoff check: z=28752224.453820, best_z=INF, threshold=INF
  %   New best:  x12, Z = 28709548.7344257        
DEBUG EVAL: Testing var 21 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=38, varin=51, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 21 = 0 gives z=28709548.734426
  % 	x21 = 0,	Z0 = 28709548.7344257        
DEBUG EVAL: First branch cutoff check: z=28709548.734426, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 21 = 1
ITER 1: row=38, varin=18, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=39, varin=19, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=1, varin=23, theta=0.500000, up=999999999999999983222784.000000
ITER 4: row=36, varin=26, theta=0.250000, up=999999999999999983222784.000000
  % 	x21 = 1,	Z1 = 29738473.5575417        
DEBUG EVAL: Second branch cutoff check: z=29738473.557542, best_z=INF, threshold=INF
  %   New best:  x21, Z = 28709548.7344257        
  % Best branch is x21, Z0 = 28709548.7344257        , Z1 = 29738473.5575417        

DEBUG CAREFUL: Final result - returning best.var = 21
DEBUG BB: Branching variable chosen: j=21
 % @NC   83   79	x21 = 0	28709548.734426
 % @NC   84   79	x21 = 1	29738473.557542
 %      79    34 28706468.2960               28709339.7547    x3 D    53    10
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabb5780
% @LO 0.11  28.70646829596516624861 99.9000000000
% @LN 0.11  28.70933975472197019485 99.9000000000
% Resuming node 77 at  28.70933975472197019485
DEBUG CONSTRNT: LP rows=51, pool->nlprows=51, pool->npend=0
DEBUG CONSTRNT: Checking 51 LP rows (pool tracks 51, total LP rows 51)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 62
DEBUG CONSTRNT: Pool row 62 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=50, expected 50
 % @PAP adding 45 rows, 228 nz to LP
DEBUG BB: Processing node 77, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 77 LP 2 Solution, length = 28709339.754722, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.090909 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.090909 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.090909 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.090909 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.272727 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.090909 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.272727 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.727273 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.909091 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.909091 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.727273 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.909091 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.909091 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.727273 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.909091 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=28709339.754722, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28709339.754722, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 77 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 77
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.090909
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.090909)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.090909
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.090909)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.090909
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.090909)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.090909
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.090909)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.272727
DEBUG CAREFUL: Adding var 23 to fractional list (xi=0.272727)
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.090909
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.090909)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.272727
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.272727)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 7 fractional variables

  %  Carefully choosing branching variable, nfrac = 7
DEBUG CAREFUL: Testing fvar[0] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 2
DEBUG CAREFUL: New best var: 2
DEBUG CAREFUL: Testing fvar[1] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[2] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 11
DEBUG CAREFUL: New best var: 11
DEBUG CAREFUL: Testing fvar[3] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 36
DEBUG CAREFUL: Testing fvar[4] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 22
DEBUG CAREFUL: Testing fvar[5] = var 23
DEBUG CAREFUL: Calling compare_branch_vars for var 23
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 23
DEBUG CAREFUL: Testing fvar[6] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 27
  % Initial guess is x11, Z0 = 28709339.754722         , Z1 = 29144049.0821647        

DEBUG EVAL: Testing var 2 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=21, theta=1.785714, up=999999999999999983222784.000000
ITER 2: row=19, varin=27, theta=1.428571, up=999999999999999983222784.000000
ITER 3: row=3, varin=45, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 1 gives z=28756773.056953
  % 	x2 = 1,	Z1 = 28756773.056953         
DEBUG EVAL: First branch cutoff check: z=28756773.056953, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 0
ITER 1: row=1, varin=19, theta=0.384615, up=999999999999999983222784.000000
ITER 2: row=43, varin=14, theta=0.006383, up=999999999999999983222784.000000
ITER 3: row=44, varin=42, theta=0.005988, up=999999999999999983222784.000000
  % 	x2 = 0,	Z0 = 28716104.0094653        
DEBUG EVAL: Second branch cutoff check: z=28716104.009465, best_z=INF, threshold=INF
  %   New best:  x2, Z = 28716104.0094653        
DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=21, theta=1.785714, up=999999999999999983222784.000000
ITER 2: row=19, varin=28, theta=1.428571, up=999999999999999983222784.000000
ITER 3: row=38, varin=42, theta=1.125000, up=999999999999999983222784.000000
ITER 4: row=42, varin=27, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=18, varin=41, theta=0.774194, up=999999999999999983222784.000000
ITER 6: row=26, varin=34, theta=1.125000, up=999999999999999983222784.000000
ITER 7: row=34, varin=31, theta=1.153846, up=999999999999999983222784.000000
ITER 8: row=31, varin=38, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 1 gives z=28836541.556560
  % 	x3 = 1,	Z1 = 28836541.5565605        
DEBUG EVAL: First branch cutoff check: z=28836541.556560, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=3, varin=19, theta=0.384615, up=999999999999999983222784.000000
ITER 2: row=43, varin=14, theta=0.006383, up=999999999999999983222784.000000
ITER 3: row=44, varin=42, theta=0.005988, up=999999999999999983222784.000000
  % 	x3 = 0,	Z0 = 28716104.0094653        
DEBUG EVAL: Second branch cutoff check: z=28716104.009465, best_z=INF, threshold=INF
  %   New best:  x3, Z = 28716104.0094653        
DEBUG EVAL: Testing var 11 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=18, varin=21, theta=1.785714, up=999999999999999983222784.000000
ITER 2: row=19, varin=45, theta=3.333333, up=999999999999999983222784.000000
ITER 3: row=38, varin=42, theta=2.625000, up=999999999999999983222784.000000
ITER 4: row=42, varin=41, theta=1.806452, up=999999999999999983222784.000000
ITER 5: row=26, varin=34, theta=2.625000, up=999999999999999983222784.000000
ITER 6: row=34, varin=31, theta=2.692308, up=999999999999999983222784.000000
ITER 7: row=31, varin=38, theta=2.333333, up=999999999999999983222784.000000
ITER 8: row=17, varin=37, theta=1.333333, up=999999999999999983222784.000000
ITER 9: row=37, varin=18, theta=1.285714, up=999999999999999983222784.000000
ITER 10: row=18, varin=30, theta=4.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 11 = 1 gives z=29314130.837843
  % 	x11 = 1,	Z1 = 29314130.8378428        
DEBUG EVAL: First branch cutoff check: z=29314130.837843, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 11 = 0
ITER 1: row=18, varin=19, theta=0.384615, up=999999999999999983222784.000000
ITER 2: row=43, varin=14, theta=0.006383, up=999999999999999983222784.000000
ITER 3: row=44, varin=42, theta=0.005988, up=999999999999999983222784.000000
  % 	x11 = 0,	Z0 = 28716104.0094653        
DEBUG EVAL: Second branch cutoff check: z=28716104.009465, best_z=INF, threshold=INF
  %   New best:  x11, Z = 28716104.0094653        
DEBUG EVAL: Testing var 36 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=10, varin=19, theta=8.000000, up=999999999999999983222784.000000
ITER 2: row=19, varin=78, theta=3.375000, up=1.000000
ITER 3: row=19, varin=77, theta=2.375000, up=1.000000
ITER 4: row=19, varin=30, theta=0.916667, up=999999999999999983222784.000000
ITER 5: row=32, varin=78, theta=1.000000, up=1.000000
ITER 6: row=5, varin=81, theta=0.875000, up=1.000000
ITER 7: row=43, varin=84, theta=1.125000, up=1.000000
ITER 8: row=43, varin=17, theta=0.083333, up=999999999999999983222784.000000
ITER 9: row=1, varin=84, theta=1.750000, up=1.000000
ITER 10: row=1, varin=43, theta=0.750000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 36 = 1 gives z=29066367.397021
  % 	x36 = 1,	Z1 = 29066367.3970211        
DEBUG EVAL: First branch cutoff check: z=29066367.397021, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 36 = 0
ITER 1: row=10, varin=21, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=19, varin=45, theta=1.500000, up=999999999999999983222784.000000
ITER 3: row=38, varin=26, theta=2.000000, up=999999999999999983222784.000000
  % 	x36 = 0,	Z0 = 28741379.9928164        
DEBUG EVAL: Second branch cutoff check: z=28741379.992816, best_z=INF, threshold=INF
  %   New best:  x36, Z = 28741379.9928164        
DEBUG EVAL: Testing var 22 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=17, varin=21, theta=1.785714, up=999999999999999983222784.000000
ITER 2: row=19, varin=28, theta=1.428571, up=999999999999999983222784.000000
ITER 3: row=38, varin=42, theta=1.125000, up=999999999999999983222784.000000
ITER 4: row=42, varin=27, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=18, varin=41, theta=0.774194, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 22 = 1 gives z=28804755.499194
  % 	x22 = 1,	Z1 = 28842580.4289045        
DEBUG EVAL: First branch cutoff check: z=28842580.428904, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 22 = 0
ITER 1: row=17, varin=19, theta=0.384615, up=999999999999999983222784.000000
  % 	x22 = 0,	Z0 = 28713636.6407667        
DEBUG EVAL: Second branch cutoff check: z=28713636.640767, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 23 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=5, varin=21, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 23 = 0 gives z=28715511.828143
  % 	x23 = 0,	Z0 = 28715511.8281432        
DEBUG EVAL: First branch cutoff check: z=28715511.828143, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 27 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=38, varin=21, theta=1.785714, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 27 = 1 gives z=28720361.314403
  % 	x27 = 1,	Z1 = 28966998.4912886        
DEBUG EVAL: First branch cutoff check: z=28966998.491289, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 27 = 0
ITER 1: row=38, varin=45, theta=0.125000, up=999999999999999983222784.000000
  % 	x27 = 0,	Z0 = 28711722.4995921        
DEBUG EVAL: Second branch cutoff check: z=28711722.499592, best_z=INF, threshold=INF
  % Best branch is x36, Z0 = 28741379.9928164        , Z1 = 29066367.3970211        

DEBUG CAREFUL: Final result - returning best.var = 36
DEBUG BB: Branching variable chosen: j=36
 % @NC   85   77	x36 = 0	28741379.992816
 % @NC   86   77	x36 = 1	29066367.397021
 %      77    35 28709339.7547               28709548.7344   x10 D    75    18
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabbca20
% @LO 0.11  28.70933975472197019485 99.9000000000
% @LN 0.11  28.70954873442574495357 99.9000000000
% Resuming node 83 at  28.70954873442574495357
DEBUG CONSTRNT: LP rows=45, pool->nlprows=45, pool->npend=0
DEBUG CONSTRNT: Checking 45 LP rows (pool tracks 45, total LP rows 45)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 162
DEBUG CONSTRNT: Pool row 162 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 70
DEBUG CONSTRNT: Pool row 70 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 73
DEBUG CONSTRNT: Pool row 73 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=44, expected 44
 % @PAP adding 51 rows, 190 nz to LP
DEBUG BB: Processing node 83, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=51, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28709548.734426
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 2.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 250 nonzeros, 1 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 9 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=23, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=36, varin=26, theta=0.250000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28751918.462540
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 2.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 53 rows, 60 cols, 259 nonzeros, 4 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 4 rows, 46 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=53, varin=37, theta=0.689119, up=999999999999999983222784.000000
ITER 2: row=50, varin=53, theta=88778.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28752224.453820
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 2.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 53 rows, 60 cols, 295 nonzeros, 5 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 1 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=80, theta=0.375000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28752924.757891
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 2.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 247 nonzeros, 0 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=79, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28768905.969458
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 2.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 251 nonzeros, 0 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=82, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28769764.960370
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 2.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 53 rows, 60 cols, 257 nonzeros, 0 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=54, varin=25, theta=0.100000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 28785168.314909
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 2.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 55 rows, 60 cols, 265 nonzeros, 4 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 1 rows, 40 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=4, theta=0.175693, up=999999999999999983222784.000000
ITER 2: row=25, varin=85, theta=0.185704, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28791261.337643
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 2.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 295 nonzeros, 0 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=53, varin=88, theta=0.180663, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 28793146.548653
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 2.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 56 rows, 60 cols, 308 nonzeros, 2 slack, 54 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=55, varin=28, theta=0.059170, up=999999999999999983222784.000000
ITER 2: row=33, varin=92, theta=0.119766, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 28801310.392222
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 2.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 55 rows, 60 cols, 304 nonzeros, 0 slack, 55 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 83 LP 1 Solution, length = 28801310.392222, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.083333 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.083333 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.083333 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.083333 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.083333 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.500000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.083333 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.083333 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.083333 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.880234 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.083333 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.119766 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.916667 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.916667 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.916667 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.916667 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.916667 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.916667 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.916667 (terminal 19)
 % 12 fractional variables
DEBUG CG: LP optimal, z=28801310.392222, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 83 at  28.80131039222244382358
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabbe180
% @LO 0.11  28.70954873442574495357 99.9000000000
% @LN 0.11  28.71053428351405756302 99.9000000000
% Resuming node 69 at  28.71053428351405756302
DEBUG CONSTRNT: LP rows=55, pool->nlprows=55, pool->npend=0
DEBUG CONSTRNT: Checking 55 LP rows (pool tracks 55, total LP rows 55)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 62
DEBUG CONSTRNT: Pool row 62 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 163
DEBUG CONSTRNT: Pool row 163 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=54, expected 54
 % @PAP adding 57 rows, 210 nz to LP
DEBUG BB: Processing node 69, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 69 LP 2 Solution, length = 28710534.283514, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.500000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.500000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.500000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28710534.283514, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28710534.283514, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 69 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 69
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.500000
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.500000
DEBUG CAREFUL: Adding var 21 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.500000
DEBUG CAREFUL: Adding var 25 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.500000
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 34
DEBUG CAREFUL: New best var: 34
DEBUG CAREFUL: Testing fvar[1] = var 25
DEBUG CAREFUL: Calling compare_branch_vars for var 25
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 25
DEBUG CAREFUL: Testing fvar[2] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
DEBUG CAREFUL: Testing fvar[3] = var 21
DEBUG CAREFUL: Calling compare_branch_vars for var 21
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 21
  % Initial guess is x34, Z0 = 28710534.2835141        , Z1 = 28745399.701599         

DEBUG EVAL: Testing var 34 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=19, varin=35, theta=0.388889, up=999999999999999983222784.000000
ITER 2: row=53, varin=52, theta=0.632653, up=999999999999999983222784.000000
ITER 3: row=46, varin=56, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 34 = 1 gives z=28745399.701599
  % 	x34 = 1,	Z1 = 28745399.701599         
DEBUG EVAL: First branch cutoff check: z=28745399.701599, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 34 = 0
ITER 1: row=19, varin=39, theta=1.750000, up=999999999999999983222784.000000
  % 	x34 = 0,	Z0 = 28719327.7800588        
DEBUG EVAL: Second branch cutoff check: z=28719327.780059, best_z=INF, threshold=INF
  %   New best:  x34, Z = 28719327.7800588        
DEBUG EVAL: Testing var 25 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=52, varin=39, theta=1.750000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 25 = 0 gives z=28719327.780059
  % 	x25 = 0,	Z0 = 28719327.7800588        
DEBUG EVAL: First branch cutoff check: z=28719327.780059, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 25 = 1
ITER 1: row=52, varin=35, theta=0.388889, up=999999999999999983222784.000000
ITER 2: row=53, varin=52, theta=0.632653, up=999999999999999983222784.000000
ITER 3: row=46, varin=51, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=57, varin=48, theta=0.780000, up=999999999999999983222784.000000
ITER 5: row=48, varin=46, theta=1.000000, up=999999999999999983222784.000000
  % 	x25 = 1,	Z1 = 28794236.2979147        
DEBUG EVAL: Second branch cutoff check: z=28794236.297915, best_z=INF, threshold=INF
  %   New best:  x25, Z = 28719327.7800588        
DEBUG EVAL: Testing var 12 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=18, varin=39, theta=1.750000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 12 = 0 gives z=28719327.780059
  % 	x12 = 0,	Z0 = 28719327.7800588        
DEBUG EVAL: First branch cutoff check: z=28719327.780059, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 1
ITER 1: row=18, varin=35, theta=0.388889, up=999999999999999983222784.000000
ITER 2: row=53, varin=52, theta=0.632653, up=999999999999999983222784.000000
ITER 3: row=46, varin=56, theta=1.000000, up=999999999999999983222784.000000
  % 	x12 = 1,	Z1 = 28745399.701599         
DEBUG EVAL: Second branch cutoff check: z=28745399.701599, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 21 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=34, varin=39, theta=1.750000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 21 = 0 gives z=28719327.780059
  % 	x21 = 0,	Z0 = 28719327.7800588        
DEBUG EVAL: First branch cutoff check: z=28719327.780059, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 21 = 1
ITER 1: row=34, varin=35, theta=0.388889, up=999999999999999983222784.000000
ITER 2: row=53, varin=52, theta=0.632653, up=999999999999999983222784.000000
ITER 3: row=46, varin=56, theta=1.000000, up=999999999999999983222784.000000
  % 	x21 = 1,	Z1 = 28745399.701599         
DEBUG EVAL: Second branch cutoff check: z=28745399.701599, best_z=INF, threshold=INF
  % Best branch is x25, Z0 = 28719327.7800588        , Z1 = 28794236.2979147        

DEBUG CAREFUL: Final result - returning best.var = 25
DEBUG BB: Branching variable chosen: j=25
 % @NC   87   69	x25 = 0	28719327.780059
 % @NC   88   69	x25 = 1	28794236.297915
 %      69    36 28710534.2835               28711828.4603    x6 D    47    10
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabbedc0
% @LO 0.11  28.71053428351405756302 99.9000000000
% @LN 0.11  28.71182846032094815314 99.9000000000
% Resuming node 81 at  28.71182846032094815314
DEBUG CONSTRNT: LP rows=57, pool->nlprows=57, pool->npend=0
DEBUG CONSTRNT: Checking 57 LP rows (pool tracks 57, total LP rows 57)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 70
DEBUG CONSTRNT: Pool row 70 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=56, expected 56
 % @PAP adding 49 rows, 187 nz to LP
DEBUG BB: Processing node 81, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 81 LP 2 Solution, length = 28711828.460321, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.333333 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.333333 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.333333 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.333333 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.333333 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.666667 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.666667 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.666667 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.666667 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28711828.460321, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28711828.460321, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 81 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 81
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.333333
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.333333
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.333333
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.333333
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.333333
DEBUG CAREFUL: Adding var 39 to fractional list (xi=0.333333)
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[1] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 22
DEBUG CAREFUL: Testing fvar[2] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 2
DEBUG CAREFUL: New best var: 2
DEBUG CAREFUL: Testing fvar[3] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 27
DEBUG CAREFUL: Testing fvar[4] = var 39
DEBUG CAREFUL: Calling compare_branch_vars for var 39
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 39
DEBUG CAREFUL: New best var: 39
  % Initial guess is x39, Z0 = 28711828.4603209        , Z1 = 28742443.0269326        

DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=47, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=40, varin=45, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=9, varin=43, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=43, varin=11, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=11, varin=42, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=42, varin=16, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=16, varin=40, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 1 gives z=28982176.703854
  % 	x3 = 1,	Z1 = 28982176.7038541        
DEBUG EVAL: First branch cutoff check: z=28982176.703854, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=7, varin=48, theta=1.000000, up=999999999999999983222784.000000
  % 	x3 = 0,	Z0 = 28726707.5590403        
DEBUG EVAL: Second branch cutoff check: z=28726707.559040, best_z=INF, threshold=INF
  %   New best:  x3, Z = 28726707.5590403        
DEBUG EVAL: Testing var 22 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=26, varin=48, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 22 = 0 gives z=28726707.559040
  % 	x22 = 0,	Z0 = 28726707.5590403        
DEBUG EVAL: First branch cutoff check: z=28726707.559040, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 22 = 1
ITER 1: row=26, varin=47, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=40, varin=45, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=9, varin=43, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=43, varin=11, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=11, varin=42, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=42, varin=16, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=16, varin=40, theta=1.000000, up=999999999999999983222784.000000
  % 	x22 = 1,	Z1 = 28982176.7038541        
DEBUG EVAL: Second branch cutoff check: z=28982176.703854, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 2 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=48, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 1 gives z=28726707.559040
  % 	x2 = 1,	Z1 = 28726707.5590403        
DEBUG EVAL: First branch cutoff check: z=28726707.559040, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 0
ITER 1: row=1, varin=29, theta=1.000000, up=999999999999999983222784.000000
  % 	x2 = 0,	Z0 = 28935400.7649424        
DEBUG EVAL: Second branch cutoff check: z=28935400.764942, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 27 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=38, varin=48, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 27 = 1 gives z=28726707.559040
  % 	x27 = 1,	Z1 = 28726707.5590403        
DEBUG EVAL: First branch cutoff check: z=28726707.559040, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 27 = 0
ITER 1: row=38, varin=40, theta=0.500000, up=999999999999999983222784.000000
  % 	x27 = 0,	Z0 = 28832775.4394378        
DEBUG EVAL: Second branch cutoff check: z=28832775.439438, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 39 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=40, varin=45, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=9, varin=43, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=43, varin=11, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=11, varin=42, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=42, varin=16, theta=2.000000, up=999999999999999983222784.000000
ITER 6: row=16, varin=40, theta=2.000000, up=999999999999999983222784.000000
ITER 7: row=38, varin=26, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=39, varin=38, theta=0.500000, up=999999999999999983222784.000000
ITER 9: row=49, varin=39, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 39 = 1 gives z=29276688.788535
  % 	x39 = 1,	Z1 = 29276688.7885349        
DEBUG EVAL: First branch cutoff check: z=29276688.788535, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 39 = 0
ITER 1: row=40, varin=47, theta=0.500000, up=999999999999999983222784.000000
  % 	x39 = 0,	Z0 = 28726055.6029707        
DEBUG EVAL: Second branch cutoff check: z=28726055.602971, best_z=INF, threshold=INF
  % Best branch is x3, Z0 = 28726707.5590403        , Z1 = 28982176.7038541        

DEBUG CAREFUL: Final result - returning best.var = 3
DEBUG BB: Branching variable chosen: j=3
 % @NC   89   81	x3 = 0	28726707.559040
 % @NC   90   81	x3 = 1	28982176.703854
 %      81    37 28711828.4603               28719069.6920   x29 D    73     6
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabbed00
% @LO 0.11  28.71182846032094815314 99.9000000000
% @LN 0.11  28.71906969202213844028 99.9000000000
% Resuming node 51 at  28.71906969202213844028
DEBUG CONSTRNT: LP rows=49, pool->nlprows=49, pool->npend=0
DEBUG CONSTRNT: Checking 49 LP rows (pool tracks 49, total LP rows 49)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 130
DEBUG CONSTRNT: Pool row 130 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=48, expected 48
 % @PAP adding 49 rows, 221 nz to LP
DEBUG BB: Processing node 51, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 51 LP 5 Solution, length = 28719069.692022, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.250000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.500000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.250000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.250000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.724331 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.275669 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.750000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.750000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28719069.692022, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28719069.692022, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 51 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 51
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.250000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=1.000000
DEBUG CAREFUL: Skipping var 9: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.500000
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.500000
DEBUG CAREFUL: Adding var 25 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.250000
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.250000
DEBUG CAREFUL: Adding var 31 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.724331
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.724331)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 12
DEBUG CAREFUL: New best var: 12
DEBUG CAREFUL: Testing fvar[1] = var 25
DEBUG CAREFUL: Calling compare_branch_vars for var 25
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 25
DEBUG CAREFUL: New best var: 25
DEBUG CAREFUL: Testing fvar[2] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[3] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 27
DEBUG CAREFUL: Testing fvar[4] = var 31
DEBUG CAREFUL: Calling compare_branch_vars for var 31
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 31
DEBUG CAREFUL: Testing fvar[5] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 36
  % Initial guess is x25, Z0 = 28799631.4675702        , Z1 = 29357922.2937942        

DEBUG EVAL: Testing var 12 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=16, varin=42, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 12 = 0 gives z=28831993.169900
  % 	x12 = 0,	Z0 = 28831993.1698998        
DEBUG EVAL: First branch cutoff check: z=28831993.169900, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 1
ITER 1: row=16, varin=39, theta=1.000000, up=999999999999999983222784.000000
  % 	x12 = 1,	Z1 = 28923159.7046239        
DEBUG EVAL: Second branch cutoff check: z=28923159.704624, best_z=INF, threshold=INF
  %   New best:  x12, Z = 28831993.1698998        
DEBUG EVAL: Testing var 25 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=20, varin=42, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 25 = 0 gives z=28831993.169900
  % 	x25 = 0,	Z0 = 28831993.1698998        
DEBUG EVAL: First branch cutoff check: z=28831993.169900, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 25 = 1
ITER 1: row=20, varin=17, theta=1.000000, up=999999999999999983222784.000000
  % 	x25 = 1,	Z1 = 29380105.5249133        
DEBUG EVAL: Second branch cutoff check: z=29380105.524913, best_z=INF, threshold=INF
  %   New best:  x25, Z = 28831993.1698998        
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=85, theta=0.444444, up=1.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28721059.925273
  % 	x2 = 0,	Z0 = 28721059.9252728        
DEBUG EVAL: First branch cutoff check: z=28721059.925273, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 27 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=39, varin=85, theta=0.444444, up=1.000000
DEBUG EVAL: Branch var 27 = 0 gives z=28721059.925273
  % 	x27 = 0,	Z0 = 28721059.9252728        
DEBUG EVAL: First branch cutoff check: z=28721059.925273, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 31 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=40, varin=85, theta=0.444444, up=1.000000
DEBUG EVAL: Branch var 31 = 0 gives z=28721059.925273
  % 	x31 = 0,	Z0 = 28721059.9252728        
DEBUG EVAL: First branch cutoff check: z=28721059.925273, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 36 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=15, varin=30, theta=0.748988, up=999999999999999983222784.000000
ITER 2: row=45, varin=38, theta=1.357118, up=999999999999999983222784.000000
ITER 3: row=38, varin=85, theta=14.347833, up=1.000000
ITER 4: row=38, varin=25, theta=1.348047, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 36 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x36 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=15, varin=88, theta=3.489192, up=1.000000
ITER 2: row=15, varin=40, theta=133807.750000, up=999999999999999983222784.000000
ITER 3: row=1, varin=88, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28789316.040193
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 49 rows, 60 cols, 281 nonzeros, 1 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 4 rows, 22 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=55, theta=0.250000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28794438.201808
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 52 rows, 60 cols, 263 nonzeros, 0 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 51 at  28.79443820180766877570
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabb5780
% @LO 0.11  28.71906969202213844028 99.9000000000
% @LN 0.11  28.71932778005880138039 99.9000000000
% Resuming node 87 at  28.71932778005880138039
DEBUG CONSTRNT: LP rows=52, pool->nlprows=52, pool->npend=0
DEBUG CONSTRNT: Checking 52 LP rows (pool tracks 52, total LP rows 52)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 105
DEBUG CONSTRNT: Pool row 105 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 130
DEBUG CONSTRNT: Pool row 130 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=51, expected 51
 % @PAP adding 57 rows, 210 nz to LP
DEBUG BB: Processing node 87, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=39, theta=1.750000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 28719327.780059
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 57 rows, 60 cols, 270 nonzeros, 4 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 40 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=58, varin=31, theta=0.070128, up=999999999999999983222784.000000
ITER 2: row=36, varin=86, theta=0.023636, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=58)
DEBUG SOLUTION: LP solution array indices: FST[59-98], not_covered[99-118]
DEBUG SOLUTION: lp->best_solution[0] = 28720093.110337
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 58 rows, 60 cols, 310 nonzeros, 4 slack, 54 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % Node 87 LP 1 Solution, length = 28720093.110337, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.244091 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.244091 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.244091 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.244091 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.244091 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.023636 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.755909 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.755909 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.755909 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.755909 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.755909 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28720093.110337, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.11  28.71932778005880138039 99.9000000000
 % @LN 0.11  28.72009311033699319182 99.9000000000
DEBUG CG: Second cutoff check: z=28720093.110337, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 87 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 87
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.244091
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.244091)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.244091
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.244091)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.244091
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.244091)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.244091
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.244091)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.244091
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.244091)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.023636
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.023636)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 27
DEBUG CAREFUL: New best var: 27
DEBUG CAREFUL: Testing fvar[1] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 4
DEBUG CAREFUL: New best var: 4
DEBUG CAREFUL: Testing fvar[2] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[3] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 11
DEBUG CAREFUL: Testing fvar[4] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[5] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 22
  % Initial guess is x4, Z0 = 28720093.110337         , Z1 = 28844744.714354         

DEBUG EVAL: Testing var 27 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=50, varin=36, theta=2.896880, up=999999999999999983222784.000000
ITER 2: row=31, varin=54, theta=385293.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 27 = 1 gives z=28751707.616100
  % 	x27 = 1,	Z1 = 28787542.799666         
DEBUG EVAL: First branch cutoff check: z=28787542.799666, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 27 = 0
ITER 1: row=50, varin=83, theta=0.023739, up=1.000000
  % 	x27 = 0,	Z0 = 28720137.2406096        
DEBUG EVAL: Second branch cutoff check: z=28720137.240610, best_z=INF, threshold=INF
  %   New best:  x27, Z = 28720137.2406096        
DEBUG EVAL: Testing var 4 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: Branch var 4 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x4 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=25, varin=36, theta=0.730243, up=999999999999999983222784.000000
ITER 2: row=31, varin=21, theta=0.884797, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 28729110.596139
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 54 rows, 60 cols, 283 nonzeros, 4 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 4 slack rows
   % @PAP adding 4 rows, 11 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=53, varin=33, theta=0.157012, up=999999999999999983222784.000000
ITER 2: row=22, varin=23, theta=0.213621, up=999999999999999983222784.000000
ITER 3: row=30, varin=48, theta=0.541067, up=999999999999999983222784.000000
ITER 4: row=7, varin=50, theta=12718.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
ITER 5: row=5, varin=30, theta=0.000000, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 28735784.057903
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 54 rows, 60 cols, 279 nonzeros, 3 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 3 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 87 at  28.73578405790252787710
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabbe180
% @LO 0.11  28.72009311033699319182 99.9000000000
% @LN 0.11  28.72670755904030670536 99.9000000000
% Resuming node 89 at  28.72670755904030670536
DEBUG CONSTRNT: LP rows=51, pool->nlprows=51, pool->npend=0
DEBUG CONSTRNT: Checking 51 LP rows (pool tracks 51, total LP rows 51)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 143
DEBUG CONSTRNT: Pool row 143 has lprow=50, expected 50
 % @PAP adding 49 rows, 187 nz to LP
DEBUG BB: Processing node 89, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=7, varin=48, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28726707.559040
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 49 rows, 60 cols, 247 nonzeros, 2 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=29, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28831054.161991
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 50 rows, 60 cols, 249 nonzeros, 6 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 3 rows, 50 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=33, theta=2.082138, up=999999999999999983222784.000000
ITER 2: row=2, varin=26, theta=0.110462, up=999999999999999983222784.000000
ITER 3: row=18, varin=92, theta=0.277598, up=1.000000
ITER 4: row=46, varin=29, theta=0.026486, up=999999999999999983222784.000000
ITER 5: row=36, varin=9, theta=0.266715, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 47 rows, 60 cols, 278 nonzeros, 3 slack, 44 tight.
  % Node 89 LP 1 Solution, length = 999999999999999983222784.000000, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.500000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.500000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.500000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.500000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.500000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.500000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 89 is INFEASIBLE
 %      89    36    infeasible               28735784.0579    x3 D    81     7
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabb5780
% @LO 0.11  28.72670755904030670536 99.9000000000
% @LN 0.11  28.73578405790252787710 99.9000000000
% Resuming node 87 at  28.73578405790252787710
DEBUG CONSTRNT: LP rows=47, pool->nlprows=47, pool->npend=0
DEBUG CONSTRNT: Checking 47 LP rows (pool tracks 47, total LP rows 47)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 130
DEBUG CONSTRNT: Pool row 130 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 105
DEBUG CONSTRNT: Pool row 105 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=46, expected 46
 % @PAP adding 51 rows, 175 nz to LP
DEBUG BB: Processing node 87, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 87 LP 2 Solution, length = 28735784.057903, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.500000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.500000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.500000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.500000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28735784.057903, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28735784.057903, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 87 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 87
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.500000
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=1.000000
DEBUG CAREFUL: Skipping var 5: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.500000
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.500000
DEBUG CAREFUL: Adding var 21 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.500000
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.500000
DEBUG CAREFUL: Adding var 30 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.500000
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 34
DEBUG CAREFUL: New best var: 34
DEBUG CAREFUL: Testing fvar[1] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[2] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 29
DEBUG CAREFUL: Testing fvar[3] = var 30
DEBUG CAREFUL: Calling compare_branch_vars for var 30
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 30
DEBUG CAREFUL: Testing fvar[4] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
DEBUG CAREFUL: Testing fvar[5] = var 21
DEBUG CAREFUL: Calling compare_branch_vars for var 21
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 21
  % Initial guess is x34, Z0 = 28735784.0579025        , Z1 = 28745399.701599         

DEBUG EVAL: Testing var 34 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=19, varin=50, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 34 = 1 gives z=28745399.701599
  % 	x34 = 1,	Z1 = 28745399.701599         
DEBUG EVAL: First branch cutoff check: z=28745399.701599, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 34 = 0
ITER 1: row=19, varin=79, theta=0.500000, up=1.000000
ITER 2: row=48, varin=80, theta=0.500000, up=1.000000
  % 	x34 = 0,	Z0 = 28739797.0060646        
DEBUG EVAL: Second branch cutoff check: z=28739797.006065, best_z=INF, threshold=INF
  %   New best:  x34, Z = 28739797.0060646        
DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=50, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 0 gives z=28745399.701599
  % 	x1 = 0,	Z0 = 28745399.701599         
DEBUG EVAL: First branch cutoff check: z=28745399.701599, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 1
ITER 1: row=1, varin=39, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=51, varin=25, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=3, varin=79, theta=1.000000, up=1.000000
ITER 4: row=48, varin=80, theta=1.000000, up=1.000000
  % 	x1 = 1,	Z1 = 29218741.9918218        
DEBUG EVAL: Second branch cutoff check: z=29218741.991822, best_z=INF, threshold=INF
  %   New best:  x1, Z = 28745399.701599         
DEBUG EVAL: Testing var 29 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=25, varin=50, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 29 = 0 gives z=28745399.701599
  % 	x29 = 0,	Z0 = 28745399.701599         
DEBUG EVAL: First branch cutoff check: z=28745399.701599, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 29 = 1
ITER 1: row=25, varin=4, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=26, varin=39, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=51, varin=11, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=26, varin=50, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=3, varin=79, theta=1.000000, up=1.000000
ITER 6: row=48, varin=80, theta=1.000000, up=1.000000
  % 	x29 = 1,	Z1 = 29580830.0372044        
DEBUG EVAL: Second branch cutoff check: z=29580830.037204, best_z=INF, threshold=INF
  %   New best:  x29, Z = 28745399.701599         
DEBUG EVAL: Testing var 30 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=39, varin=50, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 30 = 0 gives z=28745399.701599
  % 	x30 = 0,	Z0 = 28745399.701599         
DEBUG EVAL: First branch cutoff check: z=28745399.701599, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 30 = 1
ITER 1: row=39, varin=3, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=40, varin=4, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=26, varin=25, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=3, varin=79, theta=1.000000, up=1.000000
ITER 5: row=48, varin=80, theta=1.000000, up=1.000000
  % 	x30 = 1,	Z1 = 29791180.2046646        
DEBUG EVAL: Second branch cutoff check: z=29791180.204665, best_z=INF, threshold=INF
  %   New best:  x30, Z = 28745399.701599         
DEBUG EVAL: Testing var 12 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=50, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 12 = 1 gives z=28745399.701599
  % 	x12 = 1,	Z1 = 28745399.701599         
DEBUG EVAL: First branch cutoff check: z=28745399.701599, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 0
ITER 1: row=3, varin=79, theta=0.500000, up=1.000000
ITER 2: row=48, varin=80, theta=0.500000, up=1.000000
  % 	x12 = 0,	Z0 = 28739797.0060646        
DEBUG EVAL: Second branch cutoff check: z=28739797.006065, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 21 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=18, varin=50, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 21 = 1 gives z=28745399.701599
  % 	x21 = 1,	Z1 = 28745399.701599         
DEBUG EVAL: First branch cutoff check: z=28745399.701599, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 21 = 0
ITER 1: row=18, varin=79, theta=0.500000, up=1.000000
ITER 2: row=48, varin=80, theta=0.500000, up=1.000000
  % 	x21 = 0,	Z0 = 28739797.0060646        
DEBUG EVAL: Second branch cutoff check: z=28739797.006065, best_z=INF, threshold=INF
  % Best branch is x30, Z0 = 28745399.701599         , Z1 = 29791180.2046646        

DEBUG CAREFUL: Final result - returning best.var = 30
DEBUG BB: Branching variable chosen: j=30
 % @NC   91   87	x30 = 0	28745399.701599
 % @NC   92   87	x30 = 1	29791180.204665
 %      87    37 28735784.0579               28741379.9928   x25 D    69    11
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5595dabda810
% @LO 0.12  28.73578405790252787710 99.9000000000
% @LN 0.12  28.74137999281639466176 99.9000000000
% Resuming node 85 at  28.74137999281639466176
DEBUG CONSTRNT: LP rows=51, pool->nlprows=51, pool->npend=0
DEBUG CONSTRNT: Checking 51 LP rows (pool tracks 51, total LP rows 51)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 143
DEBUG CONSTRNT: Pool row 143 has lprow=50, expected 50
 % @PAP adding 45 rows, 228 nz to LP
DEBUG BB: Processing node 85, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=10, varin=21, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=19, varin=45, theta=1.500000, up=999999999999999983222784.000000
ITER 3: row=38, varin=26, theta=2.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28741379.992816
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 288 nonzeros, 2 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=27, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28756773.056953
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 293 nonzeros, 2 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 85 LP 1 Solution, length = 28756773.056953, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 0 fractional variables
DEBUG CG: LP optimal, z=28756773.056953, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG IFS: Budget mode - accepting integer solution with 1 edges covering 3 vertices
DEBUG CG: integer_feasible_solution returned: TRUE
DEBUG CG: Solution is integer feasible, returning LB_INTEGRAL
DEBUG BB: compute_good_lower_bound returned status=3
DEBUG BB: Node 85 is INTEGRAL (integer solution found)
 %  	=== 36 nodes cut off ===
 % @UO 0.12   3.25677305695297558685 -782.5109852667
 % @UN 0.12   3.25677305695297558685 -782.5109852667
DEBUG BB: Calling heuristic UB for integer solution, current best_z=3256773.056953
DEBUG BB: Heuristic did not improve integer solution
 % *    85     0  3256773.0570  3256773.0570                 x36 D    77    19
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=(nil)
DEBUG BB: No more nodes to process, exiting

 % Certificate of solution:
 % @C	.4767008182741058	.2081993675729823
%%Page: 1 1
BeginPlot
	Plot_Terminals
 % fs2: 13 0 6
	13 T	.4767008182741058	.2081993675729823	S
	.4767008182741058	.2081993675729823	0 T	S
	.4767008182741058	.2081993675729823	6 T	S
  (Euclidean SMT:  20 points,  length = 3.256773056952975,  0.12 seconds)
EndPlot

% @0 Euclidean SMT
% N M Nodes LPs P1CPU P2CPU TotCPU
% @1 20 40 67 154 0.00 0.12 0.12
% Z RootZ %Gap RootLPs RootCPU RedMST
% @2 3.256773056952975 27504757.442383 -744.54019 2 0.00 -4.1576
% InitPRows InitPNZ InitLPRows InitLPNZ
% @3 163 594 135 555
% RootPRows RootPNZ RootLPRows RootLPNZ
% @4 164 606 69 348
% FinalPRows FinalPNZ FinalLPRows FinalLPNZ
% @5 164 606 45 289
% SMTFSTs SMTAvgFSTSz SMTMaxFSTSz #2FSTs #3FSTs ... #10FSTS #>10FSTs
% @6 1 3.000000 3 0 1 0 0 0 0 0 0 0 0
