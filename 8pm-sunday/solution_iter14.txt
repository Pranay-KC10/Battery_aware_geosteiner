 % ./bb
 % Args:
DEBUG P1READ: Terminal 0 battery=100.00
DEBUG P1READ: Terminal 1 battery=82.60
DEBUG P1READ: Terminal 2 battery=91.70
DEBUG P1READ: Terminal 3 battery=100.00
DEBUG P1READ: Terminal 4 battery=98.00
DEBUG P1READ: Terminal 5 battery=97.50
DEBUG P1READ: Terminal 6 battery=100.00
DEBUG P1READ: Terminal 7 battery=100.00
DEBUG P1READ: Terminal 8 battery=100.00
DEBUG P1READ: Terminal 9 battery=100.00
DEBUG P1READ: Terminal 10 battery=98.00
DEBUG P1READ: Terminal 11 battery=76.00
DEBUG P1READ: Terminal 12 battery=93.00
DEBUG P1READ: Terminal 13 battery=100.00
DEBUG P1READ: Terminal 14 battery=100.00
DEBUG P1READ: Terminal 15 battery=100.00
DEBUG P1READ: Terminal 16 battery=68.00
DEBUG P1READ: Terminal 17 battery=100.00
DEBUG P1READ: Terminal 18 battery=100.00
DEBUG P1READ: Terminal 19 battery=100.00
DEBUG HG: num_verts=20, num_edges=40
 % Phase 1: 0.00 seconds

%%BeginSetup

0 1 0 1 SetAxes

20 DefineTerminals
	.4588350000000000	.2373240000000000	DT
	.1270640000000000	.3509960000000000	DT
	.1544540000000000	.4808220000000000	DT
	.9474030000000000	.1441120000000000	DT
	.2867390000000000	.0565890000000000	DT
	.1326890000000000	.1166050000000000	DT
	.6273950000000000	.2122140000000000	DT
	.0794880000000000	.7970990000000000	DT
	.0327480000000000	.8803250000000000	DT
	.3110550000000000	.8689670000000000	DT
	.0916180000000000	.0221720000000000	DT
	.3600710000000000	.6382240000000000	DT
	.7197120000000000	.7181670000000000	DT
	.4424420000000000	.1450340000000000	DT
	.9983770000000000	.5729870000000000	DT
	.9654920000000000	.1935700000000000	DT
	.1600100000000000	.4187950000000000	DT
	.2909450000000000	.9620800000000000	DT
	.3330000000000000	.9414120000000000	DT
	.9512590000000000	.5074670000000000	DT

%%EndSetup

DEBUG ALGO: num_verts=20 <= 8? NO, num_edges=40 <= 12? NO
DEBUG ALGO: Forcing BRANCH-AND-CUT for multi-objective optimization (vertices=20 > 1)
DEBUG SPANNING: Adding modified spanning constraint for budget mode
DEBUG SPANNING: Added modified spanning constraint: Σ(|FST|-1)*x + Σnot_covered = 19
DEBUG CONSTRAINT: Adding soft cutset constraints with not_covered variables
DEBUG CONSTRAINT: Added constraint x[2] + not_covered[0] ≤ 1 for terminal 0
DEBUG CONSTRAINT: Added constraint x[27] + not_covered[0] ≤ 1 for terminal 0
DEBUG CONSTRAINT: Added constraint x[31] + not_covered[0] ≤ 1 for terminal 0
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 3·not_covered[0] ≤ 3 for terminal 0
DEBUG CONSTRAINT: Added constraint x[0] + not_covered[1] ≤ 1 for terminal 1
DEBUG CONSTRAINT: Added constraint x[24] + not_covered[1] ≤ 1 for terminal 1
DEBUG CONSTRAINT: Added constraint x[33] + not_covered[1] ≤ 1 for terminal 1
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 3·not_covered[1] ≤ 3 for terminal 1
DEBUG CONSTRAINT: Added constraint x[5] + not_covered[2] ≤ 1 for terminal 2
DEBUG CONSTRAINT: Added constraint x[7] + not_covered[2] ≤ 1 for terminal 2
DEBUG CONSTRAINT: Added constraint x[16] + not_covered[2] ≤ 1 for terminal 2
DEBUG CONSTRAINT: Added constraint x[23] + not_covered[2] ≤ 1 for terminal 2
DEBUG CONSTRAINT: Added constraint x[36] + not_covered[2] ≤ 1 for terminal 2
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 5·not_covered[2] ≤ 5 for terminal 2
DEBUG CONSTRAINT: Added constraint x[3] + not_covered[3] ≤ 1 for terminal 3
DEBUG CONSTRAINT: Added constraint x[4] + not_covered[3] ≤ 1 for terminal 3
DEBUG CONSTRAINT: Added constraint x[17] + not_covered[3] ≤ 1 for terminal 3
DEBUG CONSTRAINT: Added constraint x[20] + not_covered[3] ≤ 1 for terminal 3
DEBUG CONSTRAINT: Added constraint x[22] + not_covered[3] ≤ 1 for terminal 3
DEBUG CONSTRAINT: Added constraint x[39] + not_covered[3] ≤ 1 for terminal 3
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 6·not_covered[3] ≤ 6 for terminal 3
DEBUG CONSTRAINT: Added constraint x[0] + not_covered[4] ≤ 1 for terminal 4
DEBUG CONSTRAINT: Added constraint x[1] + not_covered[4] ≤ 1 for terminal 4
DEBUG CONSTRAINT: Added constraint x[30] + not_covered[4] ≤ 1 for terminal 4
DEBUG CONSTRAINT: Added constraint x[32] + not_covered[4] ≤ 1 for terminal 4
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 4·not_covered[4] ≤ 4 for terminal 4
DEBUG CONSTRAINT: Added constraint x[0] + not_covered[5] ≤ 1 for terminal 5
DEBUG CONSTRAINT: Added constraint x[1] + not_covered[5] ≤ 1 for terminal 5
DEBUG CONSTRAINT: Added constraint x[29] + not_covered[5] ≤ 1 for terminal 5
DEBUG CONSTRAINT: Added constraint x[30] + not_covered[5] ≤ 1 for terminal 5
DEBUG CONSTRAINT: Added constraint x[33] + not_covered[5] ≤ 1 for terminal 5
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 5·not_covered[5] ≤ 5 for terminal 5
DEBUG CONSTRAINT: Added constraint x[2] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[3] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[4] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[11] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[17] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[18] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[20] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[31] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[39] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 9·not_covered[6] ≤ 9 for terminal 6
DEBUG CONSTRAINT: Added constraint x[5] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[6] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[8] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[13] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[14] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[15] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[16] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[19] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[28] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[35] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 10·not_covered[7] ≤ 10 for terminal 7
DEBUG CONSTRAINT: Added constraint x[6] + not_covered[8] ≤ 1 for terminal 8
DEBUG CONSTRAINT: Added constraint x[13] + not_covered[8] ≤ 1 for terminal 8
DEBUG CONSTRAINT: Added constraint x[14] + not_covered[8] ≤ 1 for terminal 8
DEBUG CONSTRAINT: Added constraint x[19] + not_covered[8] ≤ 1 for terminal 8
DEBUG CONSTRAINT: Added constraint x[28] + not_covered[8] ≤ 1 for terminal 8
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 5·not_covered[8] ≤ 5 for terminal 8
DEBUG CONSTRAINT: Added constraint x[6] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[7] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[8] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[9] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[12] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[13] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[14] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[15] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[16] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[19] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[25] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[34] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[35] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 13·not_covered[9] ≤ 13 for terminal 9
DEBUG CONSTRAINT: Added constraint x[1] + not_covered[10] ≤ 1 for terminal 10
DEBUG CONSTRAINT: Added constraint x[29] + not_covered[10] ≤ 1 for terminal 10
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 2·not_covered[10] ≤ 2 for terminal 10
DEBUG CONSTRAINT: Added constraint x[5] + not_covered[11] ≤ 1 for terminal 11
DEBUG CONSTRAINT: Added constraint x[7] + not_covered[11] ≤ 1 for terminal 11
DEBUG CONSTRAINT: Added constraint x[8] + not_covered[11] ≤ 1 for terminal 11
DEBUG CONSTRAINT: Added constraint x[9] + not_covered[11] ≤ 1 for terminal 11
DEBUG CONSTRAINT: Added constraint x[13] + not_covered[11] ≤ 1 for terminal 11
DEBUG CONSTRAINT: Added constraint x[16] + not_covered[11] ≤ 1 for terminal 11
DEBUG CONSTRAINT: Added constraint x[34] + not_covered[11] ≤ 1 for terminal 11
DEBUG CONSTRAINT: Added constraint x[36] + not_covered[11] ≤ 1 for terminal 11
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 8·not_covered[11] ≤ 8 for terminal 11
DEBUG CONSTRAINT: Added constraint x[9] + not_covered[12] ≤ 1 for terminal 12
DEBUG CONSTRAINT: Added constraint x[10] + not_covered[12] ≤ 1 for terminal 12
DEBUG CONSTRAINT: Added constraint x[18] + not_covered[12] ≤ 1 for terminal 12
DEBUG CONSTRAINT: Added constraint x[20] + not_covered[12] ≤ 1 for terminal 12
DEBUG CONSTRAINT: Added constraint x[37] + not_covered[12] ≤ 1 for terminal 12
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 5·not_covered[12] ≤ 5 for terminal 12
DEBUG CONSTRAINT: Added constraint x[2] + not_covered[13] ≤ 1 for terminal 13
DEBUG CONSTRAINT: Added constraint x[27] + not_covered[13] ≤ 1 for terminal 13
DEBUG CONSTRAINT: Added constraint x[32] + not_covered[13] ≤ 1 for terminal 13
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 3·not_covered[13] ≤ 3 for terminal 13
DEBUG CONSTRAINT: Added constraint x[10] + not_covered[14] ≤ 1 for terminal 14
DEBUG CONSTRAINT: Added constraint x[26] + not_covered[14] ≤ 1 for terminal 14
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 2·not_covered[14] ≤ 2 for terminal 14
DEBUG CONSTRAINT: Added constraint x[3] + not_covered[15] ≤ 1 for terminal 15
DEBUG CONSTRAINT: Added constraint x[11] + not_covered[15] ≤ 1 for terminal 15
DEBUG CONSTRAINT: Added constraint x[17] + not_covered[15] ≤ 1 for terminal 15
DEBUG CONSTRAINT: Added constraint x[18] + not_covered[15] ≤ 1 for terminal 15
DEBUG CONSTRAINT: Added constraint x[20] + not_covered[15] ≤ 1 for terminal 15
DEBUG CONSTRAINT: Added constraint x[22] + not_covered[15] ≤ 1 for terminal 15
DEBUG CONSTRAINT: Added constraint x[38] + not_covered[15] ≤ 1 for terminal 15
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 7·not_covered[15] ≤ 7 for terminal 15
DEBUG CONSTRAINT: Added constraint x[23] + not_covered[16] ≤ 1 for terminal 16
DEBUG CONSTRAINT: Added constraint x[24] + not_covered[16] ≤ 1 for terminal 16
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 2·not_covered[16] ≤ 2 for terminal 16
DEBUG CONSTRAINT: Added constraint x[12] + not_covered[17] ≤ 1 for terminal 17
DEBUG CONSTRAINT: Added constraint x[15] + not_covered[17] ≤ 1 for terminal 17
DEBUG CONSTRAINT: Added constraint x[19] + not_covered[17] ≤ 1 for terminal 17
DEBUG CONSTRAINT: Added constraint x[21] + not_covered[17] ≤ 1 for terminal 17
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 4·not_covered[17] ≤ 4 for terminal 17
DEBUG CONSTRAINT: Added constraint x[12] + not_covered[18] ≤ 1 for terminal 18
DEBUG CONSTRAINT: Added constraint x[14] + not_covered[18] ≤ 1 for terminal 18
DEBUG CONSTRAINT: Added constraint x[15] + not_covered[18] ≤ 1 for terminal 18
DEBUG CONSTRAINT: Added constraint x[19] + not_covered[18] ≤ 1 for terminal 18
DEBUG CONSTRAINT: Added constraint x[21] + not_covered[18] ≤ 1 for terminal 18
DEBUG CONSTRAINT: Added constraint x[25] + not_covered[18] ≤ 1 for terminal 18
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 6·not_covered[18] ≤ 6 for terminal 18
DEBUG CONSTRAINT: Added constraint x[4] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint x[10] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint x[11] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint x[17] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint x[18] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint x[20] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint x[26] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint x[37] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint x[38] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 9·not_covered[19] ≤ 9 for terminal 19
DEBUG CONSTRAINT: Added source terminal constraint: not_covered[0] = 0
DEBUG BUDGET: Adding budget constraint ≤ 1000000.000 to constraint pool
DEBUG BUDGET: Using raw tree costs directly
DEBUG BUDGET: Budget limit: 1000000.000
DEBUG BUDGET: Building raw cost constraint coefficients:
DEBUG BUDGET:   x[0] coefficient = 398991 (raw=398991.100)
DEBUG BUDGET:   x[1] coefficient = 260889 (raw=260889.712)
DEBUG BUDGET:   x[2] coefficient = 256773 (raw=256773.057)
DEBUG BUDGET:   x[3] coefficient = 376541 (raw=376541.557)
DEBUG BUDGET:   x[4] coefficient = 646084 (raw=646084.462)
DEBUG BUDGET:   x[5] coefficient = 520973 (raw=520973.020)
DEBUG BUDGET:   x[6] coefficient = 334575 (raw=334575.182)
DEBUG BUDGET:   x[7] coefficient = 494448 (raw=494448.457)
DEBUG BUDGET:   x[8] coefficient = 455905 (raw=455905.519)
DEBUG BUDGET:   x[9] coefficient = 584020 (raw=584020.499)
DEBUG BUDGET:   x[10] coefficient = 380918 (raw=380918.244)
DEBUG BUDGET:   x[11] coefficient = 621357 (raw=621357.781)
DEBUG BUDGET:   x[12] coefficient = 120675 (raw=120675.719)
DEBUG BUDGET:   x[13] coefficient = 551354 (raw=551354.477)
DEBUG BUDGET:   x[14] coefficient = 410262 (raw=410262.679)
DEBUG BUDGET:   x[15] coefficient = 362962 (raw=362962.653)
DEBUG BUDGET:   x[16] coefficient = 702244 (raw=702244.403)
DEBUG BUDGET:   x[17] coefficient = 673894 (raw=673894.542)
DEBUG BUDGET:   x[18] coefficient = 933994 (raw=933994.022)
DEBUG BUDGET:   x[19] coefficient = 454199 (raw=454199.906)
DEBUG BUDGET:   x[20] coefficient = 986439 (raw=986439.144)
DEBUG BUDGET:   x[21] coefficient = 46859 (raw=46859.249)
DEBUG BUDGET:   x[22] coefficient = 52662 (raw=52662.185)
DEBUG BUDGET:   x[23] coefficient = 62275 (raw=62275.339)
DEBUG BUDGET:   x[24] coefficient = 75379 (raw=75379.993)
DEBUG BUDGET:   x[25] coefficient = 75695 (raw=75695.846)
DEBUG BUDGET:   x[26] coefficient = 80703 (raw=80703.013)
DEBUG BUDGET:   x[27] coefficient = 93734 (raw=93734.596)
DEBUG BUDGET:   x[28] coefficient = 95452 (raw=95452.578)
DEBUG BUDGET:   x[29] coefficient = 102977 (raw=102977.757)
DEBUG BUDGET:   x[30] coefficient = 165327 (raw=165327.925)
DEBUG BUDGET:   x[31] coefficient = 170420 (raw=170420.027)
DEBUG BUDGET:   x[32] coefficient = 179069 (raw=179069.657)
DEBUG BUDGET:   x[33] coefficient = 234458 (raw=234458.486)
DEBUG BUDGET:   x[34] coefficient = 235891 (raw=235891.713)
DEBUG BUDGET:   x[35] coefficient = 242462 (raw=242462.956)
DEBUG BUDGET:   x[36] coefficient = 258947 (raw=258947.370)
DEBUG BUDGET:   x[37] coefficient = 313063 (raw=313063.098)
DEBUG BUDGET:   x[38] coefficient = 314219 (raw=314219.517)
DEBUG BUDGET:   x[39] coefficient = 327174 (raw=327174.269)
DEBUG BUDGET: Constraint: Σ tree_cost[i] * x[i] ≤ 1000000
DEBUG BUDGET: Budget constraint added to pool with 40 FSTs
DEBUG CONSTRAINT: Adding 'at least one FST' constraint: Σ x[i] ≥ 1
DEBUG CONSTRAINT: Added 'at least one FST' constraint: Σ x[i] ≥ 1
 % _gst_initialize_constraint_pool: 0.00 seconds.
 % Constraint pool initialized with:
 % 	1	Total degree rows	40	coeffs.
 % 	20	Cutset rows		111	coeffs.
 % 	0	Incompatibility rows	0	coeffs.
 % 	29	2-terminal SEC rows	102	coeffs.
 % 	1	At least one FST rows	40	coeffs.
 % 	163	Total rows in pool	135	in LP
 % @PMEM 163 rows, 1 blocks, 415 nzfree, 0 nzwasted, 1172 nztotal
DEBUG SOFT: Found 20 terminals, 40 FSTs
DEBUG SOFT: Adding space for 20 not_covered variables in soft constraints, total ncoeff=514
DEBUG LP_SETUP: Created LP with 0 rows, 60 columns (nedges=40 + nterms=20)
DEBUG SOFT: Set bounds for 40 FST vars [1-40] and 20 coverage vars [41-60]
DEBUG OBJ: Using raw costs - alpha=10000.0 (battery weight), beta=1500000 (coverage penalty)
DEBUG OBJ: Allocated rowvec[0-60] for ncols=60 LP variables
DEBUG OBJ: Full_trees battery_score=0.000 for FST 0
DEBUG OBJ: Recalculating for FST 0 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 5): battery=97.50, running_total=97.50
DEBUG OBJ: Terminal 1 (idx 1): battery=82.60, running_total=180.10
DEBUG OBJ: Terminal 2 (idx 4): battery=98.00, running_total=278.10
DEBUG OBJ: Recalculated battery_score=278.100 for FST 0
DEBUG OBJ: FST 0: tree_cost=398991.100, battery_cost=278.100 (weighted=2781000.0), combined=3179991.1
DEBUG OBJ: Full_trees battery_score=0.000 for FST 1
DEBUG OBJ: Recalculating for FST 1 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 10): battery=98.00, running_total=98.00
DEBUG OBJ: Terminal 1 (idx 5): battery=97.50, running_total=195.50
DEBUG OBJ: Terminal 2 (idx 4): battery=98.00, running_total=293.50
DEBUG OBJ: Recalculated battery_score=293.500 for FST 1
DEBUG OBJ: FST 1: tree_cost=260889.712, battery_cost=293.500 (weighted=2935000.0), combined=3195889.7
DEBUG OBJ: Full_trees battery_score=0.000 for FST 2
DEBUG OBJ: Recalculating for FST 2 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 13): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 0): battery=100.00, running_total=200.00
DEBUG OBJ: Terminal 2 (idx 6): battery=100.00, running_total=300.00
DEBUG OBJ: Recalculated battery_score=300.000 for FST 2
DEBUG OBJ: FST 2: tree_cost=256773.057, battery_cost=300.000 (weighted=3000000.0), combined=3256773.1
DEBUG OBJ: Full_trees battery_score=0.000 for FST 3
DEBUG OBJ: Recalculating for FST 3 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 15): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 3): battery=100.00, running_total=200.00
DEBUG OBJ: Terminal 2 (idx 6): battery=100.00, running_total=300.00
DEBUG OBJ: Recalculated battery_score=300.000 for FST 3
DEBUG OBJ: FST 3: tree_cost=376541.557, battery_cost=300.000 (weighted=3000000.0), combined=3376541.6
DEBUG OBJ: Full_trees battery_score=0.000 for FST 4
DEBUG OBJ: Recalculating for FST 4 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 19): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 3): battery=100.00, running_total=200.00
DEBUG OBJ: Terminal 2 (idx 6): battery=100.00, running_total=300.00
DEBUG OBJ: Recalculated battery_score=300.000 for FST 4
DEBUG OBJ: FST 4: tree_cost=646084.462, battery_cost=300.000 (weighted=3000000.0), combined=3646084.5
DEBUG OBJ: Full_trees battery_score=0.000 for FST 5
DEBUG OBJ: Recalculating for FST 5 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 11): battery=76.00, running_total=76.00
DEBUG OBJ: Terminal 1 (idx 2): battery=91.70, running_total=167.70
DEBUG OBJ: Terminal 2 (idx 7): battery=100.00, running_total=267.70
DEBUG OBJ: Recalculated battery_score=267.700 for FST 5
DEBUG OBJ: FST 5: tree_cost=520973.020, battery_cost=267.700 (weighted=2677000.0), combined=3197973.0
DEBUG OBJ: Full_trees battery_score=0.000 for FST 6
DEBUG OBJ: Recalculating for FST 6 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 9): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 7): battery=100.00, running_total=200.00
DEBUG OBJ: Terminal 2 (idx 8): battery=100.00, running_total=300.00
DEBUG OBJ: Recalculated battery_score=300.000 for FST 6
DEBUG OBJ: FST 6: tree_cost=334575.182, battery_cost=300.000 (weighted=3000000.0), combined=3334575.2
DEBUG OBJ: Full_trees battery_score=0.000 for FST 7
DEBUG OBJ: Recalculating for FST 7 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 11): battery=76.00, running_total=76.00
DEBUG OBJ: Terminal 1 (idx 2): battery=91.70, running_total=167.70
DEBUG OBJ: Terminal 2 (idx 9): battery=100.00, running_total=267.70
DEBUG OBJ: Recalculated battery_score=267.700 for FST 7
DEBUG OBJ: FST 7: tree_cost=494448.457, battery_cost=267.700 (weighted=2677000.0), combined=3171448.5
DEBUG OBJ: Full_trees battery_score=0.000 for FST 8
DEBUG OBJ: Recalculating for FST 8 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 11): battery=76.00, running_total=76.00
DEBUG OBJ: Terminal 1 (idx 7): battery=100.00, running_total=176.00
DEBUG OBJ: Terminal 2 (idx 9): battery=100.00, running_total=276.00
DEBUG OBJ: Recalculated battery_score=276.000 for FST 8
DEBUG OBJ: FST 8: tree_cost=455905.519, battery_cost=276.000 (weighted=2760000.0), combined=3215905.5
DEBUG OBJ: Full_trees battery_score=0.000 for FST 9
DEBUG OBJ: Recalculating for FST 9 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 12): battery=93.00, running_total=93.00
DEBUG OBJ: Terminal 1 (idx 11): battery=76.00, running_total=169.00
DEBUG OBJ: Terminal 2 (idx 9): battery=100.00, running_total=269.00
DEBUG OBJ: Recalculated battery_score=269.000 for FST 9
DEBUG OBJ: FST 9: tree_cost=584020.499, battery_cost=269.000 (weighted=2690000.0), combined=3274020.5
DEBUG OBJ: Full_trees battery_score=0.000 for FST 10
DEBUG OBJ: Recalculating for FST 10 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 19): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 12): battery=93.00, running_total=193.00
DEBUG OBJ: Terminal 2 (idx 14): battery=100.00, running_total=293.00
DEBUG OBJ: Recalculated battery_score=293.000 for FST 10
DEBUG OBJ: FST 10: tree_cost=380918.244, battery_cost=293.000 (weighted=2930000.0), combined=3310918.2
DEBUG OBJ: Full_trees battery_score=0.000 for FST 11
DEBUG OBJ: Recalculating for FST 11 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 19): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 15): battery=100.00, running_total=200.00
DEBUG OBJ: Terminal 2 (idx 6): battery=100.00, running_total=300.00
DEBUG OBJ: Recalculated battery_score=300.000 for FST 11
DEBUG OBJ: FST 11: tree_cost=621357.781, battery_cost=300.000 (weighted=3000000.0), combined=3621357.8
DEBUG OBJ: Full_trees battery_score=0.000 for FST 12
DEBUG OBJ: Recalculating for FST 12 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 18): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 9): battery=100.00, running_total=200.00
DEBUG OBJ: Terminal 2 (idx 17): battery=100.00, running_total=300.00
DEBUG OBJ: Recalculated battery_score=300.000 for FST 12
DEBUG OBJ: FST 12: tree_cost=120675.719, battery_cost=300.000 (weighted=3000000.0), combined=3120675.7
DEBUG OBJ: Full_trees battery_score=0.000 for FST 13
DEBUG OBJ: Recalculating for FST 13 with 4 terminals
DEBUG OBJ: Terminal 0 (idx 11): battery=76.00, running_total=76.00
DEBUG OBJ: Terminal 1 (idx 7): battery=100.00, running_total=176.00
DEBUG OBJ: Terminal 2 (idx 8): battery=100.00, running_total=276.00
DEBUG OBJ: Terminal 3 (idx 9): battery=100.00, running_total=376.00
DEBUG OBJ: Recalculated battery_score=376.000 for FST 13
DEBUG OBJ: FST 13: tree_cost=551354.477, battery_cost=376.000 (weighted=3760000.0), combined=4311354.5
DEBUG OBJ: Full_trees battery_score=0.000 for FST 14
DEBUG OBJ: Recalculating for FST 14 with 4 terminals
DEBUG OBJ: Terminal 0 (idx 18): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 9): battery=100.00, running_total=200.00
DEBUG OBJ: Terminal 2 (idx 7): battery=100.00, running_total=300.00
DEBUG OBJ: Terminal 3 (idx 8): battery=100.00, running_total=400.00
DEBUG OBJ: Recalculated battery_score=400.000 for FST 14
DEBUG OBJ: FST 14: tree_cost=410262.679, battery_cost=400.000 (weighted=4000000.0), combined=4410262.7
DEBUG OBJ: Full_trees battery_score=0.000 for FST 15
DEBUG OBJ: Recalculating for FST 15 with 4 terminals
DEBUG OBJ: Terminal 0 (idx 18): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 9): battery=100.00, running_total=200.00
DEBUG OBJ: Terminal 2 (idx 7): battery=100.00, running_total=300.00
DEBUG OBJ: Terminal 3 (idx 17): battery=100.00, running_total=400.00
DEBUG OBJ: Recalculated battery_score=400.000 for FST 15
DEBUG OBJ: FST 15: tree_cost=362962.653, battery_cost=400.000 (weighted=4000000.0), combined=4362962.7
DEBUG OBJ: Full_trees battery_score=0.000 for FST 16
DEBUG OBJ: Recalculating for FST 16 with 4 terminals
DEBUG OBJ: Terminal 0 (idx 11): battery=76.00, running_total=76.00
DEBUG OBJ: Terminal 1 (idx 2): battery=91.70, running_total=167.70
DEBUG OBJ: Terminal 2 (idx 7): battery=100.00, running_total=267.70
DEBUG OBJ: Terminal 3 (idx 9): battery=100.00, running_total=367.70
DEBUG OBJ: Recalculated battery_score=367.700 for FST 16
DEBUG OBJ: FST 16: tree_cost=702244.403, battery_cost=367.700 (weighted=3677000.0), combined=4379244.4
DEBUG OBJ: Full_trees battery_score=0.000 for FST 17
DEBUG OBJ: Recalculating for FST 17 with 4 terminals
DEBUG OBJ: Terminal 0 (idx 19): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 15): battery=100.00, running_total=200.00
DEBUG OBJ: Terminal 2 (idx 3): battery=100.00, running_total=300.00
DEBUG OBJ: Terminal 3 (idx 6): battery=100.00, running_total=400.00
DEBUG OBJ: Recalculated battery_score=400.000 for FST 17
DEBUG OBJ: FST 17: tree_cost=673894.542, battery_cost=400.000 (weighted=4000000.0), combined=4673894.5
DEBUG OBJ: Full_trees battery_score=0.000 for FST 18
DEBUG OBJ: Recalculating for FST 18 with 4 terminals
DEBUG OBJ: Terminal 0 (idx 19): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 15): battery=100.00, running_total=200.00
DEBUG OBJ: Terminal 2 (idx 6): battery=100.00, running_total=300.00
DEBUG OBJ: Terminal 3 (idx 12): battery=93.00, running_total=393.00
DEBUG OBJ: Recalculated battery_score=393.000 for FST 18
DEBUG OBJ: FST 18: tree_cost=933994.022, battery_cost=393.000 (weighted=3930000.0), combined=4863994.0
DEBUG OBJ: Full_trees battery_score=0.000 for FST 19
DEBUG OBJ: Recalculating for FST 19 with 5 terminals
DEBUG OBJ: Terminal 0 (idx 18): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 9): battery=100.00, running_total=200.00
DEBUG OBJ: Terminal 2 (idx 7): battery=100.00, running_total=300.00
DEBUG OBJ: Terminal 3 (idx 8): battery=100.00, running_total=400.00
DEBUG OBJ: Terminal 4 (idx 17): battery=100.00, running_total=500.00
DEBUG OBJ: Recalculated battery_score=500.000 for FST 19
DEBUG OBJ: FST 19: tree_cost=454199.906, battery_cost=500.000 (weighted=5000000.0), combined=5454199.9
DEBUG OBJ: Full_trees battery_score=0.000 for FST 20
DEBUG OBJ: Recalculating for FST 20 with 5 terminals
DEBUG OBJ: Terminal 0 (idx 19): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 15): battery=100.00, running_total=200.00
DEBUG OBJ: Terminal 2 (idx 3): battery=100.00, running_total=300.00
DEBUG OBJ: Terminal 3 (idx 6): battery=100.00, running_total=400.00
DEBUG OBJ: Terminal 4 (idx 12): battery=93.00, running_total=493.00
DEBUG OBJ: Recalculated battery_score=493.000 for FST 20
DEBUG OBJ: FST 20: tree_cost=986439.144, battery_cost=493.000 (weighted=4930000.0), combined=5916439.1
DEBUG OBJ: Full_trees battery_score=0.000 for FST 21
DEBUG OBJ: Recalculating for FST 21 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 18): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 17): battery=100.00, running_total=200.00
DEBUG OBJ: Recalculated battery_score=200.000 for FST 21
DEBUG OBJ: FST 21: tree_cost=46859.249, battery_cost=200.000 (weighted=2000000.0), combined=2046859.2
DEBUG OBJ: Full_trees battery_score=0.000 for FST 22
DEBUG OBJ: Recalculating for FST 22 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 15): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 3): battery=100.00, running_total=200.00
DEBUG OBJ: Recalculated battery_score=200.000 for FST 22
DEBUG OBJ: FST 22: tree_cost=52662.185, battery_cost=200.000 (weighted=2000000.0), combined=2052662.2
DEBUG OBJ: Full_trees battery_score=0.000 for FST 23
DEBUG OBJ: Recalculating for FST 23 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 16): battery=68.00, running_total=68.00
DEBUG OBJ: Terminal 1 (idx 2): battery=91.70, running_total=159.70
DEBUG OBJ: Recalculated battery_score=159.700 for FST 23
DEBUG OBJ: FST 23: tree_cost=62275.339, battery_cost=159.700 (weighted=1597000.0), combined=1659275.3
DEBUG OBJ: Full_trees battery_score=0.000 for FST 24
DEBUG OBJ: Recalculating for FST 24 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 16): battery=68.00, running_total=68.00
DEBUG OBJ: Terminal 1 (idx 1): battery=82.60, running_total=150.60
DEBUG OBJ: Recalculated battery_score=150.600 for FST 24
DEBUG OBJ: FST 24: tree_cost=75379.993, battery_cost=150.600 (weighted=1506000.0), combined=1581380.0
DEBUG OBJ: Full_trees battery_score=0.000 for FST 25
DEBUG OBJ: Recalculating for FST 25 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 18): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 9): battery=100.00, running_total=200.00
DEBUG OBJ: Recalculated battery_score=200.000 for FST 25
DEBUG OBJ: FST 25: tree_cost=75695.846, battery_cost=200.000 (weighted=2000000.0), combined=2075695.8
DEBUG OBJ: Full_trees battery_score=0.000 for FST 26
DEBUG OBJ: Recalculating for FST 26 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 14): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 19): battery=100.00, running_total=200.00
DEBUG OBJ: Recalculated battery_score=200.000 for FST 26
DEBUG OBJ: FST 26: tree_cost=80703.013, battery_cost=200.000 (weighted=2000000.0), combined=2080703.0
DEBUG OBJ: Full_trees battery_score=0.000 for FST 27
DEBUG OBJ: Recalculating for FST 27 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 0): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 13): battery=100.00, running_total=200.00
DEBUG OBJ: Recalculated battery_score=200.000 for FST 27
DEBUG OBJ: FST 27: tree_cost=93734.596, battery_cost=200.000 (weighted=2000000.0), combined=2093734.6
DEBUG OBJ: Full_trees battery_score=0.000 for FST 28
DEBUG OBJ: Recalculating for FST 28 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 8): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 7): battery=100.00, running_total=200.00
DEBUG OBJ: Recalculated battery_score=200.000 for FST 28
DEBUG OBJ: FST 28: tree_cost=95452.578, battery_cost=200.000 (weighted=2000000.0), combined=2095452.6
DEBUG OBJ: Full_trees battery_score=0.000 for FST 29
DEBUG OBJ: Recalculating for FST 29 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 5): battery=97.50, running_total=97.50
DEBUG OBJ: Terminal 1 (idx 10): battery=98.00, running_total=195.50
DEBUG OBJ: Recalculated battery_score=195.500 for FST 29
DEBUG OBJ: FST 29: tree_cost=102977.757, battery_cost=195.500 (weighted=1955000.0), combined=2057977.8
DEBUG OBJ: Full_trees battery_score=0.000 for FST 30
DEBUG OBJ: Recalculating for FST 30 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 4): battery=98.00, running_total=98.00
DEBUG OBJ: Terminal 1 (idx 5): battery=97.50, running_total=195.50
DEBUG OBJ: Recalculated battery_score=195.500 for FST 30
DEBUG OBJ: FST 30: tree_cost=165327.925, battery_cost=195.500 (weighted=1955000.0), combined=2120327.9
DEBUG OBJ: Full_trees battery_score=0.000 for FST 31
DEBUG OBJ: Recalculating for FST 31 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 6): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 0): battery=100.00, running_total=200.00
DEBUG OBJ: Recalculated battery_score=200.000 for FST 31
DEBUG OBJ: FST 31: tree_cost=170420.027, battery_cost=200.000 (weighted=2000000.0), combined=2170420.0
DEBUG OBJ: Full_trees battery_score=0.000 for FST 32
DEBUG OBJ: Recalculating for FST 32 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 13): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 4): battery=98.00, running_total=198.00
DEBUG OBJ: Recalculated battery_score=198.000 for FST 32
DEBUG OBJ: FST 32: tree_cost=179069.657, battery_cost=198.000 (weighted=1980000.0), combined=2159069.7
DEBUG OBJ: Full_trees battery_score=0.000 for FST 33
DEBUG OBJ: Recalculating for FST 33 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 5): battery=97.50, running_total=97.50
DEBUG OBJ: Terminal 1 (idx 1): battery=82.60, running_total=180.10
DEBUG OBJ: Recalculated battery_score=180.100 for FST 33
DEBUG OBJ: FST 33: tree_cost=234458.486, battery_cost=180.100 (weighted=1801000.0), combined=2035458.5
DEBUG OBJ: Full_trees battery_score=0.000 for FST 34
DEBUG OBJ: Recalculating for FST 34 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 11): battery=76.00, running_total=76.00
DEBUG OBJ: Terminal 1 (idx 9): battery=100.00, running_total=176.00
DEBUG OBJ: Recalculated battery_score=176.000 for FST 34
DEBUG OBJ: FST 34: tree_cost=235891.713, battery_cost=176.000 (weighted=1760000.0), combined=1995891.7
DEBUG OBJ: Full_trees battery_score=0.000 for FST 35
DEBUG OBJ: Recalculating for FST 35 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 9): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 7): battery=100.00, running_total=200.00
DEBUG OBJ: Recalculated battery_score=200.000 for FST 35
DEBUG OBJ: FST 35: tree_cost=242462.956, battery_cost=200.000 (weighted=2000000.0), combined=2242463.0
DEBUG OBJ: Full_trees battery_score=0.000 for FST 36
DEBUG OBJ: Recalculating for FST 36 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 2): battery=91.70, running_total=91.70
DEBUG OBJ: Terminal 1 (idx 11): battery=76.00, running_total=167.70
DEBUG OBJ: Recalculated battery_score=167.700 for FST 36
DEBUG OBJ: FST 36: tree_cost=258947.370, battery_cost=167.700 (weighted=1677000.0), combined=1935947.4
DEBUG OBJ: Full_trees battery_score=0.000 for FST 37
DEBUG OBJ: Recalculating for FST 37 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 19): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 12): battery=93.00, running_total=193.00
DEBUG OBJ: Recalculated battery_score=193.000 for FST 37
DEBUG OBJ: FST 37: tree_cost=313063.098, battery_cost=193.000 (weighted=1930000.0), combined=2243063.1
DEBUG OBJ: Full_trees battery_score=0.000 for FST 38
DEBUG OBJ: Recalculating for FST 38 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 15): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 19): battery=100.00, running_total=200.00
DEBUG OBJ: Recalculated battery_score=200.000 for FST 38
DEBUG OBJ: FST 38: tree_cost=314219.517, battery_cost=200.000 (weighted=2000000.0), combined=2314219.5
DEBUG OBJ: Full_trees battery_score=0.000 for FST 39
DEBUG OBJ: Recalculating for FST 39 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 3): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 6): battery=100.00, running_total=200.00
DEBUG OBJ: Recalculated battery_score=200.000 for FST 39
DEBUG OBJ: FST 39: tree_cost=327174.269, battery_cost=200.000 (weighted=2000000.0), combined=2327174.3
DEBUG OBJ: Added penalty terms beta=1500000 for 20 not_covered variables [41-60]
DEBUG LP_MATRIX: LP has 0 rows, 60 columns after setup
DEBUG EXTRA_COEFF: Calculated extra_coeff=1 for 135 rows
DEBUG SOFT: Added not_covered_0 (RC_var 43 -> matrix_idx 40) to soft constraint 134
DEBUG MATRIX_CHECK: nzi=495, ncoeff=514, extra_coeff=1, expected=515
ERROR: Matrix coefficient count mismatch! nzi=495 != ncoeff=514 + extra_coeff=1
WARNING: Allowing discrepancy in budget mode (nzi=495 vs expected=515)
DEBUG MATRIX: Total matrix has 495 entries (nzi=495)
DEBUG MATRIX: matbeg[135] = 495 (should equal nzi)
DEBUG LP: Calling add_rows with 135 rows
DEBUG LP: Before add_rows: LP has 0 rows, 60 cols, 60 nonzeros
DEBUG LP: After add_rows: LP has 135 rows, 60 cols, 555 nonzeros
DEBUG NLPROWS: nrows=135, extra_rows=0, setting nlprows=135
 % _gst_build_initial_formulation: 0.00 seconds.
DEBUG BB: Expected nlprows=135, total rows=163
DEBUG BB: Row 0 (uid=0) has lprow=0 (included, j=0)
DEBUG BB: Row 1 (uid=1) has lprow=1 (included, j=1)
DEBUG BB: Row 2 (uid=2) has lprow=2 (included, j=2)
DEBUG BB: Row 3 (uid=3) has lprow=3 (included, j=3)
DEBUG BB: Row 4 (uid=4) has lprow=4 (included, j=4)
DEBUG BB: Row 5 (uid=5) has lprow=5 (included, j=5)
DEBUG BB: Row 6 (uid=6) has lprow=6 (included, j=6)
DEBUG BB: Row 7 (uid=7) has lprow=7 (included, j=7)
DEBUG BB: Row 8 (uid=8) has lprow=8 (included, j=8)
DEBUG BB: Row 9 (uid=9) has lprow=9 (included, j=9)
DEBUG BB: Row 10 (uid=10) has lprow=10 (included, j=10)
DEBUG BB: Row 11 (uid=11) has lprow=11 (included, j=11)
DEBUG BB: Row 12 (uid=12) has lprow=12 (included, j=12)
DEBUG BB: Row 13 (uid=13) has lprow=13 (included, j=13)
DEBUG BB: Row 14 (uid=14) has lprow=14 (included, j=14)
DEBUG BB: Row 15 (uid=15) has lprow=15 (included, j=15)
DEBUG BB: Row 16 (uid=16) has lprow=16 (included, j=16)
DEBUG BB: Row 17 (uid=17) has lprow=17 (included, j=17)
DEBUG BB: Row 18 (uid=18) has lprow=18 (included, j=18)
DEBUG BB: Row 19 (uid=19) has lprow=19 (included, j=19)
DEBUG BB: Row 20 (uid=20) has lprow=20 (included, j=20)
DEBUG BB: Row 21 (uid=21) has lprow=21 (included, j=21)
DEBUG BB: Row 22 (uid=22) has lprow=22 (included, j=22)
DEBUG BB: Row 23 (uid=23) has lprow=23 (included, j=23)
DEBUG BB: Row 24 (uid=24) has lprow=24 (included, j=24)
DEBUG BB: Row 25 (uid=25) has lprow=25 (included, j=25)
DEBUG BB: Row 26 (uid=26) has lprow=26 (included, j=26)
DEBUG BB: Row 27 (uid=27) has lprow=27 (included, j=27)
DEBUG BB: Row 28 (uid=28) has lprow=28 (included, j=28)
DEBUG BB: Row 29 (uid=29) has lprow=29 (included, j=29)
DEBUG BB: Row 30 (uid=30) has lprow=30 (included, j=30)
DEBUG BB: Row 31 (uid=31) has lprow=31 (included, j=31)
DEBUG BB: Row 32 (uid=32) has lprow=32 (included, j=32)
DEBUG BB: Row 33 (uid=33) has lprow=33 (included, j=33)
DEBUG BB: Row 34 (uid=34) has lprow=34 (included, j=34)
DEBUG BB: Row 35 (uid=35) has lprow=35 (included, j=35)
DEBUG BB: Row 36 (uid=36) has lprow=36 (included, j=36)
DEBUG BB: Row 37 (uid=37) has lprow=37 (included, j=37)
DEBUG BB: Row 38 (uid=38) has lprow=38 (included, j=38)
DEBUG BB: Row 39 (uid=39) has lprow=39 (included, j=39)
DEBUG BB: Row 40 (uid=40) has lprow=40 (included, j=40)
DEBUG BB: Row 41 (uid=41) has lprow=41 (included, j=41)
DEBUG BB: Row 42 (uid=42) has lprow=42 (included, j=42)
DEBUG BB: Row 43 (uid=43) has lprow=43 (included, j=43)
DEBUG BB: Row 44 (uid=44) has lprow=44 (included, j=44)
DEBUG BB: Row 45 (uid=45) has lprow=45 (included, j=45)
DEBUG BB: Row 46 (uid=46) has lprow=46 (included, j=46)
DEBUG BB: Row 47 (uid=47) has lprow=47 (included, j=47)
DEBUG BB: Row 48 (uid=48) has lprow=48 (included, j=48)
DEBUG BB: Row 49 (uid=49) has lprow=49 (included, j=49)
DEBUG BB: Row 50 (uid=50) has lprow=50 (included, j=50)
DEBUG BB: Row 51 (uid=51) has lprow=51 (included, j=51)
DEBUG BB: Row 52 (uid=52) has lprow=52 (included, j=52)
DEBUG BB: Row 53 (uid=53) has lprow=53 (included, j=53)
DEBUG BB: Row 54 (uid=54) has lprow=54 (included, j=54)
DEBUG BB: Row 55 (uid=55) has lprow=55 (included, j=55)
DEBUG BB: Row 56 (uid=56) has lprow=56 (included, j=56)
DEBUG BB: Row 57 (uid=57) has lprow=57 (included, j=57)
DEBUG BB: Row 58 (uid=58) has lprow=58 (included, j=58)
DEBUG BB: Row 59 (uid=59) has lprow=59 (included, j=59)
DEBUG BB: Row 60 (uid=60) has lprow=60 (included, j=60)
DEBUG BB: Row 61 (uid=61) has lprow=61 (included, j=61)
DEBUG BB: Row 62 (uid=62) has lprow=62 (included, j=62)
DEBUG BB: Row 63 (uid=63) has lprow=63 (included, j=63)
DEBUG BB: Row 64 (uid=64) has lprow=64 (included, j=64)
DEBUG BB: Row 65 (uid=65) has lprow=65 (included, j=65)
DEBUG BB: Row 66 (uid=66) has lprow=66 (included, j=66)
DEBUG BB: Row 67 (uid=67) has lprow=67 (included, j=67)
DEBUG BB: Row 68 (uid=68) has lprow=68 (included, j=68)
DEBUG BB: Row 69 (uid=69) has lprow=69 (included, j=69)
DEBUG BB: Row 70 (uid=70) has lprow=70 (included, j=70)
DEBUG BB: Row 71 (uid=71) has lprow=71 (included, j=71)
DEBUG BB: Row 72 (uid=72) has lprow=72 (included, j=72)
DEBUG BB: Row 73 (uid=73) has lprow=73 (included, j=73)
DEBUG BB: Row 74 (uid=74) has lprow=74 (included, j=74)
DEBUG BB: Row 75 (uid=75) has lprow=75 (included, j=75)
DEBUG BB: Row 76 (uid=76) has lprow=76 (included, j=76)
DEBUG BB: Row 77 (uid=77) has lprow=77 (included, j=77)
DEBUG BB: Row 78 (uid=78) has lprow=78 (included, j=78)
DEBUG BB: Row 79 (uid=79) has lprow=79 (included, j=79)
DEBUG BB: Row 80 (uid=80) has lprow=80 (included, j=80)
DEBUG BB: Row 81 (uid=81) has lprow=81 (included, j=81)
DEBUG BB: Row 82 (uid=82) has lprow=82 (included, j=82)
DEBUG BB: Row 83 (uid=83) has lprow=83 (included, j=83)
DEBUG BB: Row 84 (uid=84) has lprow=84 (included, j=84)
DEBUG BB: Row 85 (uid=85) has lprow=85 (included, j=85)
DEBUG BB: Row 86 (uid=86) has lprow=86 (included, j=86)
DEBUG BB: Row 87 (uid=87) has lprow=87 (included, j=87)
DEBUG BB: Row 88 (uid=88) has lprow=88 (included, j=88)
DEBUG BB: Row 89 (uid=89) has lprow=89 (included, j=89)
DEBUG BB: Row 90 (uid=90) has lprow=90 (included, j=90)
DEBUG BB: Row 91 (uid=91) has lprow=91 (included, j=91)
DEBUG BB: Row 92 (uid=92) has lprow=92 (included, j=92)
DEBUG BB: Row 93 (uid=93) has lprow=93 (included, j=93)
DEBUG BB: Row 94 (uid=94) has lprow=94 (included, j=94)
DEBUG BB: Row 95 (uid=95) has lprow=95 (included, j=95)
DEBUG BB: Row 96 (uid=96) has lprow=96 (included, j=96)
DEBUG BB: Row 97 (uid=97) has lprow=97 (included, j=97)
DEBUG BB: Row 98 (uid=98) has lprow=98 (included, j=98)
DEBUG BB: Row 99 (uid=99) has lprow=99 (included, j=99)
DEBUG BB: Row 100 (uid=100) has lprow=100 (included, j=100)
DEBUG BB: Row 101 (uid=101) has lprow=101 (included, j=101)
DEBUG BB: Row 102 (uid=102) has lprow=102 (included, j=102)
DEBUG BB: Row 103 (uid=103) has lprow=103 (included, j=103)
DEBUG BB: Row 104 (uid=104) has lprow=104 (included, j=104)
DEBUG BB: Row 105 (uid=105) has lprow=105 (included, j=105)
DEBUG BB: Row 106 (uid=106) has lprow=106 (included, j=106)
DEBUG BB: Row 107 (uid=107) has lprow=107 (included, j=107)
DEBUG BB: Row 108 (uid=108) has lprow=108 (included, j=108)
DEBUG BB: Row 109 (uid=109) has lprow=109 (included, j=109)
DEBUG BB: Row 110 (uid=110) has lprow=110 (included, j=110)
DEBUG BB: Row 111 (uid=111) has lprow=111 (included, j=111)
DEBUG BB: Row 112 (uid=112) has lprow=112 (included, j=112)
DEBUG BB: Row 113 (uid=113) has lprow=113 (included, j=113)
DEBUG BB: Row 114 (uid=114) has lprow=114 (included, j=114)
DEBUG BB: Row 115 (uid=115) has lprow=115 (included, j=115)
DEBUG BB: Row 116 (uid=116) has lprow=116 (included, j=116)
DEBUG BB: Row 117 (uid=117) has lprow=117 (included, j=117)
DEBUG BB: Row 118 (uid=118) has lprow=118 (included, j=118)
DEBUG BB: Row 119 (uid=119) has lprow=119 (included, j=119)
DEBUG BB: Row 120 (uid=120) has lprow=120 (included, j=120)
DEBUG BB: Row 121 (uid=121) has lprow=121 (included, j=121)
DEBUG BB: Row 122 (uid=122) has lprow=122 (included, j=122)
DEBUG BB: Row 123 (uid=123) has lprow=123 (included, j=123)
DEBUG BB: Row 124 (uid=124) has lprow=124 (included, j=124)
DEBUG BB: Row 125 (uid=125) has lprow=125 (included, j=125)
DEBUG BB: Row 126 (uid=126) has lprow=126 (included, j=126)
DEBUG BB: Row 127 (uid=127) has lprow=127 (included, j=127)
DEBUG BB: Row 128 (uid=128) has lprow=128 (included, j=128)
DEBUG BB: Row 129 (uid=129) has lprow=129 (included, j=129)
DEBUG BB: Row 130 (uid=130) has lprow=130 (included, j=130)
DEBUG BB: Row 131 (uid=131) has lprow=131 (included, j=131)
DEBUG BB: Row 132 (uid=132) has lprow=132 (included, j=132)
DEBUG BB: Row 133 (uid=133) has lprow=-1 (skipped)
DEBUG BB: Row 134 (uid=134) has lprow=-1 (skipped)
DEBUG BB: Row 135 (uid=135) has lprow=-1 (skipped)
DEBUG BB: Row 136 (uid=136) has lprow=-1 (skipped)
DEBUG BB: Row 137 (uid=137) has lprow=-1 (skipped)
DEBUG BB: Row 138 (uid=138) has lprow=-1 (skipped)
DEBUG BB: Row 139 (uid=139) has lprow=-1 (skipped)
DEBUG BB: Row 140 (uid=140) has lprow=-1 (skipped)
DEBUG BB: Row 141 (uid=141) has lprow=-1 (skipped)
DEBUG BB: Row 142 (uid=142) has lprow=-1 (skipped)
DEBUG BB: Row 143 (uid=143) has lprow=-1 (skipped)
DEBUG BB: Row 144 (uid=144) has lprow=-1 (skipped)
DEBUG BB: Row 145 (uid=145) has lprow=-1 (skipped)
DEBUG BB: Row 146 (uid=146) has lprow=-1 (skipped)
DEBUG BB: Row 147 (uid=147) has lprow=-1 (skipped)
DEBUG BB: Row 148 (uid=148) has lprow=-1 (skipped)
DEBUG BB: Row 149 (uid=149) has lprow=-1 (skipped)
DEBUG BB: Row 150 (uid=150) has lprow=-1 (skipped)
DEBUG BB: Row 151 (uid=151) has lprow=-1 (skipped)
DEBUG BB: Row 152 (uid=152) has lprow=-1 (skipped)
DEBUG BB: Row 153 (uid=153) has lprow=-1 (skipped)
DEBUG BB: Row 154 (uid=154) has lprow=-1 (skipped)
DEBUG BB: Row 155 (uid=155) has lprow=-1 (skipped)
DEBUG BB: Row 156 (uid=156) has lprow=-1 (skipped)
DEBUG BB: Row 157 (uid=157) has lprow=-1 (skipped)
DEBUG BB: Row 158 (uid=158) has lprow=-1 (skipped)
DEBUG BB: Row 159 (uid=159) has lprow=-1 (skipped)
DEBUG BB: Row 160 (uid=160) has lprow=-1 (skipped)
DEBUG BB: Row 161 (uid=161) has lprow=133 (included, j=133)
DEBUG BB: Row 162 (uid=162) has lprow=134 (included, j=134)
DEBUG BB: Found 135 actual LP rows, expected 135
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5571bedb9600
% Resuming node 0
DEBUG CONSTRNT: LP rows=135, pool->nlprows=135, pool->npend=0
DEBUG CONSTRNT: Checking 135 LP rows (pool tracks 135, total LP rows 135)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 1
DEBUG CONSTRNT: Pool row 1 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 2
DEBUG CONSTRNT: Pool row 2 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 3
DEBUG CONSTRNT: Pool row 3 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 4
DEBUG CONSTRNT: Pool row 4 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=56, expected 56
DEBUG CONSTRNT: Checking LP row 57 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=57, expected 57
DEBUG CONSTRNT: Checking LP row 58 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=58, expected 58
DEBUG CONSTRNT: Checking LP row 59 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=59, expected 59
DEBUG CONSTRNT: Checking LP row 60 -> pool row 60
DEBUG CONSTRNT: Pool row 60 has lprow=60, expected 60
DEBUG CONSTRNT: Checking LP row 61 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=61, expected 61
DEBUG CONSTRNT: Checking LP row 62 -> pool row 62
DEBUG CONSTRNT: Pool row 62 has lprow=62, expected 62
DEBUG CONSTRNT: Checking LP row 63 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=63, expected 63
DEBUG CONSTRNT: Checking LP row 64 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=64, expected 64
DEBUG CONSTRNT: Checking LP row 65 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=65, expected 65
DEBUG CONSTRNT: Checking LP row 66 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=66, expected 66
DEBUG CONSTRNT: Checking LP row 67 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=67, expected 67
DEBUG CONSTRNT: Checking LP row 68 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=68, expected 68
DEBUG CONSTRNT: Checking LP row 69 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=69, expected 69
DEBUG CONSTRNT: Checking LP row 70 -> pool row 70
DEBUG CONSTRNT: Pool row 70 has lprow=70, expected 70
DEBUG CONSTRNT: Checking LP row 71 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=71, expected 71
DEBUG CONSTRNT: Checking LP row 72 -> pool row 72
DEBUG CONSTRNT: Pool row 72 has lprow=72, expected 72
DEBUG CONSTRNT: Checking LP row 73 -> pool row 73
DEBUG CONSTRNT: Pool row 73 has lprow=73, expected 73
DEBUG CONSTRNT: Checking LP row 74 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=74, expected 74
DEBUG CONSTRNT: Checking LP row 75 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=75, expected 75
DEBUG CONSTRNT: Checking LP row 76 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=76, expected 76
DEBUG CONSTRNT: Checking LP row 77 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=77, expected 77
DEBUG CONSTRNT: Checking LP row 78 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=78, expected 78
DEBUG CONSTRNT: Checking LP row 79 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=79, expected 79
DEBUG CONSTRNT: Checking LP row 80 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=80, expected 80
DEBUG CONSTRNT: Checking LP row 81 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=81, expected 81
DEBUG CONSTRNT: Checking LP row 82 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=82, expected 82
DEBUG CONSTRNT: Checking LP row 83 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=83, expected 83
DEBUG CONSTRNT: Checking LP row 84 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=84, expected 84
DEBUG CONSTRNT: Checking LP row 85 -> pool row 85
DEBUG CONSTRNT: Pool row 85 has lprow=85, expected 85
DEBUG CONSTRNT: Checking LP row 86 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=86, expected 86
DEBUG CONSTRNT: Checking LP row 87 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=87, expected 87
DEBUG CONSTRNT: Checking LP row 88 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=88, expected 88
DEBUG CONSTRNT: Checking LP row 89 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=89, expected 89
DEBUG CONSTRNT: Checking LP row 90 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=90, expected 90
DEBUG CONSTRNT: Checking LP row 91 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=91, expected 91
DEBUG CONSTRNT: Checking LP row 92 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=92, expected 92
DEBUG CONSTRNT: Checking LP row 93 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=93, expected 93
DEBUG CONSTRNT: Checking LP row 94 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=94, expected 94
DEBUG CONSTRNT: Checking LP row 95 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=95, expected 95
DEBUG CONSTRNT: Checking LP row 96 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=96, expected 96
DEBUG CONSTRNT: Checking LP row 97 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=97, expected 97
DEBUG CONSTRNT: Checking LP row 98 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=98, expected 98
DEBUG CONSTRNT: Checking LP row 99 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=99, expected 99
DEBUG CONSTRNT: Checking LP row 100 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=100, expected 100
DEBUG CONSTRNT: Checking LP row 101 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=101, expected 101
DEBUG CONSTRNT: Checking LP row 102 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=102, expected 102
DEBUG CONSTRNT: Checking LP row 103 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=103, expected 103
DEBUG CONSTRNT: Checking LP row 104 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=104, expected 104
DEBUG CONSTRNT: Checking LP row 105 -> pool row 105
DEBUG CONSTRNT: Pool row 105 has lprow=105, expected 105
DEBUG CONSTRNT: Checking LP row 106 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=106, expected 106
DEBUG CONSTRNT: Checking LP row 107 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=107, expected 107
DEBUG CONSTRNT: Checking LP row 108 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=108, expected 108
DEBUG CONSTRNT: Checking LP row 109 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=109, expected 109
DEBUG CONSTRNT: Checking LP row 110 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=110, expected 110
DEBUG CONSTRNT: Checking LP row 111 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=111, expected 111
DEBUG CONSTRNT: Checking LP row 112 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=112, expected 112
DEBUG CONSTRNT: Checking LP row 113 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=113, expected 113
DEBUG CONSTRNT: Checking LP row 114 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=114, expected 114
DEBUG CONSTRNT: Checking LP row 115 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=115, expected 115
DEBUG CONSTRNT: Checking LP row 116 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=116, expected 116
DEBUG CONSTRNT: Checking LP row 117 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=117, expected 117
DEBUG CONSTRNT: Checking LP row 118 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=118, expected 118
DEBUG CONSTRNT: Checking LP row 119 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=119, expected 119
DEBUG CONSTRNT: Checking LP row 120 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=120, expected 120
DEBUG CONSTRNT: Checking LP row 121 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=121, expected 121
DEBUG CONSTRNT: Checking LP row 122 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=122, expected 122
DEBUG CONSTRNT: Checking LP row 123 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=123, expected 123
DEBUG CONSTRNT: Checking LP row 124 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=124, expected 124
DEBUG CONSTRNT: Checking LP row 125 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=125, expected 125
DEBUG CONSTRNT: Checking LP row 126 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=126, expected 126
DEBUG CONSTRNT: Checking LP row 127 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=127, expected 127
DEBUG CONSTRNT: Checking LP row 128 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=128, expected 128
DEBUG CONSTRNT: Checking LP row 129 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=129, expected 129
DEBUG CONSTRNT: Checking LP row 130 -> pool row 130
DEBUG CONSTRNT: Pool row 130 has lprow=130, expected 130
DEBUG CONSTRNT: Checking LP row 131 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=131, expected 131
DEBUG CONSTRNT: Checking LP row 132 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=132, expected 132
DEBUG CONSTRNT: Checking LP row 133 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=133, expected 133
DEBUG CONSTRNT: Checking LP row 134 -> pool row 162
DEBUG CONSTRNT: Pool row 162 has lprow=134, expected 134
 % @PAP adding 135 rows, 494 nz to LP
DEBUG BB: Processing node 0, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=155, theta=4.750000, up=1.000000
ITER 2: row=1, varin=149, theta=5.000000, up=1.000000
ITER 3: row=1, varin=151, theta=4.000000, up=1.000000
ITER 4: row=1, varin=152, theta=3.000000, up=1.000000
ITER 5: row=1, varin=150, theta=2.000000, up=1.000000
ITER 6: row=1, varin=156, theta=0.750000, up=1.000000
ITER 7: row=134, varin=176, theta=9.005525, up=1.000000
ITER 8: row=134, varin=177, theta=8.005525, up=1.000000
ITER 9: row=134, varin=178, theta=7.005525, up=1.000000
ITER 10: row=134, varin=179, theta=6.005525, up=1.000000
LP PHASE: Switching to primal (iter=33)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=135)
DEBUG SOLUTION: LP solution array indices: FST[136-175], not_covered[176-195]
DEBUG SOLUTION: lp->best_solution[0] = 27754604.277613
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 0.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 3.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 135 rows, 60 cols, 554 nonzeros, 68 slack, 67 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 68 slack rows
  % @PAP adding 8 rows, 34 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=68, varin=91, theta=3.897156, up=1.000000
ITER 2: row=68, varin=96, theta=0.553304, up=1.000000
ITER 3: row=41, varin=40, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=44, varin=43, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=1, varin=132, theta=0.897443, up=1.000000
ITER 6: row=15, varin=119, theta=0.553304, up=1.000000
ITER 7: row=36, varin=122, theta=0.553304, up=1.000000
ITER 8: row=1, varin=133, theta=1.004052, up=1.000000
ITER 9: row=1, varin=134, theta=0.004052, up=1.000000
ITER 10: row=63, varin=133, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=15)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=75)
DEBUG SOLUTION: LP solution array indices: FST[76-115], not_covered[116-135]
DEBUG SOLUTION: lp->best_solution[0] = 27951738.212947
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 5.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.436600
DEBUG SOLUTION: lp->best_solution[13] = 0.436600
DEBUG SOLUTION: lp->best_solution[14] = 0.436600
  % @PL 75 rows, 60 cols, 357 nonzeros, 26 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 26 slack rows
  % @PAP adding 4 rows, 22 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=71, theta=0.765989, up=1.000000
ITER 2: row=51, varin=109, theta=0.104517, up=1.000000
ITER 3: row=53, varin=113, theta=0.081557, up=1.000000
ITER 4: row=25, varin=3, theta=1.171104, up=999999999999999983222784.000000
ITER 5: row=3, varin=51, theta=1.494262, up=999999999999999983222784.000000
ITER 6: row=52, varin=53, theta=1.699828, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28005376.822196
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 5.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 53 rows, 60 cols, 305 nonzeros, 2 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 4 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=72, theta=0.236897, up=1.000000
ITER 2: row=8, varin=107, theta=0.545703, up=1.000000
ITER 3: row=44, varin=80, theta=0.376749, up=1.000000
ITER 4: row=3, varin=75, theta=0.072302, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 28017586.668463
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 5.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 55 rows, 60 cols, 295 nonzeros, 2 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 0 LP 1 Solution, length = 28017586.668463, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.072302 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.072302 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.319244 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.927698 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.319244 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.680756 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.680756 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.072302 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.072302 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.072302 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.927698 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.680756 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.680756 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.072302 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.072302 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.680756 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28017586.668463, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.00  28.01758666846276568663 99.9000000000
 % @LN 0.00  28.01758666846276568663 99.9000000000
DEBUG CG: Second cutoff check: z=28017586.668463, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 0 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 0
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.072302
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.072302)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.072302
DEBUG CAREFUL: Adding var 13 to fractional list (xi=0.072302)
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.319244
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.319244)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.927698
DEBUG CAREFUL: Adding var 19 to fractional list (xi=0.927698)
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.319244
DEBUG CAREFUL: Adding var 20 to fractional list (xi=0.319244)
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
DEBUG CAREFUL: Testing fvar[1] = var 20
DEBUG CAREFUL: Calling compare_branch_vars for var 20
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 20
DEBUG CAREFUL: Testing fvar[2] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
DEBUG CAREFUL: Testing fvar[3] = var 13
DEBUG CAREFUL: Calling compare_branch_vars for var 13
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 13
DEBUG CAREFUL: Testing fvar[4] = var 19
DEBUG CAREFUL: Calling compare_branch_vars for var 19
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 19
DEBUG CAREFUL: New best var: 19
  % Initial guess is x19, Z0 = 28161361.5240074        , Z1 = 28017586.6684628        

DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=43, varin=12, theta=1.085689, up=999999999999999983222784.000000
ITER 2: row=51, varin=69, theta=4.033755, up=1.000000
ITER 3: row=51, varin=24, theta=0.854267, up=999999999999999983222784.000000
ITER 4: row=52, varin=8, theta=7.504985, up=999999999999999983222784.000000
ITER 5: row=8, varin=48, theta=0.895651, up=999999999999999983222784.000000
ITER 6: row=53, varin=68, theta=3.691390, up=1.000000
ITER 7: row=53, varin=49, theta=0.686264, up=999999999999999983222784.000000
ITER 8: row=44, varin=3, theta=7.812523, up=999999999999999983222784.000000
ITER 9: row=3, varin=68, theta=1.456721, up=1.000000
ITER 10: row=3, varin=69, theta=0.441361, up=1.000000
DEBUG EVAL: Branch var 17 = 1 gives z=28417286.515083
  % 	x17 = 1,	Z1 = 28417286.5150834        
DEBUG EVAL: First branch cutoff check: z=28417286.515083, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 0
ITER 1: row=43, varin=8, theta=-4.679615, up=999999999999999983222784.000000
ITER 2: row=31, varin=61, theta=1.303617, up=1.000000
ITER 3: row=31, varin=54, theta=0.408594, up=1.000000
ITER 4: row=7, varin=61, theta=1.000000, up=1.000000
ITER 5: row=2, varin=43, theta=484347.666667, up=999999999999999983222784.000000
ITER 6: row=11, varin=7, theta=0.250000, up=999999999999999983222784.000000
ITER 7: row=7, varin=96, theta=0.034483, up=1.000000
ITER 8: row=43, varin=61, theta=0.307692, up=1.000000
ITER 9: row=11, varin=67, theta=0.200000, up=1.000000
  % 	x17 = 0,	Z0 = 28049765.9638657        
DEBUG EVAL: Second branch cutoff check: z=28049765.963866, best_z=INF, threshold=INF
  %   New best:  x17, Z = 28049765.9638657        
DEBUG EVAL: Testing var 20 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=12, varin=12, theta=0.855943, up=999999999999999983222784.000000
ITER 2: row=51, varin=61, theta=1.233035, up=1.000000
ITER 3: row=51, varin=54, theta=0.304365, up=1.000000
ITER 4: row=7, varin=61, theta=1.000000, up=1.000000
ITER 5: row=2, varin=43, theta=502235.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 20 = 0 gives z=28049765.963866
  % 	x20 = 0,	Z0 = 28049765.9638657        
DEBUG EVAL: First branch cutoff check: z=28049765.963866, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 20 = 1
ITER 1: row=12, varin=69, theta=4.033755, up=1.000000
ITER 2: row=12, varin=68, theta=3.691390, up=1.000000
ITER 3: row=12, varin=50, theta=1.081127, up=999999999999999983222784.000000
ITER 4: row=44, varin=68, theta=1.105958, up=1.000000
ITER 5: row=44, varin=8, theta=0.101997, up=999999999999999983222784.000000
ITER 6: row=43, varin=105, theta=2.532455, up=1.000000
ITER 7: row=43, varin=68, theta=0.473020, up=1.000000
ITER 8: row=8, varin=105, theta=2.361568, up=1.000000
ITER 9: row=8, varin=3, theta=4.300087, up=999999999999999983222784.000000
ITER 10: row=3, varin=31, theta=1.308858, up=999999999999999983222784.000000
  % 	x20 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: Second branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=12, varin=12, theta=0.855943, up=999999999999999983222784.000000
ITER 2: row=51, varin=61, theta=1.233035, up=1.000000
ITER 3: row=51, varin=54, theta=0.304365, up=1.000000
ITER 4: row=7, varin=61, theta=1.000000, up=1.000000
ITER 5: row=2, varin=43, theta=502235.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28049765.963866
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 5.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 53 rows, 60 cols, 290 nonzeros, 1 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 0 at  28.04976596386567422314
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5571bedb9600
% @LO 0.00  28.01758666846276568663 99.9000000000
% @LN 0.00  28.04976596386567422314 99.9000000000
% Resuming node 0 at  28.04976596386567422314
DEBUG CONSTRNT: LP rows=52, pool->nlprows=52, pool->npend=0
DEBUG CONSTRNT: Checking 52 LP rows (pool tracks 52, total LP rows 52)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=51, expected 51
 % @PAP adding 52 rows, 190 nz to LP
DEBUG BB: Processing node 0, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 0 LP 2 Solution, length = 28049765.963866, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.200000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.200000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.800000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.200000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.200000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.200000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.800000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.200000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.200000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28049765.963866, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28049765.963866, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 0 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 0
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.200000
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.200000)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.200000
DEBUG CAREFUL: Adding var 13 to fractional list (xi=0.200000)
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.800000
DEBUG CAREFUL: Adding var 19 to fractional list (xi=0.800000)
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 3 fractional variables

  %  Carefully choosing branching variable, nfrac = 3
DEBUG CAREFUL: Testing fvar[0] = var 19
DEBUG CAREFUL: Calling compare_branch_vars for var 19
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 19
DEBUG CAREFUL: New best var: 19
DEBUG CAREFUL: Testing fvar[1] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
DEBUG CAREFUL: Testing fvar[2] = var 13
DEBUG CAREFUL: Calling compare_branch_vars for var 13
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 13
  % Initial guess is x19, Z0 = 28161361.5240074        , Z1 = 28049765.9638657        

DEBUG EVAL: Testing var 19 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=25, varin=58, theta=0.500000, up=1.000000
ITER 2: row=6, varin=95, theta=0.250000, up=1.000000
ITER 3: row=43, varin=71, theta=0.333333, up=1.000000
DEBUG EVAL: Branch var 19 = 1 gives z=28075531.246349
  % 	x19 = 1,	Z1 = 28075531.2463487        
DEBUG EVAL: First branch cutoff check: z=28075531.246349, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 19 = 0
ITER 1: row=25, varin=2, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=2, varin=50, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=12, varin=7, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=7, varin=3, theta=4.000000, up=999999999999999983222784.000000
ITER 5: row=3, varin=68, theta=4.000000, up=1.000000
ITER 6: row=3, varin=8, theta=3.000000, up=999999999999999983222784.000000
ITER 7: row=8, varin=44, theta=1.500000, up=999999999999999983222784.000000
ITER 8: row=1, varin=49, theta=1.000000, up=999999999999999983222784.000000
ITER 9: row=50, varin=68, theta=3.000000, up=1.000000
ITER 10: row=50, varin=24, theta=2.000000, up=999999999999999983222784.000000
  % 	x19 = 0,	Z0 = 28311354.4769014        
DEBUG EVAL: Second branch cutoff check: z=28311354.476901, best_z=INF, threshold=INF
  %   New best:  x19, Z = 28075531.2463487        
DEBUG EVAL: Testing var 12 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=58, theta=0.500000, up=1.000000
ITER 2: row=6, varin=68, theta=0.250000, up=1.000000
DEBUG EVAL: Branch var 12 = 0 gives z=28056390.592684
  % 	x12 = 0,	Z0 = 28056390.5926843        
DEBUG EVAL: First branch cutoff check: z=28056390.592684, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 13 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=31, varin=58, theta=0.500000, up=1.000000
ITER 2: row=6, varin=95, theta=0.111111, up=1.000000
DEBUG EVAL: Branch var 13 = 0 gives z=28055882.316132
  % 	x13 = 0,	Z0 = 28055882.3161319        
DEBUG EVAL: First branch cutoff check: z=28055882.316132, best_z=INF, threshold=INF
  % Best branch is x19, Z0 = 28311354.4769014        , Z1 = 28075531.2463487        

DEBUG CAREFUL: Final result - returning best.var = 19
DEBUG BB: Branching variable chosen: j=19
 % @NC    1    0	x19 = 1	28075531.246349
 % @NC    2    0	x19 = 0	28311354.476901
 %       0     2 28049765.9639               28075531.2463
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5571bedc1fb0
% @LO 0.00  28.04976596386567422314 99.9000000000
% @LN 0.00  28.07553124634865326925 99.9000000000
% Resuming node 1 at  28.07553124634865326925
DEBUG CONSTRNT: LP rows=52, pool->nlprows=52, pool->npend=0
DEBUG CONSTRNT: Checking 52 LP rows (pool tracks 52, total LP rows 52)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=51, expected 51
 % @PAP adding 52 rows, 190 nz to LP
DEBUG BB: Processing node 1, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=25, varin=58, theta=0.500000, up=1.000000
ITER 2: row=6, varin=95, theta=0.250000, up=1.000000
ITER 3: row=43, varin=71, theta=0.333333, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28075531.246349
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 5.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 250 nonzeros, 0 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 8 rows, 42 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=53, varin=8, theta=0.333333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=60)
DEBUG SOLUTION: LP solution array indices: FST[61-100], not_covered[101-120]
DEBUG SOLUTION: lp->best_solution[0] = 28077340.397976
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.666667
DEBUG SOLUTION: lp->best_solution[9] = 0.666667
DEBUG SOLUTION: lp->best_solution[10] = 0.666667
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 60 rows, 60 cols, 292 nonzeros, 4 slack, 56 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 3 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=59, varin=111, theta=0.090909, up=1.000000
ITER 2: row=57, varin=61, theta=0.666667, up=1.000000
ITER 3: row=10, varin=101, theta=0.500000, up=1.000000
ITER 4: row=9, varin=20, theta=0.250000, up=999999999999999983222784.000000
ITER 5: row=54, varin=69, theta=0.428571, up=1.000000
ITER 6: row=52, varin=59, theta=3.000000, up=999999999999999983222784.000000
ITER 7: row=39, varin=28, theta=0.111111, up=999999999999999983222784.000000
ITER 8: row=52, varin=43, theta=0.081301, up=999999999999999983222784.000000
ITER 9: row=56, varin=62, theta=0.600000, up=1.000000
ITER 10: row=50, varin=44, theta=0.014856, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=11)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=59)
DEBUG SOLUTION: LP solution array indices: FST[60-99], not_covered[100-119]
DEBUG SOLUTION: lp->best_solution[0] = 28111508.067593
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 4.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 59 rows, 60 cols, 293 nonzeros, 3 slack, 56 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=57, varin=82, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=58)
DEBUG SOLUTION: LP solution array indices: FST[59-98], not_covered[99-118]
DEBUG SOLUTION: lp->best_solution[0] = 28113475.244898
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 4.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 58 rows, 60 cols, 291 nonzeros, 0 slack, 58 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=59, varin=48, theta=2.126326, up=999999999999999983222784.000000
ITER 2: row=46, varin=6, theta=0.337838, up=999999999999999983222784.000000
ITER 3: row=61, varin=56, theta=2.142857, up=999999999999999983222784.000000
ITER 4: row=46, varin=59, theta=0.263158, up=999999999999999983222784.000000
ITER 5: row=58, varin=6, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=61, varin=57, theta=0.125000, up=999999999999999983222784.000000
ITER 7: row=55, varin=107, theta=0.400000, up=1.000000
ITER 8: row=19, varin=56, theta=3.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=62)
DEBUG SOLUTION: LP solution array indices: FST[63-102], not_covered[103-122]
DEBUG SOLUTION: lp->best_solution[0] = 28138910.644085
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 4.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 62 rows, 60 cols, 304 nonzeros, 4 slack, 58 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % Node 1 LP 1 Solution, length = 28138910.644085, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.500000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.500000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 2 fractional variables
DEBUG CG: LP optimal, z=28138910.644085, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.00  28.07553124634865326925 99.9000000000
 % @LN 0.00  28.13891064408537801000 99.9000000000
DEBUG CG: Second cutoff check: z=28138910.644085, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 1 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 1
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.500000
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.500000
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 2 fractional variables

  %  Carefully choosing branching variable, nfrac = 2
DEBUG CAREFUL: Testing fvar[0] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 5
DEBUG CAREFUL: New best var: 5
DEBUG CAREFUL: Testing fvar[1] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
  % Initial guess is x5, Z0 = 28138910.6440854        , Z1 = 28138910.6440854        

DEBUG EVAL: Testing var 5 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=27, varin=62, theta=0.538462, up=1.000000
ITER 2: row=48, varin=44, theta=0.051962, up=999999999999999983222784.000000
ITER 3: row=52, varin=53, theta=0.438479, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 5 = 0 gives z=28157289.767843
  % 	x5 = 0,	Z0 = 28157289.7678428        
DEBUG EVAL: First branch cutoff check: z=28157289.767843, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 5 = 1
ITER 1: row=27, varin=19, theta=0.800000, up=999999999999999983222784.000000
ITER 2: row=13, varin=55, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=6, varin=46, theta=0.207847, up=999999999999999983222784.000000
ITER 4: row=48, varin=57, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=57, varin=27, theta=0.302859, up=999999999999999983222784.000000
ITER 6: row=10, varin=10, theta=0.363636, up=999999999999999983222784.000000
ITER 7: row=2, varin=56, theta=0.444444, up=999999999999999983222784.000000
ITER 8: row=49, varin=9, theta=0.428571, up=999999999999999983222784.000000
ITER 9: row=1, varin=47, theta=0.331529, up=999999999999999983222784.000000
ITER 10: row=47, varin=44, theta=0.543689, up=999999999999999983222784.000000
  % 	x5 = 1,	Z1 = 28237897.1539705        
DEBUG EVAL: Second branch cutoff check: z=28237897.153971, best_z=INF, threshold=INF
  %   New best:  x5, Z = 28157289.7678428        
DEBUG EVAL: Testing var 7 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=55, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=6, varin=62, theta=0.538462, up=1.000000
ITER 3: row=48, varin=44, theta=0.051962, up=999999999999999983222784.000000
ITER 4: row=52, varin=53, theta=0.438479, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 7 = 0 gives z=28157289.767843
  % 	x7 = 0,	Z0 = 28157289.7678428        
DEBUG EVAL: First branch cutoff check: z=28157289.767843, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 7 = 1
ITER 1: row=7, varin=19, theta=0.800000, up=999999999999999983222784.000000
ITER 2: row=13, varin=46, theta=0.207847, up=999999999999999983222784.000000
ITER 3: row=48, varin=57, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=57, varin=27, theta=0.302859, up=999999999999999983222784.000000
ITER 5: row=10, varin=10, theta=0.363636, up=999999999999999983222784.000000
ITER 6: row=2, varin=56, theta=0.444444, up=999999999999999983222784.000000
ITER 7: row=49, varin=9, theta=0.428571, up=999999999999999983222784.000000
ITER 8: row=1, varin=47, theta=0.331529, up=999999999999999983222784.000000
ITER 9: row=47, varin=44, theta=0.543689, up=999999999999999983222784.000000
ITER 10: row=44, varin=54, theta=0.500000, up=999999999999999983222784.000000
  % 	x7 = 1,	Z1 = 28224634.8725275        
DEBUG EVAL: Second branch cutoff check: z=28224634.872527, best_z=INF, threshold=INF
  % Best branch is x5, Z0 = 28157289.7678428        , Z1 = 28237897.1539705        

DEBUG CAREFUL: Final result - returning best.var = 5
DEBUG BB: Branching variable chosen: j=5
 % @NC    3    1	x5 = 0	28157289.767843
 % @NC    4    1	x5 = 1	28237897.153971
 %       1     3 28138910.6441               28157289.7678   x19 U     0     1
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5571bedb9600
% @LO 0.00  28.13891064408537801000 99.9000000000
% @LN 0.00  28.15728976784282622248 99.9000000000
% Resuming node 3 at  28.15728976784282622248
DEBUG CONSTRNT: LP rows=58, pool->nlprows=58, pool->npend=0
DEBUG CONSTRNT: Checking 58 LP rows (pool tracks 58, total LP rows 58)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=56, expected 56
DEBUG CONSTRNT: Checking LP row 57 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=57, expected 57
 % @PAP adding 58 rows, 225 nz to LP
DEBUG BB: Processing node 3, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=27, varin=62, theta=0.538462, up=1.000000
ITER 2: row=48, varin=44, theta=0.051962, up=999999999999999983222784.000000
ITER 3: row=52, varin=53, theta=0.438479, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=58)
DEBUG SOLUTION: LP solution array indices: FST[59-98], not_covered[99-118]
DEBUG SOLUTION: lp->best_solution[0] = 28157289.767843
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.937360
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 4.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 58 rows, 60 cols, 285 nonzeros, 7 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 7 rows, 26 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=61, varin=52, theta=0.602151, up=999999999999999983222784.000000
ITER 2: row=44, varin=48, theta=1.244444, up=999999999999999983222784.000000
ITER 3: row=64, varin=76, theta=0.297872, up=1.000000
ITER 4: row=31, varin=49, theta=0.538462, up=999999999999999983222784.000000
ITER 5: row=62, varin=111, theta=0.190476, up=1.000000
ITER 6: row=58, varin=54, theta=0.179487, up=999999999999999983222784.000000
ITER 7: row=45, varin=44, theta=0.133333, up=999999999999999983222784.000000
ITER 8: row=59, varin=30, theta=2.000000, up=999999999999999983222784.000000
ITER 9: row=44, varin=61, theta=0.072727, up=999999999999999983222784.000000
ITER 10: row=50, varin=51, theta=0.363636, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=10)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=65)
DEBUG SOLUTION: LP solution array indices: FST[66-105], not_covered[106-125]
DEBUG SOLUTION: lp->best_solution[0] = 28217885.125539
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.909091
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.909091
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 4.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 65 rows, 60 cols, 311 nonzeros, 14 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 14 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=40, theta=0.833333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28223645.261229
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 253 nonzeros, 1 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 1 rows, 40 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=109, theta=0.020522, up=1.000000
ITER 2: row=12, varin=64, theta=0.015411, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28224916.147862
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 283 nonzeros, 0 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 3 LP 1 Solution, length = 28224916.147862, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.161530 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.161530 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.161530 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.161530 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.015411 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.161530 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.161530 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.838470 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.838470 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.838470 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.838470 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.838470 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.838470 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.838470 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.838470 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=28224916.147862, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.00  28.15728976784282622248 99.9000000000
 % @LN 0.00  28.22491614786240887724 99.9000000000
DEBUG CG: Second cutoff check: z=28224916.147862, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 3 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 3
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.161530
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.161530)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.161530
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.161530)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.161530
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.161530)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.161530
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.161530)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.015411
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.015411)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.161530
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.161530)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.161530
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.161530)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 7 fractional variables

  %  Carefully choosing branching variable, nfrac = 7
DEBUG CAREFUL: Testing fvar[0] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
DEBUG CAREFUL: Testing fvar[1] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
DEBUG CAREFUL: Testing fvar[2] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 11
DEBUG CAREFUL: New best var: 11
DEBUG CAREFUL: Testing fvar[3] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[4] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[5] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
DEBUG CAREFUL: Testing fvar[6] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
  % Initial guess is x11, Z0 = 28224916.1478624        , Z1 = 28588559.0765635        

DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: Branch var 17 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x17 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=35, varin=38, theta=0.756803, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
ITER 2: row=41, varin=37, theta=0.142682, up=999999999999999983222784.000000
ITER 3: row=1, varin=49, theta=0.306233, up=999999999999999983222784.000000
ITER 4: row=44, varin=44, theta=0.000000, up=999999999999999983222784.000000
ITER 5: row=52, varin=27, theta=0.763626, up=999999999999999983222784.000000
ITER 6: row=1, varin=52, theta=164883.000000, up=999999999999999983222784.000000
ITER 7: row=6, varin=41, theta=0.000000, up=999999999999999983222784.000000
ITER 8: row=25, varin=64, theta=0.500000, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28264878.796203
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 52 rows, 60 cols, 283 nonzeros, 1 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 6 rows, 34 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=71, theta=5.000000, up=1.000000
ITER 2: row=1, varin=73, theta=4.000000, up=1.000000
ITER 3: row=1, varin=74, theta=3.000000, up=1.000000
ITER 4: row=1, varin=72, theta=2.000000, up=1.000000
ITER 5: row=1, varin=98, theta=3.000000, up=1.000000
ITER 6: row=1, varin=99, theta=2.000000, up=1.000000
ITER 7: row=1, varin=100, theta=1.000000, up=1.000000
ITER 8: row=30, varin=98, theta=1.000000, up=1.000000
ITER 9: row=31, varin=72, theta=4.000000, up=1.000000
ITER 10: row=31, varin=74, theta=3.000000, up=1.000000
LP PHASE: Switching to primal (iter=63)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 28299789.248874
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 57 rows, 60 cols, 277 nonzeros, 8 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 8 slack rows
   % @PAP adding 4 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=36, theta=0.092308, up=999999999999999983222784.000000
ITER 2: row=45, varin=48, theta=0.125000, up=999999999999999983222784.000000
ITER 3: row=25, varin=46, theta=0.139535, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28304364.517886
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 53 rows, 60 cols, 267 nonzeros, 5 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 5 slack rows
   % @PAP adding 4 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=63, theta=0.823529, up=1.000000
ITER 2: row=51, varin=49, theta=0.150000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28307264.581102
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 52 rows, 60 cols, 263 nonzeros, 3 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 3 slack rows
   % @PAP adding 3 rows, 44 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=96, theta=0.071214, up=1.000000
ITER 2: row=50, varin=44, theta=0.109729, up=999999999999999983222784.000000
ITER 3: row=51, varin=103, theta=0.955797, up=1.000000
ITER 4: row=12, varin=52, theta=136789.695652, up=999999999999999983222784.000000
ITER 5: row=25, varin=46, theta=0.100142, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
% Warning: Numerical instability, qout = -0.375
% pcol[46] =            -420223, rhs[46] =          -0.333333 , upbo = 1e+24
ITER 6: row=46, varin=12, theta=-0.375000, up=999999999999999983222784.000000
ITER 7: row=1, varin=49, theta=0.040000, up=999999999999999983222784.000000
ITER 8: row=44, varin=51, theta=0.000000, up=999999999999999983222784.000000
ITER 9: row=1, varin=63, theta=0.043478, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28307863.739338
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 52 rows, 60 cols, 295 nonzeros, 3 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 3 slack rows
   % @PAP adding 6 rows, 26 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=43, theta=0.028986, up=999999999999999983222784.000000
ITER 2: row=55, varin=52, theta=1.695652, up=999999999999999983222784.000000
ITER 3: row=49, varin=46, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=55, varin=45, theta=0.416667, up=999999999999999983222784.000000
ITER 5: row=50, varin=52, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 28331842.165594
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 55 rows, 60 cols, 272 nonzeros, 3 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 3 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 3 at  28.33184216559413926007
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5571bedc5ef0
% @LO 0.00  28.22491614786240887724 99.9000000000
% @LN 0.00  28.23789715397054678192 99.9000000000
% Resuming node 4 at  28.23789715397054678192
DEBUG CONSTRNT: LP rows=52, pool->nlprows=52, pool->npend=0
DEBUG CONSTRNT: Checking 52 LP rows (pool tracks 52, total LP rows 52)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=51, expected 51
 % @PAP adding 58 rows, 225 nz to LP
DEBUG BB: Processing node 4, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=27, varin=19, theta=0.800000, up=999999999999999983222784.000000
ITER 2: row=13, varin=55, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=6, varin=46, theta=0.207847, up=999999999999999983222784.000000
ITER 4: row=48, varin=57, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=57, varin=27, theta=0.302859, up=999999999999999983222784.000000
ITER 6: row=10, varin=10, theta=0.363636, up=999999999999999983222784.000000
ITER 7: row=2, varin=56, theta=0.444444, up=999999999999999983222784.000000
ITER 8: row=49, varin=9, theta=0.428571, up=999999999999999983222784.000000
ITER 9: row=1, varin=47, theta=0.331529, up=999999999999999983222784.000000
ITER 10: row=47, varin=44, theta=0.543689, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=11)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=58)
DEBUG SOLUTION: LP solution array indices: FST[59-98], not_covered[99-118]
DEBUG SOLUTION: lp->best_solution[0] = 28237897.153971
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.500000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 4.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 58 rows, 60 cols, 285 nonzeros, 2 slack, 56 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 2 rows, 44 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=58, varin=82, theta=1.202472, up=1.000000
ITER 2: row=58, varin=61, theta=0.293018, up=1.000000
ITER 3: row=55, varin=82, theta=1.000000, up=1.000000
ITER 4: row=26, varin=60, theta=4.619680, up=1.000000
ITER 5: row=26, varin=80, theta=0.869688, up=1.000000
ITER 6: row=14, varin=60, theta=1.000000, up=1.000000
ITER 7: row=39, varin=42, theta=9.893773, up=999999999999999983222784.000000
ITER 8: row=57, varin=81, theta=1.386478, up=1.000000
ITER 9: row=57, varin=87, theta=0.401555, up=1.000000
ITER 10: row=42, varin=57, theta=0.136619, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=58)
DEBUG SOLUTION: LP solution array indices: FST[59-98], not_covered[99-118]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.500000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 4.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 58 rows, 60 cols, 325 nonzeros, 4 slack, 54 tight.
  % Node 4 LP 1 Solution, length = 999999999999999983222784.000000, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.500000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 4 is INFEASIBLE
 %       4     2    infeasible               28311354.4769    x5 U     1     2
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5571bedc7070
% @LO 0.00  28.23789715397054678192 99.9000000000
% @LN 0.00  28.31135447690136430765 99.9000000000
% Resuming node 2 at  28.31135447690136430765
DEBUG CONSTRNT: LP rows=58, pool->nlprows=58, pool->npend=0
DEBUG CONSTRNT: Checking 58 LP rows (pool tracks 58, total LP rows 58)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=56, expected 56
DEBUG CONSTRNT: Checking LP row 57 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=57, expected 57
 % @PAP adding 52 rows, 190 nz to LP
DEBUG BB: Processing node 2, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=25, varin=2, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=2, varin=50, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=12, varin=7, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=7, varin=3, theta=4.000000, up=999999999999999983222784.000000
ITER 5: row=3, varin=68, theta=4.000000, up=1.000000
ITER 6: row=3, varin=8, theta=3.000000, up=999999999999999983222784.000000
ITER 7: row=8, varin=44, theta=1.500000, up=999999999999999983222784.000000
ITER 8: row=1, varin=49, theta=1.000000, up=999999999999999983222784.000000
ITER 9: row=50, varin=68, theta=3.000000, up=1.000000
ITER 10: row=50, varin=24, theta=2.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=11)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28311354.476901
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 5.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 250 nonzeros, 6 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 24 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=53, varin=26, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=55, varin=27, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=1, varin=103, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 28311354.476901
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 5.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 56 rows, 60 cols, 274 nonzeros, 7 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=57, varin=106, theta=1.000000, up=1.000000
ITER 2: row=1, varin=74, theta=0.250000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=58)
DEBUG SOLUTION: LP solution array indices: FST[59-98], not_covered[99-118]
DEBUG SOLUTION: lp->best_solution[0] = 28324256.521042
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 5.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 58 rows, 60 cols, 287 nonzeros, 9 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 9 slack rows
  % @PAP adding 4 rows, 16 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=70, theta=0.250000, up=1.000000
ITER 2: row=8, varin=37, theta=0.333333, up=999999999999999983222784.000000
ITER 3: row=52, varin=96, theta=0.333333, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28333984.452292
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.666667
DEBUG SOLUTION: lp->best_solution[7] = 0.666667
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.666667
DEBUG SOLUTION: lp->best_solution[10] = 0.666667
DEBUG SOLUTION: lp->best_solution[11] = 3.666667
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 53 rows, 60 cols, 254 nonzeros, 5 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % Node 2 LP 1 Solution, length = 28333984.452292, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.666667 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.333333 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.666667 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.333333 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.333333 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.333333 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.333333 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 2 fractional variables
DEBUG CG: LP optimal, z=28333984.452292, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 2 at  28.33398445229202877726
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5571bedb9600
% @LO 0.00  28.31135447690136430765 99.9000000000
% @LN 0.00  28.33184216559413926007 99.9000000000
% Resuming node 3 at  28.33184216559413926007
DEBUG CONSTRNT: LP rows=48, pool->nlprows=48, pool->npend=0
DEBUG CONSTRNT: Checking 48 LP rows (pool tracks 48, total LP rows 48)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=47, expected 47
 % @PAP adding 52 rows, 184 nz to LP
DEBUG BB: Processing node 3, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 3 LP 2 Solution, length = 28331842.165594, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.125000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.125000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.125000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.125000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.125000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.125000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.125000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.125000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.875000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.875000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.875000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.875000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.875000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.875000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.875000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.875000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.875000 (terminal 19)
 % 8 fractional variables
DEBUG CG: LP optimal, z=28331842.165594, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28331842.165594, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 3 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 3
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.125000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.125000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.125000
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.125000)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.125000
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.125000)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.125000
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.125000)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.125000
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.125000)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.125000
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.125000)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.125000
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.125000)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.125000
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.125000)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 8 fractional variables

  %  Carefully choosing branching variable, nfrac = 8
DEBUG CAREFUL: Testing fvar[0] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
DEBUG CAREFUL: Testing fvar[1] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[2] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[3] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
DEBUG CAREFUL: Testing fvar[4] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[5] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 11
DEBUG CAREFUL: New best var: 11
DEBUG CAREFUL: Testing fvar[6] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 4
DEBUG CAREFUL: New best var: 4
DEBUG CAREFUL: Testing fvar[7] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x4, Z0 = 28331842.1655941        , Z1 = 28621746.0897695        

DEBUG EVAL: Testing var 18 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=33, varin=49, theta=7.000000, up=999999999999999983222784.000000
ITER 2: row=45, varin=52, theta=2.333333, up=999999999999999983222784.000000
ITER 3: row=39, varin=37, theta=4.000000, up=999999999999999983222784.000000
ITER 4: row=37, varin=46, theta=4.000000, up=999999999999999983222784.000000
ITER 5: row=25, varin=47, theta=1.500000, up=999999999999999983222784.000000
ITER 6: row=47, varin=42, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 18 = 1 gives z=28763662.883553
  % 	x18 = 1,	Z1 = 28763662.883553         
DEBUG EVAL: First branch cutoff check: z=28763662.883553, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 18 = 0
ITER 1: row=33, varin=53, theta=0.625000, up=1.000000
ITER 2: row=12, varin=48, theta=0.250000, up=999999999999999983222784.000000
ITER 3: row=43, varin=89, theta=1.000000, up=1.000000
  % 	x18 = 0,	Z0 = 28390147.2754937        
DEBUG EVAL: Second branch cutoff check: z=28390147.275494, best_z=INF, threshold=INF
  %   New best:  x18, Z = 28390147.2754937        
DEBUG EVAL: Testing var 9 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=36, varin=53, theta=0.625000, up=1.000000
ITER 2: row=12, varin=48, theta=0.250000, up=999999999999999983222784.000000
ITER 3: row=43, varin=36, theta=0.166667, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 9 = 0 gives z=28383478.092869
  % 	x9 = 0,	Z0 = 28383478.0928689        
DEBUG EVAL: First branch cutoff check: z=28383478.092869, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 3 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=24, varin=49, theta=0.142857, up=999999999999999983222784.000000
ITER 2: row=45, varin=53, theta=0.625000, up=1.000000
ITER 3: row=12, varin=52, theta=0.200000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 0 gives z=28353902.317750
  % 	x3 = 0,	Z0 = 28353902.31775          
DEBUG EVAL: First branch cutoff check: z=28353902.317750, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 7 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=53, theta=0.625000, up=1.000000
ITER 2: row=12, varin=48, theta=0.250000, up=999999999999999983222784.000000
ITER 3: row=43, varin=35, theta=0.142857, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 7 = 0 gives z=28361298.423159
  % 	x7 = 0,	Z0 = 28361298.4231587        
DEBUG EVAL: First branch cutoff check: z=28361298.423159, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=53, theta=0.625000, up=1.000000
ITER 2: row=12, varin=48, theta=0.250000, up=999999999999999983222784.000000
ITER 3: row=43, varin=42, theta=0.142857, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28349109.194577
  % 	x2 = 0,	Z0 = 28349109.1945774        
DEBUG EVAL: First branch cutoff check: z=28349109.194577, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 11 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=47, varin=49, theta=7.000000, up=999999999999999983222784.000000
ITER 2: row=45, varin=48, theta=2.333333, up=999999999999999983222784.000000
ITER 3: row=47, varin=52, theta=1.166667, up=999999999999999983222784.000000
ITER 4: row=43, varin=49, theta=2.333333, up=999999999999999983222784.000000
ITER 5: row=24, varin=45, theta=2.000000, up=999999999999999983222784.000000
ITER 6: row=39, varin=37, theta=4.000000, up=999999999999999983222784.000000
ITER 7: row=37, varin=46, theta=4.000000, up=999999999999999983222784.000000
ITER 8: row=25, varin=33, theta=1.000000, up=999999999999999983222784.000000
ITER 9: row=44, varin=42, theta=3.000000, up=999999999999999983222784.000000
ITER 10: row=1, varin=8, theta=2.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 11 = 1 gives z=28939551.708420
  % 	x11 = 1,	Z1 = 28939551.7084195        
DEBUG EVAL: First branch cutoff check: z=28939551.708420, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 11 = 0
ITER 1: row=47, varin=53, theta=0.625000, up=1.000000
ITER 2: row=12, varin=47, theta=0.166667, up=999999999999999983222784.000000
  % 	x11 = 0,	Z0 = 28354163.2887245        
DEBUG EVAL: Second branch cutoff check: z=28354163.288725, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 4 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=39, varin=49, theta=7.000000, up=999999999999999983222784.000000
ITER 2: row=45, varin=48, theta=2.333333, up=999999999999999983222784.000000
ITER 3: row=39, varin=37, theta=7.000000, up=999999999999999983222784.000000
ITER 4: row=37, varin=46, theta=7.000000, up=999999999999999983222784.000000
ITER 5: row=25, varin=47, theta=3.000000, up=999999999999999983222784.000000
ITER 6: row=47, varin=39, theta=0.800000, up=999999999999999983222784.000000
ITER 7: row=50, varin=33, theta=1.333333, up=999999999999999983222784.000000
ITER 8: row=51, varin=42, theta=4.000000, up=999999999999999983222784.000000
ITER 9: row=42, varin=8, theta=3.750000, up=999999999999999983222784.000000
ITER 10: row=8, varin=49, theta=0.600000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 4 = 1 gives z=29074686.181668
  % 	x4 = 1,	Z1 = 29074686.1816683        
DEBUG EVAL: First branch cutoff check: z=29074686.181668, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 4 = 0
ITER 1: row=39, varin=53, theta=0.625000, up=1.000000
ITER 2: row=12, varin=52, theta=0.166667, up=999999999999999983222784.000000
  % 	x4 = 0,	Z0 = 28350042.1751781        
DEBUG EVAL: Second branch cutoff check: z=28350042.175178, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=25, varin=53, theta=0.625000, up=1.000000
ITER 2: row=12, varin=46, theta=0.142857, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28341374.167810
  % 	x10 = 0,	Z0 = 28341374.1678104        
DEBUG EVAL: First branch cutoff check: z=28341374.167810, best_z=INF, threshold=INF
  % Best branch is x18, Z0 = 28390147.2754937        , Z1 = 28763662.883553         

DEBUG CAREFUL: Final result - returning best.var = 18
DEBUG BB: Branching variable chosen: j=18
 % @NC    5    3	x18 = 0	28390147.275494
 % @NC    6    3	x18 = 1	28763662.883553
 %       3     3 28331842.1656               28333984.4523    x5 D     1     2
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5571bedc7070
% @LO 0.00  28.33184216559413926007 99.9000000000
% @LN 0.00  28.33398445229202877726 99.9000000000
% Resuming node 2 at  28.33398445229202877726
DEBUG CONSTRNT: LP rows=52, pool->nlprows=52, pool->npend=0
DEBUG CONSTRNT: Checking 52 LP rows (pool tracks 52, total LP rows 52)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=51, expected 51
 % @PAP adding 48 rows, 180 nz to LP
DEBUG BB: Processing node 2, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 2 LP 2 Solution, length = 28333984.452292, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.666667 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.333333 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.666667 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.333333 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.333333 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.333333 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.333333 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 2 fractional variables
DEBUG CG: LP optimal, z=28333984.452292, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28333984.452292, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 2 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 2
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.666667
DEBUG CAREFUL: Adding var 13 to fractional list (xi=0.666667)
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.333333
DEBUG CAREFUL: Adding var 16 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 2 fractional variables

  %  Carefully choosing branching variable, nfrac = 2
DEBUG CAREFUL: Testing fvar[0] = var 16
DEBUG CAREFUL: Calling compare_branch_vars for var 16
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 16
DEBUG CAREFUL: New best var: 16
DEBUG CAREFUL: Testing fvar[1] = var 13
DEBUG CAREFUL: Calling compare_branch_vars for var 13
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 13
  % Initial guess is x16, Z0 = 28333984.452292         , Z1 = 28379244.4030734        

DEBUG EVAL: Testing var 16 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=47, theta=0.666667, up=999999999999999983222784.000000
ITER 2: row=46, varin=45, theta=0.400000, up=999999999999999983222784.000000
ITER 3: row=47, varin=7, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=7, varin=23, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 16 = 1 gives z=28379244.403073
  % 	x16 = 1,	Z1 = 28379244.4030734        
DEBUG EVAL: First branch cutoff check: z=28379244.403073, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 16 = 0
ITER 1: row=6, varin=63, theta=0.250000, up=1.000000
ITER 2: row=48, varin=33, theta=0.045455, up=999999999999999983222784.000000
  % 	x16 = 0,	Z0 = 28336179.4398677        
DEBUG EVAL: Second branch cutoff check: z=28336179.439868, best_z=INF, threshold=INF
  %   New best:  x16, Z = 28336179.4398677        
DEBUG EVAL: Testing var 13 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=63, theta=1.000000, up=1.000000
ITER 2: row=6, varin=47, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=46, varin=66, theta=0.333333, up=1.000000
ITER 4: row=38, varin=61, theta=0.600000, up=1.000000
ITER 5: row=48, varin=33, theta=0.111111, up=999999999999999983222784.000000
ITER 6: row=1, varin=45, theta=0.157895, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 13 = 1 gives z=28387570.720729
  % 	x13 = 1,	Z1 = 28387570.7207295        
DEBUG EVAL: First branch cutoff check: z=28387570.720729, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 13 = 0
ITER 1: row=1, varin=33, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=6, varin=42, theta=1.000000, up=999999999999999983222784.000000
  % 	x13 = 0,	Z0 = 28362962.6534628        
DEBUG EVAL: Second branch cutoff check: z=28362962.653463, best_z=INF, threshold=INF
  %   New best:  x13, Z = 28362962.6534628        
  % Best branch is x13, Z0 = 28362962.6534628        , Z1 = 28387570.7207295        

DEBUG CAREFUL: Final result - returning best.var = 13
DEBUG BB: Branching variable chosen: j=13
 % @NC    7    2	x13 = 0	28362962.653463
 % @NC    8    2	x13 = 1	28387570.720729
 %       2     4 28333984.4523               28362962.6535   x19 D     0     1
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5571bedb9600
% @LO 0.00  28.33398445229202877726 99.9000000000
% @LN 0.00  28.36296265346281231245 99.9000000000
% Resuming node 7 at  28.36296265346281231245
DEBUG CONSTRNT: LP rows=48, pool->nlprows=48, pool->npend=0
DEBUG CONSTRNT: Checking 48 LP rows (pool tracks 48, total LP rows 48)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=47, expected 47
 % @PAP adding 48 rows, 180 nz to LP
DEBUG BB: Processing node 7, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=33, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=6, varin=42, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28362962.653463
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 240 nonzeros, 5 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 29 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=44, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=51, varin=43, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=1, varin=69, theta=0.333333, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28368389.903333
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 269 nonzeros, 8 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 8 slack rows
  % @PAP adding 2 rows, 11 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=23, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28371103.528268
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 235 nonzeros, 2 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 7 LP 1 Solution, length = 28371103.528268, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.500000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.500000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 2 fractional variables
DEBUG CG: LP optimal, z=28371103.528268, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.00  28.36296265346281231245 99.9000000000
 % @LN 0.00  28.37110352826808323812 99.9000000000
DEBUG CG: Second cutoff check: z=28371103.528268, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 7 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 7
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.500000
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.500000
DEBUG CAREFUL: Adding var 16 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 2 fractional variables

  %  Carefully choosing branching variable, nfrac = 2
DEBUG CAREFUL: Testing fvar[0] = var 16
DEBUG CAREFUL: Calling compare_branch_vars for var 16
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 16
DEBUG CAREFUL: New best var: 16
DEBUG CAREFUL: Testing fvar[1] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 15
  % Initial guess is x16, Z0 = 28371103.5282681        , Z1 = 28379244.4030734        

DEBUG EVAL: Testing var 16 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=40, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 16 = 1 gives z=28379244.403073
  % 	x16 = 1,	Z1 = 28379244.4030734        
DEBUG EVAL: First branch cutoff check: z=28379244.403073, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 16 = 0
ITER 1: row=6, varin=59, theta=0.250000, up=1.000000
  % 	x16 = 0,	Z0 = 28374787.6597573        
DEBUG EVAL: Second branch cutoff check: z=28374787.659757, best_z=INF, threshold=INF
  %   New best:  x16, Z = 28374787.6597573        
DEBUG EVAL: Testing var 15 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=40, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 15 = 0 gives z=28379244.403073
  % 	x15 = 0,	Z0 = 28379244.4030734        
DEBUG EVAL: First branch cutoff check: z=28379244.403073, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 15 = 1
ITER 1: row=1, varin=59, theta=0.500000, up=1.000000
ITER 2: row=6, varin=62, theta=0.333333, up=1.000000
ITER 3: row=35, varin=57, theta=0.500000, up=1.000000
  % 	x15 = 1,	Z1 = 28423300.5131601        
DEBUG EVAL: Second branch cutoff check: z=28423300.513160, best_z=INF, threshold=INF
  %   New best:  x15, Z = 28379244.4030734        
  % Best branch is x15, Z0 = 28379244.4030734        , Z1 = 28423300.5131601        

DEBUG CAREFUL: Final result - returning best.var = 15
DEBUG BB: Branching variable chosen: j=15
 % @NC    9    7	x15 = 0	28379244.403073
 % @NC   10    7	x15 = 1	28423300.513160
 %       7     5 28371103.5283               28379244.4031   x13 D     2     2
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5571bedc7070
% @LO 0.00  28.37110352826808323812 99.9000000000
% @LN 0.00  28.37924440307335416378 99.9000000000
% Resuming node 9 at  28.37924440307335416378
DEBUG CONSTRNT: LP rows=44, pool->nlprows=44, pool->npend=0
DEBUG CONSTRNT: Checking 44 LP rows (pool tracks 44, total LP rows 44)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=43, expected 43
 % @PAP adding 44 rows, 164 nz to LP
DEBUG BB: Processing node 9, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=40, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28379244.403073
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 224 nonzeros, 1 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 29 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=42, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=47, varin=43, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=1, varin=63, theta=0.250000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28386998.971965
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 253 nonzeros, 4 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 4 rows, 17 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=97, theta=0.333333, up=1.000000
ITER 2: row=47, varin=41, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28394753.540857
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 241 nonzeros, 4 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % Node 9 LP 1 Solution, length = 28394753.540857, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.500000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.500000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 2 fractional variables
DEBUG CG: LP optimal, z=28394753.540857, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 9 at  28.39475354085712766050
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5571bedd4b10
% @LO 0.00  28.37924440307335416378 99.9000000000
% @LN 0.00  28.38757072072948517416 99.9000000000
% Resuming node 8 at  28.38757072072948517416
DEBUG CONSTRNT: LP rows=44, pool->nlprows=44, pool->npend=0
DEBUG CONSTRNT: Checking 44 LP rows (pool tracks 44, total LP rows 44)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=43, expected 43
 % @PAP adding 48 rows, 180 nz to LP
DEBUG BB: Processing node 8, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=63, theta=1.000000, up=1.000000
ITER 2: row=6, varin=47, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=46, varin=66, theta=0.333333, up=1.000000
ITER 4: row=38, varin=61, theta=0.600000, up=1.000000
ITER 5: row=48, varin=33, theta=0.111111, up=999999999999999983222784.000000
ITER 6: row=1, varin=45, theta=0.157895, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28387570.720729
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 240 nonzeros, 4 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=75, theta=1.000000, up=1.000000
ITER 2: row=3, varin=58, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28397078.705343
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 244 nonzeros, 0 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=7, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=39, varin=54, theta=0.500000, up=1.000000
ITER 3: row=2, varin=59, theta=0.500000, up=1.000000
ITER 4: row=52, varin=70, theta=0.140845, up=1.000000
ITER 5: row=53, varin=6, theta=0.183486, up=999999999999999983222784.000000
ITER 6: row=52, varin=51, theta=0.111111, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28421339.487885
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.888889
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 53 rows, 60 cols, 258 nonzeros, 2 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=53, varin=72, theta=0.333333, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28432685.817492
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 53 rows, 60 cols, 260 nonzeros, 0 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 8 rows, 42 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=54, varin=63, theta=0.666667, up=1.000000
ITER 2: row=8, varin=103, theta=0.500000, up=1.000000
ITER 3: row=7, varin=108, theta=0.250000, up=1.000000
ITER 4: row=59, varin=35, theta=0.076923, up=999999999999999983222784.000000
ITER 5: row=61, varin=36, theta=0.063636, up=999999999999999983222784.000000
ITER 6: row=56, varin=64, theta=0.600000, up=1.000000
ITER 7: row=55, varin=54, theta=0.071026, up=999999999999999983222784.000000
ITER 8: row=24, varin=47, theta=6.666667, up=999999999999999983222784.000000
ITER 9: row=48, varin=106, theta=0.400000, up=1.000000
ITER 10: row=17, varin=85, theta=1.250000, up=1.000000
LP PHASE: Switching to primal (iter=15)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=61)
DEBUG SOLUTION: LP solution array indices: FST[62-101], not_covered[102-121]
DEBUG SOLUTION: lp->best_solution[0] = 28513760.939793
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 61 rows, 60 cols, 302 nonzeros, 7 slack, 54 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 7 slack rows
  % @PAP adding 7 rows, 20 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=60, varin=85, theta=1.000000, up=1.000000
ITER 2: row=57, varin=54, theta=0.623762, up=999999999999999983222784.000000
ITER 3: row=58, varin=57, theta=1.621951, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=61)
DEBUG SOLUTION: LP solution array indices: FST[62-101], not_covered[102-121]
DEBUG SOLUTION: lp->best_solution[0] = 28527167.533828
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.658537
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 61 rows, 60 cols, 308 nonzeros, 8 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 8 slack rows
  % @PAP adding 5 rows, 48 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=58, varin=104, theta=0.109257, up=1.000000
ITER 2: row=53, varin=24, theta=0.780506, up=999999999999999983222784.000000
ITER 3: row=56, varin=27, theta=1.782813, up=999999999999999983222784.000000
ITER 4: row=53, varin=52, theta=0.380943, up=999999999999999983222784.000000
ITER 5: row=52, varin=115, theta=0.269210, up=1.000000
ITER 6: row=11, varin=70, theta=1.146078, up=1.000000
ITER 7: row=11, varin=48, theta=0.048529, up=999999999999999983222784.000000
ITER 8: row=25, varin=70, theta=0.672210, up=1.000000
ITER 9: row=54, varin=24, theta=8.343504, up=999999999999999983222784.000000
ITER 10: row=7, varin=46, theta=0.367404, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=14)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=58)
DEBUG SOLUTION: LP solution array indices: FST[59-98], not_covered[99-118]
DEBUG SOLUTION: lp->best_solution[0] = 28581976.088241
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 58 rows, 60 cols, 323 nonzeros, 6 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=54, varin=45, theta=1.833333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 28590901.653014
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 55 rows, 60 cols, 277 nonzeros, 3 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 3 rows, 44 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=55, varin=10, theta=1.307655, up=999999999999999983222784.000000
ITER 2: row=11, varin=67, theta=0.281256, up=1.000000
ITER 3: row=53, varin=43, theta=0.467235, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 28612152.041807
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 55 rows, 60 cols, 309 nonzeros, 1 slack, 54 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=55, varin=52, theta=0.043517, up=999999999999999983222784.000000
ITER 2: row=56, varin=55, theta=0.088656, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 28613288.005328
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 57 rows, 60 cols, 305 nonzeros, 3 slack, 54 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=55, varin=67, theta=0.295785, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 28613710.814969
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 56 rows, 60 cols, 303 nonzeros, 2 slack, 54 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=55, varin=61, theta=0.052411, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 28614214.753032
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 56 rows, 60 cols, 302 nonzeros, 0 slack, 56 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 8 LP 1 Solution, length = 28614214.753032, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.127882 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.127882 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.052411 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.127882 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.127882 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.127882 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.127882 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.872118 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.872118 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.872118 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.872118 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.872118 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.872118 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.872118 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=28614214.753032, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 8 at  28.61421475303193773243
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5571bedc5ef0
% @LO 0.01  28.38757072072948517416 99.9000000000
% @LN 0.01  28.39014727549374939031 99.9000000000
% Resuming node 5 at  28.39014727549374939031
DEBUG CONSTRNT: LP rows=56, pool->nlprows=56, pool->npend=0
DEBUG CONSTRNT: Checking 56 LP rows (pool tracks 56, total LP rows 56)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=55, expected 55
 % @PAP adding 52 rows, 184 nz to LP
DEBUG BB: Processing node 5, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=33, varin=53, theta=0.625000, up=1.000000
ITER 2: row=12, varin=48, theta=0.250000, up=999999999999999983222784.000000
ITER 3: row=43, varin=89, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28390147.275494
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 244 nonzeros, 0 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 19 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=53, varin=41, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 28394908.068638
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 56 rows, 60 cols, 263 nonzeros, 3 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 1 rows, 40 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=54, varin=33, theta=0.115746, up=999999999999999983222784.000000
ITER 2: row=43, varin=42, theta=3.472573, up=999999999999999983222784.000000
ITER 3: row=50, varin=89, theta=0.283969, up=1.000000
LP PHASE: Switching to primal (iter=3)
ITER 4: row=24, varin=50, theta=0.000000, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 28410578.490200
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 54 rows, 60 cols, 286 nonzeros, 0 slack, 54 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 5 LP 1 Solution, length = 28410578.490200, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.358015 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.358015 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.283969 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.358015 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.641985 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.641985 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.641985 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28410578.490200, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 5 at  28.41057849019976089266
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5571bedc7070
% @LO 0.01  28.39014727549374939031 99.9000000000
% @LN 0.01  28.39475354085712766050 99.9000000000
% Resuming node 9 at  28.39475354085712766050
DEBUG CONSTRNT: LP rows=54, pool->nlprows=54, pool->npend=0
DEBUG CONSTRNT: Checking 54 LP rows (pool tracks 54, total LP rows 54)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=53, expected 53
 % @PAP adding 44 rows, 164 nz to LP
DEBUG BB: Processing node 9, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 9 LP 2 Solution, length = 28394753.540857, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.500000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.500000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 2 fractional variables
DEBUG CG: LP optimal, z=28394753.540857, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28394753.540857, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 9 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 9
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.500000
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.500000
DEBUG CAREFUL: Adding var 16 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 2 fractional variables

  %  Carefully choosing branching variable, nfrac = 2
DEBUG CAREFUL: Testing fvar[0] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 14
DEBUG CAREFUL: New best var: 14
DEBUG CAREFUL: Testing fvar[1] = var 16
DEBUG CAREFUL: Calling compare_branch_vars for var 16
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 16
  % Initial guess is x14, Z0 = 28394753.5408571        , Z1 = 28410262.6786409        

DEBUG EVAL: Testing var 14 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=7, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 14 = 1 gives z=28410262.678641
  % 	x14 = 1,	Z1 = 28410262.6786409        
DEBUG EVAL: First branch cutoff check: z=28410262.678641, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 14 = 0
ITER 1: row=1, varin=62, theta=0.333333, up=1.000000
ITER 2: row=35, varin=57, theta=0.500000, up=1.000000
  % 	x14 = 0,	Z0 = 28439582.2627706        
DEBUG EVAL: Second branch cutoff check: z=28439582.262771, best_z=INF, threshold=INF
  %   New best:  x14, Z = 28410262.6786409        
DEBUG EVAL: Testing var 16 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=7, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 16 = 0 gives z=28410262.678641
  % 	x16 = 0,	Z0 = 28410262.6786409        
DEBUG EVAL: First branch cutoff check: z=28410262.678641, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 16 = 1
ITER 1: row=6, varin=62, theta=0.333333, up=1.000000
ITER 2: row=35, varin=57, theta=0.500000, up=1.000000
  % 	x16 = 1,	Z1 = 28439582.2627706        
DEBUG EVAL: Second branch cutoff check: z=28439582.262771, best_z=INF, threshold=INF
  % Best branch is x14, Z0 = 28439582.2627706        , Z1 = 28410262.6786409        

DEBUG CAREFUL: Final result - returning best.var = 14
DEBUG BB: Branching variable chosen: j=14
 % @NC   11    9	x14 = 1	28410262.678641
 % @NC   12    9	x14 = 0	28439582.262771
 %       9     6 28394753.5409               28410262.6786   x15 D     7     3
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5571bedb9600
% @LO 0.01  28.39475354085712766050 99.9000000000
% @LN 0.01  28.41026267864089760451 99.9000000000
% Resuming node 11 at  28.41026267864089760451
DEBUG CONSTRNT: LP rows=44, pool->nlprows=44, pool->npend=0
DEBUG CONSTRNT: Checking 44 LP rows (pool tracks 44, total LP rows 44)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=43, expected 43
 % @PAP adding 44 rows, 164 nz to LP
DEBUG BB: Processing node 11, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=7, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28410262.678641
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 224 nonzeros, 2 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 29 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=41, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=47, varin=42, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=1, varin=66, theta=0.333333, up=1.000000
ITER 4: row=35, varin=61, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28470600.538338
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 253 nonzeros, 4 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 3 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=72, theta=1.000000, up=1.000000
ITER 2: row=3, varin=55, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28495986.907083
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 236 nonzeros, 0 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 19 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=95, theta=0.500000, up=1.000000
ITER 2: row=36, varin=52, theta=0.500000, up=1.000000
ITER 3: row=2, varin=57, theta=0.500000, up=1.000000
ITER 4: row=49, varin=6, theta=0.111111, up=999999999999999983222784.000000
ITER 5: row=51, varin=40, theta=0.074627, up=999999999999999983222784.000000
ITER 6: row=50, varin=48, theta=0.044776, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28526476.081273
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.880597
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 255 nonzeros, 3 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=108, theta=1.000000, up=1.000000
ITER 2: row=45, varin=69, theta=0.333333, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28531594.019231
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 253 nonzeros, 0 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 8 rows, 42 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=60, theta=0.666667, up=1.000000
ITER 2: row=8, varin=100, theta=0.500000, up=1.000000
ITER 3: row=7, varin=105, theta=0.250000, up=1.000000
ITER 4: row=56, varin=68, theta=0.410959, up=1.000000
ITER 5: row=54, varin=48, theta=2.307692, up=999999999999999983222784.000000
ITER 6: row=49, varin=22, theta=0.111111, up=999999999999999983222784.000000
ITER 7: row=54, varin=32, theta=0.081301, up=999999999999999983222784.000000
ITER 8: row=58, varin=61, theta=0.600000, up=1.000000
ITER 9: row=52, varin=50, theta=0.055970, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=9)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=58)
DEBUG SOLUTION: LP solution array indices: FST[59-98], not_covered[99-118]
DEBUG SOLUTION: lp->best_solution[0] = 28564783.580209
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 58 rows, 60 cols, 295 nonzeros, 3 slack, 55 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=57, varin=32, theta=0.014856, up=999999999999999983222784.000000
ITER 2: row=22, varin=47, theta=1.885246, up=999999999999999983222784.000000
ITER 3: row=58, varin=50, theta=1.726450, up=999999999999999983222784.000000
ITER 4: row=54, varin=82, theta=0.800000, up=1.000000
ITER 5: row=22, varin=57, theta=0.028571, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=58)
DEBUG SOLUTION: LP solution array indices: FST[59-98], not_covered[99-118]
DEBUG SOLUTION: lp->best_solution[0] = 28577625.357271
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 58 rows, 60 cols, 295 nonzeros, 2 slack, 56 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 4 rows, 9 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=59, varin=47, theta=5.400000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=60)
DEBUG SOLUTION: LP solution array indices: FST[61-100], not_covered[101-120]
DEBUG SOLUTION: lp->best_solution[0] = 28587016.048102
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 60 rows, 60 cols, 300 nonzeros, 3 slack, 57 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=58, varin=103, theta=0.400000, up=1.000000
ITER 2: row=17, varin=45, theta=1.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=58)
DEBUG SOLUTION: LP solution array indices: FST[59-98], not_covered[99-118]
DEBUG SOLUTION: lp->best_solution[0] = 28594973.416968
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 58 rows, 60 cols, 289 nonzeros, 1 slack, 57 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 11 LP 1 Solution, length = 28594973.416968, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.500000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.500000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 1.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 2 fractional variables
DEBUG CG: LP optimal, z=28594973.416968, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 11 at  28.59497341696815198020
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5571bedc5ef0
% @LO 0.01  28.41026267864089760451 99.9000000000
% @LN 0.01  28.41057849019976089266 99.9000000000
% Resuming node 5 at  28.41057849019976089266
DEBUG CONSTRNT: LP rows=57, pool->nlprows=57, pool->npend=0
DEBUG CONSTRNT: Checking 57 LP rows (pool tracks 57, total LP rows 57)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=56, expected 56
 % @PAP adding 54 rows, 226 nz to LP
DEBUG BB: Processing node 5, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 5 LP 2 Solution, length = 28410578.490200, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.358015 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.358015 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.283969 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.358015 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.641985 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.641985 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.641985 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28410578.490200, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28410578.490200, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 5 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 5
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.358015
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.358015)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.358015
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.358015)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.283969
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.283969)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.358015
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.358015)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 34
DEBUG CAREFUL: New best var: 34
DEBUG CAREFUL: Testing fvar[1] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[2] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
DEBUG CAREFUL: Testing fvar[3] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 36
  % Initial guess is x34, Z0 = 28410578.4901998        , Z1 = 28459225.8110132        

DEBUG EVAL: Testing var 34 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=37, varin=54, theta=309910.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 34 = 1 gives z=28450091.618849
  % 	x34 = 1,	Z1 = 28459225.8110132        
DEBUG EVAL: First branch cutoff check: z=28459225.811013, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 34 = 0
ITER 1: row=37, varin=76, theta=0.197647, up=1.000000
ITER 2: row=32, varin=77, theta=0.199509, up=1.000000
  % 	x34 = 0,	Z0 = 28417243.8814443        
DEBUG EVAL: Second branch cutoff check: z=28417243.881444, best_z=INF, threshold=INF
  %   New best:  x34, Z = 28417243.8814443        
DEBUG EVAL: Testing var 9 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=8, varin=46, theta=0.558175, up=999999999999999983222784.000000
ITER 2: row=44, varin=54, theta=309910.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 9 = 0 gives z=28450091.618849
  % 	x9 = 0,	Z0 = 28450091.6188491        
DEBUG EVAL: First branch cutoff check: z=28450091.618849, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 1
ITER 1: row=8, varin=76, theta=2.939836, up=1.000000
ITER 2: row=8, varin=77, theta=2.001272, up=1.000000
ITER 3: row=8, varin=12, theta=0.262021, up=999999999999999983222784.000000
ITER 4: row=37, varin=77, theta=1.355419, up=1.000000
ITER 5: row=37, varin=76, theta=0.350852, up=1.000000
ITER 6: row=11, varin=43, theta=0.509784, up=999999999999999983222784.000000
ITER 7: row=32, varin=77, theta=1.055912, up=1.000000
ITER 8: row=32, varin=81, theta=0.060644, up=1.000000
ITER 9: row=43, varin=48, theta=2.308257, up=999999999999999983222784.000000
ITER 10: row=39, varin=8, theta=1.287144, up=999999999999999983222784.000000
  % 	x9 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: Second branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=8, varin=46, theta=0.558175, up=999999999999999983222784.000000
ITER 2: row=44, varin=54, theta=309910.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 28450091.618849
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 54 rows, 60 cols, 286 nonzeros, 1 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 2 rows, 11 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=54, varin=109, theta=0.333333, up=1.000000
ITER 2: row=50, varin=77, theta=1.000000, up=1.000000
ITER 3: row=32, varin=40, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 28505843.675614
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 55 rows, 60 cols, 257 nonzeros, 2 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 5 at  28.50584367561350873643
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5571bedd9330
% @LO 0.01  28.41057849019976089266 99.9000000000
% @LN 0.01  28.42330051316007555329 99.9000000000
% Resuming node 10 at  28.42330051316007555329
DEBUG CONSTRNT: LP rows=53, pool->nlprows=53, pool->npend=0
DEBUG CONSTRNT: Checking 53 LP rows (pool tracks 53, total LP rows 53)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=52, expected 52
 % @PAP adding 44 rows, 164 nz to LP
DEBUG BB: Processing node 10, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=59, theta=0.500000, up=1.000000
ITER 2: row=6, varin=62, theta=0.333333, up=1.000000
ITER 3: row=35, varin=57, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28423300.513160
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 224 nonzeros, 0 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=72, theta=1.000000, up=1.000000
ITER 2: row=3, varin=55, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28448686.881905
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 236 nonzeros, 0 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 19 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=7, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=36, varin=52, theta=0.500000, up=1.000000
ITER 3: row=2, varin=57, theta=0.500000, up=1.000000
ITER 4: row=49, varin=68, theta=0.125000, up=1.000000
ITER 5: row=32, varin=6, theta=0.111111, up=999999999999999983222784.000000
ITER 6: row=51, varin=44, theta=0.074627, up=999999999999999983222784.000000
ITER 7: row=50, varin=48, theta=0.044776, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28479176.056095
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.880597
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 255 nonzeros, 3 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=69, theta=0.333333, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28484293.994053
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 253 nonzeros, 0 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 8 rows, 42 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=60, theta=0.666667, up=1.000000
ITER 2: row=8, varin=100, theta=0.500000, up=1.000000
ITER 3: row=7, varin=105, theta=0.250000, up=1.000000
ITER 4: row=56, varin=68, theta=0.410959, up=1.000000
ITER 5: row=54, varin=48, theta=2.307692, up=999999999999999983222784.000000
ITER 6: row=49, varin=22, theta=0.111111, up=999999999999999983222784.000000
ITER 7: row=54, varin=32, theta=0.081301, up=999999999999999983222784.000000
ITER 8: row=58, varin=61, theta=0.600000, up=1.000000
ITER 9: row=52, varin=50, theta=0.055970, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=9)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=58)
DEBUG SOLUTION: LP solution array indices: FST[59-98], not_covered[99-118]
DEBUG SOLUTION: lp->best_solution[0] = 28517483.555031
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 58 rows, 60 cols, 295 nonzeros, 3 slack, 55 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=57, varin=32, theta=0.014856, up=999999999999999983222784.000000
ITER 2: row=22, varin=47, theta=1.885246, up=999999999999999983222784.000000
ITER 3: row=58, varin=50, theta=1.726450, up=999999999999999983222784.000000
ITER 4: row=54, varin=82, theta=0.800000, up=1.000000
ITER 5: row=22, varin=57, theta=0.028571, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=58)
DEBUG SOLUTION: LP solution array indices: FST[59-98], not_covered[99-118]
DEBUG SOLUTION: lp->best_solution[0] = 28530325.332093
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 58 rows, 60 cols, 295 nonzeros, 2 slack, 56 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 4 rows, 9 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=59, varin=47, theta=5.400000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=60)
DEBUG SOLUTION: LP solution array indices: FST[61-100], not_covered[101-120]
DEBUG SOLUTION: lp->best_solution[0] = 28539716.022924
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 60 rows, 60 cols, 300 nonzeros, 3 slack, 57 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=58, varin=103, theta=0.400000, up=1.000000
ITER 2: row=17, varin=45, theta=1.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=58)
DEBUG SOLUTION: LP solution array indices: FST[59-98], not_covered[99-118]
DEBUG SOLUTION: lp->best_solution[0] = 28547673.391790
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 58 rows, 60 cols, 289 nonzeros, 1 slack, 57 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 10 LP 1 Solution, length = 28547673.391790, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.500000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.500000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 2 fractional variables
DEBUG CG: LP optimal, z=28547673.391790, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 10 at  28.54767339179007024086
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5571bedd96e0
% @LO 0.01  28.42330051316007555329 99.9000000000
% @LN 0.01  28.43958226277062095733 99.9000000000
% Resuming node 12 at  28.43958226277062095733
DEBUG CONSTRNT: LP rows=57, pool->nlprows=57, pool->npend=0
DEBUG CONSTRNT: Checking 57 LP rows (pool tracks 57, total LP rows 57)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=56, expected 56
 % @PAP adding 44 rows, 164 nz to LP
DEBUG BB: Processing node 12, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=62, theta=0.333333, up=1.000000
ITER 2: row=35, varin=57, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28439582.262771
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 224 nonzeros, 0 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 16 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=73, theta=1.000000, up=1.000000
ITER 2: row=3, varin=56, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28464968.631515
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 240 nonzeros, 0 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=7, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=36, varin=52, theta=0.500000, up=1.000000
ITER 3: row=2, varin=32, theta=0.333333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28476645.754344
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 252 nonzeros, 1 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 12 LP 1 Solution, length = 28476645.754344, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.333333 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.666667 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.333333 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.333333 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.333333 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.333333 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 2 fractional variables
DEBUG CG: LP optimal, z=28476645.754344, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.01  28.43958226277062095733 99.9000000000
 % @LN 0.01  28.47664575434362532746 99.9000000000
DEBUG CG: Second cutoff check: z=28476645.754344, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 12 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 12
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.333333
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.666667
DEBUG CAREFUL: Adding var 16 to fractional list (xi=0.666667)
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 2 fractional variables

  %  Carefully choosing branching variable, nfrac = 2
DEBUG CAREFUL: Testing fvar[0] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 7
DEBUG CAREFUL: New best var: 7
DEBUG CAREFUL: Testing fvar[1] = var 16
DEBUG CAREFUL: Calling compare_branch_vars for var 16
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 16
  % Initial guess is x7, Z0 = 28476645.7543436        , Z1 = 28550692.8599575        

DEBUG EVAL: Testing var 7 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=2, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=2, varin=35, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=34, varin=3, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=3, varin=44, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=44, varin=34, theta=0.666667, up=999999999999999983222784.000000
ITER 6: row=35, varin=23, theta=2.000000, up=999999999999999983222784.000000
ITER 7: row=23, varin=32, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 7 = 1 gives z=28671448.456884
  % 	x7 = 1,	Z1 = 28671448.4568842        
DEBUG EVAL: First branch cutoff check: z=28671448.456884, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 7 = 0
ITER 1: row=1, varin=56, theta=0.333333, up=1.000000
  % 	x7 = 0,	Z0 = 28485487.2753057        
DEBUG EVAL: Second branch cutoff check: z=28485487.275306, best_z=INF, threshold=INF
  %   New best:  x7, Z = 28485487.2753057        
DEBUG EVAL: Testing var 16 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=59, theta=0.500000, up=1.000000
ITER 2: row=50, varin=108, theta=1.000000, up=1.000000
ITER 3: row=46, varin=56, theta=0.500000, up=1.000000
ITER 4: row=1, varin=69, theta=0.333333, up=1.000000
DEBUG EVAL: Branch var 16 = 1 gives z=28500575.743664
  % 	x16 = 1,	Z1 = 28500575.7436639        
DEBUG EVAL: First branch cutoff check: z=28500575.743664, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 16 = 0
ITER 1: row=6, varin=2, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=2, varin=35, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=7, varin=48, theta=1.000000, up=999999999999999983222784.000000
  % 	x16 = 0,	Z0 = 28500000                
DEBUG EVAL: Second branch cutoff check: z=28500000.000000, best_z=INF, threshold=INF
  %   New best:  x16, Z = 28500000                
  % Best branch is x16, Z0 = 28500000                , Z1 = 28500575.7436639        

DEBUG CAREFUL: Final result - returning best.var = 16
DEBUG BB: Branching variable chosen: j=16
 % @NC   13   12	x16 = 0	28500000.000000
 % @NC   14   12	x16 = 1	28500575.743664
 %      12     7 28476645.7543               28500000.0000   x14 D     9     4
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5571bedc7070
% @LO 0.01  28.47664575434362532746 99.9000000000
% @LN 0.01  28.50000000000000000000 99.9000000000
% Resuming node 13 at  28.50000000000000000000
DEBUG CONSTRNT: LP rows=50, pool->nlprows=50, pool->npend=0
DEBUG CONSTRNT: Checking 50 LP rows (pool tracks 50, total LP rows 50)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 138
DEBUG CONSTRNT: Pool row 138 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=49, expected 49
 % @PAP adding 50 rows, 184 nz to LP
DEBUG BB: Processing node 13, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=6, varin=2, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=2, varin=35, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=7, varin=48, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28500000.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 244 nonzeros, 3 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 40 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=109, theta=2.000000, up=1.000000
ITER 2: row=51, varin=93, theta=0.500000, up=1.000000
ITER 3: row=46, varin=109, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28581379.992816
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 0.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 284 nonzeros, 6 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 2 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=104, theta=0.666667, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28611402.814172
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 4.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 269 nonzeros, 1 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 6 rows, 35 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=4, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=32, varin=53, theta=0.333333, up=1.000000
ITER 3: row=5, varin=58, theta=0.333333, up=1.000000
ITER 4: row=48, varin=40, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=50, varin=3, theta=0.076923, up=999999999999999983222784.000000
ITER 6: row=44, varin=38, theta=0.005525, up=999999999999999983222784.000000
ITER 7: row=52, varin=76, theta=0.560345, up=1.000000
ITER 8: row=51, varin=36, theta=0.062802, up=999999999999999983222784.000000
ITER 9: row=52, varin=47, theta=0.028139, up=999999999999999983222784.000000
ITER 10: row=49, varin=44, theta=1.851852, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=10)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28623903.707992
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.950617
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 4.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 301 nonzeros, 8 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 8 slack rows
  % @PAP adding 5 rows, 19 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=73, theta=0.555556, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28624655.185218
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 4.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 5.000000
  % @PL 49 rows, 60 cols, 296 nonzeros, 1 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 3 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=43, theta=0.040000, up=999999999999999983222784.000000
ITER 2: row=45, varin=53, theta=0.400000, up=1.000000
ITER 3: row=5, varin=98, theta=0.500000, up=1.000000
ITER 4: row=32, varin=60, theta=0.316547, up=1.000000
ITER 5: row=46, varin=96, theta=0.222222, up=1.000000
ITER 6: row=14, varin=42, theta=3.520000, up=999999999999999983222784.000000
ITER 7: row=49, varin=34, theta=0.030803, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28629415.004779
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 4.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 5.000000
  % @PL 51 rows, 60 cols, 301 nonzeros, 5 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 5 rows, 10 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=97, theta=0.097561, up=1.000000
ITER 2: row=9, varin=44, theta=1.357576, up=999999999999999983222784.000000
ITER 3: row=50, varin=42, theta=0.666667, up=999999999999999983222784.000000
ITER 4: row=47, varin=39, theta=0.250000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28638677.254084
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 4.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 5.000000
  % @PL 51 rows, 60 cols, 288 nonzeros, 3 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % Node 13 LP 1 Solution, length = 28638677.254084, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.125000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.125000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.125000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.125000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.125000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.375000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.625000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.875000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.875000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.875000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.875000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.625000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.875000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.875000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28638677.254084, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 13 at  28.63867725408369224738
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5571beddf230
% @LO 0.01  28.50000000000000000000 99.9000000000
% @LN 0.01  28.50057574366388735143 99.9000000000
% Resuming node 14 at  28.50057574366388735143
DEBUG CONSTRNT: LP rows=48, pool->nlprows=48, pool->npend=0
DEBUG CONSTRNT: Checking 48 LP rows (pool tracks 48, total LP rows 48)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 162
DEBUG CONSTRNT: Pool row 162 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 62
DEBUG CONSTRNT: Pool row 62 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=47, expected 47
 % @PAP adding 50 rows, 184 nz to LP
DEBUG BB: Processing node 14, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=6, varin=59, theta=0.500000, up=1.000000
ITER 2: row=50, varin=108, theta=1.000000, up=1.000000
ITER 3: row=46, varin=56, theta=0.500000, up=1.000000
ITER 4: row=1, varin=69, theta=0.333333, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28500575.743664
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 244 nonzeros, 0 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 9 rows, 82 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=59, varin=61, theta=0.065865, up=1.000000
ITER 2: row=51, varin=59, theta=123830.000000, up=999999999999999983222784.000000
ITER 3: row=9, varin=101, theta=0.500000, up=1.000000
ITER 4: row=8, varin=106, theta=0.250000, up=1.000000
ITER 5: row=51, varin=83, theta=0.306791, up=1.000000
ITER 6: row=56, varin=62, theta=1.539279, up=1.000000
ITER 7: row=56, varin=32, theta=0.017123, up=999999999999999983222784.000000
ITER 8: row=51, varin=62, theta=0.709205, up=1.000000
ITER 9: row=58, varin=33, theta=0.029846, up=999999999999999983222784.000000
ITER 10: row=24, varin=83, theta=0.408585, up=1.000000
LP PHASE: Switching to primal (iter=19)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=59)
DEBUG SOLUTION: LP solution array indices: FST[60-99], not_covered[100-119]
DEBUG SOLUTION: lp->best_solution[0] = 28538519.742213
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 59 rows, 60 cols, 326 nonzeros, 1 slack, 58 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 2 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=59, varin=67, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=60)
DEBUG SOLUTION: LP solution array indices: FST[61-100], not_covered[101-120]
DEBUG SOLUTION: lp->best_solution[0] = 28546531.994001
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 60 rows, 60 cols, 291 nonzeros, 0 slack, 60 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 16 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=61, varin=23, theta=0.538462, up=999999999999999983222784.000000
ITER 2: row=51, varin=67, theta=0.538462, up=1.000000
ITER 3: row=52, varin=74, theta=0.666667, up=1.000000
ITER 4: row=54, varin=65, theta=0.750000, up=1.000000
ITER 5: row=18, varin=19, theta=0.046053, up=999999999999999983222784.000000
ITER 6: row=58, varin=7, theta=0.029636, up=999999999999999983222784.000000
ITER 7: row=28, varin=54, theta=0.256586, up=999999999999999983222784.000000
ITER 8: row=57, varin=51, theta=0.063636, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=63)
DEBUG SOLUTION: LP solution array indices: FST[64-103], not_covered[104-123]
DEBUG SOLUTION: lp->best_solution[0] = 28594900.021831
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 63 rows, 60 cols, 307 nonzeros, 6 slack, 57 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 4 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=59, varin=52, theta=0.623762, up=999999999999999983222784.000000
ITER 2: row=60, varin=59, theta=1.621951, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=61)
DEBUG SOLUTION: LP solution array indices: FST[62-101], not_covered[102-121]
DEBUG SOLUTION: lp->best_solution[0] = 28595057.460000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.658537
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 4.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 61 rows, 60 cols, 308 nonzeros, 8 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 8 slack rows
  % @PAP adding 5 rows, 48 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=58, varin=24, theta=1.669121, up=999999999999999983222784.000000
ITER 2: row=56, varin=104, theta=0.008526, up=1.000000
ITER 3: row=13, varin=58, theta=3356.733333, up=999999999999999983222784.000000
ITER 4: row=12, varin=46, theta=0.015337, up=999999999999999983222784.000000
% Column 60 singular!
% SINGULAR BASIS!  Will attempt to recover.
LP PHASE: Starting dual phase (iter=4)
ITER 5: row=58, varin=7, theta=1.615485, up=999999999999999983222784.000000
ITER 6: row=17, varin=13, theta=6.335079, up=999999999999999983222784.000000
ITER 7: row=2, varin=118, theta=0.974710, up=1.000000
LP PHASE: Switching to primal (iter=7)
ITER 8: row=46, varin=58, theta=3356.733333, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=58)
DEBUG SOLUTION: LP solution array indices: FST[59-98], not_covered[99-118]
DEBUG SOLUTION: lp->best_solution[0] = 28660717.967889
DEBUG SOLUTION: lp->best_solution[1] = 19.006135
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 58 rows, 60 cols, 323 nonzeros, 6 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 4 rows, 46 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=97, theta=16.000000, up=1.000000
ITER 2: row=1, varin=98, theta=15.000000, up=1.000000
ITER 3: row=1, varin=99, theta=14.000000, up=1.000000
ITER 4: row=1, varin=100, theta=13.000000, up=1.000000
ITER 5: row=1, varin=101, theta=12.000000, up=1.000000
ITER 6: row=1, varin=102, theta=11.000000, up=1.000000
ITER 7: row=1, varin=103, theta=10.000000, up=1.000000
ITER 8: row=1, varin=104, theta=9.000000, up=1.000000
ITER 9: row=1, varin=105, theta=8.000000, up=1.000000
ITER 10: row=1, varin=106, theta=7.000000, up=1.000000
LP PHASE: Switching to primal (iter=60)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 28757554.966544
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 56 rows, 60 cols, 317 nonzeros, 3 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 8 rows, 29 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=54, varin=72, theta=0.725737, up=1.000000
ITER 2: row=61, varin=73, theta=0.256147, up=1.000000
ITER 3: row=57, varin=84, theta=0.127980, up=1.000000
ITER 4: row=56, varin=54, theta=0.017588, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=61)
DEBUG SOLUTION: LP solution array indices: FST[62-101], not_covered[102-121]
DEBUG SOLUTION: lp->best_solution[0] = 28764359.880870
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 61 rows, 60 cols, 340 nonzeros, 5 slack, 56 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 11 rows, 26 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=59, varin=53, theta=0.191575, up=999999999999999983222784.000000
ITER 2: row=61, varin=86, theta=0.118297, up=1.000000
ITER 3: row=65, varin=56, theta=0.352342, up=999999999999999983222784.000000
ITER 4: row=57, varin=61, theta=0.100430, up=999999999999999983222784.000000
ITER 5: row=54, varin=95, theta=0.321936, up=1.000000
ITER 6: row=58, varin=57, theta=0.038695, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=67)
DEBUG SOLUTION: LP solution array indices: FST[68-107], not_covered[108-127]
DEBUG SOLUTION: lp->best_solution[0] = 28776502.509866
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 67 rows, 60 cols, 351 nonzeros, 4 slack, 63 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 5 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=65, varin=33, theta=0.137016, up=999999999999999983222784.000000
ITER 2: row=55, varin=97, theta=0.344083, up=1.000000
ITER 3: row=45, varin=39, theta=0.222275, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=68)
DEBUG SOLUTION: LP solution array indices: FST[69-108], not_covered[109-128]
DEBUG SOLUTION: lp->best_solution[0] = 28781822.236557
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 68 rows, 60 cols, 351 nonzeros, 6 slack, 62 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 4 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=63, varin=96, theta=0.331078, up=1.000000
ITER 2: row=19, varin=76, theta=0.074373, up=1.000000
ITER 3: row=38, varin=35, theta=0.453308, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=66)
DEBUG SOLUTION: LP solution array indices: FST[67-106], not_covered[107-126]
DEBUG SOLUTION: lp->best_solution[0] = 28794086.042549
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 66 rows, 60 cols, 334 nonzeros, 4 slack, 62 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=63, varin=26, theta=0.024460, up=999999999999999983222784.000000
ITER 2: row=62, varin=38, theta=0.132572, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=65)
DEBUG SOLUTION: LP solution array indices: FST[66-105], not_covered[106-125]
DEBUG SOLUTION: lp->best_solution[0] = 28803146.419074
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 65 rows, 60 cols, 319 nonzeros, 1 slack, 64 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 14 LP 1 Solution, length = 28803146.419074, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.066286 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.066286 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.066286 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.066286 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.066286 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.102283 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 1.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.066286 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.066286 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.102283 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.066286 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.102283 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.066286 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.066286 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.933714 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.933714 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.933714 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.933714 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.933714 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.933714 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.897717 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.897717 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.933714 (terminal 19)
 % 13 fractional variables
DEBUG CG: LP optimal, z=28803146.419074, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 14 at  28.80314641907379069607
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5571bedc5ef0
% @LO 0.01  28.50057574366388735143 99.9000000000
% @LN 0.01  28.50584367561350873643 99.9000000000
% Resuming node 5 at  28.50584367561350873643
DEBUG CONSTRNT: LP rows=64, pool->nlprows=64, pool->npend=0
DEBUG CONSTRNT: Checking 64 LP rows (pool tracks 64, total LP rows 64)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 138
DEBUG CONSTRNT: Pool row 138 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=56, expected 56
DEBUG CONSTRNT: Checking LP row 57 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=57, expected 57
DEBUG CONSTRNT: Checking LP row 58 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=58, expected 58
DEBUG CONSTRNT: Checking LP row 59 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=59, expected 59
DEBUG CONSTRNT: Checking LP row 60 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=60, expected 60
DEBUG CONSTRNT: Checking LP row 61 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=61, expected 61
DEBUG CONSTRNT: Checking LP row 62 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=62, expected 62
DEBUG CONSTRNT: Checking LP row 63 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=63, expected 63
 % @PAP adding 53 rows, 186 nz to LP
DEBUG BB: Processing node 5, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 5 LP 3 Solution, length = 28505843.675614, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.500000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.500000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.500000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28505843.675614, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28505843.675614, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 5 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 5
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.500000
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.500000
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.500000
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 3 fractional variables

  %  Carefully choosing branching variable, nfrac = 3
DEBUG CAREFUL: Testing fvar[0] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 34
DEBUG CAREFUL: New best var: 34
DEBUG CAREFUL: Testing fvar[1] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
DEBUG CAREFUL: Testing fvar[2] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 36
  % Initial guess is x34, Z0 = 28505843.6756135        , Z1 = 28505843.6756135        

DEBUG EVAL: Testing var 34 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=37, varin=76, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 34 = 0 gives z=28506862.090341
  % 	x34 = 0,	Z0 = 28506862.0903406        
DEBUG EVAL: First branch cutoff check: z=28506862.090341, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 34 = 1
ITER 1: row=37, varin=32, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=32, varin=49, theta=0.333333, up=999999999999999983222784.000000
ITER 3: row=33, varin=43, theta=0.500000, up=999999999999999983222784.000000
ITER 4: row=25, varin=51, theta=1.000000, up=999999999999999983222784.000000
  % 	x34 = 1,	Z1 = 28621540.0757333        
DEBUG EVAL: Second branch cutoff check: z=28621540.075733, best_z=INF, threshold=INF
  %   New best:  x34, Z = 28506862.0903406        
DEBUG EVAL: Testing var 7 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=76, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 7 = 0 gives z=28506862.090341
  % 	x7 = 0,	Z0 = 28506862.0903406        
DEBUG EVAL: First branch cutoff check: z=28506862.090341, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 7 = 1
ITER 1: row=6, varin=32, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=32, varin=49, theta=0.333333, up=999999999999999983222784.000000
ITER 3: row=33, varin=53, theta=1.000000, up=999999999999999983222784.000000
  % 	x7 = 1,	Z1 = 28561595.7323779        
DEBUG EVAL: Second branch cutoff check: z=28561595.732378, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 36 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=51, varin=76, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 36 = 0 gives z=28506862.090341
  % 	x36 = 0,	Z0 = 28506862.0903406        
DEBUG EVAL: First branch cutoff check: z=28506862.090341, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 36 = 1
ITER 1: row=51, varin=32, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=32, varin=49, theta=0.333333, up=999999999999999983222784.000000
ITER 3: row=33, varin=53, theta=1.000000, up=999999999999999983222784.000000
  % 	x36 = 1,	Z1 = 28561595.7323779        
DEBUG EVAL: Second branch cutoff check: z=28561595.732378, best_z=INF, threshold=INF
  % Best branch is x34, Z0 = 28506862.0903406        , Z1 = 28621540.0757333        

DEBUG CAREFUL: Final result - returning best.var = 34
DEBUG BB: Branching variable chosen: j=34
 % @NC   15    5	x34 = 0	28506862.090341
 % @NC   16    5	x34 = 1	28621540.075733
 %       5     8 28505843.6756               28506862.0903   x18 D     3     3
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5571bedd96e0
% @LO 0.01  28.50584367561350873643 99.9000000000
% @LN 0.01  28.50686209034061135981 99.9000000000
% Resuming node 15 at  28.50686209034061135981
DEBUG CONSTRNT: LP rows=53, pool->nlprows=53, pool->npend=0
DEBUG CONSTRNT: Checking 53 LP rows (pool tracks 53, total LP rows 53)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=52, expected 52
 % @PAP adding 53 rows, 186 nz to LP
DEBUG BB: Processing node 15, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=37, varin=76, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28506862.090341
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 53 rows, 60 cols, 246 nonzeros, 0 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 19 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=54, varin=34, theta=0.200000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 28507067.362853
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 57 rows, 60 cols, 265 nonzeros, 5 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=53, varin=88, theta=0.750000, up=1.000000
ITER 2: row=4, varin=84, theta=0.500000, up=1.000000
ITER 3: row=14, varin=17, theta=0.333333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 28524190.701611
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.666667
DEBUG SOLUTION: lp->best_solution[10] = 0.666667
DEBUG SOLUTION: lp->best_solution[11] = 3.333333
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 54 rows, 60 cols, 252 nonzeros, 5 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=45, theta=0.250000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28533541.959303
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 243 nonzeros, 2 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 15 LP 1 Solution, length = 28533541.959303, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.250000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.250000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.250000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.250000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.250000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.250000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.250000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.250000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.750000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.750000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.750000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.750000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.750000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.750000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.750000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 8 fractional variables
DEBUG CG: LP optimal, z=28533541.959303, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.01  28.50686209034061135981 99.9000000000
 % @LN 0.01  28.53354195930290160277 99.9000000000
DEBUG CG: Second cutoff check: z=28533541.959303, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 15 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 15
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.250000
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.250000
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.250000
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.250000
DEBUG CAREFUL: Adding var 23 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.250000
DEBUG CAREFUL: Adding var 24 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.250000
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.250000
DEBUG CAREFUL: Adding var 33 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.250000
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 8 fractional variables

  %  Carefully choosing branching variable, nfrac = 8
DEBUG CAREFUL: Testing fvar[0] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 29
DEBUG CAREFUL: New best var: 29
DEBUG CAREFUL: Testing fvar[1] = var 24
DEBUG CAREFUL: Calling compare_branch_vars for var 24
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 24
DEBUG CAREFUL: Testing fvar[2] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
DEBUG CAREFUL: Testing fvar[3] = var 33
DEBUG CAREFUL: Calling compare_branch_vars for var 33
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 33
DEBUG CAREFUL: Testing fvar[4] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[5] = var 23
DEBUG CAREFUL: Calling compare_branch_vars for var 23
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 23
DEBUG CAREFUL: Testing fvar[6] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
DEBUG CAREFUL: Testing fvar[7] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 36
  % Initial guess is x29, Z0 = 28533541.9593029        , Z1 = 28716377.7467149        

DEBUG EVAL: Testing var 29 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=11, varin=47, theta=0.600000, up=999999999999999983222784.000000
ITER 2: row=19, varin=45, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=45, varin=27, theta=3.000000, up=999999999999999983222784.000000
ITER 4: row=27, varin=4, theta=3.000000, up=999999999999999983222784.000000
ITER 5: row=4, varin=30, theta=0.666667, up=999999999999999983222784.000000
ITER 6: row=6, varin=39, theta=0.125000, up=999999999999999983222784.000000
ITER 7: row=19, varin=36, theta=0.250000, up=999999999999999983222784.000000
ITER 8: row=38, varin=43, theta=0.500000, up=999999999999999983222784.000000
ITER 9: row=30, varin=35, theta=0.125000, up=999999999999999983222784.000000
ITER 10: row=35, varin=32, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 29 = 1 gives z=28877986.307442
  % 	x29 = 1,	Z1 = 28877986.3074425        
DEBUG EVAL: First branch cutoff check: z=28877986.307442, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 29 = 0
ITER 1: row=11, varin=76, theta=1.000000, up=1.000000
  % 	x29 = 0,	Z0 = 28534902.9188617        
DEBUG EVAL: Second branch cutoff check: z=28534902.918862, best_z=INF, threshold=INF
  %   New best:  x29, Z = 28534902.9188617        
DEBUG EVAL: Testing var 24 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=76, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 24 = 0 gives z=28534902.918862
  % 	x24 = 0,	Z0 = 28534902.9188617        
DEBUG EVAL: First branch cutoff check: z=28534902.918862, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 24 = 1
ITER 1: row=3, varin=11, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=11, varin=47, theta=0.400000, up=999999999999999983222784.000000
ITER 3: row=32, varin=45, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=45, varin=27, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=27, varin=4, theta=2.000000, up=999999999999999983222784.000000
ITER 6: row=4, varin=30, theta=0.333333, up=999999999999999983222784.000000
  % 	x24 = 1,	Z1 = 28667017.7663009        
DEBUG EVAL: Second branch cutoff check: z=28667017.766301, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 0 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=76, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 0 = 0 gives z=28534902.918862
  % 	x0 = 0,	Z0 = 28534902.9188617        
DEBUG EVAL: First branch cutoff check: z=28534902.918862, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 0 = 1
ITER 1: row=1, varin=11, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=11, varin=47, theta=0.400000, up=999999999999999983222784.000000
ITER 3: row=32, varin=45, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=45, varin=27, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=27, varin=4, theta=2.000000, up=999999999999999983222784.000000
ITER 6: row=4, varin=30, theta=0.333333, up=999999999999999983222784.000000
  % 	x0 = 1,	Z1 = 28667017.7663009        
DEBUG EVAL: Second branch cutoff check: z=28667017.766301, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 33 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=4, varin=11, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=11, varin=47, theta=0.400000, up=999999999999999983222784.000000
ITER 3: row=32, varin=45, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=45, varin=27, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=27, varin=30, theta=0.666667, up=999999999999999983222784.000000
ITER 6: row=6, varin=36, theta=0.250000, up=999999999999999983222784.000000
ITER 7: row=38, varin=43, theta=0.500000, up=999999999999999983222784.000000
ITER 8: row=30, varin=35, theta=0.125000, up=999999999999999983222784.000000
ITER 9: row=35, varin=2, theta=0.500000, up=999999999999999983222784.000000
ITER 10: row=12, varin=42, theta=0.250000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 33 = 1 gives z=28848974.340690
  % 	x33 = 1,	Z1 = 28848974.3406897        
DEBUG EVAL: First branch cutoff check: z=28848974.340690, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 33 = 0
ITER 1: row=4, varin=76, theta=1.000000, up=1.000000
  % 	x33 = 0,	Z0 = 28534902.9188617        
DEBUG EVAL: Second branch cutoff check: z=28534902.918862, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=76, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 1 = 0 gives z=28534902.918862
  % 	x1 = 0,	Z0 = 28534902.9188617        
DEBUG EVAL: First branch cutoff check: z=28534902.918862, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 1
ITER 1: row=2, varin=11, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=11, varin=47, theta=0.400000, up=999999999999999983222784.000000
  % 	x1 = 1,	Z1 = 28607855.4482942        
DEBUG EVAL: Second branch cutoff check: z=28607855.448294, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 23 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=8, varin=76, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 23 = 0 gives z=28534902.918862
  % 	x23 = 0,	Z0 = 28534902.9188617        
DEBUG EVAL: First branch cutoff check: z=28534902.918862, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 23 = 1
ITER 1: row=8, varin=11, theta=3.000000, up=999999999999999983222784.000000
  % 	x23 = 1,	Z1 = 28597634.847579         
DEBUG EVAL: Second branch cutoff check: z=28597634.847579, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 7 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=49, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 7 = 1 gives z=28561595.732378
  % 	x7 = 1,	Z1 = 28561595.7323779        
DEBUG EVAL: First branch cutoff check: z=28561595.732378, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 7 = 0
ITER 1: row=6, varin=76, theta=1.000000, up=1.000000
  % 	x7 = 0,	Z0 = 28534902.9188617        
DEBUG EVAL: Second branch cutoff check: z=28534902.918862, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 36 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=30, varin=49, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 36 = 1 gives z=28561595.732378
  % 	x36 = 1,	Z1 = 28561595.7323779        
DEBUG EVAL: First branch cutoff check: z=28561595.732378, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 36 = 0
ITER 1: row=30, varin=76, theta=1.000000, up=1.000000
  % 	x36 = 0,	Z0 = 28534902.9188617        
DEBUG EVAL: Second branch cutoff check: z=28534902.918862, best_z=INF, threshold=INF
  % Best branch is x29, Z0 = 28534902.9188617        , Z1 = 28877986.3074425        

DEBUG CAREFUL: Final result - returning best.var = 29
DEBUG BB: Branching variable chosen: j=29
 % @NC   17   15	x29 = 0	28534902.918862
 % @NC   18   15	x29 = 1	28877986.307442
 %      15     9 28533541.9593               28534902.9189   x34 D     5     4
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5571bedc5ef0
% @LO 0.01  28.53354195930290160277 99.9000000000
% @LN 0.01  28.53490291886172514069 99.9000000000
% Resuming node 17 at  28.53490291886172514069
DEBUG CONSTRNT: LP rows=49, pool->nlprows=49, pool->npend=0
DEBUG CONSTRNT: Checking 49 LP rows (pool tracks 49, total LP rows 49)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=48, expected 48
 % @PAP adding 49 rows, 175 nz to LP
DEBUG BB: Processing node 17, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=11, varin=76, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28534902.918862
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 235 nonzeros, 0 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 17 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=11, theta=0.333333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28540663.391334
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.666667
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 53 rows, 60 cols, 252 nonzeros, 3 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 1 rows, 40 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=79, theta=0.098382, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28541378.734229
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 285 nonzeros, 0 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=82, theta=0.098720, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28541550.792512
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 53 rows, 60 cols, 291 nonzeros, 0 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=54, varin=33, theta=0.050363, up=999999999999999983222784.000000
ITER 2: row=35, varin=85, theta=0.114769, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 28544549.983447
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 54 rows, 60 cols, 296 nonzeros, 0 slack, 54 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 17 LP 1 Solution, length = 28544549.983447, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.295077 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.295077 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.295077 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.295077 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.295077 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.114769 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.295077 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.295077 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.704923 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.704923 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.704923 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.704923 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.704923 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.704923 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.704923 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 8 fractional variables
DEBUG CG: LP optimal, z=28544549.983447, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.01  28.53490291886172514069 99.9000000000
 % @LN 0.01  28.54454998344723293258 99.9000000000
DEBUG CG: Second cutoff check: z=28544549.983447, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 17 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 17
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.295077
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.295077)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.295077
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.295077)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.295077
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.295077)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.295077
DEBUG CAREFUL: Adding var 23 to fractional list (xi=0.295077)
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.295077
DEBUG CAREFUL: Adding var 24 to fractional list (xi=0.295077)
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.114769
DEBUG CAREFUL: Adding var 30 to fractional list (xi=0.114769)
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.295077
DEBUG CAREFUL: Adding var 33 to fractional list (xi=0.295077)
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.295077
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.295077)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 8 fractional variables

  %  Carefully choosing branching variable, nfrac = 8
DEBUG CAREFUL: Testing fvar[0] = var 30
DEBUG CAREFUL: Calling compare_branch_vars for var 30
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 30
DEBUG CAREFUL: New best var: 30
DEBUG CAREFUL: Testing fvar[1] = var 33
DEBUG CAREFUL: Calling compare_branch_vars for var 33
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 33
DEBUG CAREFUL: New best var: 33
DEBUG CAREFUL: Testing fvar[2] = var 24
DEBUG CAREFUL: Calling compare_branch_vars for var 24
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 24
DEBUG CAREFUL: Testing fvar[3] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
DEBUG CAREFUL: Testing fvar[4] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[5] = var 23
DEBUG CAREFUL: Calling compare_branch_vars for var 23
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 23
DEBUG CAREFUL: Testing fvar[6] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
DEBUG CAREFUL: Testing fvar[7] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 36
  % Initial guess is x33, Z0 = 28544549.9834472        , Z1 = 28848974.3406897        

DEBUG EVAL: Testing var 30 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=27, varin=35, theta=0.388457, up=999999999999999983222784.000000
ITER 2: row=30, varin=54, theta=0.761440, up=999999999999999983222784.000000
ITER 3: row=54, varin=52, theta=0.758831, up=999999999999999983222784.000000
ITER 4: row=52, varin=51, theta=380474.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 30 = 1 gives z=30157800.715743
  % 	x30 = 1,	Z1 = 30157800.7157433        
DEBUG EVAL: First branch cutoff check: z=30157800.715743, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 30 = 0
ITER 1: row=27, varin=34, theta=0.053127, up=999999999999999983222784.000000
  % 	x30 = 0,	Z0 = 28546764.282182         
DEBUG EVAL: Second branch cutoff check: z=28546764.282182, best_z=INF, threshold=INF
  %   New best:  x30, Z = 28546764.282182         
DEBUG EVAL: Testing var 33 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=4, varin=27, theta=0.800568, up=999999999999999983222784.000000
ITER 2: row=6, varin=35, theta=0.461302, up=999999999999999983222784.000000
ITER 3: row=30, varin=2, theta=0.690022, up=999999999999999983222784.000000
ITER 4: row=11, varin=44, theta=0.557854, up=999999999999999983222784.000000
ITER 5: row=50, varin=36, theta=0.519780, up=999999999999999983222784.000000
ITER 6: row=29, varin=34, theta=1.019044, up=999999999999999983222784.000000
ITER 7: row=27, varin=29, theta=0.815330, up=999999999999999983222784.000000
ITER 8: row=35, varin=86, theta=1.631575, up=1.000000
ITER 9: row=35, varin=39, theta=0.486425, up=999999999999999983222784.000000
ITER 10: row=39, varin=87, theta=1.371195, up=1.000000
DEBUG EVAL: Branch var 33 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x33 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=4, varin=4, theta=0.311794, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
ITER 2: row=27, varin=34, theta=0.125487, up=999999999999999983222784.000000
ITER 3: row=7, varin=46, theta=0.396467, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 28562823.861572
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 54 rows, 60 cols, 296 nonzeros, 5 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 5 slack rows
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=63, theta=5.000000, up=1.000000
ITER 2: row=1, varin=65, theta=4.000000, up=1.000000
ITER 3: row=1, varin=66, theta=3.000000, up=1.000000
ITER 4: row=1, varin=64, theta=2.000000, up=1.000000
ITER 5: row=1, varin=90, theta=3.000000, up=1.000000
ITER 6: row=1, varin=91, theta=2.000000, up=1.000000
ITER 7: row=1, varin=92, theta=1.000000, up=1.000000
ITER 8: row=20, varin=90, theta=1.000000, up=1.000000
ITER 9: row=47, varin=66, theta=2.108983, up=1.000000
ITER 10: row=47, varin=64, theta=1.898243, up=1.000000
LP PHASE: Switching to primal (iter=69)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28562823.861572
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 49 rows, 60 cols, 276 nonzeros, 0 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 17 at  28.56282386157201358401
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5571bedd9330
% @LO 0.01  28.54454998344723293258 99.9000000000
% @LN 0.01  28.54767339179007024086 99.9000000000
% Resuming node 10 at  28.54767339179007024086
DEBUG CONSTRNT: LP rows=49, pool->nlprows=49, pool->npend=0
DEBUG CONSTRNT: Checking 49 LP rows (pool tracks 49, total LP rows 49)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=48, expected 48
 % @PAP adding 57 rows, 223 nz to LP
DEBUG BB: Processing node 10, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 10 LP 2 Solution, length = 28547673.391790, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.500000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.500000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 2 fractional variables
DEBUG CG: LP optimal, z=28547673.391790, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28547673.391790, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 10 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 10
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.500000
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.500000
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=1.000000
DEBUG CAREFUL: Skipping var 15: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 2 fractional variables

  %  Carefully choosing branching variable, nfrac = 2
DEBUG CAREFUL: Testing fvar[0] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 5
DEBUG CAREFUL: New best var: 5
DEBUG CAREFUL: Testing fvar[1] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
  % Initial guess is x5, Z0 = 28547673.3917901        , Z1 = 28560935.6732332        

DEBUG EVAL: Testing var 5 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=22, varin=17, theta=0.800000, up=999999999999999983222784.000000
ITER 2: row=11, varin=57, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 5 = 1 gives z=28560935.673233
  % 	x5 = 1,	Z1 = 28560935.6732332        
DEBUG EVAL: First branch cutoff check: z=28560935.673233, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 5 = 0
ITER 1: row=22, varin=61, theta=0.538462, up=1.000000
ITER 2: row=48, varin=47, theta=0.055571, up=999999999999999983222784.000000
ITER 3: row=36, varin=53, theta=0.438479, up=999999999999999983222784.000000
  % 	x5 = 0,	Z0 = 28566052.5155475        
DEBUG EVAL: Second branch cutoff check: z=28566052.515548, best_z=INF, threshold=INF
  %   New best:  x5, Z = 28560935.6732332        
DEBUG EVAL: Testing var 7 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=45, varin=17, theta=0.800000, up=999999999999999983222784.000000
ITER 2: row=11, varin=52, theta=0.207847, up=999999999999999983222784.000000
ITER 3: row=48, varin=55, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=55, varin=22, theta=0.302859, up=999999999999999983222784.000000
ITER 5: row=8, varin=8, theta=0.363636, up=999999999999999983222784.000000
ITER 6: row=2, varin=54, theta=0.444444, up=999999999999999983222784.000000
ITER 7: row=46, varin=7, theta=0.428571, up=999999999999999983222784.000000
ITER 8: row=1, varin=47, theta=0.331529, up=999999999999999983222784.000000
ITER 9: row=47, varin=34, theta=0.543689, up=999999999999999983222784.000000
ITER 10: row=6, varin=46, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 7 = 1 gives z=28633397.620232
  % 	x7 = 1,	Z1 = 28633397.6202321        
DEBUG EVAL: First branch cutoff check: z=28633397.620232, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 7 = 0
ITER 1: row=45, varin=57, theta=1.000000, up=999999999999999983222784.000000
  % 	x7 = 0,	Z0 = 28560935.6732332        
DEBUG EVAL: Second branch cutoff check: z=28560935.673233, best_z=INF, threshold=INF
  %   New best:  x7, Z = 28560935.6732332        
  % Best branch is x7, Z0 = 28560935.6732332        , Z1 = 28633397.6202321        

DEBUG CAREFUL: Final result - returning best.var = 7
DEBUG BB: Branching variable chosen: j=7
 % @NC   19   10	x7 = 0	28560935.673233
 % @NC   20   10	x7 = 1	28633397.620232
 %      10    10 28547673.3918               28560935.6732   x15 U     7     3
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5571bedd96e0
% @LO 0.01  28.54767339179007024086 99.9000000000
% @LN 0.01  28.56093567323316051443 99.9000000000
% Resuming node 19 at  28.56093567323316051443
DEBUG CONSTRNT: LP rows=57, pool->nlprows=57, pool->npend=0
DEBUG CONSTRNT: Checking 57 LP rows (pool tracks 57, total LP rows 57)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=56, expected 56
 % @PAP adding 57 rows, 223 nz to LP
DEBUG BB: Processing node 19, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=57, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 28560935.673233
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 57 rows, 60 cols, 283 nonzeros, 1 slack, 56 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 11 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=58, varin=63, theta=0.538462, up=1.000000
ITER 2: row=48, varin=47, theta=0.055571, up=999999999999999983222784.000000
ITER 3: row=36, varin=53, theta=0.438479, up=999999999999999983222784.000000
ITER 4: row=59, varin=58, theta=0.015909, up=999999999999999983222784.000000
ITER 5: row=49, varin=45, theta=0.001961, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=59)
DEBUG SOLUTION: LP solution array indices: FST[60-99], not_covered[100-119]
DEBUG SOLUTION: lp->best_solution[0] = 28566450.842540
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.937237
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 59 rows, 60 cols, 294 nonzeros, 9 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 9 slack rows
  % @PAP adding 6 rows, 17 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=42, theta=1.252563, up=999999999999999983222784.000000
ITER 2: row=55, varin=67, theta=0.301616, up=1.000000
ITER 3: row=24, varin=102, theta=0.190476, up=1.000000
ITER 4: row=48, varin=43, theta=0.550820, up=999999999999999983222784.000000
ITER 5: row=54, varin=99, theta=0.604938, up=1.000000
ITER 6: row=56, varin=51, theta=0.064516, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 28587791.755367
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 56 rows, 60 cols, 285 nonzeros, 6 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=23, theta=2.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28619735.710416
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 53 rows, 60 cols, 262 nonzeros, 3 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 2 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=44, theta=0.545455, up=999999999999999983222784.000000
ITER 2: row=51, varin=52, theta=1.062500, up=999999999999999983222784.000000
ITER 3: row=49, varin=42, theta=0.909091, up=999999999999999983222784.000000
ITER 4: row=42, varin=39, theta=0.666667, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28636828.769414
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 266 nonzeros, 3 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % Node 19 LP 1 Solution, length = 28636828.769414, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.166667 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.166667 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.166667 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.166667 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.166667 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.166667 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.833333 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.833333 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.833333 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.833333 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.833333 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.833333 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.833333 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.833333 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28636828.769414, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 19 at  28.63682876941446053820
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5571bedc5ef0
% @LO 0.01  28.56093567323316051443 99.9000000000
% @LN 0.01  28.56282386157201358401 99.9000000000
% Resuming node 17 at  28.56282386157201358401
DEBUG CONSTRNT: LP rows=49, pool->nlprows=49, pool->npend=0
DEBUG CONSTRNT: Checking 49 LP rows (pool tracks 49, total LP rows 49)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=48, expected 48
 % @PAP adding 49 rows, 216 nz to LP
DEBUG BB: Processing node 17, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 17 LP 2 Solution, length = 28562823.861572, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.120707 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.120707 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.120707 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.396467 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.120707 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.120707 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.120707 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.396467 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.603533 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.879293 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.879293 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.603533 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.879293 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.879293 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.879293 (terminal 19)
 % 8 fractional variables
DEBUG CG: LP optimal, z=28562823.861572, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28562823.861572, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 17 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 17
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.120707
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.120707)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.120707
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.120707)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.120707
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.120707)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.396467
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.396467)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.120707
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.120707)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.120707
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.120707)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.120707
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.120707)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.396467
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.396467)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 8 fractional variables

  %  Carefully choosing branching variable, nfrac = 8
DEBUG CAREFUL: Testing fvar[0] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 7
DEBUG CAREFUL: New best var: 7
DEBUG CAREFUL: Testing fvar[1] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 36
DEBUG CAREFUL: Testing fvar[2] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[3] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[4] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 11
DEBUG CAREFUL: New best var: 11
DEBUG CAREFUL: Testing fvar[5] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 4
DEBUG CAREFUL: New best var: 4
DEBUG CAREFUL: Testing fvar[6] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 27
DEBUG CAREFUL: Testing fvar[7] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 22
  % Initial guess is x4, Z0 = 28562823.861572         , Z1 = 29074686.1816683        

DEBUG EVAL: Testing var 7 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=47, theta=136370.800000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 7 = 0 gives z=27727310.300903
  % 	x7 = 0,	Z0 = 28562823.861572         
DEBUG EVAL: First branch cutoff check: z=28562823.861572, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 7 = 1
ITER 1: row=6, varin=80, theta=0.850435, up=1.000000
ITER 2: row=1, varin=41, theta=0.251897, up=999999999999999983222784.000000
ITER 3: row=29, varin=34, theta=0.604587, up=999999999999999983222784.000000
ITER 4: row=32, varin=7, theta=0.559073, up=999999999999999983222784.000000
ITER 5: row=2, varin=35, theta=0.982861, up=999999999999999983222784.000000
ITER 6: row=1, varin=43, theta=1.012454, up=999999999999999983222784.000000
ITER 7: row=6, varin=81, theta=1.353674, up=1.000000
ITER 8: row=6, varin=82, theta=0.393202, up=1.000000
ITER 9: row=17, varin=2, theta=0.842130, up=999999999999999983222784.000000
ITER 10: row=6, varin=81, theta=1.114056, up=1.000000
  % 	x7 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: Second branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=6, varin=47, theta=136370.800000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28563630.633255
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 49 rows, 60 cols, 276 nonzeros, 1 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 17 at  28.56363063325472850806
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5571bedc5ef0
% @LO 0.01  28.56282386157201358401 99.9000000000
% @LN 0.01  28.56363063325472850806 99.9000000000
% Resuming node 17 at  28.56363063325472850806
DEBUG CONSTRNT: LP rows=48, pool->nlprows=48, pool->npend=0
DEBUG CONSTRNT: Checking 48 LP rows (pool tracks 48, total LP rows 48)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=47, expected 47
 % @PAP adding 48 rows, 176 nz to LP
DEBUG BB: Processing node 17, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 17 LP 3 Solution, length = 28563630.633255, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.200000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.200000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.200000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.200000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.200000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.200000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.800000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.800000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.800000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.800000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.800000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28563630.633255, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28563630.633255, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 17 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 17
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.200000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.200000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.200000
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.200000)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.200000
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.200000)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.200000
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.200000)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.200000
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.200000)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.200000
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.200000)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[1] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[2] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 11
DEBUG CAREFUL: New best var: 11
DEBUG CAREFUL: Testing fvar[3] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 4
DEBUG CAREFUL: New best var: 4
DEBUG CAREFUL: Testing fvar[4] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 27
DEBUG CAREFUL: Testing fvar[5] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 22
  % Initial guess is x4, Z0 = 28563630.6332547        , Z1 = 29074686.1816683        

DEBUG EVAL: Testing var 3 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=16, varin=99, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 3 = 0 gives z=28570736.050188
  % 	x3 = 0,	Z0 = 28570736.0501876        
DEBUG EVAL: First branch cutoff check: z=28570736.050188, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 1
ITER 1: row=16, varin=41, theta=1.333333, up=999999999999999983222784.000000
ITER 2: row=37, varin=48, theta=4.000000, up=999999999999999983222784.000000
ITER 3: row=48, varin=47, theta=4.000000, up=999999999999999983222784.000000
ITER 4: row=45, varin=45, theta=3.000000, up=999999999999999983222784.000000
ITER 5: row=41, varin=42, theta=3.000000, up=999999999999999983222784.000000
ITER 6: row=38, varin=24, theta=2.000000, up=999999999999999983222784.000000
ITER 7: row=24, varin=39, theta=2.000000, up=999999999999999983222784.000000
ITER 8: row=39, varin=32, theta=0.666667, up=999999999999999983222784.000000
  % 	x3 = 1,	Z1 = 29009995.2669575        
DEBUG EVAL: Second branch cutoff check: z=29009995.266958, best_z=INF, threshold=INF
  %   New best:  x3, Z = 28570736.0501876        
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=99, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28570736.050188
  % 	x2 = 0,	Z0 = 28570736.0501876        
DEBUG EVAL: First branch cutoff check: z=28570736.050188, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 1
ITER 1: row=1, varin=41, theta=1.333333, up=999999999999999983222784.000000
ITER 2: row=37, varin=48, theta=4.000000, up=999999999999999983222784.000000
ITER 3: row=48, varin=47, theta=4.000000, up=999999999999999983222784.000000
ITER 4: row=45, varin=45, theta=3.000000, up=999999999999999983222784.000000
ITER 5: row=41, varin=42, theta=3.000000, up=999999999999999983222784.000000
ITER 6: row=38, varin=35, theta=0.666667, up=999999999999999983222784.000000
  % 	x2 = 1,	Z1 = 28758967.5625839        
DEBUG EVAL: Second branch cutoff check: z=28758967.562584, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 11 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=32, varin=48, theta=4.000000, up=999999999999999983222784.000000
ITER 2: row=48, varin=47, theta=4.000000, up=999999999999999983222784.000000
ITER 3: row=45, varin=42, theta=1.500000, up=999999999999999983222784.000000
ITER 4: row=31, varin=45, theta=3.000000, up=999999999999999983222784.000000
ITER 5: row=41, varin=41, theta=3.000000, up=999999999999999983222784.000000
ITER 6: row=38, varin=24, theta=2.000000, up=999999999999999983222784.000000
ITER 7: row=24, varin=39, theta=2.000000, up=999999999999999983222784.000000
ITER 8: row=39, varin=7, theta=2.000000, up=999999999999999983222784.000000
ITER 9: row=2, varin=43, theta=2.000000, up=999999999999999983222784.000000
ITER 10: row=17, varin=35, theta=2.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 11 = 1 gives z=29173206.083177
  % 	x11 = 1,	Z1 = 29173206.0831771        
DEBUG EVAL: First branch cutoff check: z=29173206.083177, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 11 = 0
ITER 1: row=32, varin=41, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=37, varin=99, theta=1.000000, up=1.000000
  % 	x11 = 0,	Z0 = 28570736.0501876        
DEBUG EVAL: Second branch cutoff check: z=28570736.050188, best_z=INF, threshold=INF
  %   New best:  x11, Z = 28570736.0501876        
DEBUG EVAL: Testing var 4 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=29, varin=34, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=33, varin=48, theta=4.000000, up=999999999999999983222784.000000
ITER 3: row=48, varin=47, theta=4.000000, up=999999999999999983222784.000000
ITER 4: row=45, varin=41, theta=1.500000, up=999999999999999983222784.000000
ITER 5: row=37, varin=45, theta=3.000000, up=999999999999999983222784.000000
ITER 6: row=41, varin=42, theta=3.000000, up=999999999999999983222784.000000
ITER 7: row=38, varin=24, theta=2.000000, up=999999999999999983222784.000000
ITER 8: row=24, varin=39, theta=2.000000, up=999999999999999983222784.000000
ITER 9: row=39, varin=7, theta=2.000000, up=999999999999999983222784.000000
ITER 10: row=2, varin=29, theta=0.666667, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 4 = 1 gives z=29189690.537363
  % 	x4 = 1,	Z1 = 29189690.5373626        
DEBUG EVAL: First branch cutoff check: z=29189690.537363, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 4 = 0
ITER 1: row=29, varin=41, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=37, varin=99, theta=1.000000, up=1.000000
  % 	x4 = 0,	Z0 = 28570736.0501876        
DEBUG EVAL: Second branch cutoff check: z=28570736.050188, best_z=INF, threshold=INF
  %   New best:  x4, Z = 28570736.0501876        
DEBUG EVAL: Testing var 27 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=45, varin=41, theta=1.333333, up=999999999999999983222784.000000
ITER 2: row=37, varin=48, theta=4.000000, up=999999999999999983222784.000000
ITER 3: row=48, varin=45, theta=4.000000, up=999999999999999983222784.000000
ITER 4: row=41, varin=42, theta=4.000000, up=999999999999999983222784.000000
ITER 5: row=38, varin=35, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 27 = 1 gives z=28804707.559040
  % 	x27 = 1,	Z1 = 28804707.5590403        
DEBUG EVAL: First branch cutoff check: z=28804707.559040, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 27 = 0
ITER 1: row=45, varin=47, theta=0.250000, up=999999999999999983222784.000000
  % 	x27 = 0,	Z0 = 28567554.6660466        
DEBUG EVAL: Second branch cutoff check: z=28567554.666047, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 22 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=38, varin=41, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 22 = 0 gives z=28567724.510679
  % 	x22 = 0,	Z0 = 28567724.5106794        
DEBUG EVAL: First branch cutoff check: z=28567724.510679, best_z=INF, threshold=INF
  % Best branch is x4, Z0 = 28570736.0501876        , Z1 = 29189690.5373626        

DEBUG CAREFUL: Final result - returning best.var = 4
DEBUG BB: Branching variable chosen: j=4
 % @NC   21   17	x4 = 0	28570736.050188
 % @NC   22   17	x4 = 1	29189690.537363
 %      17    11 28563630.6333               28570736.0502   x29 D    15     5
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5571bedd9330
% @LO 0.01  28.56363063325472850806 99.9000000000
% @LN 0.01  28.57073605018758044594 99.9000000000
% Resuming node 21 at  28.57073605018758044594
DEBUG CONSTRNT: LP rows=48, pool->nlprows=48, pool->npend=0
DEBUG CONSTRNT: Checking 48 LP rows (pool tracks 48, total LP rows 48)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=47, expected 47
 % @PAP adding 48 rows, 176 nz to LP
DEBUG BB: Processing node 21, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=29, varin=41, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=37, varin=99, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28570736.050188
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 2.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 236 nonzeros, 3 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 51 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=83, theta=0.398181, up=1.000000
ITER 2: row=49, varin=52, theta=380474.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28574527.830671
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 287 nonzeros, 1 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 4 rows, 15 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=88, theta=1.000000, up=1.000000
ITER 2: row=53, varin=72, theta=1.000000, up=1.000000
ITER 3: row=21, varin=87, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 28624619.933044
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 55 rows, 60 cols, 262 nonzeros, 1 slack, 54 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 2 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=55, varin=27, theta=0.200000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 28648863.260836
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.600000
DEBUG SOLUTION: lp->best_solution[5] = 2.600000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.600000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 56 rows, 60 cols, 271 nonzeros, 5 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 4 rows, 11 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=48, theta=0.666667, up=999999999999999983222784.000000
ITER 2: row=55, varin=31, theta=0.166667, up=999999999999999983222784.000000
ITER 3: row=54, varin=55, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=52, varin=5, theta=0.142857, up=999999999999999983222784.000000
ITER 5: row=8, varin=52, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 28714663.746042
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 55 rows, 60 cols, 266 nonzeros, 7 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 7 slack rows
  % Node 21 LP 1 Solution, length = 28714663.746042, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.500000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.500000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28714663.746042, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 21 at  28.71466374604197824283
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5571bedb9600
% @LO 0.01  28.57073605018758044594 99.9000000000
% @LN 0.01  28.59497341696815198020 99.9000000000
% Resuming node 11 at  28.59497341696815198020
DEBUG CONSTRNT: LP rows=48, pool->nlprows=48, pool->npend=0
DEBUG CONSTRNT: Checking 48 LP rows (pool tracks 48, total LP rows 48)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=47, expected 47
 % @PAP adding 57 rows, 223 nz to LP
DEBUG BB: Processing node 11, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 11 LP 2 Solution, length = 28594973.416968, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.500000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.500000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 1.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 2 fractional variables
DEBUG CG: LP optimal, z=28594973.416968, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28594973.416968, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 11 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 11
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.500000
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.500000
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=1.000000
DEBUG CAREFUL: Skipping var 14: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 2 fractional variables

  %  Carefully choosing branching variable, nfrac = 2
DEBUG CAREFUL: Testing fvar[0] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 5
DEBUG CAREFUL: New best var: 5
DEBUG CAREFUL: Testing fvar[1] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
  % Initial guess is x5, Z0 = 28594973.4169682        , Z1 = 28608235.6984112        

DEBUG EVAL: Testing var 5 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=22, varin=17, theta=0.800000, up=999999999999999983222784.000000
ITER 2: row=11, varin=57, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 5 = 1 gives z=28608235.698411
  % 	x5 = 1,	Z1 = 28608235.6984112        
DEBUG EVAL: First branch cutoff check: z=28608235.698411, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 5 = 0
ITER 1: row=22, varin=61, theta=0.538462, up=1.000000
ITER 2: row=48, varin=47, theta=0.055571, up=999999999999999983222784.000000
ITER 3: row=36, varin=53, theta=0.438479, up=999999999999999983222784.000000
  % 	x5 = 0,	Z0 = 28613352.5407256        
DEBUG EVAL: Second branch cutoff check: z=28613352.540726, best_z=INF, threshold=INF
  %   New best:  x5, Z = 28608235.6984112        
DEBUG EVAL: Testing var 7 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=45, varin=17, theta=0.800000, up=999999999999999983222784.000000
ITER 2: row=11, varin=52, theta=0.207847, up=999999999999999983222784.000000
ITER 3: row=48, varin=55, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=55, varin=22, theta=0.302859, up=999999999999999983222784.000000
ITER 5: row=8, varin=8, theta=0.363636, up=999999999999999983222784.000000
ITER 6: row=2, varin=54, theta=0.444444, up=999999999999999983222784.000000
ITER 7: row=46, varin=7, theta=0.428571, up=999999999999999983222784.000000
ITER 8: row=1, varin=47, theta=0.331529, up=999999999999999983222784.000000
ITER 9: row=47, varin=44, theta=1.000000, up=999999999999999983222784.000000
ITER 10: row=43, varin=34, theta=0.543689, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 7 = 1 gives z=28680697.645410
  % 	x7 = 1,	Z1 = 28680697.6454102        
DEBUG EVAL: First branch cutoff check: z=28680697.645410, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 7 = 0
ITER 1: row=45, varin=57, theta=1.000000, up=999999999999999983222784.000000
  % 	x7 = 0,	Z0 = 28608235.6984112        
DEBUG EVAL: Second branch cutoff check: z=28608235.698411, best_z=INF, threshold=INF
  %   New best:  x7, Z = 28608235.6984112        
  % Best branch is x7, Z0 = 28608235.6984112        , Z1 = 28680697.6454102        

DEBUG CAREFUL: Final result - returning best.var = 7
DEBUG BB: Branching variable chosen: j=7
 % @NC   23   11	x7 = 0	28608235.698411
 % @NC   24   11	x7 = 1	28680697.645410
 %      11    12 28594973.4170               28608235.6984   x14 U     9     4
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5571bedc5ef0
% @LO 0.01  28.59497341696815198020 99.9000000000
% @LN 0.01  28.60823569841124935920 99.9000000000
% Resuming node 23 at  28.60823569841124935920
DEBUG CONSTRNT: LP rows=57, pool->nlprows=57, pool->npend=0
DEBUG CONSTRNT: Checking 57 LP rows (pool tracks 57, total LP rows 57)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=56, expected 56
 % @PAP adding 57 rows, 223 nz to LP
DEBUG BB: Processing node 23, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=57, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 28608235.698411
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 57 rows, 60 cols, 283 nonzeros, 1 slack, 56 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 11 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=58, varin=63, theta=0.538462, up=1.000000
ITER 2: row=48, varin=47, theta=0.055571, up=999999999999999983222784.000000
ITER 3: row=36, varin=53, theta=0.438479, up=999999999999999983222784.000000
ITER 4: row=59, varin=58, theta=0.015909, up=999999999999999983222784.000000
ITER 5: row=49, varin=45, theta=0.001961, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=59)
DEBUG SOLUTION: LP solution array indices: FST[60-99], not_covered[100-119]
DEBUG SOLUTION: lp->best_solution[0] = 28613750.867718
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.937237
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 59 rows, 60 cols, 294 nonzeros, 9 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 9 slack rows
  % @PAP adding 6 rows, 17 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=42, theta=1.252563, up=999999999999999983222784.000000
ITER 2: row=55, varin=67, theta=0.301616, up=1.000000
ITER 3: row=24, varin=102, theta=0.190476, up=1.000000
ITER 4: row=48, varin=43, theta=0.550820, up=999999999999999983222784.000000
ITER 5: row=54, varin=99, theta=0.604938, up=1.000000
ITER 6: row=56, varin=51, theta=0.064516, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 28635091.780545
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 56 rows, 60 cols, 285 nonzeros, 6 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=23, theta=2.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28667035.735594
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 53 rows, 60 cols, 262 nonzeros, 3 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 2 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=44, theta=0.545455, up=999999999999999983222784.000000
ITER 2: row=51, varin=52, theta=1.062500, up=999999999999999983222784.000000
ITER 3: row=49, varin=42, theta=0.909091, up=999999999999999983222784.000000
ITER 4: row=42, varin=39, theta=0.666667, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28684128.794593
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 266 nonzeros, 3 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % Node 23 LP 1 Solution, length = 28684128.794593, 0.01 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.166667 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.166667 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.166667 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.166667 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 1.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.166667 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.166667 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.833333 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.833333 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.833333 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.833333 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.833333 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.833333 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.833333 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.833333 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28684128.794593, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 23 at  28.68412879459254583026
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5571bedd4b10
% @LO 0.02  28.60823569841124935920 99.9000000000
% @LN 0.02  28.61421475303193773243 99.9000000000
% Resuming node 8 at  28.61421475303193773243
DEBUG CONSTRNT: LP rows=49, pool->nlprows=49, pool->npend=0
DEBUG CONSTRNT: Checking 49 LP rows (pool tracks 49, total LP rows 49)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=48, expected 48
 % @PAP adding 56 rows, 242 nz to LP
DEBUG BB: Processing node 8, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 8 LP 2 Solution, length = 28614214.753032, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.127882 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.127882 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.052411 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.127882 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.127882 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.127882 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.127882 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.872118 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.872118 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.872118 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.872118 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.872118 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.872118 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.872118 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=28614214.753032, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28614214.753032, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 8 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 8
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.127882
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.127882)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.127882
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.127882)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.052411
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.052411)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.127882
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.127882)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.127882
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.127882)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=1.000000
DEBUG CAREFUL: Skipping var 13: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.127882
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.127882)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.127882
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.127882)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 7 fractional variables

  %  Carefully choosing branching variable, nfrac = 7
DEBUG CAREFUL: Testing fvar[0] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 4
DEBUG CAREFUL: New best var: 4
DEBUG CAREFUL: Testing fvar[1] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 11
DEBUG CAREFUL: Testing fvar[2] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[3] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[4] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[5] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 18
DEBUG CAREFUL: Testing fvar[6] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
  % Initial guess is x4, Z0 = 28614214.7530319        , Z1 = 28957438.9390695        

DEBUG EVAL: Testing var 4 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=44, varin=55, theta=3.225730, up=999999999999999983222784.000000
ITER 2: row=22, varin=53, theta=0.871547, up=999999999999999983222784.000000
ITER 3: row=7, varin=51, theta=0.729573, up=999999999999999983222784.000000
ITER 4: row=50, varin=11, theta=0.660381, up=999999999999999983222784.000000
ITER 5: row=10, varin=50, theta=606506.000000, up=999999999999999983222784.000000
ITER 6: row=19, varin=6, theta=1.062634, up=999999999999999983222784.000000
ITER 7: row=10, varin=44, theta=0.492555, up=999999999999999983222784.000000
ITER 8: row=21, varin=19, theta=0.289566, up=999999999999999983222784.000000
ITER 9: row=1, varin=50, theta=606506.000000, up=999999999999999983222784.000000
ITER 10: row=7, varin=42, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 4 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x4 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=79, theta=0.035812, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 28620882.142775
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 56 rows, 60 cols, 302 nonzeros, 0 slack, 56 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 8 at  28.62088214277504860661
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5571bedd4b10
% @LO 0.02  28.61421475303193773243 99.9000000000
% @LN 0.02  28.62088214277504860661 99.9000000000
% Resuming node 8 at  28.62088214277504860661
DEBUG CONSTRNT: LP rows=56, pool->nlprows=56, pool->npend=0
DEBUG CONSTRNT: Checking 56 LP rows (pool tracks 56, total LP rows 56)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=55, expected 55
 % @PAP adding 56 rows, 242 nz to LP
DEBUG BB: Processing node 8, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 8 LP 3 Solution, length = 28620882.142775, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.137741 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.137741 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.137741 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.137741 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.137741 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.137741 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.035812 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.862259 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.862259 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.862259 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.862259 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.862259 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.862259 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.862259 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=28620882.142775, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28620882.142775, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 8 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 8
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.137741
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.137741)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.137741
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.137741)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.137741
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.137741)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.137741
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.137741)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=1.000000
DEBUG CAREFUL: Skipping var 13: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.137741
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.137741)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.137741
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.137741)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.035812
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.035812)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 7 fractional variables

  %  Carefully choosing branching variable, nfrac = 7
DEBUG CAREFUL: Testing fvar[0] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 22
DEBUG CAREFUL: New best var: 22
DEBUG CAREFUL: Testing fvar[1] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 11
DEBUG CAREFUL: New best var: 11
DEBUG CAREFUL: Testing fvar[2] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[3] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[4] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[5] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 18
DEBUG CAREFUL: Testing fvar[6] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
  % Initial guess is x11, Z0 = 28620882.142775         , Z1 = 28932712.2577912        

DEBUG EVAL: Testing var 22 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=50, varin=55, theta=4.803541, up=999999999999999983222784.000000
ITER 2: row=22, varin=53, theta=1.234086, up=999999999999999983222784.000000
ITER 3: row=49, varin=51, theta=0.802781, up=999999999999999983222784.000000
ITER 4: row=44, varin=11, theta=0.431158, up=999999999999999983222784.000000
ITER 5: row=10, varin=50, theta=395984.000000, up=999999999999999983222784.000000
ITER 6: row=18, varin=71, theta=55.969470, up=1.000000
ITER 7: row=18, varin=49, theta=0.710763, up=999999999999999983222784.000000
ITER 8: row=35, varin=71, theta=1.000000, up=1.000000
ITER 9: row=7, varin=36, theta=0.644145, up=999999999999999983222784.000000
ITER 10: row=34, varin=6, theta=0.693787, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 22 = 1 gives z=29131801.181932
  % 	x22 = 1,	Z1 = 29131801.1819323        
DEBUG EVAL: First branch cutoff check: z=29131801.181932, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 22 = 0
ITER 1: row=50, varin=82, theta=0.037940, up=1.000000
ITER 2: row=35, varin=83, theta=0.038437, up=1.000000
  % 	x22 = 0,	Z0 = 28622621.7144503        
DEBUG EVAL: Second branch cutoff check: z=28622621.714450, best_z=INF, threshold=INF
  %   New best:  x22, Z = 28622621.7144503        
DEBUG EVAL: Testing var 11 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=44, varin=11, theta=2.284663, up=999999999999999983222784.000000
ITER 2: row=10, varin=55, theta=7.551603, up=999999999999999983222784.000000
ITER 3: row=53, varin=47, theta=1.087321, up=999999999999999983222784.000000
ITER 4: row=52, varin=53, theta=4.073189, up=999999999999999983222784.000000
ITER 5: row=49, varin=42, theta=1.958093, up=999999999999999983222784.000000
ITER 6: row=10, varin=6, theta=1.085498, up=999999999999999983222784.000000
ITER 7: row=1, varin=22, theta=0.718979, up=999999999999999983222784.000000
ITER 8: row=50, varin=82, theta=0.955650, up=1.000000
ITER 9: row=35, varin=83, theta=0.974946, up=1.000000
ITER 10: row=22, varin=49, theta=4.190725, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 11 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x11 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=71, theta=55.969470, up=1.000000
ITER 2: row=44, varin=51, theta=0.164875, up=999999999999999983222784.000000
ITER 3: row=35, varin=71, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=3)
ITER 4: row=26, varin=35, theta=0.000000, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 28648937.641267
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 56 rows, 60 cols, 302 nonzeros, 2 slack, 54 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 8 at  28.64893764126738062714
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5571beddef90
% @LO 0.02  28.62088214277504860661 99.9000000000
% @LN 0.02  28.62154007573326808256 99.9000000000
% Resuming node 16 at  28.62154007573326808256
DEBUG CONSTRNT: LP rows=54, pool->nlprows=54, pool->npend=0
DEBUG CONSTRNT: Checking 54 LP rows (pool tracks 54, total LP rows 54)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=53, expected 53
 % @PAP adding 53 rows, 186 nz to LP
DEBUG BB: Processing node 16, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=37, varin=32, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=32, varin=49, theta=0.333333, up=999999999999999983222784.000000
ITER 3: row=33, varin=43, theta=0.500000, up=999999999999999983222784.000000
ITER 4: row=25, varin=51, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28621540.075733
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 53 rows, 60 cols, 246 nonzeros, 2 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 46 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=55, varin=12, theta=0.288928, up=999999999999999983222784.000000
ITER 2: row=54, varin=35, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=51, varin=77, theta=0.417513, up=1.000000
ITER 4: row=32, varin=78, theta=0.422948, up=1.000000
ITER 5: row=13, varin=8, theta=0.351300, up=999999999999999983222784.000000
ITER 6: row=55, varin=110, theta=0.279108, up=1.000000
ITER 7: row=43, varin=33, theta=0.171233, up=999999999999999983222784.000000
ITER 8: row=49, varin=34, theta=0.124213, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=8)
ITER 9: row=43, varin=55, theta=257248.000000, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 30022749.697424
DEBUG SOLUTION: lp->best_solution[1] = 19.496852
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 55 rows, 60 cols, 292 nonzeros, 6 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 8 rows, 71 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=71, theta=4.666667, up=1.000000
ITER 2: row=1, varin=73, theta=3.666667, up=1.000000
ITER 3: row=1, varin=74, theta=2.666667, up=1.000000
ITER 4: row=1, varin=72, theta=1.666667, up=1.000000
ITER 5: row=1, varin=98, theta=2.000000, up=1.000000
ITER 6: row=1, varin=99, theta=1.000000, up=1.000000
ITER 7: row=28, varin=98, theta=1.000000, up=1.000000
ITER 8: row=57, varin=74, theta=2.444894, up=1.000000
ITER 9: row=57, varin=72, theta=2.473220, up=1.000000
ITER 10: row=57, varin=71, theta=1.096221, up=1.000000
LP PHASE: Switching to primal (iter=85)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 29022544.799350
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.743289
DEBUG SOLUTION: lp->best_solution[10] = 0.743289
DEBUG SOLUTION: lp->best_solution[11] = 3.486578
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 57 rows, 60 cols, 313 nonzeros, 6 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 25 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=58, varin=57, theta=229207.000000, up=999999999999999983222784.000000
ITER 2: row=60, varin=86, theta=0.625000, up=1.000000
ITER 3: row=50, varin=70, theta=1.000000, up=1.000000
ITER 4: row=29, varin=91, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=63)
DEBUG SOLUTION: LP solution array indices: FST[64-103], not_covered[104-123]
DEBUG SOLUTION: lp->best_solution[0] = 29043826.215178
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 63 rows, 60 cols, 338 nonzeros, 2 slack, 61 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=64, varin=94, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=65)
DEBUG SOLUTION: LP solution array indices: FST[66-105], not_covered[106-125]
DEBUG SOLUTION: lp->best_solution[0] = 29045544.197002
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 65 rows, 60 cols, 344 nonzeros, 2 slack, 63 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=66, varin=55, theta=0.800000, up=999999999999999983222784.000000
ITER 2: row=57, varin=97, theta=0.407697, up=1.000000
ITER 3: row=9, varin=34, theta=0.255200, up=999999999999999983222784.000000
ITER 4: row=63, varin=99, theta=0.250844, up=1.000000
ITER 5: row=65, varin=98, theta=0.239008, up=1.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=66)
DEBUG SOLUTION: LP solution array indices: FST[67-106], not_covered[107-126]
DEBUG SOLUTION: lp->best_solution[0] = 29082365.278829
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.782574
DEBUG SOLUTION: lp->best_solution[11] = 3.782574
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 66 rows, 60 cols, 349 nonzeros, 4 slack, 62 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=68, varin=63, theta=0.377395, up=999999999999999983222784.000000
ITER 2: row=67, varin=86, theta=0.407999, up=1.000000
ITER 3: row=49, varin=68, theta=2.207012, up=999999999999999983222784.000000
ITER 4: row=10, varin=38, theta=0.116176, up=999999999999999983222784.000000
ITER 5: row=69, varin=3, theta=0.131017, up=999999999999999983222784.000000
ITER 6: row=4, varin=65, theta=0.348970, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=69)
DEBUG SOLUTION: LP solution array indices: FST[70-109], not_covered[110-129]
DEBUG SOLUTION: lp->best_solution[0] = 29146729.430243
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 69 rows, 60 cols, 363 nonzeros, 11 slack, 58 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 16 LP 1 Solution, length = 29146729.430243, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.348970 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.075515 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.075515 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.075515 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.075515 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.348970 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.348970 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 1.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.924485 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.651030 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.651030 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.924485 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.924485 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=29146729.430243, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 16 at  29.14672943024343254592
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5571bedda990
% @LO 0.02  28.62154007573326808256 99.9000000000
% @LN 0.02  28.63339762023214518649 99.9000000000
% Resuming node 20 at  28.63339762023214518649
DEBUG CONSTRNT: LP rows=69, pool->nlprows=69, pool->npend=0
DEBUG CONSTRNT: Checking 69 LP rows (pool tracks 69, total LP rows 69)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=56, expected 56
DEBUG CONSTRNT: Checking LP row 57 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=57, expected 57
DEBUG CONSTRNT: Checking LP row 58 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=58, expected 58
DEBUG CONSTRNT: Checking LP row 59 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=59, expected 59
DEBUG CONSTRNT: Checking LP row 60 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=60, expected 60
DEBUG CONSTRNT: Checking LP row 61 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=61, expected 61
DEBUG CONSTRNT: Checking LP row 62 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=62, expected 62
DEBUG CONSTRNT: Checking LP row 63 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=63, expected 63
DEBUG CONSTRNT: Checking LP row 64 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=64, expected 64
DEBUG CONSTRNT: Checking LP row 65 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=65, expected 65
DEBUG CONSTRNT: Checking LP row 66 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=66, expected 66
DEBUG CONSTRNT: Checking LP row 67 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=67, expected 67
DEBUG CONSTRNT: Checking LP row 68 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=68, expected 68
 % @PAP adding 57 rows, 223 nz to LP
DEBUG BB: Processing node 20, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=17, theta=0.800000, up=999999999999999983222784.000000
ITER 2: row=11, varin=52, theta=0.207847, up=999999999999999983222784.000000
ITER 3: row=48, varin=55, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=55, varin=22, theta=0.302859, up=999999999999999983222784.000000
ITER 5: row=8, varin=8, theta=0.363636, up=999999999999999983222784.000000
ITER 6: row=2, varin=54, theta=0.444444, up=999999999999999983222784.000000
ITER 7: row=46, varin=7, theta=0.428571, up=999999999999999983222784.000000
ITER 8: row=1, varin=47, theta=0.331529, up=999999999999999983222784.000000
ITER 9: row=47, varin=34, theta=0.543689, up=999999999999999983222784.000000
ITER 10: row=6, varin=46, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=10)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 28633397.620232
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 57 rows, 60 cols, 283 nonzeros, 1 slack, 56 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 44 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=59, varin=83, theta=0.594802, up=1.000000
ITER 2: row=55, varin=62, theta=0.794300, up=1.000000
ITER 3: row=22, varin=61, theta=1.821664, up=1.000000
ITER 4: row=22, varin=81, theta=0.248926, up=1.000000
ITER 5: row=13, varin=61, theta=1.000000, up=1.000000
ITER 6: row=44, varin=63, theta=1.506151, up=1.000000
ITER 7: row=44, varin=82, theta=0.232221, up=1.000000
ITER 8: row=1, varin=63, theta=0.698622, up=1.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=59)
DEBUG SOLUTION: LP solution array indices: FST[60-99], not_covered[100-119]
DEBUG SOLUTION: lp->best_solution[0] = 28953375.699815
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 59 rows, 60 cols, 327 nonzeros, 7 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 7 slack rows
  % @PAP adding 6 rows, 17 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=55, varin=64, theta=1.067479, up=1.000000
ITER 2: row=55, varin=87, theta=0.052133, up=1.000000
ITER 3: row=58, varin=64, theta=0.857187, up=1.000000
ITER 4: row=51, varin=58, theta=0.197203, up=999999999999999983222784.000000
ITER 5: row=57, varin=59, theta=0.153380, up=1.000000
ITER 6: row=12, varin=6, theta=0.081702, up=999999999999999983222784.000000
ITER 7: row=51, varin=68, theta=0.114355, up=1.000000
ITER 8: row=47, varin=77, theta=0.053027, up=1.000000
ITER 9: row=45, varin=55, theta=0.325421, up=999999999999999983222784.000000
ITER 10: row=32, varin=86, theta=0.559532, up=1.000000
LP PHASE: Switching to primal (iter=12)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=58)
DEBUG SOLUTION: LP solution array indices: FST[59-98], not_covered[99-118]
DEBUG SOLUTION: lp->best_solution[0] = 29053916.127466
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 58 rows, 60 cols, 330 nonzeros, 3 slack, 55 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 3 rows, 10 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=57, varin=23, theta=0.061307, up=999999999999999983222784.000000
ITER 2: row=56, varin=65, theta=1.062418, up=1.000000
ITER 3: row=56, varin=73, theta=0.063106, up=1.000000
ITER 4: row=27, varin=42, theta=4.149060, up=999999999999999983222784.000000
ITER 5: row=53, varin=43, theta=1.559183, up=999999999999999983222784.000000
ITER 6: row=23, varin=93, theta=1.265111, up=1.000000
ITER 7: row=23, varin=92, theta=0.260948, up=1.000000
ITER 8: row=37, varin=65, theta=1.000000, up=1.000000
ITER 9: row=41, varin=90, theta=5.224678, up=1.000000
ITER 10: row=41, varin=69, theta=1.264487, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=58)
DEBUG SOLUTION: LP solution array indices: FST[59-98], not_covered[99-118]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 58 rows, 60 cols, 332 nonzeros, 6 slack, 52 tight.
  % Node 20 LP 1 Solution, length = 999999999999999983222784.000000, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.276942 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.276942 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.476887 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.969229 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.723058 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 20 is INFEASIBLE
 %      20    11    infeasible               28636828.7694    x7 U    10     4
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5571bedd96e0
% @LO 0.02  28.63339762023214518649 99.9000000000
% @LN 0.02  28.63682876941446053820 99.9000000000
% Resuming node 19 at  28.63682876941446053820
DEBUG CONSTRNT: LP rows=58, pool->nlprows=58, pool->npend=0
DEBUG CONSTRNT: Checking 58 LP rows (pool tracks 58, total LP rows 58)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=56, expected 56
DEBUG CONSTRNT: Checking LP row 57 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=57, expected 57
 % @PAP adding 49 rows, 179 nz to LP
DEBUG BB: Processing node 19, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 19 LP 2 Solution, length = 28636828.769414, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.166667 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.166667 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.166667 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.166667 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.166667 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.166667 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.833333 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.833333 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.833333 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.833333 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.833333 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.833333 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.833333 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.833333 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28636828.769414, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28636828.769414, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 19 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 19
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.166667
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.166667
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.166667
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.166667
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=1.000000
DEBUG CAREFUL: Skipping var 15: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.166667
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.166667
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
DEBUG CAREFUL: Testing fvar[1] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
DEBUG CAREFUL: Testing fvar[2] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[3] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[4] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[5] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 5
  % Initial guess is x3, Z0 = 28636828.7694145        , Z1 = 28739504.2100233        

DEBUG EVAL: Testing var 17 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=26, varin=28, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=38, varin=106, theta=0.312500, up=1.000000
ITER 3: row=11, varin=61, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 17 = 0 gives z=28673641.543908
  % 	x17 = 0,	Z0 = 28673641.5439077        
DEBUG EVAL: First branch cutoff check: z=28673641.543908, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 1
ITER 1: row=26, varin=73, theta=4.545455, up=1.000000
ITER 2: row=26, varin=49, theta=3.900000, up=999999999999999983222784.000000
ITER 3: row=1, varin=40, theta=1.450000, up=999999999999999983222784.000000
ITER 4: row=10, varin=73, theta=1.000000, up=1.000000
ITER 5: row=37, varin=21, theta=0.666667, up=999999999999999983222784.000000
ITER 6: row=21, varin=45, theta=1.000000, up=999999999999999983222784.000000
  % 	x17 = 1,	Z1 = 28900851.2167498        
DEBUG EVAL: Second branch cutoff check: z=28900851.216750, best_z=INF, threshold=INF
  %   New best:  x17, Z = 28673641.5439077        
DEBUG EVAL: Testing var 18 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=39, varin=73, theta=4.545455, up=1.000000
ITER 2: row=39, varin=28, theta=1.300000, up=999999999999999983222784.000000
ITER 3: row=10, varin=73, theta=1.000000, up=1.000000
ITER 4: row=38, varin=49, theta=5.000000, up=999999999999999983222784.000000
ITER 5: row=1, varin=40, theta=2.000000, up=999999999999999983222784.000000
ITER 6: row=37, varin=21, theta=0.666667, up=999999999999999983222784.000000
ITER 7: row=21, varin=45, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 18 = 1 gives z=28900851.216750
  % 	x18 = 1,	Z1 = 28900851.2167498        
DEBUG EVAL: First branch cutoff check: z=28900851.216750, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 18 = 0
ITER 1: row=39, varin=106, theta=0.312500, up=1.000000
ITER 2: row=11, varin=61, theta=0.500000, up=1.000000
  % 	x18 = 0,	Z0 = 28673641.5439077        
DEBUG EVAL: Second branch cutoff check: z=28673641.543908, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 9 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=40, varin=73, theta=4.545455, up=1.000000
ITER 2: row=40, varin=28, theta=1.300000, up=999999999999999983222784.000000
ITER 3: row=10, varin=73, theta=1.000000, up=1.000000
ITER 4: row=38, varin=49, theta=5.000000, up=999999999999999983222784.000000
ITER 5: row=1, varin=44, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 9 = 1 gives z=28834956.172372
  % 	x9 = 1,	Z1 = 28834956.1723722        
DEBUG EVAL: First branch cutoff check: z=28834956.172372, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 0
ITER 1: row=40, varin=106, theta=0.312500, up=1.000000
ITER 2: row=11, varin=40, theta=0.250000, up=999999999999999983222784.000000
  % 	x9 = 0,	Z0 = 28655763.4476629        
DEBUG EVAL: Second branch cutoff check: z=28655763.447663, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=20, varin=73, theta=4.545455, up=1.000000
ITER 2: row=20, varin=49, theta=3.900000, up=999999999999999983222784.000000
ITER 3: row=1, varin=47, theta=0.725000, up=999999999999999983222784.000000
ITER 4: row=10, varin=73, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 3 = 1 gives z=28739504.210023
  % 	x3 = 1,	Z1 = 28739504.2100233        
DEBUG EVAL: First branch cutoff check: z=28739504.210023, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=20, varin=28, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=38, varin=106, theta=0.312500, up=1.000000
ITER 3: row=11, varin=61, theta=0.500000, up=1.000000
  % 	x3 = 0,	Z0 = 28673641.5439077        
DEBUG EVAL: Second branch cutoff check: z=28673641.543908, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=49, theta=0.200000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28640247.381214
  % 	x2 = 0,	Z0 = 28640247.3812142        
DEBUG EVAL: First branch cutoff check: z=28640247.381214, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 5 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=37, varin=106, theta=0.312500, up=1.000000
ITER 2: row=11, varin=46, theta=0.200000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 5 = 0 gives z=28652007.388651
  % 	x5 = 0,	Z0 = 28652007.3886507        
DEBUG EVAL: First branch cutoff check: z=28652007.388651, best_z=INF, threshold=INF
  % Best branch is x17, Z0 = 28673641.5439077        , Z1 = 28900851.2167498        

DEBUG CAREFUL: Final result - returning best.var = 17
DEBUG BB: Branching variable chosen: j=17
 % @NC   25   19	x17 = 0	28673641.543908
 % @NC   26   19	x17 = 1	28900851.216750
 %      19    12 28636828.7694               28638677.2541    x7 D    10     4
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5571bedc7070
% @LO 0.02  28.63682876941446053820 99.9000000000
% @LN 0.02  28.63867725408369224738 99.9000000000
% Resuming node 13 at  28.63867725408369224738
DEBUG CONSTRNT: LP rows=49, pool->nlprows=49, pool->npend=0
DEBUG CONSTRNT: Checking 49 LP rows (pool tracks 49, total LP rows 49)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=48, expected 48
 % @PAP adding 48 rows, 202 nz to LP
DEBUG BB: Processing node 13, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 13 LP 2 Solution, length = 28638677.254084, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.125000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.125000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.125000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.125000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.125000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.375000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.625000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.875000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.875000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.875000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.875000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.625000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.875000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.875000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28638677.254084, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28638677.254084, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 13 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 13
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.125000
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.125000)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.125000
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.125000)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.125000
DEBUG CAREFUL: Adding var 8 to fractional list (xi=0.125000)
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.125000
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.125000)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.125000
DEBUG CAREFUL: Adding var 23 to fractional list (xi=0.125000)
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.375000
DEBUG CAREFUL: Adding var 24 to fractional list (xi=0.375000)
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 5
DEBUG CAREFUL: New best var: 5
DEBUG CAREFUL: Testing fvar[1] = var 8
DEBUG CAREFUL: Calling compare_branch_vars for var 8
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 8
DEBUG CAREFUL: New best var: 8
DEBUG CAREFUL: Testing fvar[2] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
DEBUG CAREFUL: Testing fvar[3] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
DEBUG CAREFUL: Testing fvar[4] = var 24
DEBUG CAREFUL: Calling compare_branch_vars for var 24
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 24
DEBUG CAREFUL: Testing fvar[5] = var 23
DEBUG CAREFUL: Calling compare_branch_vars for var 23
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 23
  % Initial guess is x8, Z0 = 28638677.2540837        , Z1 = 28715905.5190313        

DEBUG EVAL: Testing var 5 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=5, varin=14, theta=0.857143, up=999999999999999983222784.000000
ITER 2: row=16, varin=58, theta=0.333333, up=1.000000
DEBUG EVAL: Branch var 5 = 0 gives z=28645593.494924
  % 	x5 = 0,	Z0 = 28645593.494924         
DEBUG EVAL: First branch cutoff check: z=28645593.494924, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 5 = 1
ITER 1: row=5, varin=46, theta=1.400000, up=999999999999999983222784.000000
ITER 2: row=36, varin=9, theta=0.292683, up=999999999999999983222784.000000
ITER 3: row=8, varin=5, theta=0.459770, up=999999999999999983222784.000000
ITER 4: row=4, varin=32, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=3, varin=39, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=39, varin=47, theta=0.666667, up=999999999999999983222784.000000
ITER 7: row=41, varin=35, theta=2.000000, up=999999999999999983222784.000000
ITER 8: row=3, varin=43, theta=1.000000, up=999999999999999983222784.000000
  % 	x5 = 1,	Z1 = 28697973.0197703        
DEBUG EVAL: Second branch cutoff check: z=28697973.019770, best_z=INF, threshold=INF
  %   New best:  x5, Z = 28645593.494924         
DEBUG EVAL: Testing var 8 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=41, varin=9, theta=1.024390, up=999999999999999983222784.000000
ITER 2: row=8, varin=5, theta=1.609195, up=999999999999999983222784.000000
ITER 3: row=4, varin=41, theta=1.750000, up=999999999999999983222784.000000
ITER 4: row=45, varin=39, theta=1.166667, up=999999999999999983222784.000000
ITER 5: row=48, varin=32, theta=3.500000, up=999999999999999983222784.000000
ITER 6: row=30, varin=40, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=2, varin=42, theta=1.750000, up=999999999999999983222784.000000
ITER 8: row=35, varin=43, theta=3.000000, up=999999999999999983222784.000000
ITER 9: row=37, varin=67, theta=0.666667, up=1.000000
ITER 10: row=43, varin=37, theta=0.333333, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 8 = 1 gives z=28837236.859622
  % 	x8 = 1,	Z1 = 28837236.8596219        
DEBUG EVAL: First branch cutoff check: z=28837236.859622, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 8 = 0
ITER 1: row=41, varin=14, theta=0.857143, up=999999999999999983222784.000000
ITER 2: row=16, varin=58, theta=0.333333, up=1.000000
  % 	x8 = 0,	Z0 = 28645593.494924         
DEBUG EVAL: Second branch cutoff check: z=28645593.494924, best_z=INF, threshold=INF
  %   New best:  x8, Z = 28645593.494924         
DEBUG EVAL: Testing var 7 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=39, varin=47, theta=1.166667, up=999999999999999983222784.000000
ITER 2: row=45, varin=9, theta=1.024390, up=999999999999999983222784.000000
ITER 3: row=8, varin=5, theta=1.609195, up=999999999999999983222784.000000
ITER 4: row=4, varin=44, theta=1.400000, up=999999999999999983222784.000000
ITER 5: row=2, varin=42, theta=2.000000, up=999999999999999983222784.000000
ITER 6: row=35, varin=32, theta=3.000000, up=999999999999999983222784.000000
ITER 7: row=3, varin=43, theta=3.000000, up=999999999999999983222784.000000
ITER 8: row=37, varin=67, theta=0.666667, up=1.000000
ITER 9: row=5, varin=37, theta=0.333333, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 7 = 1 gives z=28792779.797475
  % 	x7 = 1,	Z1 = 28792779.7974747        
DEBUG EVAL: First branch cutoff check: z=28792779.797475, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 7 = 0
ITER 1: row=39, varin=14, theta=0.857143, up=999999999999999983222784.000000
ITER 2: row=16, varin=39, theta=0.166667, up=999999999999999983222784.000000
ITER 3: row=48, varin=58, theta=0.333333, up=1.000000
  % 	x7 = 0,	Z0 = 28645593.494924         
DEBUG EVAL: Second branch cutoff check: z=28645593.494924, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 12 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=35, varin=42, theta=0.142857, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 12 = 0 gives z=28641248.901896
  % 	x12 = 0,	Z0 = 28641248.9018964        
DEBUG EVAL: First branch cutoff check: z=28641248.901896, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 24 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=47, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=45, varin=44, theta=0.333333, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 24 = 0 gives z=28650466.505140
  % 	x24 = 0,	Z0 = 28650466.5051396        
DEBUG EVAL: First branch cutoff check: z=28650466.505140, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 24 = 1
ITER 1: row=2, varin=58, theta=0.714286, up=1.000000
ITER 2: row=5, varin=42, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=36, varin=46, theta=0.500000, up=999999999999999983222784.000000
ITER 4: row=39, varin=67, theta=1.000000, up=1.000000
ITER 5: row=2, varin=9, theta=0.153846, up=999999999999999983222784.000000
ITER 6: row=8, varin=5, theta=0.273973, up=999999999999999983222784.000000
ITER 7: row=4, varin=32, theta=0.500000, up=999999999999999983222784.000000
ITER 8: row=3, varin=43, theta=0.500000, up=999999999999999983222784.000000
ITER 9: row=37, varin=37, theta=0.333333, up=999999999999999983222784.000000
  % 	x24 = 1,	Z1 = 28702711.3334069        
DEBUG EVAL: Second branch cutoff check: z=28702711.333407, best_z=INF, threshold=INF
  %   New best:  x24, Z = 28650466.5051396        
DEBUG EVAL: Testing var 23 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=37, varin=14, theta=0.857143, up=999999999999999983222784.000000
ITER 2: row=16, varin=43, theta=0.166667, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 23 = 0 gives z=28644793.783452
  % 	x23 = 0,	Z0 = 28644793.7834522        
DEBUG EVAL: First branch cutoff check: z=28644793.783452, best_z=INF, threshold=INF
  % Best branch is x24, Z0 = 28650466.5051396        , Z1 = 28702711.3334069        

DEBUG CAREFUL: Final result - returning best.var = 24
DEBUG BB: Branching variable chosen: j=24
 % @NC   27   13	x24 = 0	28650466.505140
 % @NC   28   13	x24 = 1	28702711.333407
 %      13    13 28638677.2541               28648937.6413   x16 D    12     5
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5571bedd4b10
% @LO 0.02  28.63867725408369224738 99.9000000000
% @LN 0.02  28.64893764126738062714 99.9000000000
% Resuming node 8 at  28.64893764126738062714
DEBUG CONSTRNT: LP rows=48, pool->nlprows=48, pool->npend=0
DEBUG CONSTRNT: Checking 48 LP rows (pool tracks 48, total LP rows 48)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 162
DEBUG CONSTRNT: Pool row 162 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 62
DEBUG CONSTRNT: Pool row 62 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=47, expected 47
 % @PAP adding 54 rows, 238 nz to LP
DEBUG BB: Processing node 8, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 8 LP 4 Solution, length = 28648937.641267, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.167874 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.167874 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.167874 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.167874 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.167874 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.160628 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.832126 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.832126 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.832126 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.832126 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.832126 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.832126 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.832126 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28648937.641267, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28648937.641267, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 8 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 8
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.167874
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.167874)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.167874
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.167874)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.167874
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.167874)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=1.000000
DEBUG CAREFUL: Skipping var 13: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.167874
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.167874)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.167874
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.167874)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.160628
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.160628)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[1] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[2] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[3] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 18
DEBUG CAREFUL: Testing fvar[4] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[5] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 22
DEBUG CAREFUL: New best var: 22
  % Initial guess is x22, Z0 = 28648937.6412674        , Z1 = 29131801.1819323        

DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=21, varin=53, theta=5.979559, up=999999999999999983222784.000000
ITER 2: row=22, varin=11, theta=1.506517, up=999999999999999983222784.000000
ITER 3: row=10, varin=27, theta=1.127366, up=999999999999999983222784.000000
ITER 4: row=52, varin=6, theta=2.234823, up=999999999999999983222784.000000
ITER 5: row=6, varin=42, theta=1.972522, up=999999999999999983222784.000000
ITER 6: row=21, varin=49, theta=3.948342, up=999999999999999983222784.000000
ITER 7: row=7, varin=47, theta=1.058426, up=999999999999999983222784.000000
ITER 8: row=44, varin=80, theta=1.215317, up=1.000000
ITER 9: row=44, varin=81, theta=0.219525, up=1.000000
ITER 10: row=35, varin=80, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 3 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x3 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=21, varin=51, theta=0.216288, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 28689000.967645
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 54 rows, 60 cols, 298 nonzeros, 2 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
   % @PAP adding 5 rows, 18 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=56, varin=44, theta=0.052240, up=999999999999999983222784.000000
ITER 2: row=53, varin=83, theta=0.172545, up=1.000000
ITER 3: row=35, varin=84, theta=0.174483, up=1.000000
ITER 4: row=54, varin=28, theta=0.248150, up=999999999999999983222784.000000
ITER 5: row=48, varin=81, theta=9.666405, up=1.000000
ITER 6: row=48, varin=56, theta=1.001946, up=999999999999999983222784.000000
ITER 7: row=43, varin=81, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 28768274.817627
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 57 rows, 60 cols, 312 nonzeros, 2 slack, 55 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
   % @PAP adding 3 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=56, varin=80, theta=0.041412, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=58)
DEBUG SOLUTION: LP solution array indices: FST[59-98], not_covered[99-118]
DEBUG SOLUTION: lp->best_solution[0] = 28768443.234242
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 58 rows, 60 cols, 307 nonzeros, 4 slack, 54 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 4 slack rows
   % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=55, varin=85, theta=0.071044, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 28769512.085149
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 57 rows, 60 cols, 305 nonzeros, 0 slack, 57 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 8 at  28.76951208514947921913
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5571bedd96e0
% @LO 0.02  28.64893764126738062714 99.9000000000
% @LN 0.02  28.65046650513955839301 99.9000000000
% Resuming node 27 at  28.65046650513955839301
DEBUG CONSTRNT: LP rows=57, pool->nlprows=57, pool->npend=0
DEBUG CONSTRNT: Checking 57 LP rows (pool tracks 57, total LP rows 57)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=56, expected 56
 % @PAP adding 48 rows, 202 nz to LP
DEBUG BB: Processing node 27, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=2, varin=47, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=45, varin=44, theta=0.333333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28650466.505140
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 4.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 5.000000
  % @PL 48 rows, 60 cols, 262 nonzeros, 3 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=39, theta=0.600000, up=999999999999999983222784.000000
ITER 2: row=48, varin=43, theta=0.166667, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28657892.358978
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 4.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 5.000000
  % @PL 50 rows, 60 cols, 267 nonzeros, 3 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % Node 27 LP 1 Solution, length = 28657892.358978, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.166667 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.166667 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.166667 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.833333 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.833333 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.833333 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28657892.358978, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.02  28.65046650513955839301 99.9000000000
 % @LN 0.02  28.65789235897823417076 99.9000000000
DEBUG CG: Second cutoff check: z=28657892.358978, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 27 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 27
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.166667
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.166667
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.166667
DEBUG CAREFUL: Adding var 8 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.500000
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 12
DEBUG CAREFUL: New best var: 12
DEBUG CAREFUL: Testing fvar[1] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 5
DEBUG CAREFUL: New best var: 5
DEBUG CAREFUL: Testing fvar[2] = var 8
DEBUG CAREFUL: Calling compare_branch_vars for var 8
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 8
DEBUG CAREFUL: New best var: 8
DEBUG CAREFUL: Testing fvar[3] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
  % Initial guess is x8, Z0 = 28657892.3589782        , Z1 = 28837236.8596219        

DEBUG EVAL: Testing var 12 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=35, varin=38, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 12 = 0 gives z=28659275.339140
  % 	x12 = 0,	Z0 = 28659275.33914          
DEBUG EVAL: First branch cutoff check: z=28659275.339140, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 1
ITER 1: row=35, varin=57, theta=1.000000, up=1.000000
ITER 2: row=37, varin=66, theta=1.000000, up=1.000000
ITER 3: row=35, varin=9, theta=0.153846, up=999999999999999983222784.000000
ITER 4: row=8, varin=5, theta=0.273973, up=999999999999999983222784.000000
ITER 5: row=4, varin=32, theta=0.500000, up=999999999999999983222784.000000
ITER 6: row=3, varin=43, theta=0.200000, up=999999999999999983222784.000000
ITER 7: row=44, varin=46, theta=0.500000, up=999999999999999983222784.000000
ITER 8: row=46, varin=45, theta=0.333333, up=999999999999999983222784.000000
ITER 9: row=5, varin=37, theta=0.333333, up=999999999999999983222784.000000
  % 	x12 = 1,	Z1 = 28742007.0599851        
DEBUG EVAL: Second branch cutoff check: z=28742007.059985, best_z=INF, threshold=INF
  %   New best:  x12, Z = 28659275.33914          
DEBUG EVAL: Testing var 5 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=5, varin=44, theta=1.250000, up=999999999999999983222784.000000
ITER 2: row=42, varin=9, theta=0.731707, up=999999999999999983222784.000000
ITER 3: row=8, varin=5, theta=1.149425, up=999999999999999983222784.000000
ITER 4: row=4, varin=45, theta=1.666667, up=999999999999999983222784.000000
ITER 5: row=40, varin=32, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=3, varin=43, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 5 = 1 gives z=28697973.019770
  % 	x5 = 1,	Z1 = 28697973.0197703        
DEBUG EVAL: First branch cutoff check: z=28697973.019770, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 5 = 0
ITER 1: row=5, varin=14, theta=0.857143, up=999999999999999983222784.000000
ITER 2: row=16, varin=38, theta=1.000000, up=999999999999999983222784.000000
  % 	x5 = 0,	Z0 = 28659275.33914          
DEBUG EVAL: Second branch cutoff check: z=28659275.339140, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 8 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=40, varin=9, theta=0.731707, up=999999999999999983222784.000000
ITER 2: row=8, varin=5, theta=1.149425, up=999999999999999983222784.000000
ITER 3: row=4, varin=32, theta=2.500000, up=999999999999999983222784.000000
ITER 4: row=3, varin=40, theta=1.666667, up=999999999999999983222784.000000
ITER 5: row=5, varin=39, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 8 = 1 gives z=28715905.519031
  % 	x8 = 1,	Z1 = 28837236.8596219        
DEBUG EVAL: First branch cutoff check: z=28837236.859622, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 8 = 0
ITER 1: row=40, varin=14, theta=0.857143, up=999999999999999983222784.000000
ITER 2: row=16, varin=38, theta=1.000000, up=999999999999999983222784.000000
  % 	x8 = 0,	Z0 = 28659275.33914          
DEBUG EVAL: Second branch cutoff check: z=28659275.339140, best_z=INF, threshold=INF
  %   New best:  x8, Z = 28659275.33914          
DEBUG EVAL: Testing var 7 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=39, varin=45, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 7 = 1 gives z=28671448.456884
  % 	x7 = 1,	Z1 = 28792779.7974747        
DEBUG EVAL: First branch cutoff check: z=28792779.797475, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 7 = 0
ITER 1: row=39, varin=14, theta=0.857143, up=999999999999999983222784.000000
ITER 2: row=16, varin=38, theta=1.000000, up=999999999999999983222784.000000
  % 	x7 = 0,	Z0 = 28659275.33914          
DEBUG EVAL: Second branch cutoff check: z=28659275.339140, best_z=INF, threshold=INF
  % Best branch is x8, Z0 = 28659275.33914          , Z1 = 28837236.8596219        

DEBUG CAREFUL: Final result - returning best.var = 8
DEBUG BB: Branching variable chosen: j=8
 % @NC   29   27	x8 = 0	28659275.339140
 % @NC   30   27	x8 = 1	28837236.859622
 %      27    14 28657892.3590               28659275.3391   x24 D    13     6
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5571bedc7070
% @LO 0.02  28.65789235897823417076 99.9000000000
% @LN 0.02  28.65927533913998459525 99.9000000000
% Resuming node 29 at  28.65927533913998459525
DEBUG CONSTRNT: LP rows=47, pool->nlprows=47, pool->npend=0
DEBUG CONSTRNT: Checking 47 LP rows (pool tracks 47, total LP rows 47)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 162
DEBUG CONSTRNT: Pool row 162 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=46, expected 46
 % @PAP adding 47 rows, 201 nz to LP
DEBUG BB: Processing node 29, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=14, theta=0.857143, up=999999999999999983222784.000000
ITER 2: row=16, varin=38, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28659275.339140
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 4.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 5.000000
  % @PL 47 rows, 60 cols, 261 nonzeros, 2 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=44, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=42, varin=45, theta=0.250000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28662343.133797
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 4.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 5.000000
  % @PL 49 rows, 60 cols, 269 nonzeros, 5 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % Node 29 LP 1 Solution, length = 28662343.133797, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.250000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.250000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.250000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.250000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.750000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.750000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.750000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.750000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.750000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.750000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.750000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28662343.133797, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.02  28.65927533913998459525 99.9000000000
 % @LN 0.02  28.66234313379725406890 99.9000000000
DEBUG CG: Second cutoff check: z=28662343.133797, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 29 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 29
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.250000
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.250000
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.250000
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.250000
DEBUG CAREFUL: Adding var 23 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 5
DEBUG CAREFUL: New best var: 5
DEBUG CAREFUL: Testing fvar[1] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 7
DEBUG CAREFUL: New best var: 7
DEBUG CAREFUL: Testing fvar[2] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
DEBUG CAREFUL: Testing fvar[3] = var 23
DEBUG CAREFUL: Calling compare_branch_vars for var 23
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 23
  % Initial guess is x7, Z0 = 28662343.1337973        , Z1 = 28792779.7974747        

DEBUG EVAL: Testing var 5 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=5, varin=44, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=37, varin=16, theta=0.285714, up=999999999999999983222784.000000
ITER 3: row=14, varin=9, theta=0.292683, up=999999999999999983222784.000000
ITER 4: row=8, varin=5, theta=0.459770, up=999999999999999983222784.000000
ITER 5: row=4, varin=32, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=3, varin=42, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 5 = 1 gives z=28697973.019770
  % 	x5 = 1,	Z1 = 28697973.0197703        
DEBUG EVAL: First branch cutoff check: z=28697973.019770, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 5 = 0
ITER 1: row=5, varin=41, theta=0.500000, up=999999999999999983222784.000000
  % 	x5 = 0,	Z0 = 28665361.8980121        
DEBUG EVAL: Second branch cutoff check: z=28665361.898012, best_z=INF, threshold=INF
  %   New best:  x5, Z = 28665361.8980121        
DEBUG EVAL: Testing var 7 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=38, varin=41, theta=1.500000, up=999999999999999983222784.000000
ITER 2: row=5, varin=44, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 7 = 1 gives z=28671448.456884
  % 	x7 = 1,	Z1 = 28792779.7974747        
DEBUG EVAL: First branch cutoff check: z=28792779.797475, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 7 = 0
ITER 1: row=38, varin=18, theta=0.333333, up=999999999999999983222784.000000
  % 	x7 = 0,	Z0 = 28665518.8439559        
DEBUG EVAL: Second branch cutoff check: z=28665518.843956, best_z=INF, threshold=INF
  %   New best:  x7, Z = 28665518.8439559        
DEBUG EVAL: Testing var 12 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=35, varin=44, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=37, varin=54, theta=0.666667, up=1.000000
ITER 3: row=5, varin=16, theta=0.200000, up=999999999999999983222784.000000
ITER 4: row=14, varin=63, theta=1.000000, up=1.000000
ITER 5: row=37, varin=9, theta=0.153846, up=999999999999999983222784.000000
ITER 6: row=8, varin=5, theta=0.273973, up=999999999999999983222784.000000
ITER 7: row=4, varin=32, theta=0.500000, up=999999999999999983222784.000000
ITER 8: row=3, varin=42, theta=0.500000, up=999999999999999983222784.000000
ITER 9: row=38, varin=37, theta=0.333333, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 12 = 1 gives z=28742007.059985
  % 	x12 = 1,	Z1 = 28742007.0599851        
DEBUG EVAL: First branch cutoff check: z=28742007.059985, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 0
ITER 1: row=35, varin=41, theta=0.500000, up=999999999999999983222784.000000
  % 	x12 = 0,	Z0 = 28665361.8980121        
DEBUG EVAL: Second branch cutoff check: z=28665361.898012, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 23 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=37, varin=44, theta=0.333333, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 23 = 0 gives z=28663365.732016
  % 	x23 = 0,	Z0 = 28663365.7320163        
DEBUG EVAL: First branch cutoff check: z=28663365.732016, best_z=INF, threshold=INF
  % Best branch is x7, Z0 = 28665518.8439559        , Z1 = 28792779.7974747        

DEBUG CAREFUL: Final result - returning best.var = 7
DEBUG BB: Branching variable chosen: j=7
 % @NC   31   29	x7 = 0	28665518.843956
 % @NC   32   29	x7 = 1	28792779.797475
 %      29    15 28662343.1338               28665518.8440    x8 D    27     7
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5571bedd96e0
% @LO 0.02  28.66234313379725406890 99.9000000000
% @LN 0.02  28.66551884395586569099 99.9000000000
% Resuming node 31 at  28.66551884395586569099
DEBUG CONSTRNT: LP rows=44, pool->nlprows=44, pool->npend=0
DEBUG CONSTRNT: Checking 44 LP rows (pool tracks 44, total LP rows 44)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 162
DEBUG CONSTRNT: Pool row 162 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=43, expected 43
 % @PAP adding 44 rows, 194 nz to LP
DEBUG BB: Processing node 31, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=18, theta=0.333333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28665518.843956
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.666667
DEBUG SOLUTION: lp->best_solution[7] = 0.666667
DEBUG SOLUTION: lp->best_solution[8] = 3.333333
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.666667
DEBUG SOLUTION: lp->best_solution[12] = 0.666667
DEBUG SOLUTION: lp->best_solution[13] = 0.666667
DEBUG SOLUTION: lp->best_solution[14] = 4.000000
  % @PL 44 rows, 60 cols, 254 nonzeros, 9 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=49, theta=0.375000, up=1.000000
ITER 2: row=20, varin=56, theta=0.333333, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28671790.645976
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 4.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 5.000000
  % @PL 46 rows, 60 cols, 260 nonzeros, 0 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 19 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=28, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=33, varin=42, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=48, varin=38, theta=0.062500, up=999999999999999983222784.000000
ITER 4: row=49, varin=69, theta=0.250000, up=1.000000
ITER 5: row=50, varin=47, theta=0.066667, up=999999999999999983222784.000000
ITER 6: row=35, varin=19, theta=0.004739, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28682590.414948
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 4.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 5.000000
  % @PL 50 rows, 60 cols, 279 nonzeros, 4 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 10 rows, 54 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=69, theta=0.708661, up=1.000000
ITER 2: row=48, varin=28, theta=0.027559, up=999999999999999983222784.000000
ITER 3: row=47, varin=2, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 28687940.406237
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 0.500000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.500000
DEBUG SOLUTION: lp->best_solution[7] = 0.500000
DEBUG SOLUTION: lp->best_solution[8] = 3.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.500000
DEBUG SOLUTION: lp->best_solution[12] = 0.500000
DEBUG SOLUTION: lp->best_solution[13] = 0.500000
DEBUG SOLUTION: lp->best_solution[14] = 3.500000
  % @PL 56 rows, 60 cols, 325 nonzeros, 11 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 11 slack rows
  % Node 31 LP 1 Solution, length = 28687940.406237, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.500000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.500000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 2 fractional variables
DEBUG CG: LP optimal, z=28687940.406237, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 31 at  28.68794040623652108479
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5571bedda990
% @LO 0.02  28.66551884395586569099 99.9000000000
% @LN 0.02  28.67364154390771346925 99.9000000000
% Resuming node 25 at  28.67364154390771346925
DEBUG CONSTRNT: LP rows=45, pool->nlprows=45, pool->npend=0
DEBUG CONSTRNT: Checking 45 LP rows (pool tracks 45, total LP rows 45)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 162
DEBUG CONSTRNT: Pool row 162 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 85
DEBUG CONSTRNT: Pool row 85 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 73
DEBUG CONSTRNT: Pool row 73 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=44, expected 44
 % @PAP adding 49 rows, 179 nz to LP
DEBUG BB: Processing node 25, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=26, varin=28, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=38, varin=106, theta=0.312500, up=1.000000
ITER 3: row=11, varin=61, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28673641.543908
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 239 nonzeros, 0 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 34 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=23, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=55, varin=79, theta=2.000000, up=1.000000
ITER 3: row=55, varin=27, theta=0.041667, up=999999999999999983222784.000000
ITER 4: row=41, varin=79, theta=1.000000, up=1.000000
ITER 5: row=53, varin=47, theta=0.027027, up=999999999999999983222784.000000
ITER 6: row=48, varin=53, theta=0.307692, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 28691200.164643
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 55 rows, 60 cols, 273 nonzeros, 7 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 7 slack rows
  % @PAP adding 5 rows, 19 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=58, theta=0.315789, up=1.000000
ITER 2: row=50, varin=48, theta=1.400000, up=999999999999999983222784.000000
ITER 3: row=51, varin=24, theta=0.024390, up=999999999999999983222784.000000
ITER 4: row=49, varin=58, theta=0.312500, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28714962.684103
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 53 rows, 60 cols, 263 nonzeros, 3 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=48, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28743920.483660
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 53 rows, 60 cols, 251 nonzeros, 1 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 25 LP 1 Solution, length = 28743920.483660, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.125000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.125000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.125000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.125000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.125000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.125000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.125000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.125000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.875000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.875000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.875000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.875000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.875000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.875000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.875000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.875000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.875000 (terminal 19)
 % 8 fractional variables
DEBUG CG: LP optimal, z=28743920.483660, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 25 at  28.74392048365960405931
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5571bedda810
% @LO 0.02  28.67364154390771346925 99.9000000000
% @LN 0.02  28.68069764541023047855 99.9000000000
% Resuming node 24 at  28.68069764541023047855
DEBUG CONSTRNT: LP rows=52, pool->nlprows=52, pool->npend=0
DEBUG CONSTRNT: Checking 52 LP rows (pool tracks 52, total LP rows 52)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=51, expected 51
 % @PAP adding 57 rows, 223 nz to LP
DEBUG BB: Processing node 24, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=17, theta=0.800000, up=999999999999999983222784.000000
ITER 2: row=11, varin=52, theta=0.207847, up=999999999999999983222784.000000
ITER 3: row=48, varin=55, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=55, varin=22, theta=0.302859, up=999999999999999983222784.000000
ITER 5: row=8, varin=8, theta=0.363636, up=999999999999999983222784.000000
ITER 6: row=2, varin=54, theta=0.444444, up=999999999999999983222784.000000
ITER 7: row=46, varin=7, theta=0.428571, up=999999999999999983222784.000000
ITER 8: row=1, varin=47, theta=0.331529, up=999999999999999983222784.000000
ITER 9: row=47, varin=44, theta=1.000000, up=999999999999999983222784.000000
ITER 10: row=43, varin=34, theta=0.543689, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=11)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 28680697.645410
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 57 rows, 60 cols, 283 nonzeros, 1 slack, 56 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 44 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=59, varin=43, theta=3.544698, up=999999999999999983222784.000000
ITER 2: row=44, varin=83, theta=0.833435, up=1.000000
ITER 3: row=55, varin=62, theta=1.112972, up=1.000000
ITER 4: row=55, varin=61, theta=0.259093, up=1.000000
ITER 5: row=22, varin=62, theta=1.000000, up=1.000000
ITER 6: row=13, varin=81, theta=0.773292, up=1.000000
ITER 7: row=59, varin=63, theta=2.110417, up=1.000000
ITER 8: row=59, varin=82, theta=0.509458, up=1.000000
ITER 9: row=1, varin=63, theta=0.874284, up=1.000000
LP PHASE: Switching to primal (iter=9)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=59)
DEBUG SOLUTION: LP solution array indices: FST[60-99], not_covered[100-119]
DEBUG SOLUTION: lp->best_solution[0] = 29132291.065170
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 59 rows, 60 cols, 327 nonzeros, 7 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 7 slack rows
  % @PAP adding 6 rows, 19 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=55, varin=64, theta=1.295151, up=1.000000
ITER 2: row=55, varin=87, theta=0.228027, up=1.000000
ITER 3: row=54, varin=64, theta=1.000491, up=1.000000
ITER 4: row=54, varin=55, theta=0.000772, up=999999999999999983222784.000000
ITER 5: row=55, varin=38, theta=0.000353, up=999999999999999983222784.000000
ITER 6: row=21, varin=31, theta=0.000318, up=999999999999999983222784.000000
ITER 7: row=31, varin=65, theta=0.000531, up=1.000000
ITER 8: row=29, varin=13, theta=0.000886, up=999999999999999983222784.000000
ITER 9: row=13, varin=87, theta=0.004913, up=1.000000
LP PHASE: Switching to primal (iter=9)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=58)
DEBUG SOLUTION: LP solution array indices: FST[59-98], not_covered[99-118]
DEBUG SOLUTION: lp->best_solution[0] = 29177820.555981
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 58 rows, 60 cols, 332 nonzeros, 3 slack, 55 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 2 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=57, varin=59, theta=0.179502, up=1.000000
ITER 2: row=56, varin=85, theta=1.429356, up=1.000000
ITER 3: row=56, varin=29, theta=1.120288, up=999999999999999983222784.000000
ITER 4: row=29, varin=89, theta=2.256130, up=1.000000
ITER 5: row=29, varin=87, theta=13.759539, up=1.000000
ITER 6: row=29, varin=84, theta=38.035822, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 57 rows, 60 cols, 331 nonzeros, 11 slack, 46 tight.
  % Node 24 LP 1 Solution, length = 999999999999999983222784.000000, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 1.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.006551 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.995087 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.998362 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 24 is INFEASIBLE
 %      24    14    infeasible               28684128.7946    x7 U    11     5
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5571bedc5ef0
% @LO 0.02  28.68069764541023047855 99.9000000000
% @LN 0.02  28.68412879459254583026 99.9000000000
% Resuming node 23 at  28.68412879459254583026
DEBUG CONSTRNT: LP rows=57, pool->nlprows=57, pool->npend=0
DEBUG CONSTRNT: Checking 57 LP rows (pool tracks 57, total LP rows 57)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=56, expected 56
 % @PAP adding 49 rows, 179 nz to LP
DEBUG BB: Processing node 23, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 23 LP 2 Solution, length = 28684128.794593, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.166667 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.166667 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.166667 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.166667 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 1.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.166667 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.166667 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.833333 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.833333 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.833333 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.833333 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.833333 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.833333 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.833333 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.833333 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28684128.794593, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28684128.794593, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 23 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 23
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.166667
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.166667
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.166667
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.166667
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=1.000000
DEBUG CAREFUL: Skipping var 14: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.166667
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.166667
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
DEBUG CAREFUL: Testing fvar[1] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
DEBUG CAREFUL: Testing fvar[2] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[3] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[4] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[5] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 5
  % Initial guess is x3, Z0 = 28684128.7945925        , Z1 = 28786804.2352014        

DEBUG EVAL: Testing var 17 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=26, varin=28, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=38, varin=106, theta=0.312500, up=1.000000
ITER 3: row=11, varin=61, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 17 = 0 gives z=28720941.569086
  % 	x17 = 0,	Z0 = 28720941.5690858        
DEBUG EVAL: First branch cutoff check: z=28720941.569086, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 1
ITER 1: row=26, varin=73, theta=4.545455, up=1.000000
ITER 2: row=26, varin=49, theta=3.900000, up=999999999999999983222784.000000
ITER 3: row=1, varin=40, theta=1.450000, up=999999999999999983222784.000000
ITER 4: row=10, varin=73, theta=1.000000, up=1.000000
ITER 5: row=37, varin=21, theta=0.666667, up=999999999999999983222784.000000
ITER 6: row=21, varin=45, theta=1.000000, up=999999999999999983222784.000000
  % 	x17 = 1,	Z1 = 28948151.2419279        
DEBUG EVAL: Second branch cutoff check: z=28948151.241928, best_z=INF, threshold=INF
  %   New best:  x17, Z = 28720941.5690858        
DEBUG EVAL: Testing var 18 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=39, varin=73, theta=4.545455, up=1.000000
ITER 2: row=39, varin=28, theta=1.300000, up=999999999999999983222784.000000
ITER 3: row=10, varin=73, theta=1.000000, up=1.000000
ITER 4: row=38, varin=49, theta=5.000000, up=999999999999999983222784.000000
ITER 5: row=1, varin=40, theta=2.000000, up=999999999999999983222784.000000
ITER 6: row=37, varin=21, theta=0.666667, up=999999999999999983222784.000000
ITER 7: row=21, varin=45, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 18 = 1 gives z=28948151.241928
  % 	x18 = 1,	Z1 = 28948151.2419279        
DEBUG EVAL: First branch cutoff check: z=28948151.241928, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 18 = 0
ITER 1: row=39, varin=106, theta=0.312500, up=1.000000
ITER 2: row=11, varin=61, theta=0.500000, up=1.000000
  % 	x18 = 0,	Z0 = 28720941.5690858        
DEBUG EVAL: Second branch cutoff check: z=28720941.569086, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 9 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=40, varin=73, theta=4.545455, up=1.000000
ITER 2: row=40, varin=28, theta=1.300000, up=999999999999999983222784.000000
ITER 3: row=10, varin=73, theta=1.000000, up=1.000000
ITER 4: row=38, varin=49, theta=5.000000, up=999999999999999983222784.000000
ITER 5: row=1, varin=44, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 9 = 1 gives z=28882256.197550
  % 	x9 = 1,	Z1 = 28882256.1975503        
DEBUG EVAL: First branch cutoff check: z=28882256.197550, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 0
ITER 1: row=40, varin=106, theta=0.312500, up=1.000000
ITER 2: row=11, varin=40, theta=0.250000, up=999999999999999983222784.000000
  % 	x9 = 0,	Z0 = 28703063.472841         
DEBUG EVAL: Second branch cutoff check: z=28703063.472841, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=20, varin=73, theta=4.545455, up=1.000000
ITER 2: row=20, varin=49, theta=3.900000, up=999999999999999983222784.000000
ITER 3: row=1, varin=47, theta=0.725000, up=999999999999999983222784.000000
ITER 4: row=10, varin=73, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 3 = 1 gives z=28786804.235201
  % 	x3 = 1,	Z1 = 28786804.2352014        
DEBUG EVAL: First branch cutoff check: z=28786804.235201, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=20, varin=28, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=38, varin=106, theta=0.312500, up=1.000000
ITER 3: row=11, varin=61, theta=0.500000, up=1.000000
  % 	x3 = 0,	Z0 = 28720941.5690858        
DEBUG EVAL: Second branch cutoff check: z=28720941.569086, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=49, theta=0.200000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28687547.406392
  % 	x2 = 0,	Z0 = 28687547.4063923        
DEBUG EVAL: First branch cutoff check: z=28687547.406392, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 5 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=37, varin=106, theta=0.312500, up=1.000000
ITER 2: row=11, varin=46, theta=0.200000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 5 = 0 gives z=28699307.413829
  % 	x5 = 0,	Z0 = 28699307.4138288        
DEBUG EVAL: First branch cutoff check: z=28699307.413829, best_z=INF, threshold=INF
  % Best branch is x17, Z0 = 28720941.5690858        , Z1 = 28948151.2419279        

DEBUG CAREFUL: Final result - returning best.var = 17
DEBUG BB: Branching variable chosen: j=17
 % @NC   33   23	x17 = 0	28720941.569086
 % @NC   34   23	x17 = 1	28948151.241928
 %      23    15 28684128.7946               28687940.4062    x7 D    11     5
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5571bedd96e0
% @LO 0.02  28.68412879459254583026 99.9000000000
% @LN 0.02  28.68794040623652108479 99.9000000000
% Resuming node 31 at  28.68794040623652108479
DEBUG CONSTRNT: LP rows=49, pool->nlprows=49, pool->npend=0
DEBUG CONSTRNT: Checking 49 LP rows (pool tracks 49, total LP rows 49)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=48, expected 48
 % @PAP adding 45 rows, 233 nz to LP
DEBUG BB: Processing node 31, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 31 LP 2 Solution, length = 28687940.406237, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.500000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.500000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 2 fractional variables
DEBUG CG: LP optimal, z=28687940.406237, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28687940.406237, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 31 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 31
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.500000
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.500000
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 2 fractional variables

  %  Carefully choosing branching variable, nfrac = 2
DEBUG CAREFUL: Testing fvar[0] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 0
DEBUG CAREFUL: New best var: 0
DEBUG CAREFUL: Testing fvar[1] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
  % Initial guess is x0, Z0 = 28687940.4062365        , Z1 = 28687940.4062365        

DEBUG EVAL: Testing var 0 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=12, theta=0.755299, up=999999999999999983222784.000000
ITER 2: row=41, varin=35, theta=0.148936, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 0 = 0 gives z=28691128.483864
  % 	x0 = 0,	Z0 = 28691128.4838639        
DEBUG EVAL: First branch cutoff check: z=28691128.483864, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 0 = 1
ITER 1: row=1, varin=36, theta=0.192913, up=999999999999999983222784.000000
ITER 2: row=39, varin=40, theta=0.424804, up=999999999999999983222784.000000
ITER 3: row=29, varin=20, theta=0.846181, up=999999999999999983222784.000000
ITER 4: row=45, varin=31, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=30, varin=34, theta=2.220132, up=999999999999999983222784.000000
ITER 6: row=27, varin=28, theta=0.894150, up=999999999999999983222784.000000
ITER 7: row=24, varin=29, theta=1.582255, up=999999999999999983222784.000000
ITER 8: row=31, varin=9, theta=1.927928, up=999999999999999983222784.000000
ITER 9: row=4, varin=22, theta=1.320988, up=999999999999999983222784.000000
ITER 10: row=43, varin=4, theta=1.757212, up=999999999999999983222784.000000
  % 	x0 = 1,	Z1 = 28853970.1949673        
DEBUG EVAL: Second branch cutoff check: z=28853970.194967, best_z=INF, threshold=INF
  %   New best:  x0, Z = 28691128.4838639        
DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=12, theta=0.755299, up=999999999999999983222784.000000
ITER 2: row=41, varin=35, theta=0.148936, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 0 gives z=28691128.483864
  % 	x1 = 0,	Z0 = 28691128.4838639        
DEBUG EVAL: First branch cutoff check: z=28691128.483864, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 1
ITER 1: row=3, varin=36, theta=0.192913, up=999999999999999983222784.000000
ITER 2: row=39, varin=40, theta=0.424804, up=999999999999999983222784.000000
ITER 3: row=29, varin=20, theta=0.846181, up=999999999999999983222784.000000
ITER 4: row=45, varin=3, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=6, varin=31, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=36, varin=34, theta=2.220132, up=999999999999999983222784.000000
ITER 7: row=27, varin=28, theta=0.894150, up=999999999999999983222784.000000
ITER 8: row=24, varin=29, theta=1.582255, up=999999999999999983222784.000000
ITER 9: row=31, varin=9, theta=1.927928, up=999999999999999983222784.000000
ITER 10: row=4, varin=22, theta=1.320988, up=999999999999999983222784.000000
  % 	x1 = 1,	Z1 = 28869868.8066344        
DEBUG EVAL: Second branch cutoff check: z=28869868.806634, best_z=INF, threshold=INF
  %   New best:  x1, Z = 28691128.4838639        
  % Best branch is x1, Z0 = 28691128.4838639        , Z1 = 28869868.8066344        

DEBUG CAREFUL: Final result - returning best.var = 1
DEBUG BB: Branching variable chosen: j=1
 % @NC   35   31	x1 = 0	28691128.483864
 % @NC   36   31	x1 = 1	28869868.806634
 %      31    16 28687940.4062               28691128.4839    x7 D    29     8
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5571bedc5ef0
% @LO 0.03  28.68794040623652108479 99.9000000000
% @LN 0.03  28.69112848386388492372 99.9000000000
% Resuming node 35 at  28.69112848386388492372
DEBUG CONSTRNT: LP rows=45, pool->nlprows=45, pool->npend=0
DEBUG CONSTRNT: Checking 45 LP rows (pool tracks 45, total LP rows 45)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 162
DEBUG CONSTRNT: Pool row 162 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 85
DEBUG CONSTRNT: Pool row 85 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 73
DEBUG CONSTRNT: Pool row 73 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=44, expected 44
 % @PAP adding 45 rows, 233 nz to LP
DEBUG BB: Processing node 35, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=3, varin=12, theta=0.755299, up=999999999999999983222784.000000
ITER 2: row=41, varin=35, theta=0.148936, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28691128.483864
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 0.950355
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.950355
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.652482
DEBUG SOLUTION: lp->best_solution[11] = 0.652482
DEBUG SOLUTION: lp->best_solution[12] = 2.304965
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 293 nonzeros, 12 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 12 slack rows
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=34, varin=42, theta=0.333333, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=35)
DEBUG SOLUTION: LP solution array indices: FST[36-75], not_covered[76-95]
DEBUG SOLUTION: lp->best_solution[0] = 28691975.540215
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 35 rows, 60 cols, 241 nonzeros, 0 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 21 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=37, varin=26, theta=0.250000, up=999999999999999983222784.000000
ITER 2: row=38, varin=29, theta=0.750000, up=999999999999999983222784.000000
ITER 3: row=35, varin=50, theta=0.400000, up=1.000000
ITER 4: row=8, varin=37, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 28698661.959608
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 39 rows, 60 cols, 262 nonzeros, 4 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % Node 35 LP 1 Solution, length = 28698661.959608, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.111111 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.111111 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.111111 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.333333 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.111111 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.111111 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.111111 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.888889 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.888889 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.888889 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.888889 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.666667 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.888889 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.888889 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.888889 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.888889 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.888889 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.666667 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.666667 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.888889 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=28698661.959608, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.03  28.69112848386388492372 99.9000000000
 % @LN 0.03  28.69866195960809918120 99.9000000000
DEBUG CG: Second cutoff check: z=28698661.959608, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 35 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 35
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.111111
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.111111)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.111111
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.111111)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.111111
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.111111)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.333333
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.111111
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.111111)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.111111
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.111111)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.111111
DEBUG CAREFUL: Adding var 23 to fractional list (xi=0.111111)
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 7 fractional variables

  %  Carefully choosing branching variable, nfrac = 7
DEBUG CAREFUL: Testing fvar[0] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
DEBUG CAREFUL: Testing fvar[1] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
DEBUG CAREFUL: Testing fvar[2] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
DEBUG CAREFUL: Testing fvar[3] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[4] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[5] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 5
DEBUG CAREFUL: Testing fvar[6] = var 23
DEBUG CAREFUL: Calling compare_branch_vars for var 23
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 23
  % Initial guess is x18, Z0 = 28698661.9596081        , Z1 = 28773925.5577038        

DEBUG EVAL: Testing var 17 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=12, varin=13, theta=0.125000, up=999999999999999983222784.000000
ITER 2: row=30, varin=39, theta=0.333333, up=1.000000
DEBUG EVAL: Branch var 17 = 0 gives z=28705964.331783
  % 	x17 = 0,	Z0 = 28705964.3317832        
DEBUG EVAL: First branch cutoff check: z=28705964.331783, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 1
ITER 1: row=12, varin=8, theta=1.600000, up=999999999999999983222784.000000
ITER 2: row=8, varin=27, theta=1.142857, up=999999999999999983222784.000000
ITER 3: row=17, varin=46, theta=1.000000, up=1.000000
ITER 4: row=19, varin=26, theta=0.428571, up=999999999999999983222784.000000
ITER 5: row=20, varin=2, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=2, varin=28, theta=0.500000, up=999999999999999983222784.000000
ITER 7: row=7, varin=24, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=23, varin=54, theta=3.000000, up=1.000000
ITER 9: row=23, varin=32, theta=2.000000, up=999999999999999983222784.000000
ITER 10: row=29, varin=39, theta=1.000000, up=1.000000
  % 	x17 = 1,	Z1 = 28855891.5524012        
DEBUG EVAL: Second branch cutoff check: z=28855891.552401, best_z=INF, threshold=INF
  %   New best:  x17, Z = 28705964.3317832        
DEBUG EVAL: Testing var 18 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=19, varin=8, theta=1.600000, up=999999999999999983222784.000000
ITER 2: row=8, varin=34, theta=2.666667, up=999999999999999983222784.000000
ITER 3: row=34, varin=32, theta=4.000000, up=999999999999999983222784.000000
ITER 4: row=29, varin=26, theta=1.500000, up=999999999999999983222784.000000
ITER 5: row=20, varin=2, theta=2.000000, up=999999999999999983222784.000000
ITER 6: row=2, varin=28, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=7, varin=13, theta=2.000000, up=999999999999999983222784.000000
ITER 8: row=30, varin=7, theta=0.666667, up=999999999999999983222784.000000
ITER 9: row=1, varin=24, theta=2.000000, up=999999999999999983222784.000000
ITER 10: row=23, varin=14, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 18 = 1 gives z=28950941.292529
  % 	x18 = 1,	Z1 = 28950941.2925293        
DEBUG EVAL: First branch cutoff check: z=28950941.292529, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 18 = 0
ITER 1: row=19, varin=39, theta=0.333333, up=1.000000
  % 	x18 = 0,	Z0 = 28705964.3317832        
DEBUG EVAL: Second branch cutoff check: z=28705964.331783, best_z=INF, threshold=INF
  %   New best:  x18, Z = 28705964.3317832        
DEBUG EVAL: Testing var 12 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=17, varin=39, theta=0.666667, up=1.000000
ITER 2: row=13, varin=2, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=4, varin=28, theta=0.250000, up=999999999999999983222784.000000
ITER 4: row=7, varin=26, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=4, varin=24, theta=0.500000, up=999999999999999983222784.000000
ITER 6: row=23, varin=12, theta=0.333333, up=999999999999999983222784.000000
ITER 7: row=7, varin=32, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=1, varin=8, theta=1.000000, up=999999999999999983222784.000000
ITER 9: row=8, varin=33, theta=0.500000, up=999999999999999983222784.000000
ITER 10: row=17, varin=19, theta=0.250000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 12 = 1 gives z=28808946.497675
  % 	x12 = 1,	Z1 = 28808946.4976747        
DEBUG EVAL: First branch cutoff check: z=28808946.497675, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 0
ITER 1: row=17, varin=8, theta=0.250000, up=999999999999999983222784.000000
ITER 2: row=8, varin=34, theta=0.333333, up=999999999999999983222784.000000
ITER 3: row=34, varin=33, theta=0.250000, up=999999999999999983222784.000000
  % 	x12 = 0,	Z0 = 28708139.629585         
DEBUG EVAL: Second branch cutoff check: z=28708139.629585, best_z=INF, threshold=INF
  %   New best:  x12, Z = 28708139.629585         
DEBUG EVAL: Testing var 9 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=20, varin=8, theta=1.600000, up=999999999999999983222784.000000
ITER 2: row=8, varin=29, theta=1.333333, up=999999999999999983222784.000000
ITER 3: row=17, varin=2, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=2, varin=28, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 9 = 1 gives z=28774020.499139
  % 	x9 = 1,	Z1 = 28774020.4991391        
DEBUG EVAL: First branch cutoff check: z=28774020.499139, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 0
ITER 1: row=20, varin=39, theta=0.333333, up=1.000000
  % 	x9 = 0,	Z0 = 28705964.3317832        
DEBUG EVAL: Second branch cutoff check: z=28705964.331783, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 2 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=8, theta=1.600000, up=999999999999999983222784.000000
ITER 2: row=8, varin=27, theta=1.142857, up=999999999999999983222784.000000
ITER 3: row=17, varin=46, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 2 = 1 gives z=28743954.402880
  % 	x2 = 1,	Z1 = 28743954.4028799        
DEBUG EVAL: First branch cutoff check: z=28743954.402880, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 0
ITER 1: row=1, varin=32, theta=0.142857, up=999999999999999983222784.000000
  % 	x2 = 0,	Z0 = 28701501.2657322        
DEBUG EVAL: Second branch cutoff check: z=28701501.265732, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 5 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=28, theta=0.142857, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 5 = 0 gives z=28704387.039652
  % 	x5 = 0,	Z0 = 28704387.0396518        
DEBUG EVAL: First branch cutoff check: z=28704387.039652, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 23 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=23, varin=24, theta=0.125000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 23 = 0 gives z=28703585.287167
  % 	x23 = 0,	Z0 = 28703585.2871666        
DEBUG EVAL: First branch cutoff check: z=28703585.287167, best_z=INF, threshold=INF
  % Best branch is x12, Z0 = 28708139.629585         , Z1 = 28808946.4976747        

DEBUG CAREFUL: Final result - returning best.var = 12
DEBUG BB: Branching variable chosen: j=12
 % @NC   37   35	x12 = 0	28708139.629585
 % @NC   38   35	x12 = 1	28808946.497675
 %      35    17 28698661.9596               28702711.3334    x1 D    31     9
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5571bedc10c0
% @LO 0.03  28.69866195960809918120 99.9000000000
% @LN 0.03  28.70271133340692415459 99.9000000000
% Resuming node 28 at  28.70271133340692415459
DEBUG CONSTRNT: LP rows=35, pool->nlprows=35, pool->npend=0
DEBUG CONSTRNT: Checking 35 LP rows (pool tracks 35, total LP rows 35)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 162
DEBUG CONSTRNT: Pool row 162 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=34, expected 34
 % @PAP adding 48 rows, 202 nz to LP
DEBUG BB: Processing node 28, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=2, varin=58, theta=0.714286, up=1.000000
ITER 2: row=5, varin=42, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=36, varin=46, theta=0.500000, up=999999999999999983222784.000000
ITER 4: row=39, varin=67, theta=1.000000, up=1.000000
ITER 5: row=2, varin=9, theta=0.153846, up=999999999999999983222784.000000
ITER 6: row=8, varin=5, theta=0.273973, up=999999999999999983222784.000000
ITER 7: row=4, varin=32, theta=0.500000, up=999999999999999983222784.000000
ITER 8: row=3, varin=43, theta=0.500000, up=999999999999999983222784.000000
ITER 9: row=37, varin=37, theta=0.333333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=9)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28702711.333407
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 4.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 5.000000
  % @PL 48 rows, 60 cols, 262 nonzeros, 1 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 8 rows, 42 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=3, theta=0.250000, up=999999999999999983222784.000000
ITER 2: row=53, varin=65, theta=0.500000, up=1.000000
ITER 3: row=51, varin=19, theta=0.111111, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 28733613.603449
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 4.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 5.000000
  % @PL 55 rows, 60 cols, 264 nonzeros, 2 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 5 rows, 29 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=54, varin=27, theta=0.081301, up=999999999999999983222784.000000
ITER 2: row=53, varin=61, theta=0.600000, up=1.000000
ITER 3: row=48, varin=28, theta=0.014856, up=999999999999999983222784.000000
ITER 4: row=19, varin=82, theta=1.000000, up=1.000000
ITER 5: row=41, varin=60, theta=0.638298, up=1.000000
ITER 6: row=10, varin=48, theta=2.126326, up=999999999999999983222784.000000
ITER 7: row=32, varin=65, theta=0.500000, up=1.000000
ITER 8: row=55, varin=37, theta=0.040323, up=999999999999999983222784.000000
ITER 9: row=57, varin=66, theta=0.011655, up=1.000000
ITER 10: row=44, varin=45, theta=0.040556, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=12)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=58)
DEBUG SOLUTION: LP solution array indices: FST[59-98], not_covered[99-118]
DEBUG SOLUTION: lp->best_solution[0] = 28755359.087381
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 4.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 5.000000
  % @PL 58 rows, 60 cols, 289 nonzeros, 4 slack, 54 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 5 rows, 23 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=55, varin=65, theta=0.133470, up=1.000000
ITER 2: row=57, varin=55, theta=0.179558, up=999999999999999983222784.000000
ITER 3: row=54, varin=52, theta=0.260000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=59)
DEBUG SOLUTION: LP solution array indices: FST[60-99], not_covered[100-119]
DEBUG SOLUTION: lp->best_solution[0] = 28774976.599871
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 4.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 5.000000
  % @PL 59 rows, 60 cols, 304 nonzeros, 5 slack, 54 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=55, varin=41, theta=0.305556, up=999999999999999983222784.000000
ITER 2: row=43, varin=60, theta=0.538462, up=1.000000
ITER 3: row=45, varin=30, theta=0.051752, up=999999999999999983222784.000000
ITER 4: row=49, varin=50, theta=0.436614, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 28784661.699624
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.937627
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 4.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 5.000000
  % @PL 56 rows, 60 cols, 282 nonzeros, 7 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 7 slack rows
  % @PAP adding 8 rows, 28 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=43, theta=0.230194, up=999999999999999983222784.000000
ITER 2: row=52, varin=7, theta=2.444444, up=999999999999999983222784.000000
ITER 3: row=8, varin=50, theta=0.598058, up=999999999999999983222784.000000
ITER 4: row=26, varin=40, theta=1.227092, up=999999999999999983222784.000000
ITER 5: row=56, varin=68, theta=0.290019, up=1.000000
ITER 6: row=21, varin=41, theta=0.513333, up=999999999999999983222784.000000
ITER 7: row=53, varin=44, theta=1.166667, up=999999999999999983222784.000000
ITER 8: row=57, varin=52, theta=0.090909, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 28810747.072285
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 4.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 5.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 57 rows, 60 cols, 288 nonzeros, 7 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 7 slack rows
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=26, theta=0.125000, up=999999999999999983222784.000000
ITER 2: row=41, varin=40, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28823011.612043
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 4.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 5.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 242 nonzeros, 1 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 28 LP 1 Solution, length = 28823011.612043, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.125000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.125000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.125000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.125000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.125000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.125000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.125000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.125000 (FST 23)
  % DEBUG LP_VARS: x[24] = 1.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.875000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.875000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.875000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.875000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.875000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.875000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.875000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.875000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.875000 (terminal 19)
 % 8 fractional variables
DEBUG CG: LP optimal, z=28823011.612043, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 28 at  28.82301161204294359663
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5571bedd96e0
% @LO 0.03  28.70271133340692415459 99.9000000000
% @LN 0.03  28.70813962958503395839 99.9000000000
% Resuming node 37 at  28.70813962958503395839
DEBUG CONSTRNT: LP rows=51, pool->nlprows=51, pool->npend=0
DEBUG CONSTRNT: Checking 51 LP rows (pool tracks 51, total LP rows 51)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 62
DEBUG CONSTRNT: Pool row 62 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=50, expected 50
 % @PAP adding 35 rows, 170 nz to LP
DEBUG BB: Processing node 37, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=17, varin=8, theta=0.250000, up=999999999999999983222784.000000
ITER 2: row=8, varin=34, theta=0.333333, up=999999999999999983222784.000000
ITER 3: row=34, varin=33, theta=0.250000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=35)
DEBUG SOLUTION: LP solution array indices: FST[36-75], not_covered[76-95]
DEBUG SOLUTION: lp->best_solution[0] = 28708139.629585
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 35 rows, 60 cols, 230 nonzeros, 1 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 16 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=44, theta=0.200000, up=1.000000
ITER 2: row=34, varin=48, theta=0.250000, up=1.000000
ITER 3: row=8, varin=21, theta=0.100000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 28714042.719611
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 37 rows, 60 cols, 246 nonzeros, 3 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % Node 37 LP 1 Solution, length = 28714042.719611, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.100000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.300000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.100000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.100000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.100000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.300000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.700000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.900000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.900000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.700000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.900000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.700000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.900000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.900000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.900000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.700000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.900000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28714042.719611, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.03  28.70813962958503395839 99.9000000000
 % @LN 0.03  28.71404271961100462818 99.9000000000
DEBUG CG: Second cutoff check: z=28714042.719611, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 37 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 37
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.100000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.100000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.300000
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.300000)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.100000
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.100000)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.100000
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.100000)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.100000
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.100000)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.300000
DEBUG CAREFUL: Adding var 23 to fractional list (xi=0.300000)
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
DEBUG CAREFUL: Testing fvar[1] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
DEBUG CAREFUL: Testing fvar[2] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[3] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[4] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 5
DEBUG CAREFUL: Testing fvar[5] = var 23
DEBUG CAREFUL: Calling compare_branch_vars for var 23
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 23
  % Initial guess is x18, Z0 = 28714042.719611         , Z1 = 28950941.2925293        

DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=12, varin=26, theta=1.125000, up=999999999999999983222784.000000
ITER 2: row=7, varin=25, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=20, varin=2, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=2, varin=23, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=22, varin=8, theta=2.000000, up=999999999999999983222784.000000
ITER 6: row=8, varin=31, theta=2.000000, up=999999999999999983222784.000000
ITER 7: row=1, varin=19, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 1 gives z=28855891.552401
  % 	x17 = 1,	Z1 = 28855891.5524012        
DEBUG EVAL: First branch cutoff check: z=28855891.552401, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 0
ITER 1: row=12, varin=38, theta=0.200000, up=1.000000
  % 	x17 = 0,	Z0 = 28718207.6548762        
DEBUG EVAL: Second branch cutoff check: z=28718207.654876, best_z=INF, threshold=INF
  %   New best:  x17, Z = 28718207.6548762        
DEBUG EVAL: Testing var 18 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=19, varin=8, theta=1.125000, up=999999999999999983222784.000000
ITER 2: row=8, varin=25, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=20, varin=32, theta=1.200000, up=999999999999999983222784.000000
ITER 4: row=32, varin=31, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=1, varin=21, theta=3.000000, up=999999999999999983222784.000000
ITER 6: row=7, varin=2, theta=2.000000, up=999999999999999983222784.000000
ITER 7: row=2, varin=13, theta=2.000000, up=999999999999999983222784.000000
ITER 8: row=29, varin=14, theta=1.000000, up=999999999999999983222784.000000
ITER 9: row=30, varin=15, theta=0.666667, up=999999999999999983222784.000000
ITER 10: row=21, varin=23, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 18 = 1 gives z=28950941.292529
  % 	x18 = 1,	Z1 = 28950941.2925293        
DEBUG EVAL: First branch cutoff check: z=28950941.292529, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 18 = 0
ITER 1: row=19, varin=26, theta=0.500000, up=999999999999999983222784.000000
  % 	x18 = 0,	Z0 = 28715333.7992342        
DEBUG EVAL: Second branch cutoff check: z=28715333.799234, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 9 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=20, varin=8, theta=1.125000, up=999999999999999983222784.000000
ITER 2: row=8, varin=32, theta=1.800000, up=999999999999999983222784.000000
ITER 3: row=32, varin=28, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 9 = 1 gives z=28774020.499139
  % 	x9 = 1,	Z1 = 28774020.4991391        
DEBUG EVAL: First branch cutoff check: z=28774020.499139, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 0
ITER 1: row=20, varin=26, theta=0.500000, up=999999999999999983222784.000000
  % 	x9 = 0,	Z0 = 28715333.7992342        
DEBUG EVAL: Second branch cutoff check: z=28715333.799234, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 2 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=26, theta=1.125000, up=999999999999999983222784.000000
ITER 2: row=7, varin=25, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=20, varin=2, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=2, varin=13, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 1 gives z=28756773.056953
  % 	x2 = 1,	Z1 = 28756773.056953         
DEBUG EVAL: First branch cutoff check: z=28756773.056953, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 0
ITER 1: row=1, varin=31, theta=0.142857, up=999999999999999983222784.000000
  % 	x2 = 0,	Z0 = 28718057.9686067        
DEBUG EVAL: Second branch cutoff check: z=28718057.968607, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 5 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=26, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 5 = 0 gives z=28715333.799234
  % 	x5 = 0,	Z0 = 28715333.7992342        
DEBUG EVAL: First branch cutoff check: z=28715333.799234, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 23 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=22, varin=26, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 23 = 0 gives z=28715333.799234
  % 	x23 = 0,	Z0 = 28715333.7992342        
DEBUG EVAL: First branch cutoff check: z=28715333.799234, best_z=INF, threshold=INF
  % Best branch is x17, Z0 = 28718207.6548762        , Z1 = 28855891.5524012        

DEBUG CAREFUL: Final result - returning best.var = 17
DEBUG BB: Branching variable chosen: j=17
 % @NC   39   37	x17 = 0	28718207.654876
 % @NC   40   37	x17 = 1	28855891.552401
 %      37    18 28714042.7196               28714663.7460   x12 D    35    10
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5571bedd9330
% @LO 0.03  28.71404271961100462818 99.9000000000
% @LN 0.03  28.71466374604197824283 99.9000000000
% Resuming node 21 at  28.71466374604197824283
DEBUG CONSTRNT: LP rows=34, pool->nlprows=34, pool->npend=0
DEBUG CONSTRNT: Checking 34 LP rows (pool tracks 34, total LP rows 34)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 162
DEBUG CONSTRNT: Pool row 162 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=33, expected 33
 % @PAP adding 48 rows, 181 nz to LP
DEBUG BB: Processing node 21, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 21 LP 2 Solution, length = 28714663.746042, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.500000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.500000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28714663.746042, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28714663.746042, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 21 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 21
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.500000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.500000
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.500000
DEBUG CAREFUL: Adding var 31 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 3 fractional variables

  %  Carefully choosing branching variable, nfrac = 3
DEBUG CAREFUL: Testing fvar[0] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 2
DEBUG CAREFUL: New best var: 2
DEBUG CAREFUL: Testing fvar[1] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 27
DEBUG CAREFUL: New best var: 27
DEBUG CAREFUL: Testing fvar[2] = var 31
DEBUG CAREFUL: Calling compare_branch_vars for var 31
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 31
  % Initial guess is x27, Z0 = 28714663.746042         , Z1 = 28804707.5590403        

DEBUG EVAL: Testing var 2 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=8, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=45, varin=44, theta=0.666667, up=999999999999999983222784.000000
ITER 3: row=40, varin=47, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 1 gives z=28804707.559040
  % 	x2 = 1,	Z1 = 28804707.5590403        
DEBUG EVAL: First branch cutoff check: z=28804707.559040, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 0
ITER 1: row=6, varin=86, theta=0.800000, up=1.000000
  % 	x2 = 0,	Z0 = 28726974.6354895        
DEBUG EVAL: Second branch cutoff check: z=28726974.635489, best_z=INF, threshold=INF
  %   New best:  x2, Z = 28726974.6354895        
DEBUG EVAL: Testing var 27 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=38, varin=8, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=45, varin=44, theta=0.666667, up=999999999999999983222784.000000
ITER 3: row=40, varin=47, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 27 = 1 gives z=28804707.559040
  % 	x27 = 1,	Z1 = 28804707.5590403        
DEBUG EVAL: First branch cutoff check: z=28804707.559040, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 27 = 0
ITER 1: row=38, varin=86, theta=0.800000, up=1.000000
  % 	x27 = 0,	Z0 = 28726974.6354895        
DEBUG EVAL: Second branch cutoff check: z=28726974.635489, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 31 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=44, varin=86, theta=0.800000, up=1.000000
DEBUG EVAL: Branch var 31 = 0 gives z=28726974.635489
  % 	x31 = 0,	Z0 = 28726974.6354895        
DEBUG EVAL: First branch cutoff check: z=28726974.635489, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 31 = 1
ITER 1: row=44, varin=8, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=45, varin=44, theta=0.666667, up=999999999999999983222784.000000
ITER 3: row=40, varin=62, theta=1.000000, up=1.000000
ITER 4: row=18, varin=48, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=1, varin=41, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=41, varin=40, theta=1.000000, up=999999999999999983222784.000000
  % 	x31 = 1,	Z1 = 28881392.9899966        
DEBUG EVAL: Second branch cutoff check: z=28881392.989997, best_z=INF, threshold=INF
  %   New best:  x31, Z = 28726974.6354895        
  % Best branch is x31, Z0 = 28726974.6354895        , Z1 = 28881392.9899966        

DEBUG CAREFUL: Final result - returning best.var = 31
DEBUG BB: Branching variable chosen: j=31
 % @NC   41   21	x31 = 0	28726974.635489
 % @NC   42   21	x31 = 1	28881392.989997
 %      21    19 28714663.7460               28718207.6549    x4 D    17     6
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5571bedc5ef0
% @LO 0.03  28.71466374604197824283 99.9000000000
% @LN 0.03  28.71820765487622395540 99.9000000000
% Resuming node 39 at  28.71820765487622395540
DEBUG CONSTRNT: LP rows=48, pool->nlprows=48, pool->npend=0
DEBUG CONSTRNT: Checking 48 LP rows (pool tracks 48, total LP rows 48)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=47, expected 47
 % @PAP adding 34 rows, 168 nz to LP
DEBUG BB: Processing node 39, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=12, varin=38, theta=0.200000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=34)
DEBUG SOLUTION: LP solution array indices: FST[35-74], not_covered[75-94]
DEBUG SOLUTION: lp->best_solution[0] = 28718207.654876
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 34 rows, 60 cols, 228 nonzeros, 0 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 31 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=35, varin=13, theta=0.111111, up=999999999999999983222784.000000
ITER 2: row=40, varin=35, theta=0.250000, up=999999999999999983222784.000000
ITER 3: row=1, varin=14, theta=0.016393, up=999999999999999983222784.000000
ITER 4: row=30, varin=44, theta=0.212121, up=1.000000
ITER 5: row=38, varin=26, theta=0.025830, up=999999999999999983222784.000000
ITER 6: row=36, varin=10, theta=0.333333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28722722.201077
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.666667
DEBUG SOLUTION: lp->best_solution[10] = 1.666667
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 259 nonzeros, 2 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 4 rows, 20 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=10, theta=0.036988, up=999999999999999983222784.000000
ITER 2: row=35, varin=13, theta=0.105452, up=999999999999999983222784.000000
ITER 3: row=24, varin=36, theta=0.425676, up=999999999999999983222784.000000
ITER 4: row=33, varin=35, theta=0.102941, up=999999999999999983222784.000000
ITER 5: row=27, varin=14, theta=0.333333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28730607.846922
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.666667
  % @PL 42 rows, 60 cols, 274 nonzeros, 2 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 2 rows, 16 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=25, theta=0.142857, up=999999999999999983222784.000000
ITER 2: row=39, varin=36, theta=0.545455, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28737456.916434
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.909091
DEBUG SOLUTION: lp->best_solution[12] = 0.909091
DEBUG SOLUTION: lp->best_solution[13] = 0.909091
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 282 nonzeros, 10 slack, 32 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 10 slack rows
  % Node 39 LP 1 Solution, length = 28737456.916434, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.090909 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.272727 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.090909 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.090909 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.090909 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.090909 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.272727 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.727273 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.909091 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.727273 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.909091 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.909091 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.727273 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.909091 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.909091 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.909091 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.909091 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.727273 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.909091 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=28737456.916434, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 39 at  28.73745691643372879298
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5571bedda810
% @LO 0.03  28.71820765487622395540 99.9000000000
% @LN 0.03  28.72094156908579876131 99.9000000000
% Resuming node 33 at  28.72094156908579876131
DEBUG CONSTRNT: LP rows=32, pool->nlprows=32, pool->npend=0
DEBUG CONSTRNT: Checking 32 LP rows (pool tracks 32, total LP rows 32)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 162
DEBUG CONSTRNT: Pool row 162 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 60
DEBUG CONSTRNT: Pool row 60 has lprow=31, expected 31
 % @PAP adding 49 rows, 179 nz to LP
DEBUG BB: Processing node 33, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=26, varin=28, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=38, varin=106, theta=0.312500, up=1.000000
ITER 3: row=11, varin=61, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28720941.569086
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 239 nonzeros, 0 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 34 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=23, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=55, varin=79, theta=2.000000, up=1.000000
ITER 3: row=55, varin=27, theta=0.041667, up=999999999999999983222784.000000
ITER 4: row=41, varin=79, theta=1.000000, up=1.000000
ITER 5: row=53, varin=47, theta=0.027027, up=999999999999999983222784.000000
ITER 6: row=48, varin=53, theta=0.307692, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 28738500.189821
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 55 rows, 60 cols, 273 nonzeros, 7 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 7 slack rows
  % @PAP adding 5 rows, 19 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=58, theta=0.315789, up=1.000000
ITER 2: row=50, varin=48, theta=1.400000, up=999999999999999983222784.000000
ITER 3: row=51, varin=24, theta=0.024390, up=999999999999999983222784.000000
ITER 4: row=49, varin=58, theta=0.312500, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28762262.709281
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 53 rows, 60 cols, 263 nonzeros, 3 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=48, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28791220.508838
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 4.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 53 rows, 60 cols, 251 nonzeros, 1 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 33 LP 1 Solution, length = 28791220.508838, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.125000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.125000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.125000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.125000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.125000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.125000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.125000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 1.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.125000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.875000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.875000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.875000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.875000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.875000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.875000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.875000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.875000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.875000 (terminal 19)
 % 8 fractional variables
DEBUG CG: LP optimal, z=28791220.508838, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 33 at  28.79122050883768935137
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5571bedd96e0
% @LO 0.03  28.72094156908579876131 99.9000000000
% @LN 0.03  28.72697463548945506773 99.9000000000
% Resuming node 41 at  28.72697463548945506773
DEBUG CONSTRNT: LP rows=52, pool->nlprows=52, pool->npend=0
DEBUG CONSTRNT: Checking 52 LP rows (pool tracks 52, total LP rows 52)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=51, expected 51
 % @PAP adding 48 rows, 181 nz to LP
DEBUG BB: Processing node 41, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=86, theta=0.800000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28726974.635489
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 241 nonzeros, 1 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 5 rows, 18 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=53, varin=31, theta=0.115385, up=999999999999999983222784.000000
ITER 2: row=52, varin=53, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=49, varin=52, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28729480.666775
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 53 rows, 60 cols, 259 nonzeros, 6 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 3 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=4, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=31, varin=45, theta=0.111111, up=999999999999999983222784.000000
ITER 3: row=48, varin=50, theta=2.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28754556.297530
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 253 nonzeros, 2 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 41 LP 1 Solution, length = 28754556.297530, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.333333 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.333333 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.333333 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.333333 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.333333 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.666667 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.666667 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.666667 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.666667 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.666667 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28754556.297530, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 41 at  28.75455629752977060321
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5571bedc5ef0
% @LO 0.03  28.72697463548945506773 99.9000000000
% @LN 0.03  28.73745691643372879298 99.9000000000
% Resuming node 39 at  28.73745691643372879298
DEBUG CONSTRNT: LP rows=48, pool->nlprows=48, pool->npend=0
DEBUG CONSTRNT: Checking 48 LP rows (pool tracks 48, total LP rows 48)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=47, expected 47
 % @PAP adding 32 rows, 164 nz to LP
DEBUG BB: Processing node 39, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 39 LP 2 Solution, length = 28737456.916434, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.090909 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.272727 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.090909 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.090909 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.090909 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.090909 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.272727 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.727273 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.909091 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.727273 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.909091 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.909091 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.727273 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.909091 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.909091 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.909091 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.909091 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.727273 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.909091 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=28737456.916434, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28737456.916434, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 39 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 39
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.090909
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.090909)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.272727
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.272727)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.090909
DEBUG CAREFUL: Adding var 6 to fractional list (xi=0.090909)
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.090909
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.090909)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.090909
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.090909)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.090909
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.090909)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.272727
DEBUG CAREFUL: Adding var 23 to fractional list (xi=0.272727)
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 7 fractional variables

  %  Carefully choosing branching variable, nfrac = 7
DEBUG CAREFUL: Testing fvar[0] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
DEBUG CAREFUL: Testing fvar[1] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[2] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[3] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 5
DEBUG CAREFUL: Testing fvar[4] = var 23
DEBUG CAREFUL: Calling compare_branch_vars for var 23
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 23
DEBUG CAREFUL: Testing fvar[5] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[6] = var 6
DEBUG CAREFUL: Calling compare_branch_vars for var 6
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 6
  % Initial guess is x18, Z0 = 28737456.9164337        , Z1 = 28950941.2925293        

DEBUG EVAL: Testing var 18 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=13, varin=31, theta=1.428571, up=999999999999999983222784.000000
ITER 2: row=22, varin=32, theta=3.333333, up=999999999999999983222784.000000
ITER 3: row=26, varin=30, theta=2.333333, up=999999999999999983222784.000000
ITER 4: row=8, varin=28, theta=0.714286, up=999999999999999983222784.000000
ITER 5: row=7, varin=19, theta=1.333333, up=999999999999999983222784.000000
ITER 6: row=19, varin=25, theta=0.333333, up=999999999999999983222784.000000
ITER 7: row=14, varin=2, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=2, varin=17, theta=1.000000, up=999999999999999983222784.000000
ITER 9: row=16, varin=36, theta=1.200000, up=1.000000
ITER 10: row=16, varin=13, theta=0.166667, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 18 = 1 gives z=29120767.078725
  % 	x18 = 1,	Z1 = 29120767.0787246        
DEBUG EVAL: First branch cutoff check: z=29120767.078725, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 18 = 0
ITER 1: row=13, varin=30, theta=0.250000, up=999999999999999983222784.000000
  % 	x18 = 0,	Z0 = 28741461.009976         
DEBUG EVAL: Second branch cutoff check: z=28741461.009976, best_z=INF, threshold=INF
  %   New best:  x18, Z = 28741461.009976         
DEBUG EVAL: Testing var 9 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=19, varin=30, theta=1.428571, up=999999999999999983222784.000000
ITER 2: row=23, varin=20, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=8, varin=32, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 9 = 1 gives z=28774020.499139
  % 	x9 = 1,	Z1 = 28774020.4991391        
DEBUG EVAL: First branch cutoff check: z=28774020.499139, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 0
ITER 1: row=19, varin=31, theta=0.250000, up=999999999999999983222784.000000
ITER 2: row=22, varin=29, theta=1.666667, up=999999999999999983222784.000000
  % 	x9 = 0,	Z0 = 28744596.6384903        
DEBUG EVAL: Second branch cutoff check: z=28744596.638490, best_z=INF, threshold=INF
  %   New best:  x9, Z = 28744596.6384903        
DEBUG EVAL: Testing var 2 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=20, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 1 gives z=28756773.056953
  % 	x2 = 1,	Z1 = 28756773.056953         
DEBUG EVAL: First branch cutoff check: z=28756773.056953, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 0
ITER 1: row=1, varin=30, theta=0.250000, up=999999999999999983222784.000000
  % 	x2 = 0,	Z0 = 28741461.009976         
DEBUG EVAL: Second branch cutoff check: z=28741461.009976, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 5 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=14, varin=15, theta=0.375000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 5 = 0 gives z=28752263.377683
  % 	x5 = 0,	Z0 = 28752263.3776825        
DEBUG EVAL: First branch cutoff check: z=28752263.377683, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 5 = 1
ITER 1: row=14, varin=29, theta=20.000000, up=999999999999999983222784.000000
ITER 2: row=7, varin=2, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=2, varin=44, theta=0.857143, up=1.000000
ITER 4: row=1, varin=17, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=16, varin=31, theta=0.500000, up=999999999999999983222784.000000
ITER 6: row=26, varin=36, theta=2.000000, up=1.000000
ITER 7: row=26, varin=20, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=16, varin=30, theta=0.500000, up=999999999999999983222784.000000
ITER 9: row=8, varin=13, theta=0.500000, up=999999999999999983222784.000000
  % 	x5 = 1,	Z1 = 29008651.9102152        
DEBUG EVAL: Second branch cutoff check: z=29008651.910215, best_z=INF, threshold=INF
  %   New best:  x5, Z = 28752263.3776825        
DEBUG EVAL: Testing var 23 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=16, varin=20, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 23 = 0 gives z=28756773.056953
  % 	x23 = 0,	Z0 = 28756773.056953         
DEBUG EVAL: First branch cutoff check: z=28756773.056953, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 23 = 1
ITER 1: row=16, varin=29, theta=20.000000, up=999999999999999983222784.000000
ITER 2: row=7, varin=15, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=14, varin=2, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=2, varin=44, theta=0.428571, up=1.000000
ITER 5: row=29, varin=30, theta=0.500000, up=999999999999999983222784.000000
ITER 6: row=1, varin=36, theta=2.000000, up=1.000000
ITER 7: row=1, varin=20, theta=0.500000, up=999999999999999983222784.000000
ITER 8: row=8, varin=13, theta=0.500000, up=999999999999999983222784.000000
  % 	x23 = 1,	Z1 = 28969954.2295849        
DEBUG EVAL: Second branch cutoff check: z=28969954.229585, best_z=INF, threshold=INF
  %   New best:  x23, Z = 28756773.056953         
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=8, varin=32, theta=3.333333, up=999999999999999983222784.000000
ITER 2: row=26, varin=24, theta=1.166667, up=999999999999999983222784.000000
ITER 3: row=14, varin=2, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=2, varin=17, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=16, varin=13, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=29084938.743461
  % 	x10 = 1,	Z1 = 29084938.743461         
DEBUG EVAL: First branch cutoff check: z=29084938.743461, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=8, varin=30, theta=0.250000, up=999999999999999983222784.000000
  % 	x10 = 0,	Z0 = 28741461.009976         
DEBUG EVAL: Second branch cutoff check: z=28741461.009976, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 6 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=26, varin=30, theta=1.428571, up=999999999999999983222784.000000
ITER 2: row=1, varin=20, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=24, varin=31, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=8, varin=28, theta=0.535714, up=999999999999999983222784.000000
ITER 5: row=7, varin=23, theta=0.600000, up=999999999999999983222784.000000
ITER 6: row=24, varin=27, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 6 = 1 gives z=28834575.181854
  % 	x6 = 1,	Z1 = 28834575.1818545        
DEBUG EVAL: First branch cutoff check: z=28834575.181854, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 6 = 0
ITER 1: row=26, varin=32, theta=0.125000, up=999999999999999983222784.000000
  % 	x6 = 0,	Z0 = 28740025.3175008        
DEBUG EVAL: Second branch cutoff check: z=28740025.317501, best_z=INF, threshold=INF
  % Best branch is x23, Z0 = 28756773.056953         , Z1 = 28969954.2295849        

DEBUG CAREFUL: Final result - returning best.var = 23
DEBUG BB: Branching variable chosen: j=23
 % @NC   43   39	x23 = 0	28756773.056953
 % @NC   44   39	x23 = 1	28969954.229585
 %      39    20 28737456.9164               28743920.4837   x17 D    37    11
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5571bedda990
% @LO 0.03  28.73745691643372879298 99.9000000000
% @LN 0.03  28.74392048365960405931 99.9000000000
% Resuming node 25 at  28.74392048365960405931
DEBUG CONSTRNT: LP rows=32, pool->nlprows=32, pool->npend=0
DEBUG CONSTRNT: Checking 32 LP rows (pool tracks 32, total LP rows 32)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 162
DEBUG CONSTRNT: Pool row 162 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 60
DEBUG CONSTRNT: Pool row 60 has lprow=31, expected 31
 % @PAP adding 52 rows, 184 nz to LP
DEBUG BB: Processing node 25, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 25 LP 2 Solution, length = 28743920.483660, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.125000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.125000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.125000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.125000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.125000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.125000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.125000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.125000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.875000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.875000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.875000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.875000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.875000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.875000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.875000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.875000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.875000 (terminal 19)
 % 8 fractional variables
DEBUG CG: LP optimal, z=28743920.483660, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28743920.483660, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 25 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 25
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.125000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.125000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.125000
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.125000)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.125000
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.125000)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.125000
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.125000)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.125000
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.125000)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.125000
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.125000)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.125000
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.125000)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=1.000000
DEBUG CAREFUL: Skipping var 15: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.125000
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.125000)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 8 fractional variables

  %  Carefully choosing branching variable, nfrac = 8
DEBUG CAREFUL: Testing fvar[0] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
DEBUG CAREFUL: Testing fvar[1] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[2] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[3] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 4
DEBUG CAREFUL: New best var: 4
DEBUG CAREFUL: Testing fvar[4] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 11
DEBUG CAREFUL: Testing fvar[5] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[6] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[7] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 5
  % Initial guess is x4, Z0 = 28743920.4836596        , Z1 = 29009047.1156309        

DEBUG EVAL: Testing var 18 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=33, varin=40, theta=2.333333, up=999999999999999983222784.000000
ITER 2: row=20, varin=50, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=40, varin=36, theta=4.000000, up=999999999999999983222784.000000
ITER 4: row=36, varin=48, theta=4.000000, up=999999999999999983222784.000000
ITER 5: row=21, varin=44, theta=1.500000, up=999999999999999983222784.000000
ITER 6: row=44, varin=11, theta=0.375000, up=999999999999999983222784.000000
ITER 7: row=10, varin=43, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 18 = 1 gives z=29198950.194144
  % 	x18 = 1,	Z1 = 29198950.1941438        
DEBUG EVAL: First branch cutoff check: z=29198950.194144, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 18 = 0
ITER 1: row=33, varin=39, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=49, varin=6, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=12, varin=16, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=17, varin=12, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=49, varin=89, theta=1.000000, up=1.000000
  % 	x18 = 0,	Z0 = 28798910.0231984        
DEBUG EVAL: Second branch cutoff check: z=28798910.023198, best_z=INF, threshold=INF
  %   New best:  x18, Z = 28798910.0231984        
DEBUG EVAL: Testing var 9 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=35, varin=39, theta=1.166667, up=999999999999999983222784.000000
ITER 2: row=49, varin=48, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 9 = 1 gives z=28834956.172372
  % 	x9 = 1,	Z1 = 28834956.1723722        
DEBUG EVAL: First branch cutoff check: z=28834956.172372, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 0
ITER 1: row=35, varin=6, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=12, varin=16, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=17, varin=12, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=35, varin=35, theta=0.166667, up=999999999999999983222784.000000
  % 	x9 = 0,	Z0 = 28792240.8405736        
DEBUG EVAL: Second branch cutoff check: z=28792240.840574, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 3 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=20, varin=39, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=49, varin=6, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=12, varin=40, theta=0.200000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 0 gives z=28767969.978032
  % 	x3 = 0,	Z0 = 28767969.978032         
DEBUG EVAL: First branch cutoff check: z=28767969.978032, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 4 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=40, varin=47, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=51, varin=36, theta=7.000000, up=999999999999999983222784.000000
ITER 3: row=36, varin=48, theta=7.000000, up=999999999999999983222784.000000
ITER 4: row=21, varin=44, theta=3.000000, up=999999999999999983222784.000000
ITER 5: row=44, varin=33, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=52, varin=11, theta=1.500000, up=999999999999999983222784.000000
ITER 7: row=10, varin=43, theta=4.000000, up=999999999999999983222784.000000
ITER 8: row=7, varin=34, theta=0.600000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 4 = 1 gives z=29494058.754527
  % 	x4 = 1,	Z1 = 29494058.7545275        
DEBUG EVAL: First branch cutoff check: z=29494058.754527, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 4 = 0
ITER 1: row=40, varin=39, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=49, varin=50, theta=0.166667, up=999999999999999983222784.000000
  % 	x4 = 0,	Z0 = 28763225.6833639        
DEBUG EVAL: Second branch cutoff check: z=28763225.683364, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 11 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=44, varin=33, theta=1.166667, up=999999999999999983222784.000000
ITER 2: row=45, varin=40, theta=2.333333, up=999999999999999983222784.000000
ITER 3: row=20, varin=50, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=40, varin=36, theta=4.000000, up=999999999999999983222784.000000
ITER 5: row=36, varin=48, theta=4.000000, up=999999999999999983222784.000000
ITER 6: row=21, varin=11, theta=1.125000, up=999999999999999983222784.000000
ITER 7: row=10, varin=42, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=46, varin=43, theta=3.000000, up=999999999999999983222784.000000
ITER 9: row=7, varin=35, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 11 = 1 gives z=29348314.456124
  % 	x11 = 1,	Z1 = 29348314.4561242        
DEBUG EVAL: First branch cutoff check: z=29348314.456124, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 11 = 0
ITER 1: row=44, varin=39, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=49, varin=6, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=12, varin=44, theta=0.166667, up=999999999999999983222784.000000
  % 	x11 = 0,	Z0 = 28767346.7969102        
DEBUG EVAL: Second branch cutoff check: z=28767346.796910, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=39, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=49, varin=43, theta=0.142857, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28761661.165552
  % 	x2 = 0,	Z0 = 28761661.1655516        
DEBUG EVAL: First branch cutoff check: z=28761661.165552, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=21, varin=48, theta=0.142857, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28753926.138785
  % 	x10 = 0,	Z0 = 28753926.1387846        
DEBUG EVAL: First branch cutoff check: z=28753926.138785, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 5 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=32, varin=6, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=12, varin=41, theta=0.142857, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 5 = 0 gives z=28770061.170863
  % 	x5 = 0,	Z0 = 28770061.1708634        
DEBUG EVAL: First branch cutoff check: z=28770061.170863, best_z=INF, threshold=INF
  % Best branch is x18, Z0 = 28798910.0231984        , Z1 = 29198950.1941438        

DEBUG CAREFUL: Final result - returning best.var = 18
DEBUG BB: Branching variable chosen: j=18
 % @NC   45   25	x18 = 0	28798910.023198
 % @NC   46   25	x18 = 1	29198950.194144
 %      25    21 28743920.4837               28754556.2975   x17 D    19     5
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5571bedd96e0
% @LO 0.03  28.74392048365960405931 99.9000000000
% @LN 0.03  28.75455629752977060321 99.9000000000
% Resuming node 41 at  28.75455629752977060321
DEBUG CONSTRNT: LP rows=52, pool->nlprows=52, pool->npend=0
DEBUG CONSTRNT: Checking 52 LP rows (pool tracks 52, total LP rows 52)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=51, expected 51
 % @PAP adding 48 rows, 181 nz to LP
DEBUG BB: Processing node 41, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 41 LP 2 Solution, length = 28754556.297530, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.333333 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.333333 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.333333 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.333333 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.333333 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.666667 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.666667 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.666667 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.666667 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.666667 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28754556.297530, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28754556.297530, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 41 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 41
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.333333
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.333333
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.333333
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.333333
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.333333
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[1] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 11
DEBUG CAREFUL: New best var: 11
DEBUG CAREFUL: Testing fvar[2] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 22
DEBUG CAREFUL: Testing fvar[3] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[4] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 27
  % Initial guess is x11, Z0 = 28754556.2975298        , Z1 = 29173206.0831771        

DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=13, varin=31, theta=0.666667, up=999999999999999983222784.000000
ITER 2: row=41, varin=46, theta=1.200000, up=999999999999999983222784.000000
ITER 3: row=35, varin=62, theta=1.000000, up=1.000000
ITER 4: row=18, varin=8, theta=0.666667, up=999999999999999983222784.000000
ITER 5: row=42, varin=42, theta=1.333333, up=999999999999999983222784.000000
ITER 6: row=38, varin=45, theta=2.000000, up=999999999999999983222784.000000
ITER 7: row=1, varin=27, theta=2.000000, up=999999999999999983222784.000000
ITER 8: row=25, varin=39, theta=1.000000, up=999999999999999983222784.000000
ITER 9: row=39, varin=38, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 1 gives z=29140176.703854
  % 	x3 = 1,	Z1 = 29140176.7038541        
DEBUG EVAL: First branch cutoff check: z=29140176.703854, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=13, varin=87, theta=1.000000, up=1.000000
  % 	x3 = 0,	Z0 = 28768419.4228127        
DEBUG EVAL: Second branch cutoff check: z=28768419.422813, best_z=INF, threshold=INF
  %   New best:  x3, Z = 28768419.4228127        
DEBUG EVAL: Testing var 11 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=25, varin=31, theta=0.666667, up=999999999999999983222784.000000
ITER 2: row=41, varin=46, theta=1.200000, up=999999999999999983222784.000000
ITER 3: row=35, varin=62, theta=1.000000, up=1.000000
ITER 4: row=18, varin=8, theta=0.666667, up=999999999999999983222784.000000
ITER 5: row=42, varin=42, theta=1.333333, up=999999999999999983222784.000000
ITER 6: row=38, varin=45, theta=2.000000, up=999999999999999983222784.000000
ITER 7: row=1, varin=29, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=32, varin=39, theta=2.000000, up=999999999999999983222784.000000
ITER 9: row=39, varin=38, theta=2.000000, up=999999999999999983222784.000000
ITER 10: row=36, varin=33, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 11 = 1 gives z=29208872.300161
  % 	x11 = 1,	Z1 = 29208872.3001614        
DEBUG EVAL: First branch cutoff check: z=29208872.300161, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 11 = 0
ITER 1: row=25, varin=87, theta=1.000000, up=1.000000
  % 	x11 = 0,	Z0 = 28768419.4228127        
DEBUG EVAL: Second branch cutoff check: z=28768419.422813, best_z=INF, threshold=INF
  %   New best:  x11, Z = 28768419.4228127        
DEBUG EVAL: Testing var 22 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=27, varin=87, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 22 = 0 gives z=28768419.422813
  % 	x22 = 0,	Z0 = 28768419.4228127        
DEBUG EVAL: First branch cutoff check: z=28768419.422813, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 22 = 1
ITER 1: row=27, varin=31, theta=0.666667, up=999999999999999983222784.000000
ITER 2: row=41, varin=46, theta=1.200000, up=999999999999999983222784.000000
ITER 3: row=35, varin=62, theta=1.000000, up=1.000000
ITER 4: row=18, varin=8, theta=0.666667, up=999999999999999983222784.000000
ITER 5: row=42, varin=42, theta=1.333333, up=999999999999999983222784.000000
ITER 6: row=38, varin=45, theta=2.000000, up=999999999999999983222784.000000
ITER 7: row=1, varin=27, theta=2.000000, up=999999999999999983222784.000000
ITER 8: row=25, varin=29, theta=0.500000, up=999999999999999983222784.000000
ITER 9: row=32, varin=39, theta=1.000000, up=999999999999999983222784.000000
ITER 10: row=39, varin=38, theta=1.000000, up=999999999999999983222784.000000
  % 	x22 = 1,	Z1 = 29140176.7038541        
DEBUG EVAL: Second branch cutoff check: z=29140176.703854, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 2 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=31, theta=0.666667, up=999999999999999983222784.000000
ITER 2: row=41, varin=47, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 1 gives z=28804707.559040
  % 	x2 = 1,	Z1 = 28804707.5590403        
DEBUG EVAL: First branch cutoff check: z=28804707.559040, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 0
ITER 1: row=6, varin=87, theta=1.000000, up=1.000000
  % 	x2 = 0,	Z0 = 28768419.4228127        
DEBUG EVAL: Second branch cutoff check: z=28768419.422813, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 27 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=36, varin=31, theta=0.666667, up=999999999999999983222784.000000
ITER 2: row=41, varin=47, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 27 = 1 gives z=28804707.559040
  % 	x27 = 1,	Z1 = 28804707.5590403        
DEBUG EVAL: First branch cutoff check: z=28804707.559040, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 27 = 0
ITER 1: row=36, varin=87, theta=1.000000, up=1.000000
  % 	x27 = 0,	Z0 = 28768419.4228127        
DEBUG EVAL: Second branch cutoff check: z=28768419.422813, best_z=INF, threshold=INF
  % Best branch is x11, Z0 = 28768419.4228127        , Z1 = 29208872.3001614        

DEBUG CAREFUL: Final result - returning best.var = 11
DEBUG BB: Branching variable chosen: j=11
 % @NC   47   41	x11 = 0	28768419.422813
 % @NC   48   41	x11 = 1	29208872.300161
 %      41    22 28754556.2975               28756773.0570   x31 D    21     7
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x5571bedd9330
% @LO 0.03  28.75455629752977060321 99.9000000000
% @LN 0.03  28.75677305695297647503 99.9000000000
% Resuming node 43 at  28.75677305695297647503
DEBUG CONSTRNT: LP rows=48, pool->nlprows=48, pool->npend=0
DEBUG CONSTRNT: Checking 48 LP rows (pool tracks 48, total LP rows 48)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=47, expected 47
 % @PAP adding 32 rows, 164 nz to LP
DEBUG BB: Processing node 43, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=16, varin=20, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=32)
DEBUG SOLUTION: LP solution array indices: FST[33-72], not_covered[73-92]
DEBUG SOLUTION: lp->best_solution[0] = 28756773.056953
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 32 rows, 60 cols, 224 nonzeros, 1 slack, 31 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 43 LP 1 Solution, length = 28756773.056953, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 0 fractional variables
DEBUG CG: LP optimal, z=28756773.056953, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG IFS: Budget mode - accepting integer solution with 1 edges covering 3 vertices
DEBUG CG: integer_feasible_solution returned: TRUE
DEBUG CG: Solution is integer feasible, returning LB_INTEGRAL
DEBUG BB: compute_good_lower_bound returned status=3
DEBUG BB: Node 43 is INTEGRAL (integer solution found)
 %  	=== 21 nodes cut off ===
 % @UO 0.03   3.25677305695297558685 -782.9836330032
 % @UN 0.03   3.25677305695297558685 -782.9836330032
DEBUG BB: Calling heuristic UB for integer solution, current best_z=3256773.056953
DEBUG BB: Heuristic did not improve integer solution
 % *    43     0  3256773.0570  3256773.0570                 x23 D    39    12
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=(nil)
DEBUG BB: No more nodes to process, exiting

 % Certificate of solution:
 % @C	.4767008182741058	.2081993675729823
%%Page: 1 1
BeginPlot
	Plot_Terminals
 % fs2: 13 0 6
	13 T	.4767008182741058	.2081993675729823	S
	.4767008182741058	.2081993675729823	0 T	S
	.4767008182741058	.2081993675729823	6 T	S
  (Euclidean SMT:  20 points,  length = 3.256773056952975,  0.03 seconds)
EndPlot

% @0 Euclidean SMT
% N M Nodes LPs P1CPU P2CPU TotCPU
% @1 20 40 33 54 0.00 0.03 0.03
% Z RootZ %Gap RootLPs RootCPU RedMST
% @2 3.256773056952975 28049765.963866 -761.27481 2 0.00 -4.1576
% InitPRows InitPNZ InitLPRows InitLPNZ
% @3 163 594 135 555
% RootPRows RootPNZ RootLPRows RootLPNZ
% @4 163 594 52 250
% FinalPRows FinalPNZ FinalLPRows FinalLPNZ
% @5 163 594 32 224
% SMTFSTs SMTAvgFSTSz SMTMaxFSTSz #2FSTs #3FSTs ... #10FSTS #>10FSTs
% @6 1 3.000000 3 0 1 0 0 0 0 0 0 0 0
