 % ./bb
 % Args:
DEBUG P1READ: Terminal 0 battery=100.00
DEBUG P1READ: Terminal 1 battery=80.60
DEBUG P1READ: Terminal 2 battery=69.70
DEBUG P1READ: Terminal 3 battery=83.50
DEBUG P1READ: Terminal 4 battery=71.30
DEBUG P1READ: Terminal 5 battery=35.50
DEBUG P1READ: Terminal 6 battery=40.60
DEBUG P1READ: Terminal 7 battery=41.20
DEBUG P1READ: Terminal 8 battery=56.90
DEBUG P1READ: Terminal 9 battery=54.10
DEBUG P1READ: Terminal 10 battery=38.20
DEBUG P1READ: Terminal 11 battery=0.00
DEBUG P1READ: Terminal 12 battery=61.00
DEBUG P1READ: Terminal 13 battery=27.90
DEBUG P1READ: Terminal 14 battery=68.30
DEBUG P1READ: Terminal 15 battery=84.60
DEBUG P1READ: Terminal 16 battery=46.00
DEBUG P1READ: Terminal 17 battery=54.60
DEBUG P1READ: Terminal 18 battery=29.20
DEBUG P1READ: Terminal 19 battery=65.60
DEBUG HG: num_verts=20, num_edges=40
 % Phase 1: 0.00 seconds

%%BeginSetup

0 1 0 1 SetAxes

20 DefineTerminals
	.4588350000000000	.2373240000000000	DT
	.1270640000000000	.3509960000000000	DT
	.1544540000000000	.4808220000000000	DT
	.9474030000000000	.1441120000000000	DT
	.2867390000000000	.0565890000000000	DT
	.1326890000000000	.1166050000000000	DT
	.6273950000000000	.2122140000000000	DT
	.0794880000000000	.7970990000000000	DT
	.0327480000000000	.8803250000000000	DT
	.3110550000000000	.8689670000000000	DT
	.0916180000000000	.0221720000000000	DT
	.3600710000000000	.6382240000000000	DT
	.7197120000000000	.7181670000000000	DT
	.4424420000000000	.1450340000000000	DT
	.9983770000000000	.5729870000000000	DT
	.9654920000000000	.1935700000000000	DT
	.1600100000000000	.4187950000000000	DT
	.2909450000000000	.9620800000000000	DT
	.3330000000000000	.9414120000000000	DT
	.9512590000000000	.5074670000000000	DT

%%EndSetup

DEBUG ALGO: num_verts=20 <= 8? NO, num_edges=40 <= 12? NO
DEBUG ALGO: Forcing BRANCH-AND-CUT for multi-objective optimization (vertices=20 > 1)
DEBUG SPANNING: Adding modified spanning constraint for budget mode
DEBUG SPANNING: Added modified spanning constraint: Σ(|FST|-1)*x + Σnot_covered = 19
DEBUG CONSTRAINT: Adding soft cutset constraints with not_covered variables
DEBUG CONSTRAINT: Added constraint x[2] + not_covered[0] ≤ 1 for terminal 0
DEBUG CONSTRAINT: Added constraint x[27] + not_covered[0] ≤ 1 for terminal 0
DEBUG CONSTRAINT: Added constraint x[31] + not_covered[0] ≤ 1 for terminal 0
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 3·not_covered[0] ≤ 3 for terminal 0
DEBUG CONSTRAINT: Added constraint x[0] + not_covered[1] ≤ 1 for terminal 1
DEBUG CONSTRAINT: Added constraint x[24] + not_covered[1] ≤ 1 for terminal 1
DEBUG CONSTRAINT: Added constraint x[33] + not_covered[1] ≤ 1 for terminal 1
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 3·not_covered[1] ≤ 3 for terminal 1
DEBUG CONSTRAINT: Added constraint x[5] + not_covered[2] ≤ 1 for terminal 2
DEBUG CONSTRAINT: Added constraint x[7] + not_covered[2] ≤ 1 for terminal 2
DEBUG CONSTRAINT: Added constraint x[16] + not_covered[2] ≤ 1 for terminal 2
DEBUG CONSTRAINT: Added constraint x[23] + not_covered[2] ≤ 1 for terminal 2
DEBUG CONSTRAINT: Added constraint x[36] + not_covered[2] ≤ 1 for terminal 2
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 5·not_covered[2] ≤ 5 for terminal 2
DEBUG CONSTRAINT: Added constraint x[3] + not_covered[3] ≤ 1 for terminal 3
DEBUG CONSTRAINT: Added constraint x[4] + not_covered[3] ≤ 1 for terminal 3
DEBUG CONSTRAINT: Added constraint x[17] + not_covered[3] ≤ 1 for terminal 3
DEBUG CONSTRAINT: Added constraint x[20] + not_covered[3] ≤ 1 for terminal 3
DEBUG CONSTRAINT: Added constraint x[22] + not_covered[3] ≤ 1 for terminal 3
DEBUG CONSTRAINT: Added constraint x[39] + not_covered[3] ≤ 1 for terminal 3
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 6·not_covered[3] ≤ 6 for terminal 3
DEBUG CONSTRAINT: Added constraint x[0] + not_covered[4] ≤ 1 for terminal 4
DEBUG CONSTRAINT: Added constraint x[1] + not_covered[4] ≤ 1 for terminal 4
DEBUG CONSTRAINT: Added constraint x[30] + not_covered[4] ≤ 1 for terminal 4
DEBUG CONSTRAINT: Added constraint x[32] + not_covered[4] ≤ 1 for terminal 4
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 4·not_covered[4] ≤ 4 for terminal 4
DEBUG CONSTRAINT: Added constraint x[0] + not_covered[5] ≤ 1 for terminal 5
DEBUG CONSTRAINT: Added constraint x[1] + not_covered[5] ≤ 1 for terminal 5
DEBUG CONSTRAINT: Added constraint x[29] + not_covered[5] ≤ 1 for terminal 5
DEBUG CONSTRAINT: Added constraint x[30] + not_covered[5] ≤ 1 for terminal 5
DEBUG CONSTRAINT: Added constraint x[33] + not_covered[5] ≤ 1 for terminal 5
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 5·not_covered[5] ≤ 5 for terminal 5
DEBUG CONSTRAINT: Added constraint x[2] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[3] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[4] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[11] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[17] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[18] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[20] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[31] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[39] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 9·not_covered[6] ≤ 9 for terminal 6
DEBUG CONSTRAINT: Added constraint x[5] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[6] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[8] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[13] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[14] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[15] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[16] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[19] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[28] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[35] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 10·not_covered[7] ≤ 10 for terminal 7
DEBUG CONSTRAINT: Added constraint x[6] + not_covered[8] ≤ 1 for terminal 8
DEBUG CONSTRAINT: Added constraint x[13] + not_covered[8] ≤ 1 for terminal 8
DEBUG CONSTRAINT: Added constraint x[14] + not_covered[8] ≤ 1 for terminal 8
DEBUG CONSTRAINT: Added constraint x[19] + not_covered[8] ≤ 1 for terminal 8
DEBUG CONSTRAINT: Added constraint x[28] + not_covered[8] ≤ 1 for terminal 8
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 5·not_covered[8] ≤ 5 for terminal 8
DEBUG CONSTRAINT: Added constraint x[6] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[7] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[8] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[9] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[12] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[13] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[14] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[15] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[16] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[19] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[25] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[34] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[35] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 13·not_covered[9] ≤ 13 for terminal 9
DEBUG CONSTRAINT: Added constraint x[1] + not_covered[10] ≤ 1 for terminal 10
DEBUG CONSTRAINT: Added constraint x[29] + not_covered[10] ≤ 1 for terminal 10
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 2·not_covered[10] ≤ 2 for terminal 10
DEBUG CONSTRAINT: Added constraint x[5] + not_covered[11] ≤ 1 for terminal 11
DEBUG CONSTRAINT: Added constraint x[7] + not_covered[11] ≤ 1 for terminal 11
DEBUG CONSTRAINT: Added constraint x[8] + not_covered[11] ≤ 1 for terminal 11
DEBUG CONSTRAINT: Added constraint x[9] + not_covered[11] ≤ 1 for terminal 11
DEBUG CONSTRAINT: Added constraint x[13] + not_covered[11] ≤ 1 for terminal 11
DEBUG CONSTRAINT: Added constraint x[16] + not_covered[11] ≤ 1 for terminal 11
DEBUG CONSTRAINT: Added constraint x[34] + not_covered[11] ≤ 1 for terminal 11
DEBUG CONSTRAINT: Added constraint x[36] + not_covered[11] ≤ 1 for terminal 11
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 8·not_covered[11] ≤ 8 for terminal 11
DEBUG CONSTRAINT: Added constraint x[9] + not_covered[12] ≤ 1 for terminal 12
DEBUG CONSTRAINT: Added constraint x[10] + not_covered[12] ≤ 1 for terminal 12
DEBUG CONSTRAINT: Added constraint x[18] + not_covered[12] ≤ 1 for terminal 12
DEBUG CONSTRAINT: Added constraint x[20] + not_covered[12] ≤ 1 for terminal 12
DEBUG CONSTRAINT: Added constraint x[37] + not_covered[12] ≤ 1 for terminal 12
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 5·not_covered[12] ≤ 5 for terminal 12
DEBUG CONSTRAINT: Added constraint x[2] + not_covered[13] ≤ 1 for terminal 13
DEBUG CONSTRAINT: Added constraint x[27] + not_covered[13] ≤ 1 for terminal 13
DEBUG CONSTRAINT: Added constraint x[32] + not_covered[13] ≤ 1 for terminal 13
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 3·not_covered[13] ≤ 3 for terminal 13
DEBUG CONSTRAINT: Added constraint x[10] + not_covered[14] ≤ 1 for terminal 14
DEBUG CONSTRAINT: Added constraint x[26] + not_covered[14] ≤ 1 for terminal 14
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 2·not_covered[14] ≤ 2 for terminal 14
DEBUG CONSTRAINT: Added constraint x[3] + not_covered[15] ≤ 1 for terminal 15
DEBUG CONSTRAINT: Added constraint x[11] + not_covered[15] ≤ 1 for terminal 15
DEBUG CONSTRAINT: Added constraint x[17] + not_covered[15] ≤ 1 for terminal 15
DEBUG CONSTRAINT: Added constraint x[18] + not_covered[15] ≤ 1 for terminal 15
DEBUG CONSTRAINT: Added constraint x[20] + not_covered[15] ≤ 1 for terminal 15
DEBUG CONSTRAINT: Added constraint x[22] + not_covered[15] ≤ 1 for terminal 15
DEBUG CONSTRAINT: Added constraint x[38] + not_covered[15] ≤ 1 for terminal 15
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 7·not_covered[15] ≤ 7 for terminal 15
DEBUG CONSTRAINT: Added constraint x[23] + not_covered[16] ≤ 1 for terminal 16
DEBUG CONSTRAINT: Added constraint x[24] + not_covered[16] ≤ 1 for terminal 16
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 2·not_covered[16] ≤ 2 for terminal 16
DEBUG CONSTRAINT: Added constraint x[12] + not_covered[17] ≤ 1 for terminal 17
DEBUG CONSTRAINT: Added constraint x[15] + not_covered[17] ≤ 1 for terminal 17
DEBUG CONSTRAINT: Added constraint x[19] + not_covered[17] ≤ 1 for terminal 17
DEBUG CONSTRAINT: Added constraint x[21] + not_covered[17] ≤ 1 for terminal 17
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 4·not_covered[17] ≤ 4 for terminal 17
DEBUG CONSTRAINT: Added constraint x[12] + not_covered[18] ≤ 1 for terminal 18
DEBUG CONSTRAINT: Added constraint x[14] + not_covered[18] ≤ 1 for terminal 18
DEBUG CONSTRAINT: Added constraint x[15] + not_covered[18] ≤ 1 for terminal 18
DEBUG CONSTRAINT: Added constraint x[19] + not_covered[18] ≤ 1 for terminal 18
DEBUG CONSTRAINT: Added constraint x[21] + not_covered[18] ≤ 1 for terminal 18
DEBUG CONSTRAINT: Added constraint x[25] + not_covered[18] ≤ 1 for terminal 18
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 6·not_covered[18] ≤ 6 for terminal 18
DEBUG CONSTRAINT: Added constraint x[4] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint x[10] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint x[11] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint x[17] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint x[18] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint x[20] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint x[26] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint x[37] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint x[38] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 9·not_covered[19] ≤ 9 for terminal 19
DEBUG CONSTRAINT: Added source terminal constraint: not_covered[0] = 0
DEBUG BUDGET: Adding budget constraint ≤ 500000.000 to constraint pool
DEBUG BUDGET: Using raw tree costs directly
DEBUG BUDGET: Budget limit: 500000.000
DEBUG BUDGET: Building raw cost constraint coefficients:
DEBUG BUDGET:   x[0] coefficient = 398991 (raw=398991.100)
DEBUG BUDGET:   x[1] coefficient = 260889 (raw=260889.712)
DEBUG BUDGET:   x[2] coefficient = 256773 (raw=256773.057)
DEBUG BUDGET:   x[3] coefficient = 376541 (raw=376541.557)
DEBUG BUDGET:   x[4] coefficient = 646084 (raw=646084.462)
DEBUG BUDGET:   x[5] coefficient = 520973 (raw=520973.020)
DEBUG BUDGET:   x[6] coefficient = 334575 (raw=334575.182)
DEBUG BUDGET:   x[7] coefficient = 494448 (raw=494448.457)
DEBUG BUDGET:   x[8] coefficient = 455905 (raw=455905.519)
DEBUG BUDGET:   x[9] coefficient = 584020 (raw=584020.499)
DEBUG BUDGET:   x[10] coefficient = 380918 (raw=380918.244)
DEBUG BUDGET:   x[11] coefficient = 621357 (raw=621357.781)
DEBUG BUDGET:   x[12] coefficient = 120675 (raw=120675.719)
DEBUG BUDGET:   x[13] coefficient = 551354 (raw=551354.477)
DEBUG BUDGET:   x[14] coefficient = 410262 (raw=410262.679)
DEBUG BUDGET:   x[15] coefficient = 362962 (raw=362962.653)
DEBUG BUDGET:   x[16] coefficient = 702244 (raw=702244.403)
DEBUG BUDGET:   x[17] coefficient = 673894 (raw=673894.542)
DEBUG BUDGET:   x[18] coefficient = 933994 (raw=933994.022)
DEBUG BUDGET:   x[19] coefficient = 454199 (raw=454199.906)
DEBUG BUDGET:   x[20] coefficient = 986439 (raw=986439.144)
DEBUG BUDGET:   x[21] coefficient = 46859 (raw=46859.249)
DEBUG BUDGET:   x[22] coefficient = 52662 (raw=52662.185)
DEBUG BUDGET:   x[23] coefficient = 62275 (raw=62275.339)
DEBUG BUDGET:   x[24] coefficient = 75379 (raw=75379.993)
DEBUG BUDGET:   x[25] coefficient = 75695 (raw=75695.846)
DEBUG BUDGET:   x[26] coefficient = 80703 (raw=80703.013)
DEBUG BUDGET:   x[27] coefficient = 93734 (raw=93734.596)
DEBUG BUDGET:   x[28] coefficient = 95452 (raw=95452.578)
DEBUG BUDGET:   x[29] coefficient = 102977 (raw=102977.757)
DEBUG BUDGET:   x[30] coefficient = 165327 (raw=165327.925)
DEBUG BUDGET:   x[31] coefficient = 170420 (raw=170420.027)
DEBUG BUDGET:   x[32] coefficient = 179069 (raw=179069.657)
DEBUG BUDGET:   x[33] coefficient = 234458 (raw=234458.486)
DEBUG BUDGET:   x[34] coefficient = 235891 (raw=235891.713)
DEBUG BUDGET:   x[35] coefficient = 242462 (raw=242462.956)
DEBUG BUDGET:   x[36] coefficient = 258947 (raw=258947.370)
DEBUG BUDGET:   x[37] coefficient = 313063 (raw=313063.098)
DEBUG BUDGET:   x[38] coefficient = 314219 (raw=314219.517)
DEBUG BUDGET:   x[39] coefficient = 327174 (raw=327174.269)
DEBUG BUDGET: Constraint: Σ tree_cost[i] * x[i] ≤ 500000
DEBUG BUDGET: Budget constraint added to pool with 40 FSTs
DEBUG CONSTRAINT: Adding 'at least one FST' constraint: Σ x[i] ≥ 1
DEBUG CONSTRAINT: Added 'at least one FST' constraint: Σ x[i] ≥ 1
 % _gst_initialize_constraint_pool: 0.00 seconds.
 % Constraint pool initialized with:
 % 	1	Total degree rows	40	coeffs.
 % 	20	Cutset rows		111	coeffs.
 % 	0	Incompatibility rows	0	coeffs.
 % 	29	2-terminal SEC rows	102	coeffs.
 % 	1	At least one FST rows	40	coeffs.
 % 	163	Total rows in pool	135	in LP
 % @PMEM 163 rows, 1 blocks, 415 nzfree, 0 nzwasted, 1172 nztotal
DEBUG SOFT: Found 20 terminals, 40 FSTs
DEBUG SOFT: Adding space for 20 not_covered variables in soft constraints, total ncoeff=514
DEBUG LP_SETUP: Created LP with 0 rows, 60 columns (nedges=40 + nterms=20)
DEBUG SOFT: Set bounds for 40 FST vars [1-40] and 20 coverage vars [41-60]
DEBUG OBJ: Using raw costs - alpha=10000.0 (battery weight), beta=1500000 (coverage penalty)
DEBUG OBJ: Allocated rowvec[0-60] for ncols=60 LP variables
DEBUG OBJ: Full_trees battery_score=0.000 for FST 0
DEBUG OBJ: Recalculating for FST 0 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 5): battery=35.50, running_total=35.50
DEBUG OBJ: Terminal 1 (idx 1): battery=80.60, running_total=116.10
DEBUG OBJ: Terminal 2 (idx 4): battery=71.30, running_total=187.40
DEBUG OBJ: Recalculated battery_score=187.400 for FST 0
DEBUG OBJ: FST 0: tree_cost=398991.100, battery_cost=187.400 (weighted=1874000.0), combined=2272991.1
DEBUG OBJ: Full_trees battery_score=0.000 for FST 1
DEBUG OBJ: Recalculating for FST 1 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 10): battery=38.20, running_total=38.20
DEBUG OBJ: Terminal 1 (idx 5): battery=35.50, running_total=73.70
DEBUG OBJ: Terminal 2 (idx 4): battery=71.30, running_total=145.00
DEBUG OBJ: Recalculated battery_score=145.000 for FST 1
DEBUG OBJ: FST 1: tree_cost=260889.712, battery_cost=145.000 (weighted=1450000.0), combined=1710889.7
DEBUG OBJ: Full_trees battery_score=0.000 for FST 2
DEBUG OBJ: Recalculating for FST 2 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 13): battery=27.90, running_total=27.90
DEBUG OBJ: Terminal 1 (idx 0): battery=100.00, running_total=127.90
DEBUG OBJ: Terminal 2 (idx 6): battery=40.60, running_total=168.50
DEBUG OBJ: Recalculated battery_score=168.500 for FST 2
DEBUG OBJ: FST 2: tree_cost=256773.057, battery_cost=168.500 (weighted=1685000.0), combined=1941773.1
DEBUG OBJ: Full_trees battery_score=0.000 for FST 3
DEBUG OBJ: Recalculating for FST 3 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 15): battery=84.60, running_total=84.60
DEBUG OBJ: Terminal 1 (idx 3): battery=83.50, running_total=168.10
DEBUG OBJ: Terminal 2 (idx 6): battery=40.60, running_total=208.70
DEBUG OBJ: Recalculated battery_score=208.700 for FST 3
DEBUG OBJ: FST 3: tree_cost=376541.557, battery_cost=208.700 (weighted=2087000.0), combined=2463541.6
DEBUG OBJ: Full_trees battery_score=0.000 for FST 4
DEBUG OBJ: Recalculating for FST 4 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 19): battery=65.60, running_total=65.60
DEBUG OBJ: Terminal 1 (idx 3): battery=83.50, running_total=149.10
DEBUG OBJ: Terminal 2 (idx 6): battery=40.60, running_total=189.70
DEBUG OBJ: Recalculated battery_score=189.700 for FST 4
DEBUG OBJ: FST 4: tree_cost=646084.462, battery_cost=189.700 (weighted=1897000.0), combined=2543084.5
DEBUG OBJ: Full_trees battery_score=0.000 for FST 5
DEBUG OBJ: Recalculating for FST 5 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 11): battery=0.00, running_total=0.00
DEBUG OBJ: Terminal 1 (idx 2): battery=69.70, running_total=69.70
DEBUG OBJ: Terminal 2 (idx 7): battery=41.20, running_total=110.90
DEBUG OBJ: Recalculated battery_score=110.900 for FST 5
DEBUG OBJ: FST 5: tree_cost=520973.020, battery_cost=110.900 (weighted=1109000.0), combined=1629973.0
DEBUG OBJ: Full_trees battery_score=0.000 for FST 6
DEBUG OBJ: Recalculating for FST 6 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 9): battery=54.10, running_total=54.10
DEBUG OBJ: Terminal 1 (idx 7): battery=41.20, running_total=95.30
DEBUG OBJ: Terminal 2 (idx 8): battery=56.90, running_total=152.20
DEBUG OBJ: Recalculated battery_score=152.200 for FST 6
DEBUG OBJ: FST 6: tree_cost=334575.182, battery_cost=152.200 (weighted=1522000.0), combined=1856575.2
DEBUG OBJ: Full_trees battery_score=0.000 for FST 7
DEBUG OBJ: Recalculating for FST 7 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 11): battery=0.00, running_total=0.00
DEBUG OBJ: Terminal 1 (idx 2): battery=69.70, running_total=69.70
DEBUG OBJ: Terminal 2 (idx 9): battery=54.10, running_total=123.80
DEBUG OBJ: Recalculated battery_score=123.800 for FST 7
DEBUG OBJ: FST 7: tree_cost=494448.457, battery_cost=123.800 (weighted=1238000.0), combined=1732448.5
DEBUG OBJ: Full_trees battery_score=0.000 for FST 8
DEBUG OBJ: Recalculating for FST 8 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 11): battery=0.00, running_total=0.00
DEBUG OBJ: Terminal 1 (idx 7): battery=41.20, running_total=41.20
DEBUG OBJ: Terminal 2 (idx 9): battery=54.10, running_total=95.30
DEBUG OBJ: Recalculated battery_score=95.300 for FST 8
DEBUG OBJ: FST 8: tree_cost=455905.519, battery_cost=95.300 (weighted=953000.0), combined=1408905.5
DEBUG OBJ: Full_trees battery_score=0.000 for FST 9
DEBUG OBJ: Recalculating for FST 9 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 12): battery=61.00, running_total=61.00
DEBUG OBJ: Terminal 1 (idx 11): battery=0.00, running_total=61.00
DEBUG OBJ: Terminal 2 (idx 9): battery=54.10, running_total=115.10
DEBUG OBJ: Recalculated battery_score=115.100 for FST 9
DEBUG OBJ: FST 9: tree_cost=584020.499, battery_cost=115.100 (weighted=1151000.0), combined=1735020.5
DEBUG OBJ: Full_trees battery_score=0.000 for FST 10
DEBUG OBJ: Recalculating for FST 10 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 19): battery=65.60, running_total=65.60
DEBUG OBJ: Terminal 1 (idx 12): battery=61.00, running_total=126.60
DEBUG OBJ: Terminal 2 (idx 14): battery=68.30, running_total=194.90
DEBUG OBJ: Recalculated battery_score=194.900 for FST 10
DEBUG OBJ: FST 10: tree_cost=380918.244, battery_cost=194.900 (weighted=1949000.0), combined=2329918.2
DEBUG OBJ: Full_trees battery_score=0.000 for FST 11
DEBUG OBJ: Recalculating for FST 11 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 19): battery=65.60, running_total=65.60
DEBUG OBJ: Terminal 1 (idx 15): battery=84.60, running_total=150.20
DEBUG OBJ: Terminal 2 (idx 6): battery=40.60, running_total=190.80
DEBUG OBJ: Recalculated battery_score=190.800 for FST 11
DEBUG OBJ: FST 11: tree_cost=621357.781, battery_cost=190.800 (weighted=1908000.0), combined=2529357.8
DEBUG OBJ: Full_trees battery_score=0.000 for FST 12
DEBUG OBJ: Recalculating for FST 12 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 18): battery=29.20, running_total=29.20
DEBUG OBJ: Terminal 1 (idx 9): battery=54.10, running_total=83.30
DEBUG OBJ: Terminal 2 (idx 17): battery=54.60, running_total=137.90
DEBUG OBJ: Recalculated battery_score=137.900 for FST 12
DEBUG OBJ: FST 12: tree_cost=120675.719, battery_cost=137.900 (weighted=1379000.0), combined=1499675.7
DEBUG OBJ: Full_trees battery_score=0.000 for FST 13
DEBUG OBJ: Recalculating for FST 13 with 4 terminals
DEBUG OBJ: Terminal 0 (idx 11): battery=0.00, running_total=0.00
DEBUG OBJ: Terminal 1 (idx 7): battery=41.20, running_total=41.20
DEBUG OBJ: Terminal 2 (idx 8): battery=56.90, running_total=98.10
DEBUG OBJ: Terminal 3 (idx 9): battery=54.10, running_total=152.20
DEBUG OBJ: Recalculated battery_score=152.200 for FST 13
DEBUG OBJ: FST 13: tree_cost=551354.477, battery_cost=152.200 (weighted=1522000.0), combined=2073354.5
DEBUG OBJ: Full_trees battery_score=0.000 for FST 14
DEBUG OBJ: Recalculating for FST 14 with 4 terminals
DEBUG OBJ: Terminal 0 (idx 18): battery=29.20, running_total=29.20
DEBUG OBJ: Terminal 1 (idx 9): battery=54.10, running_total=83.30
DEBUG OBJ: Terminal 2 (idx 7): battery=41.20, running_total=124.50
DEBUG OBJ: Terminal 3 (idx 8): battery=56.90, running_total=181.40
DEBUG OBJ: Recalculated battery_score=181.400 for FST 14
DEBUG OBJ: FST 14: tree_cost=410262.679, battery_cost=181.400 (weighted=1814000.0), combined=2224262.7
DEBUG OBJ: Full_trees battery_score=0.000 for FST 15
DEBUG OBJ: Recalculating for FST 15 with 4 terminals
DEBUG OBJ: Terminal 0 (idx 18): battery=29.20, running_total=29.20
DEBUG OBJ: Terminal 1 (idx 9): battery=54.10, running_total=83.30
DEBUG OBJ: Terminal 2 (idx 7): battery=41.20, running_total=124.50
DEBUG OBJ: Terminal 3 (idx 17): battery=54.60, running_total=179.10
DEBUG OBJ: Recalculated battery_score=179.100 for FST 15
DEBUG OBJ: FST 15: tree_cost=362962.653, battery_cost=179.100 (weighted=1791000.0), combined=2153962.7
DEBUG OBJ: Full_trees battery_score=0.000 for FST 16
DEBUG OBJ: Recalculating for FST 16 with 4 terminals
DEBUG OBJ: Terminal 0 (idx 11): battery=0.00, running_total=0.00
DEBUG OBJ: Terminal 1 (idx 2): battery=69.70, running_total=69.70
DEBUG OBJ: Terminal 2 (idx 7): battery=41.20, running_total=110.90
DEBUG OBJ: Terminal 3 (idx 9): battery=54.10, running_total=165.00
DEBUG OBJ: Recalculated battery_score=165.000 for FST 16
DEBUG OBJ: FST 16: tree_cost=702244.403, battery_cost=165.000 (weighted=1650000.0), combined=2352244.4
DEBUG OBJ: Full_trees battery_score=0.000 for FST 17
DEBUG OBJ: Recalculating for FST 17 with 4 terminals
DEBUG OBJ: Terminal 0 (idx 19): battery=65.60, running_total=65.60
DEBUG OBJ: Terminal 1 (idx 15): battery=84.60, running_total=150.20
DEBUG OBJ: Terminal 2 (idx 3): battery=83.50, running_total=233.70
DEBUG OBJ: Terminal 3 (idx 6): battery=40.60, running_total=274.30
DEBUG OBJ: Recalculated battery_score=274.300 for FST 17
DEBUG OBJ: FST 17: tree_cost=673894.542, battery_cost=274.300 (weighted=2743000.0), combined=3416894.5
DEBUG OBJ: Full_trees battery_score=0.000 for FST 18
DEBUG OBJ: Recalculating for FST 18 with 4 terminals
DEBUG OBJ: Terminal 0 (idx 19): battery=65.60, running_total=65.60
DEBUG OBJ: Terminal 1 (idx 15): battery=84.60, running_total=150.20
DEBUG OBJ: Terminal 2 (idx 6): battery=40.60, running_total=190.80
DEBUG OBJ: Terminal 3 (idx 12): battery=61.00, running_total=251.80
DEBUG OBJ: Recalculated battery_score=251.800 for FST 18
DEBUG OBJ: FST 18: tree_cost=933994.022, battery_cost=251.800 (weighted=2518000.0), combined=3451994.0
DEBUG OBJ: Full_trees battery_score=0.000 for FST 19
DEBUG OBJ: Recalculating for FST 19 with 5 terminals
DEBUG OBJ: Terminal 0 (idx 18): battery=29.20, running_total=29.20
DEBUG OBJ: Terminal 1 (idx 9): battery=54.10, running_total=83.30
DEBUG OBJ: Terminal 2 (idx 7): battery=41.20, running_total=124.50
DEBUG OBJ: Terminal 3 (idx 8): battery=56.90, running_total=181.40
DEBUG OBJ: Terminal 4 (idx 17): battery=54.60, running_total=236.00
DEBUG OBJ: Recalculated battery_score=236.000 for FST 19
DEBUG OBJ: FST 19: tree_cost=454199.906, battery_cost=236.000 (weighted=2360000.0), combined=2814199.9
DEBUG OBJ: Full_trees battery_score=0.000 for FST 20
DEBUG OBJ: Recalculating for FST 20 with 5 terminals
DEBUG OBJ: Terminal 0 (idx 19): battery=65.60, running_total=65.60
DEBUG OBJ: Terminal 1 (idx 15): battery=84.60, running_total=150.20
DEBUG OBJ: Terminal 2 (idx 3): battery=83.50, running_total=233.70
DEBUG OBJ: Terminal 3 (idx 6): battery=40.60, running_total=274.30
DEBUG OBJ: Terminal 4 (idx 12): battery=61.00, running_total=335.30
DEBUG OBJ: Recalculated battery_score=335.300 for FST 20
DEBUG OBJ: FST 20: tree_cost=986439.144, battery_cost=335.300 (weighted=3353000.0), combined=4339439.1
DEBUG OBJ: Full_trees battery_score=0.000 for FST 21
DEBUG OBJ: Recalculating for FST 21 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 18): battery=29.20, running_total=29.20
DEBUG OBJ: Terminal 1 (idx 17): battery=54.60, running_total=83.80
DEBUG OBJ: Recalculated battery_score=83.800 for FST 21
DEBUG OBJ: FST 21: tree_cost=46859.249, battery_cost=83.800 (weighted=838000.0), combined=884859.2
DEBUG OBJ: Full_trees battery_score=0.000 for FST 22
DEBUG OBJ: Recalculating for FST 22 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 15): battery=84.60, running_total=84.60
DEBUG OBJ: Terminal 1 (idx 3): battery=83.50, running_total=168.10
DEBUG OBJ: Recalculated battery_score=168.100 for FST 22
DEBUG OBJ: FST 22: tree_cost=52662.185, battery_cost=168.100 (weighted=1681000.0), combined=1733662.2
DEBUG OBJ: Full_trees battery_score=0.000 for FST 23
DEBUG OBJ: Recalculating for FST 23 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 16): battery=46.00, running_total=46.00
DEBUG OBJ: Terminal 1 (idx 2): battery=69.70, running_total=115.70
DEBUG OBJ: Recalculated battery_score=115.700 for FST 23
DEBUG OBJ: FST 23: tree_cost=62275.339, battery_cost=115.700 (weighted=1157000.0), combined=1219275.3
DEBUG OBJ: Full_trees battery_score=0.000 for FST 24
DEBUG OBJ: Recalculating for FST 24 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 16): battery=46.00, running_total=46.00
DEBUG OBJ: Terminal 1 (idx 1): battery=80.60, running_total=126.60
DEBUG OBJ: Recalculated battery_score=126.600 for FST 24
DEBUG OBJ: FST 24: tree_cost=75379.993, battery_cost=126.600 (weighted=1266000.0), combined=1341380.0
DEBUG OBJ: Full_trees battery_score=0.000 for FST 25
DEBUG OBJ: Recalculating for FST 25 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 18): battery=29.20, running_total=29.20
DEBUG OBJ: Terminal 1 (idx 9): battery=54.10, running_total=83.30
DEBUG OBJ: Recalculated battery_score=83.300 for FST 25
DEBUG OBJ: FST 25: tree_cost=75695.846, battery_cost=83.300 (weighted=833000.0), combined=908695.8
DEBUG OBJ: Full_trees battery_score=0.000 for FST 26
DEBUG OBJ: Recalculating for FST 26 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 14): battery=68.30, running_total=68.30
DEBUG OBJ: Terminal 1 (idx 19): battery=65.60, running_total=133.90
DEBUG OBJ: Recalculated battery_score=133.900 for FST 26
DEBUG OBJ: FST 26: tree_cost=80703.013, battery_cost=133.900 (weighted=1339000.0), combined=1419703.0
DEBUG OBJ: Full_trees battery_score=0.000 for FST 27
DEBUG OBJ: Recalculating for FST 27 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 0): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 13): battery=27.90, running_total=127.90
DEBUG OBJ: Recalculated battery_score=127.900 for FST 27
DEBUG OBJ: FST 27: tree_cost=93734.596, battery_cost=127.900 (weighted=1279000.0), combined=1372734.6
DEBUG OBJ: Full_trees battery_score=0.000 for FST 28
DEBUG OBJ: Recalculating for FST 28 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 8): battery=56.90, running_total=56.90
DEBUG OBJ: Terminal 1 (idx 7): battery=41.20, running_total=98.10
DEBUG OBJ: Recalculated battery_score=98.100 for FST 28
DEBUG OBJ: FST 28: tree_cost=95452.578, battery_cost=98.100 (weighted=981000.0), combined=1076452.6
DEBUG OBJ: Full_trees battery_score=0.000 for FST 29
DEBUG OBJ: Recalculating for FST 29 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 5): battery=35.50, running_total=35.50
DEBUG OBJ: Terminal 1 (idx 10): battery=38.20, running_total=73.70
DEBUG OBJ: Recalculated battery_score=73.700 for FST 29
DEBUG OBJ: FST 29: tree_cost=102977.757, battery_cost=73.700 (weighted=737000.0), combined=839977.8
DEBUG OBJ: Full_trees battery_score=0.000 for FST 30
DEBUG OBJ: Recalculating for FST 30 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 4): battery=71.30, running_total=71.30
DEBUG OBJ: Terminal 1 (idx 5): battery=35.50, running_total=106.80
DEBUG OBJ: Recalculated battery_score=106.800 for FST 30
DEBUG OBJ: FST 30: tree_cost=165327.925, battery_cost=106.800 (weighted=1068000.0), combined=1233327.9
DEBUG OBJ: Full_trees battery_score=0.000 for FST 31
DEBUG OBJ: Recalculating for FST 31 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 6): battery=40.60, running_total=40.60
DEBUG OBJ: Terminal 1 (idx 0): battery=100.00, running_total=140.60
DEBUG OBJ: Recalculated battery_score=140.600 for FST 31
DEBUG OBJ: FST 31: tree_cost=170420.027, battery_cost=140.600 (weighted=1406000.0), combined=1576420.0
DEBUG OBJ: Full_trees battery_score=0.000 for FST 32
DEBUG OBJ: Recalculating for FST 32 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 13): battery=27.90, running_total=27.90
DEBUG OBJ: Terminal 1 (idx 4): battery=71.30, running_total=99.20
DEBUG OBJ: Recalculated battery_score=99.200 for FST 32
DEBUG OBJ: FST 32: tree_cost=179069.657, battery_cost=99.200 (weighted=992000.0), combined=1171069.7
DEBUG OBJ: Full_trees battery_score=0.000 for FST 33
DEBUG OBJ: Recalculating for FST 33 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 5): battery=35.50, running_total=35.50
DEBUG OBJ: Terminal 1 (idx 1): battery=80.60, running_total=116.10
DEBUG OBJ: Recalculated battery_score=116.100 for FST 33
DEBUG OBJ: FST 33: tree_cost=234458.486, battery_cost=116.100 (weighted=1161000.0), combined=1395458.5
DEBUG OBJ: Full_trees battery_score=0.000 for FST 34
DEBUG OBJ: Recalculating for FST 34 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 11): battery=0.00, running_total=0.00
DEBUG OBJ: Terminal 1 (idx 9): battery=54.10, running_total=54.10
DEBUG OBJ: Recalculated battery_score=54.100 for FST 34
DEBUG OBJ: FST 34: tree_cost=235891.713, battery_cost=54.100 (weighted=541000.0), combined=776891.7
DEBUG OBJ: Full_trees battery_score=0.000 for FST 35
DEBUG OBJ: Recalculating for FST 35 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 9): battery=54.10, running_total=54.10
DEBUG OBJ: Terminal 1 (idx 7): battery=41.20, running_total=95.30
DEBUG OBJ: Recalculated battery_score=95.300 for FST 35
DEBUG OBJ: FST 35: tree_cost=242462.956, battery_cost=95.300 (weighted=953000.0), combined=1195463.0
DEBUG OBJ: Full_trees battery_score=0.000 for FST 36
DEBUG OBJ: Recalculating for FST 36 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 2): battery=69.70, running_total=69.70
DEBUG OBJ: Terminal 1 (idx 11): battery=0.00, running_total=69.70
DEBUG OBJ: Recalculated battery_score=69.700 for FST 36
DEBUG OBJ: FST 36: tree_cost=258947.370, battery_cost=69.700 (weighted=697000.0), combined=955947.4
DEBUG OBJ: Full_trees battery_score=0.000 for FST 37
DEBUG OBJ: Recalculating for FST 37 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 19): battery=65.60, running_total=65.60
DEBUG OBJ: Terminal 1 (idx 12): battery=61.00, running_total=126.60
DEBUG OBJ: Recalculated battery_score=126.600 for FST 37
DEBUG OBJ: FST 37: tree_cost=313063.098, battery_cost=126.600 (weighted=1266000.0), combined=1579063.1
DEBUG OBJ: Full_trees battery_score=0.000 for FST 38
DEBUG OBJ: Recalculating for FST 38 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 15): battery=84.60, running_total=84.60
DEBUG OBJ: Terminal 1 (idx 19): battery=65.60, running_total=150.20
DEBUG OBJ: Recalculated battery_score=150.200 for FST 38
DEBUG OBJ: FST 38: tree_cost=314219.517, battery_cost=150.200 (weighted=1502000.0), combined=1816219.5
DEBUG OBJ: Full_trees battery_score=0.000 for FST 39
DEBUG OBJ: Recalculating for FST 39 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 3): battery=83.50, running_total=83.50
DEBUG OBJ: Terminal 1 (idx 6): battery=40.60, running_total=124.10
DEBUG OBJ: Recalculated battery_score=124.100 for FST 39
DEBUG OBJ: FST 39: tree_cost=327174.269, battery_cost=124.100 (weighted=1241000.0), combined=1568174.3
DEBUG OBJ: Added penalty terms beta=1500000 for 20 not_covered variables [41-60]
DEBUG LP_MATRIX: LP has 0 rows, 60 columns after setup
DEBUG EXTRA_COEFF: Calculated extra_coeff=1 for 135 rows
DEBUG SOFT: Added not_covered_0 (RC_var 43 -> matrix_idx 40) to soft constraint 134
DEBUG MATRIX_CHECK: nzi=495, ncoeff=514, extra_coeff=1, expected=515
ERROR: Matrix coefficient count mismatch! nzi=495 != ncoeff=514 + extra_coeff=1
WARNING: Allowing discrepancy in budget mode (nzi=495 vs expected=515)
DEBUG MATRIX: Total matrix has 495 entries (nzi=495)
DEBUG MATRIX: matbeg[135] = 495 (should equal nzi)
DEBUG LP: Calling add_rows with 135 rows
DEBUG LP: Before add_rows: LP has 0 rows, 60 cols, 60 nonzeros
DEBUG LP: After add_rows: LP has 135 rows, 60 cols, 555 nonzeros
DEBUG NLPROWS: nrows=135, extra_rows=0, setting nlprows=135
 % _gst_build_initial_formulation: 0.00 seconds.
DEBUG BB: Expected nlprows=135, total rows=163
DEBUG BB: Row 0 (uid=0) has lprow=0 (included, j=0)
DEBUG BB: Row 1 (uid=1) has lprow=1 (included, j=1)
DEBUG BB: Row 2 (uid=2) has lprow=2 (included, j=2)
DEBUG BB: Row 3 (uid=3) has lprow=3 (included, j=3)
DEBUG BB: Row 4 (uid=4) has lprow=4 (included, j=4)
DEBUG BB: Row 5 (uid=5) has lprow=5 (included, j=5)
DEBUG BB: Row 6 (uid=6) has lprow=6 (included, j=6)
DEBUG BB: Row 7 (uid=7) has lprow=7 (included, j=7)
DEBUG BB: Row 8 (uid=8) has lprow=8 (included, j=8)
DEBUG BB: Row 9 (uid=9) has lprow=9 (included, j=9)
DEBUG BB: Row 10 (uid=10) has lprow=10 (included, j=10)
DEBUG BB: Row 11 (uid=11) has lprow=11 (included, j=11)
DEBUG BB: Row 12 (uid=12) has lprow=12 (included, j=12)
DEBUG BB: Row 13 (uid=13) has lprow=13 (included, j=13)
DEBUG BB: Row 14 (uid=14) has lprow=14 (included, j=14)
DEBUG BB: Row 15 (uid=15) has lprow=15 (included, j=15)
DEBUG BB: Row 16 (uid=16) has lprow=16 (included, j=16)
DEBUG BB: Row 17 (uid=17) has lprow=17 (included, j=17)
DEBUG BB: Row 18 (uid=18) has lprow=18 (included, j=18)
DEBUG BB: Row 19 (uid=19) has lprow=19 (included, j=19)
DEBUG BB: Row 20 (uid=20) has lprow=20 (included, j=20)
DEBUG BB: Row 21 (uid=21) has lprow=21 (included, j=21)
DEBUG BB: Row 22 (uid=22) has lprow=22 (included, j=22)
DEBUG BB: Row 23 (uid=23) has lprow=23 (included, j=23)
DEBUG BB: Row 24 (uid=24) has lprow=24 (included, j=24)
DEBUG BB: Row 25 (uid=25) has lprow=25 (included, j=25)
DEBUG BB: Row 26 (uid=26) has lprow=26 (included, j=26)
DEBUG BB: Row 27 (uid=27) has lprow=27 (included, j=27)
DEBUG BB: Row 28 (uid=28) has lprow=28 (included, j=28)
DEBUG BB: Row 29 (uid=29) has lprow=29 (included, j=29)
DEBUG BB: Row 30 (uid=30) has lprow=30 (included, j=30)
DEBUG BB: Row 31 (uid=31) has lprow=31 (included, j=31)
DEBUG BB: Row 32 (uid=32) has lprow=32 (included, j=32)
DEBUG BB: Row 33 (uid=33) has lprow=33 (included, j=33)
DEBUG BB: Row 34 (uid=34) has lprow=34 (included, j=34)
DEBUG BB: Row 35 (uid=35) has lprow=35 (included, j=35)
DEBUG BB: Row 36 (uid=36) has lprow=36 (included, j=36)
DEBUG BB: Row 37 (uid=37) has lprow=37 (included, j=37)
DEBUG BB: Row 38 (uid=38) has lprow=38 (included, j=38)
DEBUG BB: Row 39 (uid=39) has lprow=39 (included, j=39)
DEBUG BB: Row 40 (uid=40) has lprow=40 (included, j=40)
DEBUG BB: Row 41 (uid=41) has lprow=41 (included, j=41)
DEBUG BB: Row 42 (uid=42) has lprow=42 (included, j=42)
DEBUG BB: Row 43 (uid=43) has lprow=43 (included, j=43)
DEBUG BB: Row 44 (uid=44) has lprow=44 (included, j=44)
DEBUG BB: Row 45 (uid=45) has lprow=45 (included, j=45)
DEBUG BB: Row 46 (uid=46) has lprow=46 (included, j=46)
DEBUG BB: Row 47 (uid=47) has lprow=47 (included, j=47)
DEBUG BB: Row 48 (uid=48) has lprow=48 (included, j=48)
DEBUG BB: Row 49 (uid=49) has lprow=49 (included, j=49)
DEBUG BB: Row 50 (uid=50) has lprow=50 (included, j=50)
DEBUG BB: Row 51 (uid=51) has lprow=51 (included, j=51)
DEBUG BB: Row 52 (uid=52) has lprow=52 (included, j=52)
DEBUG BB: Row 53 (uid=53) has lprow=53 (included, j=53)
DEBUG BB: Row 54 (uid=54) has lprow=54 (included, j=54)
DEBUG BB: Row 55 (uid=55) has lprow=55 (included, j=55)
DEBUG BB: Row 56 (uid=56) has lprow=56 (included, j=56)
DEBUG BB: Row 57 (uid=57) has lprow=57 (included, j=57)
DEBUG BB: Row 58 (uid=58) has lprow=58 (included, j=58)
DEBUG BB: Row 59 (uid=59) has lprow=59 (included, j=59)
DEBUG BB: Row 60 (uid=60) has lprow=60 (included, j=60)
DEBUG BB: Row 61 (uid=61) has lprow=61 (included, j=61)
DEBUG BB: Row 62 (uid=62) has lprow=62 (included, j=62)
DEBUG BB: Row 63 (uid=63) has lprow=63 (included, j=63)
DEBUG BB: Row 64 (uid=64) has lprow=64 (included, j=64)
DEBUG BB: Row 65 (uid=65) has lprow=65 (included, j=65)
DEBUG BB: Row 66 (uid=66) has lprow=66 (included, j=66)
DEBUG BB: Row 67 (uid=67) has lprow=67 (included, j=67)
DEBUG BB: Row 68 (uid=68) has lprow=68 (included, j=68)
DEBUG BB: Row 69 (uid=69) has lprow=69 (included, j=69)
DEBUG BB: Row 70 (uid=70) has lprow=70 (included, j=70)
DEBUG BB: Row 71 (uid=71) has lprow=71 (included, j=71)
DEBUG BB: Row 72 (uid=72) has lprow=72 (included, j=72)
DEBUG BB: Row 73 (uid=73) has lprow=73 (included, j=73)
DEBUG BB: Row 74 (uid=74) has lprow=74 (included, j=74)
DEBUG BB: Row 75 (uid=75) has lprow=75 (included, j=75)
DEBUG BB: Row 76 (uid=76) has lprow=76 (included, j=76)
DEBUG BB: Row 77 (uid=77) has lprow=77 (included, j=77)
DEBUG BB: Row 78 (uid=78) has lprow=78 (included, j=78)
DEBUG BB: Row 79 (uid=79) has lprow=79 (included, j=79)
DEBUG BB: Row 80 (uid=80) has lprow=80 (included, j=80)
DEBUG BB: Row 81 (uid=81) has lprow=81 (included, j=81)
DEBUG BB: Row 82 (uid=82) has lprow=82 (included, j=82)
DEBUG BB: Row 83 (uid=83) has lprow=83 (included, j=83)
DEBUG BB: Row 84 (uid=84) has lprow=84 (included, j=84)
DEBUG BB: Row 85 (uid=85) has lprow=85 (included, j=85)
DEBUG BB: Row 86 (uid=86) has lprow=86 (included, j=86)
DEBUG BB: Row 87 (uid=87) has lprow=87 (included, j=87)
DEBUG BB: Row 88 (uid=88) has lprow=88 (included, j=88)
DEBUG BB: Row 89 (uid=89) has lprow=89 (included, j=89)
DEBUG BB: Row 90 (uid=90) has lprow=90 (included, j=90)
DEBUG BB: Row 91 (uid=91) has lprow=91 (included, j=91)
DEBUG BB: Row 92 (uid=92) has lprow=92 (included, j=92)
DEBUG BB: Row 93 (uid=93) has lprow=93 (included, j=93)
DEBUG BB: Row 94 (uid=94) has lprow=94 (included, j=94)
DEBUG BB: Row 95 (uid=95) has lprow=95 (included, j=95)
DEBUG BB: Row 96 (uid=96) has lprow=96 (included, j=96)
DEBUG BB: Row 97 (uid=97) has lprow=97 (included, j=97)
DEBUG BB: Row 98 (uid=98) has lprow=98 (included, j=98)
DEBUG BB: Row 99 (uid=99) has lprow=99 (included, j=99)
DEBUG BB: Row 100 (uid=100) has lprow=100 (included, j=100)
DEBUG BB: Row 101 (uid=101) has lprow=101 (included, j=101)
DEBUG BB: Row 102 (uid=102) has lprow=102 (included, j=102)
DEBUG BB: Row 103 (uid=103) has lprow=103 (included, j=103)
DEBUG BB: Row 104 (uid=104) has lprow=104 (included, j=104)
DEBUG BB: Row 105 (uid=105) has lprow=105 (included, j=105)
DEBUG BB: Row 106 (uid=106) has lprow=106 (included, j=106)
DEBUG BB: Row 107 (uid=107) has lprow=107 (included, j=107)
DEBUG BB: Row 108 (uid=108) has lprow=108 (included, j=108)
DEBUG BB: Row 109 (uid=109) has lprow=109 (included, j=109)
DEBUG BB: Row 110 (uid=110) has lprow=110 (included, j=110)
DEBUG BB: Row 111 (uid=111) has lprow=111 (included, j=111)
DEBUG BB: Row 112 (uid=112) has lprow=112 (included, j=112)
DEBUG BB: Row 113 (uid=113) has lprow=113 (included, j=113)
DEBUG BB: Row 114 (uid=114) has lprow=114 (included, j=114)
DEBUG BB: Row 115 (uid=115) has lprow=115 (included, j=115)
DEBUG BB: Row 116 (uid=116) has lprow=116 (included, j=116)
DEBUG BB: Row 117 (uid=117) has lprow=117 (included, j=117)
DEBUG BB: Row 118 (uid=118) has lprow=118 (included, j=118)
DEBUG BB: Row 119 (uid=119) has lprow=119 (included, j=119)
DEBUG BB: Row 120 (uid=120) has lprow=120 (included, j=120)
DEBUG BB: Row 121 (uid=121) has lprow=121 (included, j=121)
DEBUG BB: Row 122 (uid=122) has lprow=122 (included, j=122)
DEBUG BB: Row 123 (uid=123) has lprow=123 (included, j=123)
DEBUG BB: Row 124 (uid=124) has lprow=124 (included, j=124)
DEBUG BB: Row 125 (uid=125) has lprow=125 (included, j=125)
DEBUG BB: Row 126 (uid=126) has lprow=126 (included, j=126)
DEBUG BB: Row 127 (uid=127) has lprow=127 (included, j=127)
DEBUG BB: Row 128 (uid=128) has lprow=128 (included, j=128)
DEBUG BB: Row 129 (uid=129) has lprow=129 (included, j=129)
DEBUG BB: Row 130 (uid=130) has lprow=130 (included, j=130)
DEBUG BB: Row 131 (uid=131) has lprow=131 (included, j=131)
DEBUG BB: Row 132 (uid=132) has lprow=132 (included, j=132)
DEBUG BB: Row 133 (uid=133) has lprow=-1 (skipped)
DEBUG BB: Row 134 (uid=134) has lprow=-1 (skipped)
DEBUG BB: Row 135 (uid=135) has lprow=-1 (skipped)
DEBUG BB: Row 136 (uid=136) has lprow=-1 (skipped)
DEBUG BB: Row 137 (uid=137) has lprow=-1 (skipped)
DEBUG BB: Row 138 (uid=138) has lprow=-1 (skipped)
DEBUG BB: Row 139 (uid=139) has lprow=-1 (skipped)
DEBUG BB: Row 140 (uid=140) has lprow=-1 (skipped)
DEBUG BB: Row 141 (uid=141) has lprow=-1 (skipped)
DEBUG BB: Row 142 (uid=142) has lprow=-1 (skipped)
DEBUG BB: Row 143 (uid=143) has lprow=-1 (skipped)
DEBUG BB: Row 144 (uid=144) has lprow=-1 (skipped)
DEBUG BB: Row 145 (uid=145) has lprow=-1 (skipped)
DEBUG BB: Row 146 (uid=146) has lprow=-1 (skipped)
DEBUG BB: Row 147 (uid=147) has lprow=-1 (skipped)
DEBUG BB: Row 148 (uid=148) has lprow=-1 (skipped)
DEBUG BB: Row 149 (uid=149) has lprow=-1 (skipped)
DEBUG BB: Row 150 (uid=150) has lprow=-1 (skipped)
DEBUG BB: Row 151 (uid=151) has lprow=-1 (skipped)
DEBUG BB: Row 152 (uid=152) has lprow=-1 (skipped)
DEBUG BB: Row 153 (uid=153) has lprow=-1 (skipped)
DEBUG BB: Row 154 (uid=154) has lprow=-1 (skipped)
DEBUG BB: Row 155 (uid=155) has lprow=-1 (skipped)
DEBUG BB: Row 156 (uid=156) has lprow=-1 (skipped)
DEBUG BB: Row 157 (uid=157) has lprow=-1 (skipped)
DEBUG BB: Row 158 (uid=158) has lprow=-1 (skipped)
DEBUG BB: Row 159 (uid=159) has lprow=-1 (skipped)
DEBUG BB: Row 160 (uid=160) has lprow=-1 (skipped)
DEBUG BB: Row 161 (uid=161) has lprow=133 (included, j=133)
DEBUG BB: Row 162 (uid=162) has lprow=134 (included, j=134)
DEBUG BB: Found 135 actual LP rows, expected 135
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ff1996d600
% Resuming node 0
DEBUG CONSTRNT: LP rows=135, pool->nlprows=135, pool->npend=0
DEBUG CONSTRNT: Checking 135 LP rows (pool tracks 135, total LP rows 135)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 1
DEBUG CONSTRNT: Pool row 1 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 2
DEBUG CONSTRNT: Pool row 2 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 3
DEBUG CONSTRNT: Pool row 3 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 4
DEBUG CONSTRNT: Pool row 4 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=56, expected 56
DEBUG CONSTRNT: Checking LP row 57 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=57, expected 57
DEBUG CONSTRNT: Checking LP row 58 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=58, expected 58
DEBUG CONSTRNT: Checking LP row 59 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=59, expected 59
DEBUG CONSTRNT: Checking LP row 60 -> pool row 60
DEBUG CONSTRNT: Pool row 60 has lprow=60, expected 60
DEBUG CONSTRNT: Checking LP row 61 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=61, expected 61
DEBUG CONSTRNT: Checking LP row 62 -> pool row 62
DEBUG CONSTRNT: Pool row 62 has lprow=62, expected 62
DEBUG CONSTRNT: Checking LP row 63 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=63, expected 63
DEBUG CONSTRNT: Checking LP row 64 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=64, expected 64
DEBUG CONSTRNT: Checking LP row 65 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=65, expected 65
DEBUG CONSTRNT: Checking LP row 66 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=66, expected 66
DEBUG CONSTRNT: Checking LP row 67 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=67, expected 67
DEBUG CONSTRNT: Checking LP row 68 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=68, expected 68
DEBUG CONSTRNT: Checking LP row 69 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=69, expected 69
DEBUG CONSTRNT: Checking LP row 70 -> pool row 70
DEBUG CONSTRNT: Pool row 70 has lprow=70, expected 70
DEBUG CONSTRNT: Checking LP row 71 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=71, expected 71
DEBUG CONSTRNT: Checking LP row 72 -> pool row 72
DEBUG CONSTRNT: Pool row 72 has lprow=72, expected 72
DEBUG CONSTRNT: Checking LP row 73 -> pool row 73
DEBUG CONSTRNT: Pool row 73 has lprow=73, expected 73
DEBUG CONSTRNT: Checking LP row 74 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=74, expected 74
DEBUG CONSTRNT: Checking LP row 75 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=75, expected 75
DEBUG CONSTRNT: Checking LP row 76 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=76, expected 76
DEBUG CONSTRNT: Checking LP row 77 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=77, expected 77
DEBUG CONSTRNT: Checking LP row 78 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=78, expected 78
DEBUG CONSTRNT: Checking LP row 79 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=79, expected 79
DEBUG CONSTRNT: Checking LP row 80 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=80, expected 80
DEBUG CONSTRNT: Checking LP row 81 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=81, expected 81
DEBUG CONSTRNT: Checking LP row 82 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=82, expected 82
DEBUG CONSTRNT: Checking LP row 83 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=83, expected 83
DEBUG CONSTRNT: Checking LP row 84 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=84, expected 84
DEBUG CONSTRNT: Checking LP row 85 -> pool row 85
DEBUG CONSTRNT: Pool row 85 has lprow=85, expected 85
DEBUG CONSTRNT: Checking LP row 86 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=86, expected 86
DEBUG CONSTRNT: Checking LP row 87 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=87, expected 87
DEBUG CONSTRNT: Checking LP row 88 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=88, expected 88
DEBUG CONSTRNT: Checking LP row 89 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=89, expected 89
DEBUG CONSTRNT: Checking LP row 90 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=90, expected 90
DEBUG CONSTRNT: Checking LP row 91 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=91, expected 91
DEBUG CONSTRNT: Checking LP row 92 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=92, expected 92
DEBUG CONSTRNT: Checking LP row 93 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=93, expected 93
DEBUG CONSTRNT: Checking LP row 94 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=94, expected 94
DEBUG CONSTRNT: Checking LP row 95 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=95, expected 95
DEBUG CONSTRNT: Checking LP row 96 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=96, expected 96
DEBUG CONSTRNT: Checking LP row 97 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=97, expected 97
DEBUG CONSTRNT: Checking LP row 98 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=98, expected 98
DEBUG CONSTRNT: Checking LP row 99 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=99, expected 99
DEBUG CONSTRNT: Checking LP row 100 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=100, expected 100
DEBUG CONSTRNT: Checking LP row 101 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=101, expected 101
DEBUG CONSTRNT: Checking LP row 102 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=102, expected 102
DEBUG CONSTRNT: Checking LP row 103 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=103, expected 103
DEBUG CONSTRNT: Checking LP row 104 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=104, expected 104
DEBUG CONSTRNT: Checking LP row 105 -> pool row 105
DEBUG CONSTRNT: Pool row 105 has lprow=105, expected 105
DEBUG CONSTRNT: Checking LP row 106 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=106, expected 106
DEBUG CONSTRNT: Checking LP row 107 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=107, expected 107
DEBUG CONSTRNT: Checking LP row 108 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=108, expected 108
DEBUG CONSTRNT: Checking LP row 109 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=109, expected 109
DEBUG CONSTRNT: Checking LP row 110 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=110, expected 110
DEBUG CONSTRNT: Checking LP row 111 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=111, expected 111
DEBUG CONSTRNT: Checking LP row 112 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=112, expected 112
DEBUG CONSTRNT: Checking LP row 113 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=113, expected 113
DEBUG CONSTRNT: Checking LP row 114 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=114, expected 114
DEBUG CONSTRNT: Checking LP row 115 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=115, expected 115
DEBUG CONSTRNT: Checking LP row 116 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=116, expected 116
DEBUG CONSTRNT: Checking LP row 117 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=117, expected 117
DEBUG CONSTRNT: Checking LP row 118 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=118, expected 118
DEBUG CONSTRNT: Checking LP row 119 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=119, expected 119
DEBUG CONSTRNT: Checking LP row 120 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=120, expected 120
DEBUG CONSTRNT: Checking LP row 121 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=121, expected 121
DEBUG CONSTRNT: Checking LP row 122 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=122, expected 122
DEBUG CONSTRNT: Checking LP row 123 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=123, expected 123
DEBUG CONSTRNT: Checking LP row 124 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=124, expected 124
DEBUG CONSTRNT: Checking LP row 125 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=125, expected 125
DEBUG CONSTRNT: Checking LP row 126 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=126, expected 126
DEBUG CONSTRNT: Checking LP row 127 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=127, expected 127
DEBUG CONSTRNT: Checking LP row 128 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=128, expected 128
DEBUG CONSTRNT: Checking LP row 129 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=129, expected 129
DEBUG CONSTRNT: Checking LP row 130 -> pool row 130
DEBUG CONSTRNT: Pool row 130 has lprow=130, expected 130
DEBUG CONSTRNT: Checking LP row 131 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=131, expected 131
DEBUG CONSTRNT: Checking LP row 132 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=132, expected 132
DEBUG CONSTRNT: Checking LP row 133 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=133, expected 133
DEBUG CONSTRNT: Checking LP row 134 -> pool row 162
DEBUG CONSTRNT: Pool row 162 has lprow=134, expected 134
 % @PAP adding 135 rows, 494 nz to LP
DEBUG BB: Processing node 0, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=149, theta=6.333333, up=1.000000
ITER 2: row=1, varin=155, theta=4.000000, up=1.000000
ITER 3: row=1, varin=144, theta=6.000000, up=1.000000
ITER 4: row=1, varin=151, theta=3.333333, up=1.000000
ITER 5: row=1, varin=150, theta=2.333333, up=1.000000
ITER 6: row=1, varin=148, theta=2.000000, up=1.000000
ITER 7: row=1, varin=170, theta=2.000000, up=1.000000
ITER 8: row=1, varin=152, theta=0.333333, up=1.000000
ITER 9: row=134, varin=165, theta=17.736480, up=1.000000
ITER 10: row=134, varin=157, theta=11.719889, up=1.000000
LP PHASE: Switching to primal (iter=50)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=135)
DEBUG SOLUTION: LP solution array indices: FST[136-175], not_covered[176-195]
DEBUG SOLUTION: lp->best_solution[0] = 23992211.710439
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 0.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 3.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 135 rows, 60 cols, 554 nonzeros, 60 slack, 75 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 60 slack rows
  % @PAP adding 3 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=76, varin=104, theta=1.878369, up=1.000000
ITER 2: row=76, varin=108, theta=3.228546, up=1.000000
ITER 3: row=76, varin=91, theta=0.688073, up=1.000000
ITER 4: row=26, varin=124, theta=1.000000, up=1.000000
ITER 5: row=1, varin=135, theta=1.311927, up=1.000000
ITER 6: row=1, varin=136, theta=0.311927, up=1.000000
ITER 7: row=45, varin=129, theta=1.000000, up=1.000000
ITER 8: row=70, varin=137, theta=1.311927, up=1.000000
ITER 9: row=70, varin=138, theta=0.311927, up=1.000000
ITER 10: row=72, varin=137, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=13)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=78)
DEBUG SOLUTION: LP solution array indices: FST[79-118], not_covered[119-138]
DEBUG SOLUTION: lp->best_solution[0] = 24943118.684308
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 5.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 78 rows, 60 cols, 358 nonzeros, 11 slack, 67 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 11 slack rows
  % @PAP adding 4 rows, 11 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=68, varin=37, theta=0.657140, up=999999999999999983222784.000000
ITER 2: row=69, varin=61, theta=0.657140, up=999999999999999983222784.000000
ITER 3: row=1, varin=73, theta=0.327211, up=1.000000
ITER 4: row=20, varin=23, theta=1.394727, up=999999999999999983222784.000000
ITER 5: row=68, varin=95, theta=0.105020, up=1.000000
ITER 6: row=9, varin=100, theta=0.126081, up=1.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=71)
DEBUG SOLUTION: LP solution array indices: FST[72-111], not_covered[112-131]
DEBUG SOLUTION: lp->best_solution[0] = 24961491.654521
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 5.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 71 rows, 60 cols, 342 nonzeros, 5 slack, 66 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=67, varin=33, theta=0.288408, up=999999999999999983222784.000000
ITER 2: row=66, varin=58, theta=0.199587, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=67)
DEBUG SOLUTION: LP solution array indices: FST[68-107], not_covered[108-127]
DEBUG SOLUTION: lp->best_solution[0] = 24990140.464678
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 5.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 67 rows, 60 cols, 328 nonzeros, 3 slack, 64 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 3 rows, 9 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=67, varin=81, theta=0.107594, up=1.000000
ITER 2: row=38, varin=97, theta=0.223363, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=67)
DEBUG SOLUTION: LP solution array indices: FST[68-107], not_covered[108-127]
DEBUG SOLUTION: lp->best_solution[0] = 25003692.519715
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 5.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 67 rows, 60 cols, 331 nonzeros, 2 slack, 65 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 0 LP 1 Solution, length = 25003692.519715, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.223363 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.388318 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.611682 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.388318 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.776637 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.776637 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.223363 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.388318 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.388318 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.388318 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.223363 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.388318 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.388318 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=25003692.519715, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.00  25.00369251971535078383 99.9000000000
 % @LN 0.00  25.00369251971535078383 99.9000000000
DEBUG CG: Second cutoff check: z=25003692.519715, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 0 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 0
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.223363
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.223363)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.388318
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.388318)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.611682
DEBUG CAREFUL: Adding var 19 to fractional list (xi=0.611682)
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.388318
DEBUG CAREFUL: Adding var 28 to fractional list (xi=0.388318)
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.776637
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.776637)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 19
DEBUG CAREFUL: Calling compare_branch_vars for var 19
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 19
DEBUG CAREFUL: New best var: 19
DEBUG CAREFUL: Testing fvar[1] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 29
DEBUG CAREFUL: New best var: 29
DEBUG CAREFUL: Testing fvar[2] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[3] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
DEBUG CAREFUL: Testing fvar[4] = var 28
DEBUG CAREFUL: Calling compare_branch_vars for var 28
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 28
  % Initial guess is x29, Z0 = 25082742.8659638        , Z1 = 25003692.5197154        

DEBUG EVAL: Testing var 19 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=31, varin=38, theta=0.721796, up=999999999999999983222784.000000
ITER 2: row=1, varin=68, theta=1.746619, up=1.000000
ITER 3: row=1, varin=64, theta=0.277833, up=999999999999999983222784.000000
ITER 4: row=21, varin=68, theta=1.000000, up=1.000000
ITER 5: row=20, varin=90, theta=1.409748, up=1.000000
ITER 6: row=20, varin=88, theta=0.356645, up=1.000000
ITER 7: row=3, varin=90, theta=1.000000, up=1.000000
ITER 8: row=16, varin=67, theta=6.530087, up=1.000000
ITER 9: row=16, varin=93, theta=3.127934, up=1.000000
ITER 10: row=16, varin=96, theta=1.978741, up=1.000000
DEBUG EVAL: Branch var 19 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x19 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=31, varin=108, theta=5.440514, up=1.000000
ITER 2: row=31, varin=117, theta=0.733614, up=1.000000
ITER 3: row=20, varin=38, theta=2.260190, up=999999999999999983222784.000000
ITER 4: row=31, varin=63, theta=1.520379, up=999999999999999983222784.000000
ITER 5: row=65, varin=19, theta=0.520379, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=65)
DEBUG SOLUTION: LP solution array indices: FST[66-105], not_covered[106-125]
DEBUG SOLUTION: lp->best_solution[0] = 25114195.920357
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 65 rows, 60 cols, 327 nonzeros, 16 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 16 slack rows
   % @PAP adding 13 rows, 55 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=58, varin=46, theta=0.096938, up=999999999999999983222784.000000
ITER 2: row=52, varin=25, theta=0.100000, up=999999999999999983222784.000000
ITER 3: row=55, varin=26, theta=0.200000, up=999999999999999983222784.000000
ITER 4: row=59, varin=119, theta=1.000000, up=1.000000
ITER 5: row=61, varin=47, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=1, varin=114, theta=1.876558, up=1.000000
ITER 7: row=1, varin=121, theta=0.876558, up=1.000000
ITER 8: row=56, varin=58, theta=11.739810, up=999999999999999983222784.000000
ITER 9: row=1, varin=105, theta=0.612334, up=1.000000
ITER 10: row=51, varin=49, theta=0.488061, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=15)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=62)
DEBUG SOLUTION: LP solution array indices: FST[63-102], not_covered[103-122]
DEBUG SOLUTION: lp->best_solution[0] = 25125775.321765
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 6.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 62 rows, 60 cols, 339 nonzeros, 10 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 10 slack rows
   % @PAP adding 6 rows, 27 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=57, varin=73, theta=1.000000, up=1.000000
ITER 2: row=58, varin=117, theta=0.285714, up=1.000000
ITER 3: row=1, varin=58, theta=2.974958, up=999999999999999983222784.000000
ITER 4: row=55, varin=110, theta=0.244634, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=58)
DEBUG SOLUTION: LP solution array indices: FST[59-98], not_covered[99-118]
DEBUG SOLUTION: lp->best_solution[0] = 25154212.819836
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 6.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 58 rows, 60 cols, 315 nonzeros, 3 slack, 55 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 3 slack rows
   % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=57, varin=59, theta=0.154032, up=1.000000
ITER 2: row=52, varin=46, theta=0.161109, up=999999999999999983222784.000000
ITER 3: row=56, varin=6, theta=0.825414, up=999999999999999983222784.000000
ITER 4: row=6, varin=44, theta=0.229883, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 25158957.535892
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 6.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 57 rows, 60 cols, 300 nonzeros, 2 slack, 55 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 0 at  25.15895753589167327391
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ff1996d600
% @LO 0.00  25.00369251971535078383 99.9000000000
% @LN 0.00  25.15895753589167327391 99.9000000000
% Resuming node 0 at  25.15895753589167327391
DEBUG CONSTRNT: LP rows=55, pool->nlprows=55, pool->npend=0
DEBUG CONSTRNT: Checking 55 LP rows (pool tracks 55, total LP rows 55)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 143
DEBUG CONSTRNT: Pool row 143 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=54, expected 54
 % @PAP adding 55 rows, 236 nz to LP
DEBUG BB: Processing node 0, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 0 LP 2 Solution, length = 25158957.535892, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.590039 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.180078 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.409961 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.409961 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.409961 (FST 28)
  % DEBUG LP_VARS: x[29] = 1.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.590039 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.590039 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.409961 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.819922 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.409961 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.409961 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=25158957.535892, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=25158957.535892, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 0 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 0
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.590039
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.590039)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.180078
DEBUG CAREFUL: Adding var 13 to fractional list (xi=0.180078)
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.409961
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.409961)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.409961
DEBUG CAREFUL: Adding var 21 to fractional list (xi=0.409961)
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.409961
DEBUG CAREFUL: Adding var 28 to fractional list (xi=0.409961)
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=1.000000
DEBUG CAREFUL: Skipping var 29: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 14
DEBUG CAREFUL: New best var: 14
DEBUG CAREFUL: Testing fvar[1] = var 21
DEBUG CAREFUL: Calling compare_branch_vars for var 21
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 21
DEBUG CAREFUL: Testing fvar[2] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
DEBUG CAREFUL: Testing fvar[3] = var 28
DEBUG CAREFUL: Calling compare_branch_vars for var 28
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 28
DEBUG CAREFUL: Testing fvar[4] = var 13
DEBUG CAREFUL: Calling compare_branch_vars for var 13
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 13
DEBUG CAREFUL: New best var: 13
  % Initial guess is x13, Z0 = 25158957.5358917        , Z1 = 25432821.7849098        

DEBUG EVAL: Testing var 14 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=41, varin=79, theta=6.355745, up=1.000000
ITER 2: row=41, varin=50, theta=0.498460, up=999999999999999983222784.000000
ITER 3: row=6, varin=79, theta=1.000000, up=1.000000
ITER 4: row=14, varin=54, theta=4.146629, up=999999999999999983222784.000000
ITER 5: row=44, varin=98, theta=1.171184, up=1.000000
ITER 6: row=44, varin=25, theta=0.209854, up=999999999999999983222784.000000
ITER 7: row=40, varin=84, theta=2.282037, up=1.000000
ITER 8: row=40, varin=6, theta=1.965042, up=999999999999999983222784.000000
ITER 9: row=14, varin=44, theta=1.000000, up=999999999999999983222784.000000
ITER 10: row=6, varin=43, theta=0.230359, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 14 = 1 gives z=25334292.657970
  % 	x14 = 1,	Z1 = 25334292.6579705        
DEBUG EVAL: First branch cutoff check: z=25334292.657970, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 14 = 0
ITER 1: row=41, varin=100, theta=0.698975, up=1.000000
  % 	x14 = 0,	Z0 = 25169455.1345701        
DEBUG EVAL: Second branch cutoff check: z=25169455.134570, best_z=INF, threshold=INF
  %   New best:  x14, Z = 25169455.1345701        
DEBUG EVAL: Testing var 21 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=42, varin=100, theta=0.698975, up=1.000000
DEBUG EVAL: Branch var 21 = 0 gives z=25169455.134570
  % 	x21 = 0,	Z0 = 25169455.1345701        
DEBUG EVAL: First branch cutoff check: z=25169455.134570, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 21 = 1
ITER 1: row=42, varin=79, theta=6.355745, up=1.000000
ITER 2: row=42, varin=50, theta=0.498460, up=999999999999999983222784.000000
ITER 3: row=6, varin=79, theta=1.000000, up=1.000000
ITER 4: row=14, varin=54, theta=4.146629, up=999999999999999983222784.000000
ITER 5: row=45, varin=98, theta=1.171184, up=1.000000
ITER 6: row=45, varin=55, theta=0.155881, up=999999999999999983222784.000000
ITER 7: row=40, varin=46, theta=3.282037, up=999999999999999983222784.000000
ITER 8: row=45, varin=45, theta=2.282037, up=999999999999999983222784.000000
ITER 9: row=14, varin=44, theta=2.282037, up=999999999999999983222784.000000
ITER 10: row=40, varin=98, theta=0.775853, up=1.000000
  % 	x21 = 1,	Z1 = 25251673.054811         
DEBUG EVAL: Second branch cutoff check: z=25251673.054811, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 12 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=100, theta=0.698975, up=1.000000
DEBUG EVAL: Branch var 12 = 1 gives z=25169455.134570
  % 	x12 = 1,	Z1 = 25169455.1345701        
DEBUG EVAL: First branch cutoff check: z=25169455.134570, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 0
ITER 1: row=1, varin=79, theta=6.355745, up=1.000000
ITER 2: row=1, varin=50, theta=0.498460, up=999999999999999983222784.000000
ITER 3: row=6, varin=79, theta=1.000000, up=1.000000
ITER 4: row=14, varin=54, theta=4.146629, up=999999999999999983222784.000000
ITER 5: row=44, varin=98, theta=1.171184, up=1.000000
ITER 6: row=44, varin=25, theta=0.209854, up=999999999999999983222784.000000
ITER 7: row=40, varin=84, theta=2.282037, up=1.000000
ITER 8: row=40, varin=6, theta=1.965042, up=999999999999999983222784.000000
ITER 9: row=14, varin=44, theta=1.000000, up=999999999999999983222784.000000
ITER 10: row=6, varin=43, theta=0.230359, up=999999999999999983222784.000000
  % 	x12 = 0,	Z0 = 25251673.054811         
DEBUG EVAL: Second branch cutoff check: z=25251673.054811, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 28 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=44, varin=100, theta=0.698975, up=1.000000
DEBUG EVAL: Branch var 28 = 0 gives z=25169455.134570
  % 	x28 = 0,	Z0 = 25169455.1345701        
DEBUG EVAL: First branch cutoff check: z=25169455.134570, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 28 = 1
ITER 1: row=44, varin=54, theta=0.516539, up=999999999999999983222784.000000
ITER 2: row=45, varin=79, theta=6.355745, up=1.000000
ITER 3: row=45, varin=50, theta=0.498460, up=999999999999999983222784.000000
ITER 4: row=6, varin=79, theta=1.000000, up=1.000000
ITER 5: row=43, varin=55, theta=0.379873, up=999999999999999983222784.000000
ITER 6: row=40, varin=6, theta=0.336758, up=999999999999999983222784.000000
ITER 7: row=6, varin=85, theta=0.477109, up=1.000000
ITER 8: row=45, varin=43, theta=0.123169, up=999999999999999983222784.000000
  % 	x28 = 1,	Z1 = 25197323.1378077        
DEBUG EVAL: Second branch cutoff check: z=25197323.137808, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 13 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=40, varin=100, theta=4.738460, up=1.000000
ITER 2: row=40, varin=71, theta=1.144285, up=1.000000
ITER 3: row=40, varin=81, theta=0.084951, up=1.000000
ITER 4: row=52, varin=71, theta=2.800243, up=1.000000
ITER 5: row=52, varin=100, theta=2.755440, up=1.000000
ITER 6: row=52, varin=55, theta=0.641389, up=999999999999999983222784.000000
ITER 7: row=41, varin=43, theta=2.654413, up=999999999999999983222784.000000
ITER 8: row=14, varin=44, theta=1.807556, up=999999999999999983222784.000000
ITER 9: row=44, varin=50, theta=0.660164, up=999999999999999983222784.000000
ITER 10: row=50, varin=14, theta=1.664475, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 13 = 1 gives z=26048851.898938
  % 	x13 = 1,	Z1 = 26048851.8989381        
DEBUG EVAL: First branch cutoff check: z=26048851.898938, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 13 = 0
ITER 1: row=40, varin=79, theta=0.969876, up=1.000000
  % 	x13 = 0,	Z0 = 25160334.8848104        
DEBUG EVAL: Second branch cutoff check: z=25160334.884810, best_z=INF, threshold=INF
  % Best branch is x14, Z0 = 25169455.1345701        , Z1 = 25334292.6579705        

DEBUG CAREFUL: Final result - returning best.var = 14
DEBUG BB: Branching variable chosen: j=14
 % @NC    1    0	x14 = 0	25169455.134570
 % @NC    2    0	x14 = 1	25334292.657970
 %       0     2 25158957.5359               25169455.1346
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ff19975e70
% @LO 0.00  25.15895753589167327391 99.9000000000
% @LN 0.00  25.16945513457011429637 99.9000000000
% Resuming node 1 at  25.16945513457011429637
DEBUG CONSTRNT: LP rows=55, pool->nlprows=55, pool->npend=0
DEBUG CONSTRNT: Checking 55 LP rows (pool tracks 55, total LP rows 55)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 143
DEBUG CONSTRNT: Pool row 143 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=54, expected 54
 % @PAP adding 55 rows, 236 nz to LP
DEBUG BB: Processing node 1, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=100, theta=0.698975, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 25169455.134570
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 6.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 55 rows, 60 cols, 296 nonzeros, 1 slack, 54 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 7 rows, 28 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=56, varin=78, theta=0.090985, up=1.000000
ITER 2: row=58, varin=54, theta=0.044893, up=999999999999999983222784.000000
ITER 3: row=60, varin=55, theta=0.068865, up=999999999999999983222784.000000
ITER 4: row=57, varin=58, theta=1.840032, up=999999999999999983222784.000000
ITER 5: row=45, varin=65, theta=0.878066, up=1.000000
ITER 6: row=15, varin=44, theta=0.199390, up=999999999999999983222784.000000
ITER 7: row=59, varin=86, theta=2.197033, up=1.000000
ITER 8: row=59, varin=60, theta=0.381478, up=999999999999999983222784.000000
ITER 9: row=6, varin=86, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=9)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=62)
DEBUG SOLUTION: LP solution array indices: FST[63-102], not_covered[103-122]
DEBUG SOLUTION: lp->best_solution[0] = 25197824.227766
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 6.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 62 rows, 60 cols, 324 nonzeros, 5 slack, 57 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % Node 1 LP 1 Solution, length = 25197824.227766, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.808347 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.233388 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.191653 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.233388 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.500000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.766612 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.766612 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.191653 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.766612 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.191653 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.191653 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=25197824.227766, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.00  25.16945513457011429637 99.9000000000
 % @LN 0.00  25.19782422776582464508 99.9000000000
DEBUG CG: Second cutoff check: z=25197824.227766, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 1 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 1
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.500000
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.808347
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.808347)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.233388
DEBUG CAREFUL: Adding var 13 to fractional list (xi=0.233388)
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.191653
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.191653)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.233388
DEBUG CAREFUL: Adding var 28 to fractional list (xi=0.233388)
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.500000
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 1
DEBUG CAREFUL: New best var: 1
DEBUG CAREFUL: Testing fvar[1] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 29
DEBUG CAREFUL: Testing fvar[2] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 12
DEBUG CAREFUL: New best var: 12
DEBUG CAREFUL: Testing fvar[3] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 15
DEBUG CAREFUL: New best var: 15
DEBUG CAREFUL: Testing fvar[4] = var 13
DEBUG CAREFUL: Calling compare_branch_vars for var 13
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 13
DEBUG CAREFUL: New best var: 13
DEBUG CAREFUL: Testing fvar[5] = var 28
DEBUG CAREFUL: Calling compare_branch_vars for var 28
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 28
  % Initial guess is x13, Z0 = 25197824.2277658        , Z1 = 26048851.8989381        

DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=53, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 0 gives z=25218188.576086
  % 	x1 = 0,	Z0 = 25218188.5760856        
DEBUG EVAL: First branch cutoff check: z=25218188.576086, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 1
ITER 1: row=1, varin=14, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=56, varin=25, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=45, varin=6, theta=0.043477, up=999999999999999983222784.000000
ITER 4: row=47, varin=55, theta=0.005517, up=999999999999999983222784.000000
ITER 5: row=44, varin=15, theta=0.017376, up=999999999999999983222784.000000
ITER 6: row=15, varin=54, theta=0.006293, up=999999999999999983222784.000000
ITER 7: row=41, varin=83, theta=0.015055, up=1.000000
  % 	x1 = 1,	Z1 = 25301682.7469524        
DEBUG EVAL: Second branch cutoff check: z=25301682.746952, best_z=INF, threshold=INF
  %   New best:  x1, Z = 25218188.5760856        
DEBUG EVAL: Testing var 29 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=14, varin=14, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=56, varin=25, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=45, varin=6, theta=0.043477, up=999999999999999983222784.000000
ITER 4: row=47, varin=55, theta=0.005517, up=999999999999999983222784.000000
ITER 5: row=44, varin=15, theta=0.017376, up=999999999999999983222784.000000
ITER 6: row=15, varin=54, theta=0.006293, up=999999999999999983222784.000000
ITER 7: row=41, varin=43, theta=0.008422, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 29 = 0 gives z=25300347.169691
  % 	x29 = 0,	Z0 = 25300347.1696907        
DEBUG EVAL: First branch cutoff check: z=25300347.169691, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 29 = 1
ITER 1: row=14, varin=53, theta=1.000000, up=999999999999999983222784.000000
  % 	x29 = 1,	Z1 = 25218188.5760856        
DEBUG EVAL: Second branch cutoff check: z=25218188.576086, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 12 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=40, varin=104, theta=2.576457, up=1.000000
ITER 2: row=40, varin=82, theta=0.481222, up=1.000000
ITER 3: row=32, varin=104, theta=1.000000, up=1.000000
ITER 4: row=3, varin=6, theta=7.216604, up=999999999999999983222784.000000
ITER 5: row=47, varin=64, theta=0.468610, up=1.000000
DEBUG EVAL: Branch var 12 = 1 gives z=25310352.475808
  % 	x12 = 1,	Z1 = 25310352.4758076        
DEBUG EVAL: First branch cutoff check: z=25310352.475808, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 0
ITER 1: row=40, varin=15, theta=2.308132, up=999999999999999983222784.000000
ITER 2: row=15, varin=53, theta=3.338070, up=999999999999999983222784.000000
ITER 3: row=46, varin=50, theta=0.744835, up=999999999999999983222784.000000
ITER 4: row=14, varin=55, theta=13.909326, up=999999999999999983222784.000000
ITER 5: row=44, varin=100, theta=1.872386, up=1.000000
ITER 6: row=44, varin=54, theta=0.833392, up=999999999999999983222784.000000
ITER 7: row=41, varin=35, theta=3.886749, up=999999999999999983222784.000000
ITER 8: row=35, varin=52, theta=0.295583, up=999999999999999983222784.000000
ITER 9: row=44, varin=44, theta=0.295583, up=999999999999999983222784.000000
ITER 10: row=45, varin=6, theta=0.453055, up=999999999999999983222784.000000
  % 	x12 = 0,	Z0 = 25340399.460718         
DEBUG EVAL: Second branch cutoff check: z=25340399.460718, best_z=INF, threshold=INF
  %   New best:  x12, Z = 25310352.4758076        
DEBUG EVAL: Testing var 15 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=43, varin=15, theta=2.308132, up=999999999999999983222784.000000
ITER 2: row=15, varin=53, theta=3.338070, up=999999999999999983222784.000000
ITER 3: row=46, varin=50, theta=0.744835, up=999999999999999983222784.000000
ITER 4: row=14, varin=55, theta=13.909326, up=999999999999999983222784.000000
ITER 5: row=44, varin=100, theta=1.872386, up=1.000000
ITER 6: row=44, varin=54, theta=0.833392, up=999999999999999983222784.000000
ITER 7: row=41, varin=35, theta=3.886749, up=999999999999999983222784.000000
ITER 8: row=35, varin=52, theta=0.295583, up=999999999999999983222784.000000
ITER 9: row=44, varin=44, theta=0.295583, up=999999999999999983222784.000000
ITER 10: row=45, varin=6, theta=0.453055, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 15 = 1 gives z=25340399.460718
  % 	x15 = 1,	Z1 = 25340399.460718         
DEBUG EVAL: First branch cutoff check: z=25340399.460718, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 15 = 0
ITER 1: row=43, varin=83, theta=0.231831, up=1.000000
  % 	x15 = 0,	Z0 = 25225338.6787867        
DEBUG EVAL: Second branch cutoff check: z=25225338.678787, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 13 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=41, varin=6, theta=7.216604, up=999999999999999983222784.000000
ITER 2: row=6, varin=15, theta=2.884185, up=999999999999999983222784.000000
ITER 3: row=15, varin=83, theta=2.499018, up=1.000000
ITER 4: row=15, varin=43, theta=1.481742, up=999999999999999983222784.000000
ITER 5: row=43, varin=53, theta=3.000000, up=999999999999999983222784.000000
ITER 6: row=46, varin=83, theta=1.860593, up=1.000000
ITER 7: row=46, varin=45, theta=1.347993, up=999999999999999983222784.000000
ITER 8: row=43, varin=83, theta=0.940255, up=1.000000
ITER 9: row=45, varin=50, theta=0.475321, up=999999999999999983222784.000000
ITER 10: row=1, varin=14, theta=1.676640, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 13 = 1 gives z=26635960.150148
  % 	x13 = 1,	Z1 = 26635960.1501477        
DEBUG EVAL: First branch cutoff check: z=26635960.150148, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 13 = 0
ITER 1: row=41, varin=55, theta=1.433393, up=999999999999999983222784.000000
  % 	x13 = 0,	Z0 = 25206571.183231         
DEBUG EVAL: Second branch cutoff check: z=25206571.183231, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 28 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=45, varin=45, theta=0.248153, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 28 = 0 gives z=25211501.377367
  % 	x28 = 0,	Z0 = 25211501.3773665        
DEBUG EVAL: First branch cutoff check: z=25211501.377367, best_z=INF, threshold=INF
  % Best branch is x12, Z0 = 25340399.460718         , Z1 = 25310352.4758076        

DEBUG CAREFUL: Final result - returning best.var = 12
DEBUG BB: Branching variable chosen: j=12
 % @NC    3    1	x12 = 1	25310352.475808
 % @NC    4    1	x12 = 0	25340399.460718
 %       1     3 25197824.2278               25310352.4758   x14 D     0     1
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ff1996d600
% @LO 0.00  25.19782422776582464508 99.9000000000
% @LN 0.00  25.31035247580756930574 99.9000000000
% Resuming node 3 at  25.31035247580756930574
DEBUG CONSTRNT: LP rows=57, pool->nlprows=57, pool->npend=0
DEBUG CONSTRNT: Checking 57 LP rows (pool tracks 57, total LP rows 57)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 143
DEBUG CONSTRNT: Pool row 143 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=56, expected 56
 % @PAP adding 57 rows, 238 nz to LP
DEBUG BB: Processing node 3, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=104, theta=2.576457, up=1.000000
ITER 2: row=40, varin=82, theta=0.481222, up=1.000000
ITER 3: row=32, varin=104, theta=1.000000, up=1.000000
ITER 4: row=3, varin=6, theta=7.216604, up=999999999999999983222784.000000
ITER 5: row=47, varin=64, theta=0.468610, up=1.000000
LP PHASE: Switching to primal (iter=5)
ITER 6: row=15, varin=32, theta=0.000000, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 25310352.475808
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 6.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 57 rows, 60 cols, 298 nonzeros, 0 slack, 57 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 10 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=58, varin=43, theta=0.713092, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=60)
DEBUG SOLUTION: LP solution array indices: FST[61-100], not_covered[101-120]
DEBUG SOLUTION: lp->best_solution[0] = 25388859.117988
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 6.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 60 rows, 60 cols, 308 nonzeros, 2 slack, 58 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 3 LP 1 Solution, length = 25388859.117988, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.143454 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.333333 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.333333 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.333333 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.143454 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.856546 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.856546 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.666667 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.666667 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.856546 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.666667 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=25388859.117988, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 3 at  25.38885911798762506919
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ff1997a3c0
% @LO 0.00  25.31035247580756930574 99.9000000000
% @LN 0.00  25.33429265797047236219 99.9000000000
% Resuming node 2 at  25.33429265797047236219
DEBUG CONSTRNT: LP rows=58, pool->nlprows=58, pool->npend=0
DEBUG CONSTRNT: Checking 58 LP rows (pool tracks 58, total LP rows 58)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=56, expected 56
DEBUG CONSTRNT: Checking LP row 57 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=57, expected 57
 % @PAP adding 55 rows, 236 nz to LP
DEBUG BB: Processing node 2, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=79, theta=6.355745, up=1.000000
ITER 2: row=41, varin=50, theta=0.498460, up=999999999999999983222784.000000
ITER 3: row=6, varin=79, theta=1.000000, up=1.000000
ITER 4: row=14, varin=54, theta=4.146629, up=999999999999999983222784.000000
ITER 5: row=44, varin=98, theta=1.171184, up=1.000000
ITER 6: row=44, varin=25, theta=0.209854, up=999999999999999983222784.000000
ITER 7: row=40, varin=84, theta=2.282037, up=1.000000
ITER 8: row=40, varin=6, theta=1.965042, up=999999999999999983222784.000000
ITER 9: row=14, varin=44, theta=1.000000, up=999999999999999983222784.000000
ITER 10: row=6, varin=43, theta=0.230359, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=12)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 25334292.657970
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 6.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.416394
  % @PL 55 rows, 60 cols, 296 nonzeros, 5 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 7 rows, 34 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=57, varin=48, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=51, varin=41, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=53, varin=44, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=1, varin=103, theta=1.333333, up=1.000000
ITER 5: row=1, varin=86, theta=0.333333, up=1.000000
ITER 6: row=55, varin=57, theta=4.000000, up=999999999999999983222784.000000
ITER 7: row=38, varin=40, theta=1.121940, up=999999999999999983222784.000000
ITER 8: row=54, varin=82, theta=0.284661, up=1.000000
ITER 9: row=3, varin=80, theta=0.133536, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 6.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.416394
  % @PL 57 rows, 60 cols, 320 nonzeros, 6 slack, 51 tight.
  % Node 2 LP 1 Solution, length = 999999999999999983222784.000000, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 1.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 1.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.416394 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.583606 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 2 is INFEASIBLE
 %       2     2    infeasible               25340399.4607   x14 U     0     1
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ff19984250
% @LO 0.00  25.33429265797047236219 99.9000000000
% @LN 0.00  25.34039946071801807648 99.9000000000
% Resuming node 4 at  25.34039946071801807648
DEBUG CONSTRNT: LP rows=57, pool->nlprows=57, pool->npend=0
DEBUG CONSTRNT: Checking 57 LP rows (pool tracks 57, total LP rows 57)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 73
DEBUG CONSTRNT: Pool row 73 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=56, expected 56
 % @PAP adding 57 rows, 238 nz to LP
DEBUG BB: Processing node 4, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=15, theta=2.308132, up=999999999999999983222784.000000
ITER 2: row=15, varin=53, theta=3.338070, up=999999999999999983222784.000000
ITER 3: row=46, varin=50, theta=0.744835, up=999999999999999983222784.000000
ITER 4: row=14, varin=55, theta=13.909326, up=999999999999999983222784.000000
ITER 5: row=44, varin=100, theta=1.872386, up=1.000000
ITER 6: row=44, varin=54, theta=0.833392, up=999999999999999983222784.000000
ITER 7: row=41, varin=35, theta=3.886749, up=999999999999999983222784.000000
ITER 8: row=35, varin=52, theta=0.295583, up=999999999999999983222784.000000
ITER 9: row=44, varin=44, theta=0.295583, up=999999999999999983222784.000000
ITER 10: row=45, varin=6, theta=0.453055, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=10)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 25340399.460718
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.546945
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 6.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 57 rows, 60 cols, 298 nonzeros, 9 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 8 rows, 45 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=58, varin=54, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=65, varin=108, theta=1.166667, up=1.000000
ITER 3: row=65, varin=119, theta=0.166667, up=1.000000
ITER 4: row=60, varin=46, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=62, varin=49, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=35, varin=95, theta=0.388889, up=1.000000
ITER 7: row=64, varin=91, theta=0.714286, up=1.000000
ITER 8: row=6, varin=79, theta=0.478167, up=1.000000
ITER 9: row=55, varin=94, theta=0.393884, up=1.000000
ITER 10: row=35, varin=65, theta=1.457001, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=10)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=65)
DEBUG SOLUTION: LP solution array indices: FST[66-105], not_covered[106-125]
DEBUG SOLUTION: lp->best_solution[0] = 25384450.582370
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 6.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 65 rows, 60 cols, 343 nonzeros, 12 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 12 slack rows
  % @PAP adding 4 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=54, varin=87, theta=0.009155, up=1.000000
ITER 2: row=47, varin=6, theta=0.119414, up=999999999999999983222784.000000
ITER 3: row=6, varin=102, theta=0.015211, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 25384973.319350
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 6.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 57 rows, 60 cols, 297 nonzeros, 0 slack, 57 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 4 LP 1 Solution, length = 25384973.319350, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.015211 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.234789 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.500000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.500000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.500000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.234789 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.984789 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.984789 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.015211 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.765211 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.015211 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.765211 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=25384973.319350, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.00  25.34039946071801807648 99.9000000000
 % @LN 0.00  25.38497331934953393784 99.9000000000
DEBUG CG: Second cutoff check: z=25384973.319350, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 4 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 4
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.015211
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.015211)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.234789
DEBUG CAREFUL: Adding var 13 to fractional list (xi=0.234789)
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.500000
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.500000
DEBUG CAREFUL: Adding var 21 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.500000
DEBUG CAREFUL: Adding var 25 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.234789
DEBUG CAREFUL: Adding var 28 to fractional list (xi=0.234789)
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.984789
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.984789)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 7 fractional variables

  %  Carefully choosing branching variable, nfrac = 7
DEBUG CAREFUL: Testing fvar[0] = var 25
DEBUG CAREFUL: Calling compare_branch_vars for var 25
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 25
DEBUG CAREFUL: New best var: 25
DEBUG CAREFUL: Testing fvar[1] = var 21
DEBUG CAREFUL: Calling compare_branch_vars for var 21
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 21
DEBUG CAREFUL: Testing fvar[2] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 15
DEBUG CAREFUL: Testing fvar[3] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 29
DEBUG CAREFUL: New best var: 29
DEBUG CAREFUL: Testing fvar[4] = var 13
DEBUG CAREFUL: Calling compare_branch_vars for var 13
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 13
DEBUG CAREFUL: New best var: 13
DEBUG CAREFUL: Testing fvar[5] = var 28
DEBUG CAREFUL: Calling compare_branch_vars for var 28
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 28
DEBUG CAREFUL: Testing fvar[6] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
  % Initial guess is x13, Z0 = 25384973.3193495        , Z1 = 26635960.1501477        

DEBUG EVAL: Testing var 25 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=43, varin=51, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=55, varin=52, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=56, varin=53, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 25 = 1 gives z=25474912.180821
  % 	x25 = 1,	Z1 = 25474912.1808209        
DEBUG EVAL: First branch cutoff check: z=25474912.180821, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 25 = 0
ITER 1: row=43, varin=54, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=60, theta=0.438827, up=1.000000
ITER 3: row=15, varin=41, theta=0.128622, up=999999999999999983222784.000000
ITER 4: row=49, varin=49, theta=0.142775, up=999999999999999983222784.000000
ITER 5: row=52, varin=15, theta=0.238087, up=999999999999999983222784.000000
ITER 6: row=1, varin=48, theta=0.120770, up=999999999999999983222784.000000
ITER 7: row=40, varin=59, theta=0.261281, up=1.000000
  % 	x25 = 0,	Z0 = 25481470.9489217        
DEBUG EVAL: Second branch cutoff check: z=25481470.948922, best_z=INF, threshold=INF
  %   New best:  x25, Z = 25474912.1808209        
DEBUG EVAL: Testing var 21 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=42, varin=54, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=60, theta=0.438827, up=1.000000
ITER 3: row=15, varin=43, theta=0.290471, up=999999999999999983222784.000000
ITER 4: row=14, varin=42, theta=0.132592, up=999999999999999983222784.000000
ITER 5: row=49, varin=49, theta=0.147684, up=999999999999999983222784.000000
ITER 6: row=52, varin=15, theta=0.249618, up=999999999999999983222784.000000
ITER 7: row=1, varin=48, theta=0.126089, up=999999999999999983222784.000000
ITER 8: row=40, varin=87, theta=3.046278, up=1.000000
ITER 9: row=40, varin=59, theta=0.205661, up=1.000000
ITER 10: row=15, varin=87, theta=0.721795, up=1.000000
DEBUG EVAL: Branch var 21 = 0 gives z=25528043.226053
  % 	x21 = 0,	Z0 = 25528043.2260527        
DEBUG EVAL: First branch cutoff check: z=25528043.226053, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 21 = 1
ITER 1: row=42, varin=51, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=55, varin=52, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=56, varin=53, theta=1.000000, up=999999999999999983222784.000000
  % 	x21 = 1,	Z1 = 25474912.1808209        
DEBUG EVAL: Second branch cutoff check: z=25474912.180821, best_z=INF, threshold=INF
  %   New best:  x21, Z = 25474912.1808209        
DEBUG EVAL: Testing var 15 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=41, varin=51, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=55, varin=52, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=56, varin=53, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 15 = 0 gives z=25474912.180821
  % 	x15 = 0,	Z0 = 25474912.1808209        
DEBUG EVAL: First branch cutoff check: z=25474912.180821, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 15 = 1
ITER 1: row=41, varin=54, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=60, theta=0.438827, up=1.000000
ITER 3: row=15, varin=43, theta=0.290471, up=999999999999999983222784.000000
ITER 4: row=14, varin=82, theta=0.499351, up=1.000000
ITER 5: row=3, varin=64, theta=0.396665, up=1.000000
ITER 6: row=44, varin=49, theta=0.571324, up=999999999999999983222784.000000
ITER 7: row=52, varin=80, theta=1.080484, up=1.000000
ITER 8: row=52, varin=59, theta=0.098561, up=1.000000
ITER 9: row=11, varin=80, theta=1.000000, up=1.000000
ITER 10: row=47, varin=85, theta=1.700270, up=1.000000
  % 	x15 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: Second branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=51, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=55, varin=52, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=56, varin=53, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 25474912.180821
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 6.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 57 rows, 60 cols, 297 nonzeros, 3 slack, 54 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 3 slack rows
   % @PAP adding 6 rows, 22 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=55, varin=63, theta=0.453138, up=1.000000
ITER 2: row=15, varin=85, theta=0.515636, up=1.000000
ITER 3: row=3, varin=43, theta=0.702951, up=999999999999999983222784.000000
ITER 4: row=58, varin=50, theta=0.111111, up=999999999999999983222784.000000
ITER 5: row=56, varin=67, theta=0.470588, up=1.000000
ITER 6: row=3, varin=58, theta=0.000328, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=60)
DEBUG SOLUTION: LP solution array indices: FST[61-100], not_covered[101-120]
DEBUG SOLUTION: lp->best_solution[0] = 25613160.109505
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 6.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 60 rows, 60 cols, 313 nonzeros, 2 slack, 58 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
   % @PAP adding 3 rows, 10 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=60, varin=49, theta=0.586968, up=999999999999999983222784.000000
ITER 2: row=56, varin=42, theta=0.351922, up=999999999999999983222784.000000
ITER 3: row=53, varin=43, theta=0.723420, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=61)
DEBUG SOLUTION: LP solution array indices: FST[62-101], not_covered[102-121]
DEBUG SOLUTION: lp->best_solution[0] = 25692803.792427
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 6.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 61 rows, 60 cols, 310 nonzeros, 2 slack, 59 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 4 at  25.69280379242690059982
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ff1996d600
% @LO 0.00  25.38497331934953393784 99.9000000000
% @LN 0.00  25.38885911798762506919 99.9000000000
% Resuming node 3 at  25.38885911798762506919
DEBUG CONSTRNT: LP rows=59, pool->nlprows=59, pool->npend=0
DEBUG CONSTRNT: Checking 59 LP rows (pool tracks 59, total LP rows 59)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 70
DEBUG CONSTRNT: Pool row 70 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=56, expected 56
DEBUG CONSTRNT: Checking LP row 57 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=57, expected 57
DEBUG CONSTRNT: Checking LP row 58 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=58, expected 58
 % @PAP adding 58 rows, 240 nz to LP
DEBUG BB: Processing node 3, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 3 LP 2 Solution, length = 25388859.117988, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.143454 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.333333 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.333333 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.333333 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.143454 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.856546 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.856546 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.666667 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.666667 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.856546 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.666667 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=25388859.117988, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=25388859.117988, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 3 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 3
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.143454
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.143454)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.333333
DEBUG CAREFUL: Adding var 6 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=1.000000
DEBUG CAREFUL: Skipping var 12: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.333333
DEBUG CAREFUL: Adding var 13 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.333333
DEBUG CAREFUL: Adding var 28 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.143454
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.143454)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 6
DEBUG CAREFUL: Calling compare_branch_vars for var 6
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 6
DEBUG CAREFUL: New best var: 6
DEBUG CAREFUL: Testing fvar[1] = var 13
DEBUG CAREFUL: Calling compare_branch_vars for var 13
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 13
DEBUG CAREFUL: New best var: 13
DEBUG CAREFUL: Testing fvar[2] = var 28
DEBUG CAREFUL: Calling compare_branch_vars for var 28
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 28
DEBUG CAREFUL: Testing fvar[3] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[4] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 29
  % Initial guess is x13, Z0 = 25388859.1179876        , Z1 = 26635960.1501477        

DEBUG EVAL: Testing var 6 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=40, varin=53, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=58, varin=54, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=14, varin=81, theta=0.227348, up=1.000000
ITER 4: row=11, varin=86, theta=0.563039, up=1.000000
ITER 5: row=33, varin=89, theta=0.459465, up=1.000000
ITER 6: row=57, varin=52, theta=0.530567, up=999999999999999983222784.000000
ITER 7: row=1, varin=84, theta=0.675297, up=1.000000
ITER 8: row=41, varin=85, theta=25.861770, up=1.000000
ITER 9: row=41, varin=50, theta=0.880239, up=999999999999999983222784.000000
ITER 10: row=33, varin=90, theta=1.575423, up=1.000000
DEBUG EVAL: Branch var 6 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x6 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=67, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=58)
DEBUG SOLUTION: LP solution array indices: FST[59-98], not_covered[99-118]
DEBUG SOLUTION: lp->best_solution[0] = 25393266.612262
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 6.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 58 rows, 60 cols, 300 nonzeros, 0 slack, 58 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 4 rows, 24 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=59, varin=65, theta=1.500000, up=1.000000
ITER 2: row=59, varin=57, theta=0.111111, up=999999999999999983222784.000000
ITER 3: row=32, varin=65, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=62)
DEBUG SOLUTION: LP solution array indices: FST[63-102], not_covered[103-122]
DEBUG SOLUTION: lp->best_solution[0] = 25456279.982069
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 6.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 62 rows, 60 cols, 324 nonzeros, 4 slack, 58 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 4 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 3 at  25.45627998206943942705
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ff1996d600
% @LO 0.00  25.38885911798762506919 99.9000000000
% @LN 0.00  25.45627998206943942705 99.9000000000
% Resuming node 3 at  25.45627998206943942705
DEBUG CONSTRNT: LP rows=58, pool->nlprows=58, pool->npend=0
DEBUG CONSTRNT: Checking 58 LP rows (pool tracks 58, total LP rows 58)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=56, expected 56
DEBUG CONSTRNT: Checking LP row 57 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=57, expected 57
 % @PAP adding 58 rows, 240 nz to LP
DEBUG BB: Processing node 3, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 3 LP 3 Solution, length = 25456279.982069, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.032305 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.333333 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.333333 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.333333 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.032305 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.967695 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.967695 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.666667 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.666667 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.967695 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.666667 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=25456279.982069, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=25456279.982069, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 3 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 3
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.032305
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.032305)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.333333
DEBUG CAREFUL: Adding var 8 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=1.000000
DEBUG CAREFUL: Skipping var 12: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.333333
DEBUG CAREFUL: Adding var 13 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.333333
DEBUG CAREFUL: Adding var 28 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.032305
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.032305)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 8
DEBUG CAREFUL: Calling compare_branch_vars for var 8
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 8
DEBUG CAREFUL: New best var: 8
DEBUG CAREFUL: Testing fvar[1] = var 13
DEBUG CAREFUL: Calling compare_branch_vars for var 13
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 13
DEBUG CAREFUL: New best var: 13
DEBUG CAREFUL: Testing fvar[2] = var 28
DEBUG CAREFUL: Calling compare_branch_vars for var 28
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 28
DEBUG CAREFUL: Testing fvar[3] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[4] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 29
  % Initial guess is x13, Z0 = 25456279.9820694        , Z1 = 26635960.1501477        

DEBUG EVAL: Testing var 8 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=40, varin=32, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=24, varin=53, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=58, varin=3, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=3, varin=50, theta=0.666667, up=999999999999999983222784.000000
ITER 5: row=14, varin=83, theta=2.083695, up=1.000000
ITER 6: row=14, varin=81, theta=0.932607, up=1.000000
ITER 7: row=5, varin=100, theta=0.333333, up=1.000000
ITER 8: row=11, varin=52, theta=4.942397, up=999999999999999983222784.000000
ITER 9: row=1, varin=84, theta=9.023072, up=1.000000
ITER 10: row=1, varin=86, theta=3.980354, up=1.000000
DEBUG EVAL: Branch var 8 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x8 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=81, theta=1.000000, up=1.000000
ITER 2: row=11, varin=86, theta=1.000000, up=1.000000
ITER 3: row=33, varin=75, theta=0.333333, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=58)
DEBUG SOLUTION: LP solution array indices: FST[59-98], not_covered[99-118]
DEBUG SOLUTION: lp->best_solution[0] = 25505725.836133
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 6.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 58 rows, 60 cols, 300 nonzeros, 0 slack, 58 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 6 rows, 32 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=59, varin=99, theta=1.000000, up=1.000000
ITER 2: row=64, varin=57, theta=0.125000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=64)
DEBUG SOLUTION: LP solution array indices: FST[65-104], not_covered[105-124]
DEBUG SOLUTION: lp->best_solution[0] = 25517489.572974
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 6.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 64 rows, 60 cols, 332 nonzeros, 5 slack, 59 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 5 slack rows
   % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=60, varin=59, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=25, varin=91, theta=0.224705, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=60)
DEBUG SOLUTION: LP solution array indices: FST[61-100], not_covered[101-120]
DEBUG SOLUTION: lp->best_solution[0] = 25554572.370719
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 6.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 60 rows, 60 cols, 315 nonzeros, 1 slack, 59 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 4 rows, 15 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=60, varin=90, theta=0.443116, up=1.000000
ITER 2: row=37, varin=96, theta=0.175644, up=1.000000
ITER 3: row=61, varin=71, theta=0.159752, up=1.000000
ITER 4: row=58, varin=109, theta=0.100297, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=63)
DEBUG SOLUTION: LP solution array indices: FST[64-103], not_covered[104-123]
DEBUG SOLUTION: lp->best_solution[0] = 25582981.440776
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 6.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 63 rows, 60 cols, 321 nonzeros, 10 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 10 slack rows
   % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=54, varin=55, theta=0.082810, up=1.000000
ITER 2: row=2, varin=58, theta=0.122538, up=1.000000
ITER 3: row=7, varin=97, theta=0.035780, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 25594034.289758
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.964220
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 6.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 54 rows, 60 cols, 291 nonzeros, 1 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=54, varin=51, theta=0.233807, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 25594066.095837
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 6.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 54 rows, 60 cols, 291 nonzeros, 1 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 3 at  25.59406609583716019074
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ff1996d600
% @LO 0.00  25.45627998206943942705 99.9000000000
% @LN 0.00  25.59406609583716019074 99.9000000000
% Resuming node 3 at  25.59406609583716019074
DEBUG CONSTRNT: LP rows=53, pool->nlprows=53, pool->npend=0
DEBUG CONSTRNT: Checking 53 LP rows (pool tracks 53, total LP rows 53)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=52, expected 52
 % @PAP adding 53 rows, 226 nz to LP
DEBUG BB: Processing node 3, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 3 LP 4 Solution, length = 25594066.095837, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.233807 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.233807 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.149290 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.233807 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.149290 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.233807 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.233807 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.233807 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.149290 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.766193 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.766193 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.766193 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.850710 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.850710 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.766193 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.850710 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.766193 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 9 fractional variables
DEBUG CG: LP optimal, z=25594066.095837, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=25594066.095837, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 3 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 3
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.233807
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.233807)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.233807
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.233807)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=1.000000
DEBUG CAREFUL: Skipping var 12: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.149290
DEBUG CAREFUL: Adding var 13 to fractional list (xi=0.149290)
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.233807
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.233807)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.149290
DEBUG CAREFUL: Adding var 28 to fractional list (xi=0.149290)
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.233807
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.233807)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.233807
DEBUG CAREFUL: Adding var 30 to fractional list (xi=0.233807)
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.233807
DEBUG CAREFUL: Adding var 32 to fractional list (xi=0.233807)
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.149290
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.149290)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 9 fractional variables

  %  Carefully choosing branching variable, nfrac = 9
DEBUG CAREFUL: Testing fvar[0] = var 30
DEBUG CAREFUL: Calling compare_branch_vars for var 30
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 30
DEBUG CAREFUL: New best var: 30
DEBUG CAREFUL: Testing fvar[1] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 27
DEBUG CAREFUL: Testing fvar[2] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[3] = var 32
DEBUG CAREFUL: Calling compare_branch_vars for var 32
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 32
DEBUG CAREFUL: New best var: 32
DEBUG CAREFUL: Testing fvar[4] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[5] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 29
DEBUG CAREFUL: Testing fvar[6] = var 28
DEBUG CAREFUL: Calling compare_branch_vars for var 28
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 28
DEBUG CAREFUL: Testing fvar[7] = var 13
DEBUG CAREFUL: Calling compare_branch_vars for var 13
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 13
DEBUG CAREFUL: New best var: 13
DEBUG CAREFUL: Testing fvar[8] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 34
  % Initial guess is x13, Z0 = 25594066.0958372        , Z1 = 26635960.1501477        

DEBUG EVAL: Testing var 30 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=47, varin=53, theta=0.351761, up=999999999999999983222784.000000
ITER 2: row=30, varin=6, theta=0.401562, up=999999999999999983222784.000000
ITER 3: row=34, varin=44, theta=0.737521, up=999999999999999983222784.000000
ITER 4: row=33, varin=52, theta=1.979305, up=999999999999999983222784.000000
ITER 5: row=12, varin=13, theta=1.455354, up=999999999999999983222784.000000
ITER 6: row=45, varin=97, theta=0.210337, up=1.000000
ITER 7: row=14, varin=47, theta=0.747745, up=999999999999999983222784.000000
ITER 8: row=30, varin=39, theta=1.325508, up=999999999999999983222784.000000
ITER 9: row=51, varin=85, theta=1.864461, up=1.000000
ITER 10: row=51, varin=22, theta=1.397253, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 30 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x30 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=59, theta=0.112506, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 25600837.196253
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 6.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 53 rows, 60 cols, 286 nonzeros, 0 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=54, varin=48, theta=0.133323, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 25608631.821307
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 6.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 54 rows, 60 cols, 288 nonzeros, 1 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 3 at  25.60863182130724169383
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ff1996d600
% @LO 0.00  25.59406609583716019074 99.9000000000
% @LN 0.00  25.60863182130724169383 99.9000000000
% Resuming node 3 at  25.60863182130724169383
DEBUG CONSTRNT: LP rows=53, pool->nlprows=53, pool->npend=0
DEBUG CONSTRNT: Checking 53 LP rows (pool tracks 53, total LP rows 53)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=52, expected 52
 % @PAP adding 53 rows, 222 nz to LP
DEBUG BB: Processing node 3, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 3 LP 5 Solution, length = 25608631.821307, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.066661 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.066661 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.300016 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.066661 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.300016 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.300016 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.933339 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.699984 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.699984 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.699984 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=25608631.821307, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=25608631.821307, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 3 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 3
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.066661
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.066661)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.066661
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.066661)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=1.000000
DEBUG CAREFUL: Skipping var 12: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.300016
DEBUG CAREFUL: Adding var 13 to fractional list (xi=0.300016)
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.066661
DEBUG CAREFUL: Adding var 16 to fractional list (xi=0.066661)
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.300016
DEBUG CAREFUL: Adding var 28 to fractional list (xi=0.300016)
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.300016
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.300016)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 5
DEBUG CAREFUL: New best var: 5
DEBUG CAREFUL: Testing fvar[1] = var 16
DEBUG CAREFUL: Calling compare_branch_vars for var 16
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 16
DEBUG CAREFUL: New best var: 16
DEBUG CAREFUL: Testing fvar[2] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
DEBUG CAREFUL: Testing fvar[3] = var 13
DEBUG CAREFUL: Calling compare_branch_vars for var 13
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 13
DEBUG CAREFUL: Testing fvar[4] = var 28
DEBUG CAREFUL: Calling compare_branch_vars for var 28
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 28
DEBUG CAREFUL: Testing fvar[5] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 34
  % Initial guess is x16, Z0 = 25608631.8213072        , Z1 = 26770070.2196213        

DEBUG EVAL: Testing var 5 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=14, varin=6, theta=1.715682, up=999999999999999983222784.000000
ITER 2: row=6, varin=52, theta=2.236715, up=999999999999999983222784.000000
ITER 3: row=30, varin=2, theta=0.992656, up=999999999999999983222784.000000
ITER 4: row=2, varin=51, theta=1.359742, up=999999999999999983222784.000000
ITER 5: row=1, varin=27, theta=1.715186, up=999999999999999983222784.000000
ITER 6: row=27, varin=25, theta=1.830694, up=999999999999999983222784.000000
ITER 7: row=51, varin=49, theta=1.319589, up=999999999999999983222784.000000
ITER 8: row=34, varin=48, theta=3.000000, up=999999999999999983222784.000000
ITER 9: row=48, varin=47, theta=1.000000, up=999999999999999983222784.000000
ITER 10: row=2, varin=44, theta=0.446455, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 5 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x5 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=14, varin=13, theta=0.602304, up=999999999999999983222784.000000
ITER 2: row=13, varin=53, theta=0.109062, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 25619965.813202
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 6.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 53 rows, 60 cols, 282 nonzeros, 1 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 3 at  25.61996581320166654905
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ff1996d600
% @LO 0.01  25.60863182130724169383 99.9000000000
% @LN 0.01  25.61996581320166654905 99.9000000000
% Resuming node 3 at  25.61996581320166654905
DEBUG CONSTRNT: LP rows=52, pool->nlprows=52, pool->npend=0
DEBUG CONSTRNT: Checking 52 LP rows (pool tracks 52, total LP rows 52)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=51, expected 51
 % @PAP adding 52 rows, 220 nz to LP
DEBUG BB: Processing node 3, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 3 LP 6 Solution, length = 25619965.813202, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.109062 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.281877 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.109062 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.281877 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.281877 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.890938 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.718123 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.718123 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.718123 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=25619965.813202, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=25619965.813202, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 3 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 3
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.109062
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.109062)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=1.000000
DEBUG CAREFUL: Skipping var 12: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.281877
DEBUG CAREFUL: Adding var 13 to fractional list (xi=0.281877)
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.109062
DEBUG CAREFUL: Adding var 16 to fractional list (xi=0.109062)
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.281877
DEBUG CAREFUL: Adding var 28 to fractional list (xi=0.281877)
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.281877
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.281877)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 13
DEBUG CAREFUL: Calling compare_branch_vars for var 13
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 13
DEBUG CAREFUL: New best var: 13
DEBUG CAREFUL: Testing fvar[1] = var 28
DEBUG CAREFUL: Calling compare_branch_vars for var 28
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 28
DEBUG CAREFUL: Testing fvar[2] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 34
DEBUG CAREFUL: Testing fvar[3] = var 16
DEBUG CAREFUL: Calling compare_branch_vars for var 16
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 16
DEBUG CAREFUL: New best var: 16
DEBUG CAREFUL: Testing fvar[4] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
  % Initial guess is x16, Z0 = 25619965.8132017        , Z1 = 26770070.2196213        

DEBUG EVAL: Testing var 13 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=30, varin=70, theta=0.913131, up=1.000000
ITER 2: row=40, varin=84, theta=5.141742, up=1.000000
ITER 3: row=40, varin=22, theta=1.420916, up=999999999999999983222784.000000
ITER 4: row=1, varin=52, theta=4.969076, up=999999999999999983222784.000000
ITER 5: row=14, varin=96, theta=11.193074, up=1.000000
ITER 6: row=14, varin=51, theta=156.721768, up=999999999999999983222784.000000
ITER 7: row=51, varin=39, theta=5.639350, up=999999999999999983222784.000000
ITER 8: row=13, varin=48, theta=18.159478, up=999999999999999983222784.000000
ITER 9: row=47, varin=78, theta=12.246567, up=1.000000
DEBUG EVAL: Branch var 13 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x13 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=30, varin=25, theta=1.561382, up=999999999999999983222784.000000
ITER 2: row=1, varin=82, theta=0.279849, up=1.000000
ITER 3: row=13, varin=49, theta=0.118222, up=999999999999999983222784.000000
ITER 4: row=48, varin=55, theta=0.149760, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 25650560.108775
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 6.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 52 rows, 60 cols, 280 nonzeros, 4 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 4 slack rows
   % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=92, theta=0.069121, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 25661674.889292
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 6.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 49 rows, 60 cols, 272 nonzeros, 0 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 5 rows, 26 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=54, varin=96, theta=0.110214, up=1.000000
ITER 2: row=35, varin=72, theta=0.070578, up=1.000000
ITER 3: row=8, varin=38, theta=0.021215, up=999999999999999983222784.000000
ITER 4: row=50, varin=65, theta=0.107963, up=1.000000
ITER 5: row=17, varin=111, theta=0.122711, up=1.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 25683860.758240
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.877289
DEBUG SOLUTION: lp->best_solution[5] = 2.877289
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 6.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 54 rows, 60 cols, 298 nonzeros, 2 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
   % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=53, varin=98, theta=0.041820, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 25686281.454808
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.958180
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.958180
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.958180
DEBUG SOLUTION: lp->best_solution[10] = 5.874540
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 54 rows, 60 cols, 300 nonzeros, 4 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 4 slack rows
   % @PAP adding 6 rows, 26 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=54, varin=88, theta=0.180922, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 25693874.860940
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 56 rows, 60 cols, 313 nonzeros, 0 slack, 56 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 3 at  25.69387486093974715118
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ff19984250
% @LO 0.01  25.61996581320166654905 99.9000000000
% @LN 0.01  25.69280379242690059982 99.9000000000
% Resuming node 4 at  25.69280379242690059982
DEBUG CONSTRNT: LP rows=56, pool->nlprows=56, pool->npend=0
DEBUG CONSTRNT: Checking 56 LP rows (pool tracks 56, total LP rows 56)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 85
DEBUG CONSTRNT: Pool row 85 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=55, expected 55
 % @PAP adding 59 rows, 242 nz to LP
DEBUG BB: Processing node 4, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 4 LP 2 Solution, length = 25692803.792427, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.138290 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.333333 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.333333 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 1.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 1.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.333333 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.138290 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.861710 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.861710 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.666667 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.666667 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.861710 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.666667 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=25692803.792427, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=25692803.792427, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 4 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 4
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.138290
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.138290)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.333333
DEBUG CAREFUL: Adding var 6 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.333333
DEBUG CAREFUL: Adding var 13 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=1.000000
DEBUG CAREFUL: Skipping var 21: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=1.000000
DEBUG CAREFUL: Skipping var 25: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.333333
DEBUG CAREFUL: Adding var 28 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.138290
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.138290)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 6
DEBUG CAREFUL: Calling compare_branch_vars for var 6
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 6
DEBUG CAREFUL: New best var: 6
DEBUG CAREFUL: Testing fvar[1] = var 13
DEBUG CAREFUL: Calling compare_branch_vars for var 13
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 13
DEBUG CAREFUL: New best var: 13
DEBUG CAREFUL: Testing fvar[2] = var 28
DEBUG CAREFUL: Calling compare_branch_vars for var 28
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 28
DEBUG CAREFUL: Testing fvar[3] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[4] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 29
  % Initial guess is x13, Z0 = 25692803.7924269        , Z1 = 26635960.1501477        

DEBUG EVAL: Testing var 6 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=40, varin=52, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=42, varin=43, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=58, varin=54, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=14, varin=42, theta=0.163024, up=999999999999999983222784.000000
ITER 5: row=40, varin=41, theta=0.132036, up=999999999999999983222784.000000
ITER 6: row=59, varin=53, theta=0.137129, up=999999999999999983222784.000000
ITER 7: row=1, varin=47, theta=0.057214, up=999999999999999983222784.000000
ITER 8: row=46, varin=15, theta=0.114051, up=999999999999999983222784.000000
ITER 9: row=15, varin=3, theta=0.265650, up=999999999999999983222784.000000
ITER 10: row=3, varin=55, theta=0.241191, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 6 = 1 gives z=26119721.697692
  % 	x6 = 1,	Z1 = 26119721.6976916        
DEBUG EVAL: First branch cutoff check: z=26119721.697692, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 6 = 0
ITER 1: row=40, varin=68, theta=0.500000, up=1.000000
  % 	x6 = 0,	Z0 = 25697211.2867017        
DEBUG EVAL: Second branch cutoff check: z=25697211.286702, best_z=INF, threshold=INF
  %   New best:  x6, Z = 25697211.2867017        
DEBUG EVAL: Testing var 13 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=46, varin=55, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=48, varin=52, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=42, varin=59, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=14, varin=42, theta=1.257831, up=999999999999999983222784.000000
ITER 5: row=48, varin=41, theta=0.929336, up=999999999999999983222784.000000
ITER 6: row=40, varin=53, theta=0.702477, up=999999999999999983222784.000000
ITER 7: row=1, varin=15, theta=0.584257, up=999999999999999983222784.000000
ITER 8: row=15, varin=3, theta=1.360865, up=999999999999999983222784.000000
ITER 9: row=3, varin=43, theta=1.235562, up=999999999999999983222784.000000
ITER 10: row=51, varin=52, theta=0.678433, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 13 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x13 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=68, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=59)
DEBUG SOLUTION: LP solution array indices: FST[60-99], not_covered[100-119]
DEBUG SOLUTION: lp->best_solution[0] = 25697211.286702
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 6.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 59 rows, 60 cols, 302 nonzeros, 0 slack, 59 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 4 rows, 24 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=60, varin=110, theta=1.500000, up=1.000000
ITER 2: row=60, varin=86, theta=0.333333, up=1.000000
ITER 3: row=32, varin=110, theta=1.000000, up=1.000000
ITER 4: row=11, varin=54, theta=0.333333, up=999999999999999983222784.000000
ITER 5: row=62, varin=91, theta=1.000000, up=1.000000
ITER 6: row=33, varin=80, theta=0.333333, up=1.000000
ITER 7: row=61, varin=98, theta=1.000000, up=1.000000
ITER 8: row=63, varin=60, theta=0.058824, up=999999999999999983222784.000000
ITER 9: row=61, varin=41, theta=1.000000, up=999999999999999983222784.000000
ITER 10: row=25, varin=47, theta=0.015792, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=10)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=63)
DEBUG SOLUTION: LP solution array indices: FST[64-103], not_covered[104-123]
DEBUG SOLUTION: lp->best_solution[0] = 25825368.749855
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 6.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 63 rows, 60 cols, 326 nonzeros, 5 slack, 58 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 5 slack rows
   % @PAP adding 5 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=63, varin=109, theta=0.500000, up=1.000000
ITER 2: row=59, varin=98, theta=0.705327, up=1.000000
ITER 3: row=55, varin=56, theta=0.611641, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=63)
DEBUG SOLUTION: LP solution array indices: FST[64-103], not_covered[104-123]
DEBUG SOLUTION: lp->best_solution[0] = 25858464.114906
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 6.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 63 rows, 60 cols, 325 nonzeros, 3 slack, 60 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 3 slack rows
   % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=61, varin=41, theta=0.695793, up=999999999999999983222784.000000
ITER 2: row=53, varin=92, theta=1.104856, up=1.000000
ITER 3: row=53, varin=94, theta=0.038966, up=1.000000
ITER 4: row=47, varin=35, theta=0.352151, up=999999999999999983222784.000000
ITER 5: row=53, varin=92, theta=0.163009, up=1.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=61)
DEBUG SOLUTION: LP solution array indices: FST[62-101], not_covered[102-121]
DEBUG SOLUTION: lp->best_solution[0] = 25902540.813865
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 6.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 61 rows, 60 cols, 312 nonzeros, 11 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 11 slack rows
   % @PAP adding 3 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=53, varin=86, theta=0.364003, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 25904698.026312
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 6.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 53 rows, 60 cols, 287 nonzeros, 0 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=54, varin=113, theta=0.050458, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 25906129.273593
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 6.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 55 rows, 60 cols, 293 nonzeros, 0 slack, 55 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 4 at  25.90612927359262229743
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ff1996d600
% @LO 0.01  25.69280379242690059982 99.9000000000
% @LN 0.01  25.69387486093974715118 99.9000000000
% Resuming node 3 at  25.69387486093974715118
DEBUG CONSTRNT: LP rows=55, pool->nlprows=55, pool->npend=0
DEBUG CONSTRNT: Checking 55 LP rows (pool tracks 55, total LP rows 55)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 70
DEBUG CONSTRNT: Pool row 70 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 85
DEBUG CONSTRNT: Pool row 85 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 143
DEBUG CONSTRNT: Pool row 143 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=54, expected 54
 % @PAP adding 56 rows, 253 nz to LP
DEBUG BB: Processing node 3, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 3 LP 7 Solution, length = 25693874.860940, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.319078 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.500000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.319078 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.180922 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.319078 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.680922 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.680922 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.680922 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=25693874.860940, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=25693874.860940, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 3 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 3
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.319078
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.319078)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.500000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=1.000000
DEBUG CAREFUL: Skipping var 12: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.500000
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.319078
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.319078)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.180922
DEBUG CAREFUL: Adding var 31 to fractional list (xi=0.180922)
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.319078
DEBUG CAREFUL: Adding var 32 to fractional list (xi=0.319078)
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 27
DEBUG CAREFUL: New best var: 27
DEBUG CAREFUL: Testing fvar[1] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[2] = var 31
DEBUG CAREFUL: Calling compare_branch_vars for var 31
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 31
DEBUG CAREFUL: New best var: 31
DEBUG CAREFUL: Testing fvar[3] = var 32
DEBUG CAREFUL: Calling compare_branch_vars for var 32
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 32
DEBUG CAREFUL: Testing fvar[4] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 29
DEBUG CAREFUL: Testing fvar[5] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
  % Initial guess is x31, Z0 = 25693874.8609397        , Z1 = 25980122.7896498        

DEBUG EVAL: Testing var 27 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=17, varin=43, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 27 = 0 gives z=25755710.660761
  % 	x27 = 0,	Z0 = 25755710.6607608        
DEBUG EVAL: First branch cutoff check: z=25755710.660761, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 27 = 1
ITER 1: row=17, varin=16, theta=1.000000, up=999999999999999983222784.000000
  % 	x27 = 1,	Z1 = 26220891.4677769        
DEBUG EVAL: Second branch cutoff check: z=26220891.467777, best_z=INF, threshold=INF
  %   New best:  x27, Z = 25755710.6607608        
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=8, varin=43, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 0 gives z=25755710.660761
  % 	x2 = 0,	Z0 = 25755710.6607608        
DEBUG EVAL: First branch cutoff check: z=25755710.660761, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 1
ITER 1: row=8, varin=17, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=9, varin=7, theta=0.464842, up=999999999999999983222784.000000
ITER 3: row=37, varin=49, theta=0.244468, up=999999999999999983222784.000000
ITER 4: row=22, varin=44, theta=0.250881, up=999999999999999983222784.000000
ITER 5: row=50, varin=112, theta=0.097345, up=1.000000
ITER 6: row=2, varin=42, theta=0.329741, up=999999999999999983222784.000000
ITER 7: row=42, varin=40, theta=1.692211, up=999999999999999983222784.000000
ITER 8: row=40, varin=39, theta=0.674674, up=999999999999999983222784.000000
ITER 9: row=44, varin=34, theta=0.793435, up=999999999999999983222784.000000
ITER 10: row=1, varin=90, theta=6.993676, up=1.000000
  % 	x2 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: Second branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=8, varin=43, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 25755710.660761
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 56 rows, 60 cols, 313 nonzeros, 1 slack, 55 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 5 rows, 20 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=58, varin=81, theta=0.944872, up=1.000000
ITER 2: row=22, varin=41, theta=0.313716, up=999999999999999983222784.000000
ITER 3: row=13, varin=97, theta=1.000000, up=1.000000
ITER 4: row=49, varin=35, theta=0.142857, up=999999999999999983222784.000000
ITER 5: row=45, varin=70, theta=0.230769, up=1.000000
ITER 6: row=10, varin=42, theta=0.065217, up=999999999999999983222784.000000
ITER 7: row=46, varin=92, theta=1.000000, up=1.000000
ITER 8: row=57, varin=116, theta=0.166667, up=1.000000
ITER 9: row=46, varin=47, theta=0.428571, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=9)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=60)
DEBUG SOLUTION: LP solution array indices: FST[61-100], not_covered[101-120]
DEBUG SOLUTION: lp->best_solution[0] = 25957729.325427
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 60 rows, 60 cols, 331 nonzeros, 7 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 7 slack rows
   % @PAP adding 4 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=54, varin=93, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 25962000.306852
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 57 rows, 60 cols, 309 nonzeros, 2 slack, 55 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
   % @PAP adding 2 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=56, varin=41, theta=0.111111, up=999999999999999983222784.000000
ITER 2: row=38, varin=16, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 25972870.200905
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 57 rows, 60 cols, 318 nonzeros, 2 slack, 55 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
   % @PAP adding 2 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=56, varin=42, theta=0.129576, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 25978730.114063
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 57 rows, 60 cols, 319 nonzeros, 3 slack, 54 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 3 slack rows
   % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=55, varin=8, theta=0.003445, up=999999999999999983222784.000000
ITER 2: row=46, varin=88, theta=0.051982, up=1.000000
ITER 3: row=48, varin=109, theta=0.014898, up=1.000000
ITER 4: row=47, varin=90, theta=0.059032, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 25986822.879761
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 56 rows, 60 cols, 301 nonzeros, 0 slack, 56 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 3 at  25.98682287976127369689
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ff19984250
% @LO 0.01  25.69387486093974715118 99.9000000000
% @LN 0.01  25.90612927359262229743 99.9000000000
% Resuming node 4 at  25.90612927359262229743
DEBUG CONSTRNT: LP rows=56, pool->nlprows=56, pool->npend=0
DEBUG CONSTRNT: Checking 56 LP rows (pool tracks 56, total LP rows 56)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=55, expected 55
 % @PAP adding 55 rows, 233 nz to LP
DEBUG BB: Processing node 4, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 4 LP 3 Solution, length = 25906129.273593, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.224771 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.949542 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.949542 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.224771 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.500000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.500000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.224771 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.775229 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.050458 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.775229 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.050458 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.050458 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 8 fractional variables
DEBUG CG: LP optimal, z=25906129.273593, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=25906129.273593, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 4 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 4
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.500000
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.224771
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.224771)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.949542
DEBUG CAREFUL: Adding var 21 to fractional list (xi=0.949542)
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.949542
DEBUG CAREFUL: Adding var 25 to fractional list (xi=0.949542)
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.224771
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.224771)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.500000
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.500000
DEBUG CAREFUL: Adding var 30 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.224771
DEBUG CAREFUL: Adding var 32 to fractional list (xi=0.224771)
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 8 fractional variables

  %  Carefully choosing branching variable, nfrac = 8
DEBUG CAREFUL: Testing fvar[0] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 1
DEBUG CAREFUL: New best var: 1
DEBUG CAREFUL: Testing fvar[1] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 29
DEBUG CAREFUL: Testing fvar[2] = var 30
DEBUG CAREFUL: Calling compare_branch_vars for var 30
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 30
DEBUG CAREFUL: New best var: 30
DEBUG CAREFUL: Testing fvar[3] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 27
DEBUG CAREFUL: Testing fvar[4] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[5] = var 32
DEBUG CAREFUL: Calling compare_branch_vars for var 32
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 32
DEBUG CAREFUL: New best var: 32
DEBUG CAREFUL: Testing fvar[6] = var 25
DEBUG CAREFUL: Calling compare_branch_vars for var 25
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 25
DEBUG CAREFUL: Testing fvar[7] = var 21
DEBUG CAREFUL: Calling compare_branch_vars for var 21
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 21
  % Initial guess is x32, Z0 = 25906129.2735926        , Z1 = 26043816.7709395        

DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=49, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=51, varin=53, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=34, varin=54, theta=1.314271, up=999999999999999983222784.000000
ITER 4: row=15, varin=46, theta=0.276479, up=999999999999999983222784.000000
ITER 5: row=44, varin=51, theta=0.129133, up=999999999999999983222784.000000
ITER 6: row=42, varin=44, theta=0.480316, up=999999999999999983222784.000000
ITER 7: row=15, varin=58, theta=0.338770, up=1.000000
DEBUG EVAL: Branch var 1 = 0 gives z=25978828.758785
  % 	x1 = 0,	Z0 = 25978828.7587854        
DEBUG EVAL: First branch cutoff check: z=25978828.758785, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 1
ITER 1: row=1, varin=14, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=40, varin=16, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=34, varin=42, theta=0.367934, up=999999999999999983222784.000000
ITER 4: row=45, varin=82, theta=0.496740, up=1.000000
ITER 5: row=26, varin=59, theta=0.167785, up=1.000000
ITER 6: row=7, varin=87, theta=0.272094, up=1.000000
  % 	x1 = 1,	Z1 = 26680504.757083         
DEBUG EVAL: Second branch cutoff check: z=26680504.757083, best_z=INF, threshold=INF
  %   New best:  x1, Z = 25978828.7587854        
DEBUG EVAL: Testing var 29 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=14, varin=49, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=51, varin=53, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=36, varin=54, theta=1.314271, up=999999999999999983222784.000000
ITER 4: row=23, varin=14, theta=0.109000, up=999999999999999983222784.000000
ITER 5: row=40, varin=46, theta=0.276479, up=999999999999999983222784.000000
ITER 6: row=44, varin=51, theta=0.129133, up=999999999999999983222784.000000
ITER 7: row=42, varin=44, theta=0.480316, up=999999999999999983222784.000000
ITER 8: row=40, varin=102, theta=0.338770, up=1.000000
DEBUG EVAL: Branch var 29 = 0 gives z=25978828.758785
  % 	x29 = 0,	Z0 = 25978828.7587854        
DEBUG EVAL: First branch cutoff check: z=25978828.758785, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 29 = 1
ITER 1: row=14, varin=38, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=51, varin=53, theta=1.000000, up=999999999999999983222784.000000
  % 	x29 = 1,	Z1 = 26412392.2107974        
DEBUG EVAL: Second branch cutoff check: z=26412392.210797, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 30 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=42, varin=49, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=51, varin=33, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=52, varin=38, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=36, varin=42, theta=0.474186, up=999999999999999983222784.000000
ITER 5: row=45, varin=82, theta=0.640189, up=1.000000
ITER 6: row=26, varin=59, theta=0.216238, up=1.000000
ITER 7: row=7, varin=14, theta=0.321353, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 30 = 1 gives z=27028194.671326
  % 	x30 = 1,	Z1 = 27028194.6713256        
DEBUG EVAL: First branch cutoff check: z=27028194.671326, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 30 = 0
ITER 1: row=42, varin=53, theta=0.500000, up=999999999999999983222784.000000
  % 	x30 = 0,	Z0 = 25912971.7442075        
DEBUG EVAL: Second branch cutoff check: z=25912971.744207, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 27 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=24, varin=46, theta=0.701423, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 27 = 0 gives z=25912036.937345
  % 	x27 = 0,	Z0 = 25912036.9373452        
DEBUG EVAL: First branch cutoff check: z=25912036.937345, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=15, varin=46, theta=0.701423, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 0 gives z=25912036.937345
  % 	x2 = 0,	Z0 = 25912036.9373452        
DEBUG EVAL: First branch cutoff check: z=25912036.937345, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 32 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=44, varin=53, theta=2.086131, up=999999999999999983222784.000000
ITER 2: row=42, varin=42, theta=0.998880, up=999999999999999983222784.000000
ITER 3: row=45, varin=50, theta=0.860722, up=999999999999999983222784.000000
ITER 4: row=46, varin=47, theta=0.391550, up=999999999999999983222784.000000
ITER 5: row=47, varin=49, theta=2.509809, up=999999999999999983222784.000000
ITER 6: row=34, varin=11, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=11, varin=45, theta=0.466667, up=999999999999999983222784.000000
ITER 8: row=43, varin=44, theta=0.533333, up=999999999999999983222784.000000
ITER 9: row=33, varin=24, theta=1.000000, up=999999999999999983222784.000000
ITER 10: row=16, varin=23, theta=0.358172, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 32 = 1 gives z=26239842.139045
  % 	x32 = 1,	Z1 = 26239842.1390446        
DEBUG EVAL: First branch cutoff check: z=26239842.139045, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 32 = 0
ITER 1: row=44, varin=54, theta=0.368085, up=999999999999999983222784.000000
  % 	x32 = 0,	Z0 = 25908439.8212514        
DEBUG EVAL: Second branch cutoff check: z=25908439.821251, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 25 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=34, varin=49, theta=0.084366, up=999999999999999983222784.000000
ITER 2: row=51, varin=53, theta=0.147838, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 25 = 1 gives z=25914864.581719
  % 	x25 = 1,	Z1 = 25914864.5817185        
DEBUG EVAL: First branch cutoff check: z=25914864.581719, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 21 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=35, varin=49, theta=0.084366, up=999999999999999983222784.000000
ITER 2: row=51, varin=53, theta=0.147838, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 21 = 1 gives z=25914864.581719
  % 	x21 = 1,	Z1 = 25914864.5817185        
DEBUG EVAL: First branch cutoff check: z=25914864.581719, best_z=INF, threshold=INF
  % Best branch is x1, Z0 = 25978828.7587854        , Z1 = 26680504.757083         

DEBUG CAREFUL: Final result - returning best.var = 1
DEBUG BB: Branching variable chosen: j=1
 % @NC    5    4	x1 = 0	25978828.758785
 % @NC    6    4	x1 = 1	26680504.757083
 %       4     3 25906129.2736               25978828.7588   x12 D     1     2
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ff1997a3c0
% @LO 0.01  25.90612927359262229743 99.9000000000
% @LN 0.01  25.97882875878541497627 99.9000000000
% Resuming node 5 at  25.97882875878541497627
DEBUG CONSTRNT: LP rows=55, pool->nlprows=55, pool->npend=0
DEBUG CONSTRNT: Checking 55 LP rows (pool tracks 55, total LP rows 55)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 70
DEBUG CONSTRNT: Pool row 70 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 85
DEBUG CONSTRNT: Pool row 85 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 143
DEBUG CONSTRNT: Pool row 143 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=54, expected 54
 % @PAP adding 55 rows, 233 nz to LP
DEBUG BB: Processing node 5, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=49, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=51, varin=53, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=34, varin=54, theta=1.314271, up=999999999999999983222784.000000
ITER 4: row=15, varin=46, theta=0.276479, up=999999999999999983222784.000000
ITER 5: row=44, varin=51, theta=0.129133, up=999999999999999983222784.000000
ITER 6: row=42, varin=44, theta=0.480316, up=999999999999999983222784.000000
ITER 7: row=15, varin=58, theta=0.338770, up=1.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 25978828.758785
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 6.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 55 rows, 60 cols, 293 nonzeros, 5 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=45, theta=0.457191, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 25979785.855355
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 6.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 282 nonzeros, 1 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 5 LP 1 Solution, length = 25979785.855355, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.347603 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.076198 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 1.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 1.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.500000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.347603 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.076198 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.652397 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.652397 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.923802 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=25979785.855355, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.01  25.97882875878541497627 99.9000000000
 % @LN 0.01  25.97978585535540929641 99.9000000000
DEBUG CG: Second cutoff check: z=25979785.855355, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 5 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 5
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.500000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.347603
DEBUG CAREFUL: Adding var 6 to fractional list (xi=0.347603)
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.076198
DEBUG CAREFUL: Adding var 8 to fractional list (xi=0.076198)
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=1.000000
DEBUG CAREFUL: Skipping var 21: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=1.000000
DEBUG CAREFUL: Skipping var 25: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.500000
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.347603
DEBUG CAREFUL: Adding var 28 to fractional list (xi=0.347603)
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.076198
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.076198)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 2
DEBUG CAREFUL: New best var: 2
DEBUG CAREFUL: Testing fvar[1] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 27
DEBUG CAREFUL: Testing fvar[2] = var 6
DEBUG CAREFUL: Calling compare_branch_vars for var 6
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 6
DEBUG CAREFUL: New best var: 6
DEBUG CAREFUL: Testing fvar[3] = var 28
DEBUG CAREFUL: Calling compare_branch_vars for var 28
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 28
DEBUG CAREFUL: Testing fvar[4] = var 8
DEBUG CAREFUL: Calling compare_branch_vars for var 8
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 8
DEBUG CAREFUL: Testing fvar[5] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 34
  % Initial guess is x6, Z0 = 25979785.8553554        , Z1 = 26119721.6976916        

DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=50, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 0 gives z=25982753.967018
  % 	x2 = 0,	Z0 = 25982753.9670177        
DEBUG EVAL: First branch cutoff check: z=25982753.967018, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 1
ITER 1: row=1, varin=24, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=15, varin=81, theta=1.247293, up=1.000000
ITER 3: row=15, varin=83, theta=0.267663, up=1.000000
ITER 4: row=48, varin=81, theta=1.000000, up=1.000000
ITER 5: row=15, varin=76, theta=0.124657, up=1.000000
ITER 6: row=42, varin=83, theta=0.193606, up=1.000000
  % 	x2 = 1,	Z1 = 26203655.5548879        
DEBUG EVAL: Second branch cutoff check: z=26203655.554888, best_z=INF, threshold=INF
  %   New best:  x2, Z = 25982753.9670177        
DEBUG EVAL: Testing var 27 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=24, varin=50, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 27 = 0 gives z=25982753.967018
  % 	x27 = 0,	Z0 = 25982753.9670177        
DEBUG EVAL: First branch cutoff check: z=25982753.967018, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 27 = 1
ITER 1: row=24, varin=23, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=15, varin=81, theta=0.344385, up=1.000000
ITER 3: row=48, varin=83, theta=0.372753, up=1.000000
  % 	x27 = 1,	Z1 = 26317891.49678          
DEBUG EVAL: Second branch cutoff check: z=26317891.496780, best_z=INF, threshold=INF
  %   New best:  x27, Z = 25982753.9670177        
DEBUG EVAL: Testing var 6 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=15, varin=81, theta=0.303955, up=1.000000
ITER 2: row=29, varin=50, theta=1.567891, up=999999999999999983222784.000000
ITER 3: row=48, varin=83, theta=0.306706, up=1.000000
ITER 4: row=1, varin=76, theta=0.174327, up=1.000000
ITER 5: row=48, varin=48, theta=0.182648, up=999999999999999983222784.000000
ITER 6: row=15, varin=47, theta=0.146692, up=999999999999999983222784.000000
ITER 7: row=42, varin=45, theta=0.049145, up=999999999999999983222784.000000
ITER 8: row=45, varin=11, theta=0.300092, up=999999999999999983222784.000000
ITER 9: row=11, varin=24, theta=0.243106, up=999999999999999983222784.000000
ITER 10: row=24, varin=14, theta=0.510609, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 6 = 1 gives z=26119721.697692
  % 	x6 = 1,	Z1 = 26119721.6976916        
DEBUG EVAL: First branch cutoff check: z=26119721.697692, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 6 = 0
ITER 1: row=15, varin=11, theta=0.099727, up=999999999999999983222784.000000
ITER 2: row=11, varin=37, theta=0.074457, up=999999999999999983222784.000000
ITER 3: row=35, varin=74, theta=0.469587, up=1.000000
ITER 4: row=6, varin=42, theta=0.306369, up=999999999999999983222784.000000
ITER 5: row=30, varin=24, theta=0.114920, up=999999999999999983222784.000000
  % 	x6 = 0,	Z0 = 26002278.2162378        
DEBUG EVAL: Second branch cutoff check: z=26002278.216238, best_z=INF, threshold=INF
  %   New best:  x6, Z = 26002278.2162378        
DEBUG EVAL: Testing var 28 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=39, varin=11, theta=0.099727, up=999999999999999983222784.000000
ITER 2: row=11, varin=37, theta=0.074457, up=999999999999999983222784.000000
ITER 3: row=35, varin=74, theta=0.469587, up=1.000000
ITER 4: row=6, varin=24, theta=0.114920, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 28 = 0 gives z=26002278.216238
  % 	x28 = 0,	Z0 = 26002278.2162378        
DEBUG EVAL: First branch cutoff check: z=26002278.216238, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 28 = 1
ITER 1: row=39, varin=81, theta=0.303955, up=1.000000
ITER 2: row=29, varin=50, theta=1.567891, up=999999999999999983222784.000000
ITER 3: row=48, varin=83, theta=0.306706, up=1.000000
ITER 4: row=1, varin=76, theta=0.174327, up=1.000000
ITER 5: row=48, varin=48, theta=0.182648, up=999999999999999983222784.000000
ITER 6: row=39, varin=42, theta=0.115024, up=999999999999999983222784.000000
ITER 7: row=30, varin=47, theta=0.146692, up=999999999999999983222784.000000
ITER 8: row=42, varin=45, theta=0.049145, up=999999999999999983222784.000000
ITER 9: row=45, varin=11, theta=0.300092, up=999999999999999983222784.000000
ITER 10: row=11, varin=43, theta=0.090706, up=999999999999999983222784.000000
  % 	x28 = 1,	Z1 = 26049163.6094254        
DEBUG EVAL: Second branch cutoff check: z=26049163.609425, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 8 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=29, varin=81, theta=0.048436, up=1.000000
ITER 2: row=48, varin=83, theta=0.051088, up=1.000000
DEBUG EVAL: Branch var 8 = 0 gives z=25980572.170735
  % 	x8 = 0,	Z0 = 25980572.1707348        
DEBUG EVAL: First branch cutoff check: z=25980572.170735, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 34 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=42, varin=81, theta=0.048436, up=1.000000
ITER 2: row=48, varin=83, theta=0.051088, up=1.000000
DEBUG EVAL: Branch var 34 = 0 gives z=25980572.170735
  % 	x34 = 0,	Z0 = 25980572.1707348        
DEBUG EVAL: First branch cutoff check: z=25980572.170735, best_z=INF, threshold=INF
  % Best branch is x6, Z0 = 26002278.2162378        , Z1 = 26119721.6976916        

DEBUG CAREFUL: Final result - returning best.var = 6
DEBUG BB: Branching variable chosen: j=6
 % @NC    7    5	x6 = 0	26002278.216238
 % @NC    8    5	x6 = 1	26119721.697692
 %       5     4 25979785.8554               25986822.8798    x1 D     4     3
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ff1996d600
% @LO 0.01  25.97978585535540929641 99.9000000000
% @LN 0.01  25.98682287976127369689 99.9000000000
% Resuming node 3 at  25.98682287976127369689
DEBUG CONSTRNT: LP rows=50, pool->nlprows=50, pool->npend=0
DEBUG CONSTRNT: Checking 50 LP rows (pool tracks 50, total LP rows 50)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 70
DEBUG CONSTRNT: Pool row 70 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=49, expected 49
 % @PAP adding 56 rows, 241 nz to LP
DEBUG BB: Processing node 3, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 3 LP 8 Solution, length = 25986822.879761, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.117621 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.117621 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.117621 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.117621 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.117621 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.117621 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.117621 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.117621 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.117621 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.059032 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.117621 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.117621 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.117621 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.882379 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.882379 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.882379 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.882379 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.882379 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.882379 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.882379 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.882379 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.882379 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 13 fractional variables
DEBUG CG: LP optimal, z=25986822.879761, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=25986822.879761, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 3 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 3
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.117621
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.117621)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.117621
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.117621)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.117621
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.117621)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=1.000000
DEBUG CAREFUL: Skipping var 12: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.117621
DEBUG CAREFUL: Adding var 16 to fractional list (xi=0.117621)
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.117621
DEBUG CAREFUL: Adding var 23 to fractional list (xi=0.117621)
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.117621
DEBUG CAREFUL: Adding var 24 to fractional list (xi=0.117621)
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.117621
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.117621)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.117621
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.117621)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.117621
DEBUG CAREFUL: Adding var 32 to fractional list (xi=0.117621)
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.059032
DEBUG CAREFUL: Adding var 33 to fractional list (xi=0.059032)
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.117621
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.117621)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.117621
DEBUG CAREFUL: Adding var 35 to fractional list (xi=0.117621)
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.117621
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.117621)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 13 fractional variables

  %  Carefully choosing branching variable, nfrac = 13
DEBUG CAREFUL: Testing fvar[0] = var 16
DEBUG CAREFUL: Calling compare_branch_vars for var 16
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 16
DEBUG CAREFUL: New best var: 16
DEBUG CAREFUL: Testing fvar[1] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
DEBUG CAREFUL: Testing fvar[2] = var 24
DEBUG CAREFUL: Calling compare_branch_vars for var 24
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 24
DEBUG CAREFUL: Testing fvar[3] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
DEBUG CAREFUL: Testing fvar[4] = var 23
DEBUG CAREFUL: Calling compare_branch_vars for var 23
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 23
DEBUG CAREFUL: Testing fvar[5] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 34
DEBUG CAREFUL: Testing fvar[6] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 36
DEBUG CAREFUL: Testing fvar[7] = var 33
DEBUG CAREFUL: Calling compare_branch_vars for var 33
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 33
DEBUG CAREFUL: Testing fvar[8] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[9] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 29
DEBUG CAREFUL: Testing fvar[10] = var 35
DEBUG CAREFUL: Calling compare_branch_vars for var 35
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 35
DEBUG CAREFUL: Testing fvar[11] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 27
DEBUG CAREFUL: Testing fvar[12] = var 32
DEBUG CAREFUL: Calling compare_branch_vars for var 32
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 32
  % Initial guess is x16, Z0 = 25986822.8797613        , Z1 = 26770070.2196213        

DEBUG EVAL: Testing var 16 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=29, varin=7, theta=10.553570, up=999999999999999983222784.000000
ITER 2: row=33, varin=47, theta=7.315550, up=999999999999999983222784.000000
ITER 3: row=48, varin=37, theta=4.312571, up=999999999999999983222784.000000
ITER 4: row=40, varin=41, theta=2.061492, up=999999999999999983222784.000000
ITER 5: row=9, varin=5, theta=4.644595, up=999999999999999983222784.000000
ITER 6: row=15, varin=10, theta=2.580790, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 16 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x16 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=29, varin=26, theta=0.137996, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
ITER 2: row=42, varin=116, theta=0.000000, up=1.000000
ITER 3: row=43, varin=4, theta=0.000000, up=999999999999999983222784.000000
ITER 4: row=48, varin=46, theta=0.006855, up=999999999999999983222784.000000
ITER 5: row=43, varin=43, theta=0.000000, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 26056403.600224
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.988432
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.938305
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.938305
   % @PL 56 rows, 60 cols, 301 nonzeros, 6 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 6 slack rows
   % @PAP adding 12 rows, 36 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=78, theta=5.666667, up=1.000000
ITER 2: row=1, varin=97, theta=14.000000, up=1.000000
ITER 3: row=1, varin=92, theta=13.000000, up=1.000000
ITER 4: row=1, varin=64, theta=6.000000, up=1.000000
ITER 5: row=1, varin=70, theta=5.000000, up=1.000000
ITER 6: row=1, varin=72, theta=4.000000, up=1.000000
ITER 7: row=1, varin=84, theta=6.000000, up=1.000000
ITER 8: row=1, varin=88, theta=5.000000, up=1.000000
ITER 9: row=1, varin=99, theta=4.000000, up=1.000000
ITER 10: row=1, varin=91, theta=3.000000, up=1.000000
LP PHASE: Switching to primal (iter=99)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=62)
DEBUG SOLUTION: LP solution array indices: FST[63-102], not_covered[103-122]
DEBUG SOLUTION: lp->best_solution[0] = 26066444.597132
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 62 rows, 60 cols, 321 nonzeros, 2 slack, 60 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
   % @PAP adding 3 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=61, varin=4, theta=0.052245, up=999999999999999983222784.000000
ITER 2: row=54, varin=55, theta=0.221051, up=999999999999999983222784.000000
ITER 3: row=52, varin=54, theta=0.180852, up=999999999999999983222784.000000
ITER 4: row=63, varin=43, theta=0.093217, up=999999999999999983222784.000000
ITER 5: row=58, varin=61, theta=0.279924, up=999999999999999983222784.000000
ITER 6: row=42, varin=10, theta=0.002111, up=999999999999999983222784.000000
ITER 7: row=59, varin=49, theta=0.003567, up=999999999999999983222784.000000
ITER 8: row=37, varin=41, theta=0.038782, up=999999999999999983222784.000000
ITER 9: row=56, varin=51, theta=0.003676, up=999999999999999983222784.000000
ITER 10: row=38, varin=82, theta=0.005675, up=1.000000
LP PHASE: Switching to primal (iter=10)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=63)
DEBUG SOLUTION: LP solution array indices: FST[64-103], not_covered[104-123]
DEBUG SOLUTION: lp->best_solution[0] = 26092287.741022
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 63 rows, 60 cols, 325 nonzeros, 9 slack, 54 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 9 slack rows
   % @PAP adding 9 rows, 29 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=55, varin=97, theta=0.123569, up=1.000000
ITER 2: row=60, varin=38, theta=0.042314, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=63)
DEBUG SOLUTION: LP solution array indices: FST[64-103], not_covered[104-123]
DEBUG SOLUTION: lp->best_solution[0] = 26121582.503535
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 63 rows, 60 cols, 306 nonzeros, 4 slack, 59 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 4 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 3 at  26.12158250353515853703
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ff19984250
% @LO 0.01  25.98682287976127369689 99.9000000000
% @LN 0.01  26.00227821623780855020 99.9000000000
% Resuming node 7 at  26.00227821623780855020
DEBUG CONSTRNT: LP rows=59, pool->nlprows=59, pool->npend=0
DEBUG CONSTRNT: Checking 59 LP rows (pool tracks 59, total LP rows 59)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=56, expected 56
DEBUG CONSTRNT: Checking LP row 57 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=57, expected 57
DEBUG CONSTRNT: Checking LP row 58 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=58, expected 58
 % @PAP adding 50 rows, 213 nz to LP
DEBUG BB: Processing node 7, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=15, varin=11, theta=0.099727, up=999999999999999983222784.000000
ITER 2: row=11, varin=37, theta=0.074457, up=999999999999999983222784.000000
ITER 3: row=35, varin=74, theta=0.469587, up=1.000000
ITER 4: row=6, varin=42, theta=0.306369, up=999999999999999983222784.000000
ITER 5: row=30, varin=24, theta=0.114920, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 26002278.216238
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 6.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 273 nonzeros, 1 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=95, theta=0.260144, up=1.000000
ITER 2: row=52, varin=43, theta=0.029324, up=999999999999999983222784.000000
ITER 3: row=24, varin=39, theta=0.005931, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 26052454.697326
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 6.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 286 nonzeros, 5 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 3 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=58, theta=0.170264, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 26052764.115522
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 6.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 284 nonzeros, 1 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 4 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=47, theta=0.679011, up=999999999999999983222784.000000
ITER 2: row=53, varin=59, theta=0.008164, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 26067256.400944
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 6.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 53 rows, 60 cols, 287 nonzeros, 2 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 7 LP 1 Solution, length = 26067256.400944, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.008164 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.096734 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.096734 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.096734 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 1.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.096734 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 1.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.500000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.096734 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.096734 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.903266 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.903266 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.903266 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.903266 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.903266 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 9 fractional variables
DEBUG CG: LP optimal, z=26067256.400944, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.01  26.00227821623780855020 99.9000000000
 % @LN 0.01  26.06725640094428086968 99.9000000000
DEBUG CG: Second cutoff check: z=26067256.400944, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 7 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 7
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.500000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.008164
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.008164)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.096734
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.096734)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.096734
DEBUG CAREFUL: Adding var 8 to fractional list (xi=0.096734)
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.096734
DEBUG CAREFUL: Adding var 16 to fractional list (xi=0.096734)
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=1.000000
DEBUG CAREFUL: Skipping var 21: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.096734
DEBUG CAREFUL: Adding var 23 to fractional list (xi=0.096734)
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=1.000000
DEBUG CAREFUL: Skipping var 25: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.500000
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.096734
DEBUG CAREFUL: Adding var 28 to fractional list (xi=0.096734)
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.096734
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.096734)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 9 fractional variables

  %  Carefully choosing branching variable, nfrac = 9
DEBUG CAREFUL: Testing fvar[0] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 2
DEBUG CAREFUL: New best var: 2
DEBUG CAREFUL: Testing fvar[1] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 27
DEBUG CAREFUL: New best var: 27
DEBUG CAREFUL: Testing fvar[2] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 5
DEBUG CAREFUL: New best var: 5
DEBUG CAREFUL: Testing fvar[3] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
DEBUG CAREFUL: Testing fvar[4] = var 23
DEBUG CAREFUL: Calling compare_branch_vars for var 23
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 23
DEBUG CAREFUL: Testing fvar[5] = var 16
DEBUG CAREFUL: Calling compare_branch_vars for var 16
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 16
DEBUG CAREFUL: New best var: 16
DEBUG CAREFUL: Testing fvar[6] = var 8
DEBUG CAREFUL: Calling compare_branch_vars for var 8
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 8
DEBUG CAREFUL: Testing fvar[7] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 34
DEBUG CAREFUL: Testing fvar[8] = var 28
DEBUG CAREFUL: Calling compare_branch_vars for var 28
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 28
  % Initial guess is x16, Z0 = 26067256.4009443        , Z1 = 26770070.2196213        

DEBUG EVAL: Testing var 2 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=24, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=6, varin=109, theta=0.454907, up=1.000000
ITER 3: row=36, varin=84, theta=1.717241, up=1.000000
ITER 4: row=36, varin=82, theta=0.613664, up=1.000000
ITER 5: row=43, varin=74, theta=0.280987, up=1.000000
ITER 6: row=11, varin=50, theta=0.611784, up=999999999999999983222784.000000
ITER 7: row=50, varin=40, theta=0.298825, up=999999999999999983222784.000000
ITER 8: row=11, varin=77, theta=0.152454, up=1.000000
ITER 9: row=15, varin=41, theta=0.028551, up=999999999999999983222784.000000
ITER 10: row=48, varin=51, theta=0.078961, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 1 gives z=26203655.554888
  % 	x2 = 1,	Z1 = 26203655.5548879        
DEBUG EVAL: First branch cutoff check: z=26203655.554888, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 0
ITER 1: row=1, varin=45, theta=1.000000, up=999999999999999983222784.000000
  % 	x2 = 0,	Z0 = 26135422.4494251        
DEBUG EVAL: Second branch cutoff check: z=26135422.449425, best_z=INF, threshold=INF
  %   New best:  x2, Z = 26135422.4494251        
DEBUG EVAL: Testing var 27 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=24, varin=23, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 27 = 1 gives z=26387325.483701
  % 	x27 = 1,	Z1 = 26387325.4837014        
DEBUG EVAL: First branch cutoff check: z=26387325.483701, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 27 = 0
ITER 1: row=24, varin=24, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=6, varin=45, theta=0.544502, up=999999999999999983222784.000000
  % 	x27 = 0,	Z0 = 26126521.7112639        
DEBUG EVAL: Second branch cutoff check: z=26126521.711264, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 5 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=15, varin=51, theta=0.910646, up=999999999999999983222784.000000
ITER 2: row=29, varin=24, theta=1.343838, up=999999999999999983222784.000000
ITER 3: row=31, varin=37, theta=9.379291, up=999999999999999983222784.000000
ITER 4: row=29, varin=41, theta=0.248893, up=999999999999999983222784.000000
ITER 5: row=30, varin=46, theta=0.247912, up=999999999999999983222784.000000
ITER 6: row=40, varin=45, theta=2.087156, up=999999999999999983222784.000000
ITER 7: row=1, varin=24, theta=1.253128, up=999999999999999983222784.000000
ITER 8: row=24, varin=42, theta=0.727434, up=999999999999999983222784.000000
ITER 9: row=42, varin=48, theta=0.243780, up=999999999999999983222784.000000
ITER 10: row=41, varin=3, theta=1.382090, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 5 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x5 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=15, varin=84, theta=0.010553, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 26067538.551827
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 6.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 51 rows, 60 cols, 270 nonzeros, 0 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 2 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=111, theta=0.005326, up=1.000000
ITER 2: row=36, varin=84, theta=0.009958, up=1.000000
ITER 3: row=43, varin=76, theta=0.006812, up=1.000000
ITER 4: row=11, varin=54, theta=0.005790, up=1.000000
ITER 5: row=2, varin=50, theta=0.025447, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 26068208.880059
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 6.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 53 rows, 60 cols, 277 nonzeros, 1 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 7 at  26.06820888005908898322
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ff19984250
% @LO 0.01  26.06725640094428086968 99.9000000000
% @LN 0.01  26.06820888005908898322 99.9000000000
% Resuming node 7 at  26.06820888005908898322
DEBUG CONSTRNT: LP rows=52, pool->nlprows=52, pool->npend=0
DEBUG CONSTRNT: Checking 52 LP rows (pool tracks 52, total LP rows 52)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 70
DEBUG CONSTRNT: Pool row 70 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=51, expected 51
 % @PAP adding 52 rows, 215 nz to LP
DEBUG BB: Processing node 7, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 7 LP 2 Solution, length = 26068208.880059, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.100000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.100000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.100000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 1.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.100000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 1.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.500000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.074553 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.100000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.900000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.900000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.925447 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.900000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.900000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 8 fractional variables
DEBUG CG: LP optimal, z=26068208.880059, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=26068208.880059, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 7 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 7
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.500000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.100000
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.100000)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.100000
DEBUG CAREFUL: Adding var 8 to fractional list (xi=0.100000)
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.100000
DEBUG CAREFUL: Adding var 16 to fractional list (xi=0.100000)
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=1.000000
DEBUG CAREFUL: Skipping var 21: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.100000
DEBUG CAREFUL: Adding var 23 to fractional list (xi=0.100000)
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=1.000000
DEBUG CAREFUL: Skipping var 25: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.500000
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.074553
DEBUG CAREFUL: Adding var 28 to fractional list (xi=0.074553)
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.100000
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.100000)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 8 fractional variables

  %  Carefully choosing branching variable, nfrac = 8
DEBUG CAREFUL: Testing fvar[0] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 27
DEBUG CAREFUL: New best var: 27
DEBUG CAREFUL: Testing fvar[1] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 2
DEBUG CAREFUL: New best var: 2
DEBUG CAREFUL: Testing fvar[2] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
DEBUG CAREFUL: Testing fvar[3] = var 23
DEBUG CAREFUL: Calling compare_branch_vars for var 23
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 23
DEBUG CAREFUL: Testing fvar[4] = var 16
DEBUG CAREFUL: Calling compare_branch_vars for var 16
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 16
DEBUG CAREFUL: Testing fvar[5] = var 8
DEBUG CAREFUL: Calling compare_branch_vars for var 8
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 8
DEBUG CAREFUL: Testing fvar[6] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 34
DEBUG CAREFUL: Testing fvar[7] = var 28
DEBUG CAREFUL: Calling compare_branch_vars for var 28
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 28
  % Initial guess is x2, Z0 = 26135422.4494251        , Z1 = 26203655.5548879        

DEBUG EVAL: Testing var 27 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=24, varin=45, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=46, varin=6, theta=0.204040, up=999999999999999983222784.000000
ITER 3: row=6, varin=79, theta=0.002326, up=1.000000
ITER 4: row=26, varin=56, theta=0.000664, up=1.000000
ITER 5: row=7, varin=78, theta=0.000503, up=1.000000
DEBUG EVAL: Branch var 27 = 0 gives z=26148836.219032
  % 	x27 = 0,	Z0 = 26148836.2190325        
DEBUG EVAL: First branch cutoff check: z=26148836.219032, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 27 = 1
ITER 1: row=24, varin=23, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=30, varin=6, theta=1.709203, up=999999999999999983222784.000000
ITER 3: row=6, varin=79, theta=0.869064, up=1.000000
ITER 4: row=26, varin=56, theta=0.248079, up=1.000000
ITER 5: row=7, varin=78, theta=0.187877, up=1.000000
  % 	x27 = 1,	Z1 = 26462338.7870521        
DEBUG EVAL: Second branch cutoff check: z=26462338.787052, best_z=INF, threshold=INF
  %   New best:  x27, Z = 26148836.2190325        
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=45, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=46, varin=6, theta=0.204040, up=999999999999999983222784.000000
ITER 3: row=6, varin=79, theta=0.002326, up=1.000000
ITER 4: row=26, varin=56, theta=0.000664, up=1.000000
ITER 5: row=7, varin=78, theta=0.000503, up=1.000000
DEBUG EVAL: Branch var 2 = 0 gives z=26148836.219032
  % 	x2 = 0,	Z0 = 26148836.2190325        
DEBUG EVAL: First branch cutoff check: z=26148836.219032, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 1
ITER 1: row=1, varin=24, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=30, varin=6, theta=4.327252, up=999999999999999983222784.000000
ITER 3: row=6, varin=79, theta=2.376649, up=1.000000
ITER 4: row=6, varin=56, theta=0.392971, up=1.000000
ITER 5: row=26, varin=79, theta=1.000000, up=1.000000
ITER 6: row=7, varin=78, theta=0.513791, up=1.000000
  % 	x2 = 1,	Z1 = 26298040.0310462        
DEBUG EVAL: Second branch cutoff check: z=26298040.031046, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 7 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=15, varin=2, theta=2.250000, up=999999999999999983222784.000000
ITER 2: row=30, varin=6, theta=13.662637, up=999999999999999983222784.000000
ITER 3: row=6, varin=48, theta=2.600356, up=999999999999999983222784.000000
ITER 4: row=49, varin=40, theta=3.075415, up=999999999999999983222784.000000
ITER 5: row=47, varin=78, theta=2.448586, up=1.000000
ITER 6: row=47, varin=79, theta=24.495793, up=1.000000
ITER 7: row=47, varin=45, theta=5.926323, up=999999999999999983222784.000000
ITER 8: row=1, varin=41, theta=1.032759, up=999999999999999983222784.000000
ITER 9: row=2, varin=79, theta=1.924025, up=1.000000
ITER 10: row=2, varin=51, theta=0.535885, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 7 = 1 gives z=27202561.363128
  % 	x7 = 1,	Z1 = 27202561.3631279        
DEBUG EVAL: First branch cutoff check: z=27202561.363128, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 7 = 0
ITER 1: row=15, varin=79, theta=1.000000, up=1.000000
ITER 2: row=26, varin=56, theta=0.250000, up=1.000000
ITER 3: row=7, varin=50, theta=0.166667, up=999999999999999983222784.000000
ITER 4: row=30, varin=6, theta=0.650769, up=999999999999999983222784.000000
ITER 5: row=50, varin=89, theta=0.146537, up=1.000000
  % 	x7 = 0,	Z0 = 26095372.7003548        
DEBUG EVAL: Second branch cutoff check: z=26095372.700355, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 23 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=6, theta=0.100000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 23 = 0 gives z=26068648.173770
  % 	x23 = 0,	Z0 = 26068648.1737699        
DEBUG EVAL: First branch cutoff check: z=26068648.173770, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 16 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=40, varin=2, theta=2.250000, up=999999999999999983222784.000000
ITER 2: row=30, varin=6, theta=13.662637, up=999999999999999983222784.000000
ITER 3: row=6, varin=40, theta=3.075415, up=999999999999999983222784.000000
ITER 4: row=47, varin=78, theta=2.448586, up=1.000000
ITER 5: row=47, varin=79, theta=24.495793, up=1.000000
ITER 6: row=47, varin=45, theta=5.926323, up=999999999999999983222784.000000
ITER 7: row=1, varin=50, theta=3.896684, up=999999999999999983222784.000000
ITER 8: row=15, varin=14, theta=2.685151, up=999999999999999983222784.000000
ITER 9: row=14, varin=56, theta=12.316648, up=1.000000
ITER 10: row=14, varin=42, theta=6.980499, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 16 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x16 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=79, theta=1.000000, up=1.000000
ITER 2: row=26, varin=48, theta=0.166667, up=999999999999999983222784.000000
ITER 3: row=49, varin=56, theta=0.250000, up=1.000000
ITER 4: row=7, varin=89, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 26106107.911698
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 6.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 52 rows, 60 cols, 275 nonzeros, 0 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 6 rows, 32 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=55, varin=50, theta=0.137647, up=999999999999999983222784.000000
ITER 2: row=53, varin=100, theta=0.174009, up=1.000000
ITER 3: row=52, varin=76, theta=0.113417, up=1.000000
ITER 4: row=9, varin=69, theta=0.172015, up=1.000000
ITER 5: row=18, varin=68, theta=0.193272, up=1.000000
ITER 6: row=17, varin=32, theta=0.072427, up=999999999999999983222784.000000
ITER 7: row=44, varin=79, theta=0.088521, up=1.000000
ITER 8: row=10, varin=43, theta=0.061331, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=58)
DEBUG SOLUTION: LP solution array indices: FST[59-98], not_covered[99-118]
DEBUG SOLUTION: lp->best_solution[0] = 26156257.952844
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.816008
DEBUG SOLUTION: lp->best_solution[5] = 2.816008
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 6.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 58 rows, 60 cols, 307 nonzeros, 10 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 10 slack rows
   % @PAP adding 5 rows, 15 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=97, theta=0.038319, up=1.000000
ITER 2: row=18, varin=8, theta=0.067569, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
ITER 3: row=39, varin=79, theta=0.210410, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 26161832.181890
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 6.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 53 rows, 60 cols, 284 nonzeros, 0 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 7 at  26.16183218189017622990
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ff19980d00
% @LO 0.01  26.06820888005908898322 99.9000000000
% @LN 0.01  26.11972169769164864306 99.9000000000
% Resuming node 8 at  26.11972169769164864306
DEBUG CONSTRNT: LP rows=53, pool->nlprows=53, pool->npend=0
DEBUG CONSTRNT: Checking 53 LP rows (pool tracks 53, total LP rows 53)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 70
DEBUG CONSTRNT: Pool row 70 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=52, expected 52
 % @PAP adding 50 rows, 213 nz to LP
DEBUG BB: Processing node 8, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=15, varin=81, theta=0.303955, up=1.000000
ITER 2: row=29, varin=50, theta=1.567891, up=999999999999999983222784.000000
ITER 3: row=48, varin=83, theta=0.306706, up=1.000000
ITER 4: row=1, varin=76, theta=0.174327, up=1.000000
ITER 5: row=48, varin=48, theta=0.182648, up=999999999999999983222784.000000
ITER 6: row=15, varin=47, theta=0.146692, up=999999999999999983222784.000000
ITER 7: row=42, varin=45, theta=0.049145, up=999999999999999983222784.000000
ITER 8: row=45, varin=11, theta=0.300092, up=999999999999999983222784.000000
ITER 9: row=11, varin=24, theta=0.243106, up=999999999999999983222784.000000
ITER 10: row=24, varin=14, theta=0.510609, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=12)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 26119721.697692
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 6.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 273 nonzeros, 3 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 2 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=74, theta=0.835763, up=1.000000
ITER 2: row=3, varin=79, theta=1.606427, up=1.000000
ITER 3: row=3, varin=77, theta=0.288726, up=1.000000
ITER 4: row=14, varin=79, theta=1.000000, up=1.000000
ITER 5: row=24, varin=72, theta=0.944120, up=1.000000
ITER 6: row=11, varin=66, theta=0.154616, up=1.000000
ITER 7: row=48, varin=14, theta=1.856826, up=999999999999999983222784.000000
ITER 8: row=16, varin=80, theta=2.781066, up=1.000000
ITER 9: row=16, varin=82, theta=2.225974, up=1.000000
ITER 10: row=16, varin=76, theta=1.856026, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 6.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 274 nonzeros, 3 slack, 46 tight.
  % Node 8 LP 1 Solution, length = 999999999999999983222784.000000, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 1.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.758809 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.758809 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.758809 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.241191 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.241191 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.241191 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 8 is INFEASIBLE
 %       8     3    infeasible               26121582.5035    x6 U     5     4
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ff1996d600
% @LO 0.01  26.11972169769164864306 99.9000000000
% @LN 0.01  26.12158250353515853703 99.9000000000
% Resuming node 3 at  26.12158250353515853703
DEBUG CONSTRNT: LP rows=49, pool->nlprows=49, pool->npend=0
DEBUG CONSTRNT: Checking 49 LP rows (pool tracks 49, total LP rows 49)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 70
DEBUG CONSTRNT: Pool row 70 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 60
DEBUG CONSTRNT: Pool row 60 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=48, expected 48
 % @PAP adding 59 rows, 221 nz to LP
DEBUG BB: Processing node 3, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 3 LP 9 Solution, length = 26121582.503535, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.120826 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.120826 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.021157 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.120826 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.021157 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.021157 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.021157 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.021157 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.021157 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.021157 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.120826 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.120826 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.021157 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.120826 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.120826 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.021157 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.120826 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.120826 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.120826 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.120826 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.879174 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.879174 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.978843 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.879174 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.879174 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.978843 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.879174 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.879174 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.978843 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.879174 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.978843 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.978843 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.879174 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.978843 (terminal 19)
 % 20 fractional variables
DEBUG CG: LP optimal, z=26121582.503535, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=26121582.503535, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 3 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 3
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.120826
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.120826)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.120826
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.120826)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.021157
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.021157)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.120826
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.120826)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.021157
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.021157)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.021157
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.021157)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=1.000000
DEBUG CAREFUL: Skipping var 12: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.021157
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.021157)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.021157
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.021157)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.021157
DEBUG CAREFUL: Adding var 20 to fractional list (xi=0.021157)
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.021157
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.021157)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.120826
DEBUG CAREFUL: Adding var 23 to fractional list (xi=0.120826)
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.120826
DEBUG CAREFUL: Adding var 24 to fractional list (xi=0.120826)
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.021157
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.021157)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.120826
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.120826)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.120826
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.120826)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.021157
DEBUG CAREFUL: Adding var 31 to fractional list (xi=0.021157)
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.120826
DEBUG CAREFUL: Adding var 32 to fractional list (xi=0.120826)
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.120826
DEBUG CAREFUL: Adding var 33 to fractional list (xi=0.120826)
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.120826
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.120826)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.120826
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.120826)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 20 fractional variables

  %  Carefully choosing branching variable, nfrac = 20
DEBUG CAREFUL: Testing fvar[0] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
DEBUG CAREFUL: Testing fvar[1] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[2] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[3] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 22
DEBUG CAREFUL: Testing fvar[4] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
DEBUG CAREFUL: Testing fvar[5] = var 23
DEBUG CAREFUL: Calling compare_branch_vars for var 23
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 23
DEBUG CAREFUL: Testing fvar[6] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 34
DEBUG CAREFUL: Testing fvar[7] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 36
DEBUG CAREFUL: Testing fvar[8] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[9] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[10] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[11] = var 20
DEBUG CAREFUL: Calling compare_branch_vars for var 20
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 20
DEBUG CAREFUL: Testing fvar[12] = var 24
DEBUG CAREFUL: Calling compare_branch_vars for var 24
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 24
DEBUG CAREFUL: Testing fvar[13] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
DEBUG CAREFUL: Testing fvar[14] = var 31
DEBUG CAREFUL: Calling compare_branch_vars for var 31
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 31
DEBUG CAREFUL: Testing fvar[15] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 29
DEBUG CAREFUL: Testing fvar[16] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[17] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 27
DEBUG CAREFUL: Testing fvar[18] = var 32
DEBUG CAREFUL: Calling compare_branch_vars for var 32
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 32
DEBUG CAREFUL: Testing fvar[19] = var 33
DEBUG CAREFUL: Calling compare_branch_vars for var 33
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 33
  % Initial guess is x18, Z0 = 26121582.5035352        , Z1 = 29495338.9870639        

DEBUG EVAL: Testing var 18 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=31, varin=36, theta=3.096802, up=999999999999999983222784.000000
ITER 2: row=56, varin=54, theta=12.950773, up=999999999999999983222784.000000
ITER 3: row=1, varin=11, theta=1.732417, up=999999999999999983222784.000000
ITER 4: row=58, varin=53, theta=6.794921, up=999999999999999983222784.000000
ITER 5: row=39, varin=48, theta=2.178179, up=999999999999999983222784.000000
ITER 6: row=59, varin=3, theta=4.826869, up=999999999999999983222784.000000
ITER 7: row=3, varin=46, theta=3.193847, up=999999999999999983222784.000000
ITER 8: row=44, varin=43, theta=10.387786, up=999999999999999983222784.000000
ITER 9: row=12, varin=42, theta=12.000000, up=999999999999999983222784.000000
ITER 10: row=42, varin=38, theta=12.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 18 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x18 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=31, varin=57, theta=0.029274, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=59)
DEBUG SOLUTION: LP solution array indices: FST[60-99], not_covered[100-119]
DEBUG SOLUTION: lp->best_solution[0] = 26121610.657802
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 59 rows, 60 cols, 281 nonzeros, 4 slack, 55 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 4 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 3 at  26.12161065780171398387
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ff1996d600
% @LO 0.02  26.12158250353515853703 99.9000000000
% @LN 0.02  26.12161065780171398387 99.9000000000
% Resuming node 3 at  26.12161065780171398387
DEBUG CONSTRNT: LP rows=55, pool->nlprows=55, pool->npend=0
DEBUG CONSTRNT: Checking 55 LP rows (pool tracks 55, total LP rows 55)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=54, expected 54
 % @PAP adding 55 rows, 213 nz to LP
DEBUG BB: Processing node 3, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 3 LP 10 Solution, length = 26121610.657802, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.117876 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.117876 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.029274 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.117876 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.029274 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.029274 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.029274 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.029274 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.029274 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.117876 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.117876 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.029274 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.117876 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.117876 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.029274 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.117876 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.117876 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.117876 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.117876 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.882124 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.882124 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.970726 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.882124 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.882124 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.970726 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.882124 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.882124 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.970726 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.882124 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.970726 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.970726 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.882124 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.970726 (terminal 19)
 % 19 fractional variables
DEBUG CG: LP optimal, z=26121610.657802, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=26121610.657802, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 3 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 3
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.117876
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.117876)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.117876
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.117876)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.029274
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.029274)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.117876
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.117876)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.029274
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.029274)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.029274
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.029274)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=1.000000
DEBUG CAREFUL: Skipping var 12: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.029274
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.029274)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.029274
DEBUG CAREFUL: Adding var 20 to fractional list (xi=0.029274)
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.029274
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.029274)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.117876
DEBUG CAREFUL: Adding var 23 to fractional list (xi=0.117876)
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.117876
DEBUG CAREFUL: Adding var 24 to fractional list (xi=0.117876)
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.029274
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.029274)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.117876
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.117876)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.117876
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.117876)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.029274
DEBUG CAREFUL: Adding var 31 to fractional list (xi=0.029274)
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.117876
DEBUG CAREFUL: Adding var 32 to fractional list (xi=0.117876)
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.117876
DEBUG CAREFUL: Adding var 33 to fractional list (xi=0.117876)
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.117876
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.117876)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.117876
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.117876)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 19 fractional variables

  %  Carefully choosing branching variable, nfrac = 19
DEBUG CAREFUL: Testing fvar[0] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[1] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 22
DEBUG CAREFUL: Testing fvar[2] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
DEBUG CAREFUL: Testing fvar[3] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[4] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[5] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[6] = var 20
DEBUG CAREFUL: Calling compare_branch_vars for var 20
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 20
DEBUG CAREFUL: New best var: 20
DEBUG CAREFUL: Testing fvar[7] = var 31
DEBUG CAREFUL: Calling compare_branch_vars for var 31
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 31
DEBUG CAREFUL: Testing fvar[8] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
DEBUG CAREFUL: Testing fvar[9] = var 23
DEBUG CAREFUL: Calling compare_branch_vars for var 23
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 23
DEBUG CAREFUL: Testing fvar[10] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 34
DEBUG CAREFUL: Testing fvar[11] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 36
DEBUG CAREFUL: Testing fvar[12] = var 24
DEBUG CAREFUL: Calling compare_branch_vars for var 24
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 24
DEBUG CAREFUL: Testing fvar[13] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
DEBUG CAREFUL: Testing fvar[14] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 29
DEBUG CAREFUL: Testing fvar[15] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[16] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 27
DEBUG CAREFUL: Testing fvar[17] = var 32
DEBUG CAREFUL: Calling compare_branch_vars for var 32
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 32
DEBUG CAREFUL: Testing fvar[18] = var 33
DEBUG CAREFUL: Calling compare_branch_vars for var 33
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 33
  % Initial guess is x20, Z0 = 26121610.6578017        , Z1 = 29250638.9175699        

DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=17, varin=36, theta=2.219560, up=999999999999999983222784.000000
ITER 2: row=4, varin=48, theta=1.833850, up=999999999999999983222784.000000
ITER 3: row=48, varin=54, theta=4.220591, up=999999999999999983222784.000000
ITER 4: row=24, varin=5, theta=0.892127, up=999999999999999983222784.000000
ITER 5: row=45, varin=53, theta=2.051155, up=999999999999999983222784.000000
ITER 6: row=38, varin=49, theta=1.056746, up=999999999999999983222784.000000
ITER 7: row=1, varin=11, theta=0.585388, up=999999999999999983222784.000000
ITER 8: row=11, varin=42, theta=2.576857, up=999999999999999983222784.000000
ITER 9: row=42, varin=43, theta=2.791728, up=999999999999999983222784.000000
ITER 10: row=12, varin=38, theta=3.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x3 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=17, varin=67, theta=0.113613, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 26146262.269106
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 55 rows, 60 cols, 273 nonzeros, 0 slack, 55 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 6 rows, 34 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=56, varin=66, theta=0.131982, up=1.000000
ITER 2: row=57, varin=35, theta=0.016690, up=999999999999999983222784.000000
ITER 3: row=61, varin=57, theta=0.019107, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=61)
DEBUG SOLUTION: LP solution array indices: FST[62-101], not_covered[102-121]
DEBUG SOLUTION: lp->best_solution[0] = 26191612.142972
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.980893
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 61 rows, 60 cols, 307 nonzeros, 5 slack, 56 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 5 slack rows
   % @PAP adding 4 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=59, varin=56, theta=0.101325, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=60)
DEBUG SOLUTION: LP solution array indices: FST[61-100], not_covered[101-120]
DEBUG SOLUTION: lp->best_solution[0] = 26202478.174557
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
   % @PL 60 rows, 60 cols, 296 nonzeros, 2 slack, 58 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 3 at  26.20247817455725325431
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ff19984250
% @LO 0.02  26.12161065780171398387 99.9000000000
% @LN 0.02  26.16183218189017622990 99.9000000000
% Resuming node 7 at  26.16183218189017622990
DEBUG CONSTRNT: LP rows=58, pool->nlprows=58, pool->npend=0
DEBUG CONSTRNT: Checking 58 LP rows (pool tracks 58, total LP rows 58)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=56, expected 56
DEBUG CONSTRNT: Checking LP row 57 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=57, expected 57
 % @PAP adding 53 rows, 224 nz to LP
DEBUG BB: Processing node 7, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 7 LP 3 Solution, length = 26161832.181890, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.289590 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.789590 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.789590 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.500000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.289590 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.289590 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.710410 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.710410 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.210410 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.710410 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.210410 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.210410 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=26161832.181890, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=26161832.181890, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 7 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 7
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.500000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.289590
DEBUG CAREFUL: Adding var 8 to fractional list (xi=0.289590)
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.789590
DEBUG CAREFUL: Adding var 21 to fractional list (xi=0.789590)
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.789590
DEBUG CAREFUL: Adding var 25 to fractional list (xi=0.789590)
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.500000
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.289590
DEBUG CAREFUL: Adding var 28 to fractional list (xi=0.289590)
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.289590
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.289590)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 7 fractional variables

  %  Carefully choosing branching variable, nfrac = 7
DEBUG CAREFUL: Testing fvar[0] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 27
DEBUG CAREFUL: New best var: 27
DEBUG CAREFUL: Testing fvar[1] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[2] = var 25
DEBUG CAREFUL: Calling compare_branch_vars for var 25
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 25
DEBUG CAREFUL: Testing fvar[3] = var 21
DEBUG CAREFUL: Calling compare_branch_vars for var 21
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 21
DEBUG CAREFUL: Testing fvar[4] = var 8
DEBUG CAREFUL: Calling compare_branch_vars for var 8
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 8
DEBUG CAREFUL: Testing fvar[5] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 34
DEBUG CAREFUL: Testing fvar[6] = var 28
DEBUG CAREFUL: Calling compare_branch_vars for var 28
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 28
  % Initial guess is x27, Z0 = 26161832.1818902        , Z1 = 26462338.7870521        

DEBUG EVAL: Testing var 27 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=22, varin=21, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 27 = 1 gives z=26611480.648379
  % 	x27 = 1,	Z1 = 26611480.6483793        
DEBUG EVAL: First branch cutoff check: z=26611480.648379, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 27 = 0
ITER 1: row=22, varin=41, theta=1.000000, up=999999999999999983222784.000000
  % 	x27 = 0,	Z0 = 26332388.2038493        
DEBUG EVAL: Second branch cutoff check: z=26332388.203849, best_z=INF, threshold=INF
  %   New best:  x27, Z = 26332388.2038493        
DEBUG EVAL: Testing var 2 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=22, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 1 gives z=26387329.628268
  % 	x2 = 1,	Z1 = 26387329.6282683        
DEBUG EVAL: First branch cutoff check: z=26387329.628268, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 0
ITER 1: row=1, varin=41, theta=1.000000, up=999999999999999983222784.000000
  % 	x2 = 0,	Z0 = 26332388.2038493        
DEBUG EVAL: Second branch cutoff check: z=26332388.203849, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 25 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=30, varin=97, theta=0.067569, up=1.000000
DEBUG EVAL: Branch var 25 = 1 gives z=26163220.098818
  % 	x25 = 1,	Z1 = 26163220.0988178        
DEBUG EVAL: First branch cutoff check: z=26163220.098818, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 21 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=27, varin=97, theta=0.067569, up=1.000000
DEBUG EVAL: Branch var 21 = 1 gives z=26163220.098818
  % 	x21 = 1,	Z1 = 26163220.0988178        
DEBUG EVAL: First branch cutoff check: z=26163220.098818, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 8 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=13, varin=97, theta=0.153549, up=1.000000
ITER 2: row=32, varin=38, theta=0.245393, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 8 = 0 gives z=26184812.113696
  % 	x8 = 0,	Z0 = 26184812.1136962        
DEBUG EVAL: First branch cutoff check: z=26184812.113696, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 34 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=37, varin=97, theta=0.153549, up=1.000000
ITER 2: row=27, varin=38, theta=0.245393, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 34 = 0 gives z=26184812.113696
  % 	x34 = 0,	Z0 = 26184812.1136962        
DEBUG EVAL: First branch cutoff check: z=26184812.113696, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 28 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=28, varin=48, theta=0.323533, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 28 = 0 gives z=26164983.935020
  % 	x28 = 0,	Z0 = 26164983.9350204        
DEBUG EVAL: First branch cutoff check: z=26164983.935020, best_z=INF, threshold=INF
  % Best branch is x27, Z0 = 26332388.2038493        , Z1 = 26611480.6483793        

DEBUG CAREFUL: Final result - returning best.var = 27
DEBUG BB: Branching variable chosen: j=27
 % @NC    9    7	x27 = 0	26332388.203849
 % @NC   10    7	x27 = 1	26611480.648379
 %       7     4 26161832.1819               26202478.1746    x6 D     5     4
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ff1996d600
% @LO 0.02  26.16183218189017622990 99.9000000000
% @LN 0.02  26.20247817455725325431 99.9000000000
% Resuming node 3 at  26.20247817455725325431
DEBUG CONSTRNT: LP rows=53, pool->nlprows=53, pool->npend=0
DEBUG CONSTRNT: Checking 53 LP rows (pool tracks 53, total LP rows 53)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 70
DEBUG CONSTRNT: Pool row 70 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=52, expected 52
 % @PAP adding 58 rows, 219 nz to LP
DEBUG BB: Processing node 3, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 3 LP 11 Solution, length = 26202478.174557, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.099116 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.099116 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.033775 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.099116 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.033775 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.033775 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.033775 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.033775 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.033775 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.033775 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.099116 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.099116 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.033775 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.099116 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.099116 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.033775 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.099116 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.099116 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.099116 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.099116 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.900884 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.900884 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.966225 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.900884 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.900884 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.966225 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.900884 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.900884 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.966225 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.900884 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.966225 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.966225 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.900884 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.966225 (terminal 19)
 % 20 fractional variables
DEBUG CG: LP optimal, z=26202478.174557, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=26202478.174557, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 3 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 3
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.099116
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.099116)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.099116
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.099116)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.033775
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.033775)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.099116
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.099116)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.033775
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.033775)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.033775
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.033775)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.033775
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.033775)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=1.000000
DEBUG CAREFUL: Skipping var 12: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.033775
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.033775)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.033775
DEBUG CAREFUL: Adding var 20 to fractional list (xi=0.033775)
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.033775
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.033775)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.099116
DEBUG CAREFUL: Adding var 23 to fractional list (xi=0.099116)
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.099116
DEBUG CAREFUL: Adding var 24 to fractional list (xi=0.099116)
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.033775
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.033775)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.099116
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.099116)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.099116
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.099116)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.033775
DEBUG CAREFUL: Adding var 31 to fractional list (xi=0.033775)
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.099116
DEBUG CAREFUL: Adding var 32 to fractional list (xi=0.099116)
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.099116
DEBUG CAREFUL: Adding var 33 to fractional list (xi=0.099116)
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.099116
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.099116)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.099116
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.099116)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 20 fractional variables

  %  Carefully choosing branching variable, nfrac = 20
DEBUG CAREFUL: Testing fvar[0] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 22
DEBUG CAREFUL: New best var: 22
DEBUG CAREFUL: Testing fvar[1] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
DEBUG CAREFUL: Testing fvar[2] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
DEBUG CAREFUL: Testing fvar[3] = var 23
DEBUG CAREFUL: Calling compare_branch_vars for var 23
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 23
DEBUG CAREFUL: Testing fvar[4] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 34
DEBUG CAREFUL: Testing fvar[5] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[6] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[7] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[8] = var 20
DEBUG CAREFUL: Calling compare_branch_vars for var 20
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 20
DEBUG CAREFUL: New best var: 20
DEBUG CAREFUL: Testing fvar[9] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 36
DEBUG CAREFUL: Testing fvar[10] = var 31
DEBUG CAREFUL: Calling compare_branch_vars for var 31
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 31
DEBUG CAREFUL: Testing fvar[11] = var 24
DEBUG CAREFUL: Calling compare_branch_vars for var 24
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 24
DEBUG CAREFUL: Testing fvar[12] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
DEBUG CAREFUL: Testing fvar[13] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 4
DEBUG CAREFUL: Testing fvar[14] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 29
DEBUG CAREFUL: Testing fvar[15] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[16] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 11
DEBUG CAREFUL: Testing fvar[17] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 27
DEBUG CAREFUL: Testing fvar[18] = var 32
DEBUG CAREFUL: Calling compare_branch_vars for var 32
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 32
DEBUG CAREFUL: Testing fvar[19] = var 33
DEBUG CAREFUL: Calling compare_branch_vars for var 33
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 33
  % Initial guess is x20, Z0 = 26202478.1745573        , Z1 = 29250638.9175699        

DEBUG EVAL: Testing var 22 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=5, varin=96, theta=0.233493, up=1.000000
DEBUG EVAL: Branch var 22 = 0 gives z=26224681.781739
  % 	x22 = 0,	Z0 = 26224681.7817388        
DEBUG EVAL: First branch cutoff check: z=26224681.781739, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 22 = 1
ITER 1: row=5, varin=57, theta=3.775676, up=999999999999999983222784.000000
ITER 2: row=16, varin=4, theta=0.853529, up=999999999999999983222784.000000
ITER 3: row=35, varin=53, theta=2.389358, up=999999999999999983222784.000000
ITER 4: row=30, varin=45, theta=0.676306, up=999999999999999983222784.000000
ITER 5: row=23, varin=46, theta=0.558876, up=999999999999999983222784.000000
ITER 6: row=25, varin=70, theta=3.195740, up=1.000000
ITER 7: row=25, varin=63, theta=3.931705, up=1.000000
ITER 8: row=25, varin=96, theta=3.579342, up=1.000000
ITER 9: row=25, varin=97, theta=2.701239, up=1.000000
ITER 10: row=25, varin=98, theta=3.616722, up=1.000000
  % 	x22 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: Second branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=5, varin=96, theta=0.233493, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=58)
DEBUG SOLUTION: LP solution array indices: FST[59-98], not_covered[99-118]
DEBUG SOLUTION: lp->best_solution[0] = 26224681.781739
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
   % @PL 58 rows, 60 cols, 279 nonzeros, 0 slack, 58 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 4 rows, 20 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=59, varin=102, theta=0.279042, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=62)
DEBUG SOLUTION: LP solution array indices: FST[63-102], not_covered[103-122]
DEBUG SOLUTION: lp->best_solution[0] = 26272394.884007
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
   % @PL 62 rows, 60 cols, 299 nonzeros, 0 slack, 62 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 4 rows, 21 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=63, varin=105, theta=0.236657, up=1.000000
ITER 2: row=62, varin=48, theta=0.037734, up=999999999999999983222784.000000
ITER 3: row=9, varin=5, theta=0.034793, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=66)
DEBUG SOLUTION: LP solution array indices: FST[67-106], not_covered[107-126]
DEBUG SOLUTION: lp->best_solution[0] = 26336695.925005
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.965207
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
   % @PL 66 rows, 60 cols, 320 nonzeros, 5 slack, 61 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 5 slack rows
   % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=62, varin=8, theta=0.005724, up=999999999999999983222784.000000
ITER 2: row=46, varin=59, theta=0.040790, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=63)
DEBUG SOLUTION: LP solution array indices: FST[64-103], not_covered[104-123]
DEBUG SOLUTION: lp->best_solution[0] = 26345721.168046
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
   % @PL 63 rows, 60 cols, 297 nonzeros, 1 slack, 62 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 3 at  26.34572116804606523033
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ff19980d00
% @LO 0.02  26.20247817455725325431 99.9000000000
% @LN 0.02  26.33238820384926981433 99.9000000000
% Resuming node 9 at  26.33238820384926981433
DEBUG CONSTRNT: LP rows=62, pool->nlprows=62, pool->npend=0
DEBUG CONSTRNT: Checking 62 LP rows (pool tracks 62, total LP rows 62)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=56, expected 56
DEBUG CONSTRNT: Checking LP row 57 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=57, expected 57
DEBUG CONSTRNT: Checking LP row 58 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=58, expected 58
DEBUG CONSTRNT: Checking LP row 59 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=59, expected 59
DEBUG CONSTRNT: Checking LP row 60 -> pool row 105
DEBUG CONSTRNT: Pool row 105 has lprow=60, expected 60
DEBUG CONSTRNT: Checking LP row 61 -> pool row 130
DEBUG CONSTRNT: Pool row 130 has lprow=61, expected 61
 % @PAP adding 53 rows, 224 nz to LP
DEBUG BB: Processing node 9, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=22, varin=41, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 26332388.203849
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 6.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 53 rows, 60 cols, 284 nonzeros, 1 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=54, varin=98, theta=0.026284, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 26332928.089589
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.973716
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.973716
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.973716
DEBUG SOLUTION: lp->best_solution[11] = 5.921149
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 54 rows, 60 cols, 290 nonzeros, 5 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 9 rows, 40 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=56, varin=34, theta=0.074436, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=58)
DEBUG SOLUTION: LP solution array indices: FST[59-98], not_covered[99-118]
DEBUG SOLUTION: lp->best_solution[0] = 26339347.303082
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 58 rows, 60 cols, 315 nonzeros, 4 slack, 54 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % Node 9 LP 1 Solution, length = 26339347.303082, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.074436 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.462782 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.611654 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.074436 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.611654 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.462782 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.462782 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.074436 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.925564 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.537218 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.537218 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.388346 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.537218 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.925564 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.388346 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.388346 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 8 fractional variables
DEBUG CG: LP optimal, z=26339347.303082, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.02  26.33238820384926981433 99.9000000000
 % @LN 0.02  26.33934730308178018277 99.9000000000
DEBUG CG: Second cutoff check: z=26339347.303082, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 9 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 9
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.074436
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.074436)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.462782
DEBUG CAREFUL: Adding var 8 to fractional list (xi=0.462782)
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.611654
DEBUG CAREFUL: Adding var 21 to fractional list (xi=0.611654)
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.074436
DEBUG CAREFUL: Adding var 23 to fractional list (xi=0.074436)
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.611654
DEBUG CAREFUL: Adding var 25 to fractional list (xi=0.611654)
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.462782
DEBUG CAREFUL: Adding var 28 to fractional list (xi=0.462782)
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.462782
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.462782)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.074436
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.074436)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 8 fractional variables

  %  Carefully choosing branching variable, nfrac = 8
DEBUG CAREFUL: Testing fvar[0] = var 25
DEBUG CAREFUL: Calling compare_branch_vars for var 25
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 25
DEBUG CAREFUL: New best var: 25
DEBUG CAREFUL: Testing fvar[1] = var 21
DEBUG CAREFUL: Calling compare_branch_vars for var 21
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 21
DEBUG CAREFUL: Testing fvar[2] = var 8
DEBUG CAREFUL: Calling compare_branch_vars for var 8
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 8
DEBUG CAREFUL: Testing fvar[3] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 34
DEBUG CAREFUL: Testing fvar[4] = var 28
DEBUG CAREFUL: Calling compare_branch_vars for var 28
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 28
DEBUG CAREFUL: Testing fvar[5] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 7
DEBUG CAREFUL: New best var: 7
DEBUG CAREFUL: Testing fvar[6] = var 23
DEBUG CAREFUL: Calling compare_branch_vars for var 23
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 23
DEBUG CAREFUL: Testing fvar[7] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 36
  % Initial guess is x7, Z0 = 26339347.3030818        , Z1 = 27202561.3631279        

DEBUG EVAL: Testing var 25 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=26, varin=41, theta=1.643339, up=999999999999999983222784.000000
ITER 2: row=24, varin=110, theta=0.163090, up=1.000000
ITER 3: row=4, varin=45, theta=0.395581, up=999999999999999983222784.000000
ITER 4: row=48, varin=78, theta=0.553509, up=1.000000
ITER 5: row=26, varin=90, theta=0.183760, up=1.000000
DEBUG EVAL: Branch var 25 = 1 gives z=26383672.381874
  % 	x25 = 1,	Z1 = 26383672.3818738        
DEBUG EVAL: First branch cutoff check: z=26383672.381874, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 25 = 0
ITER 1: row=26, varin=18, theta=0.962165, up=999999999999999983222784.000000
ITER 2: row=4, varin=52, theta=0.300000, up=999999999999999983222784.000000
ITER 3: row=38, varin=43, theta=0.250000, up=999999999999999983222784.000000
ITER 4: row=2, varin=14, theta=0.125000, up=999999999999999983222784.000000
ITER 5: row=14, varin=11, theta=0.333333, up=999999999999999983222784.000000
ITER 6: row=11, varin=12, theta=0.250000, up=999999999999999983222784.000000
ITER 7: row=12, varin=6, theta=0.166667, up=999999999999999983222784.000000
ITER 8: row=6, varin=35, theta=0.500000, up=999999999999999983222784.000000
ITER 9: row=35, varin=38, theta=0.500000, up=999999999999999983222784.000000
ITER 10: row=33, varin=2, theta=0.285714, up=999999999999999983222784.000000
  % 	x25 = 0,	Z0 = 26464064.4359292        
DEBUG EVAL: Second branch cutoff check: z=26464064.435929, best_z=INF, threshold=INF
  %   New best:  x25, Z = 26383672.3818738        
DEBUG EVAL: Testing var 21 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=27, varin=41, theta=1.643339, up=999999999999999983222784.000000
ITER 2: row=24, varin=110, theta=0.163090, up=1.000000
ITER 3: row=4, varin=45, theta=0.395581, up=999999999999999983222784.000000
ITER 4: row=48, varin=78, theta=0.553509, up=1.000000
ITER 5: row=27, varin=90, theta=0.183760, up=1.000000
DEBUG EVAL: Branch var 21 = 1 gives z=26383672.381874
  % 	x21 = 1,	Z1 = 26383672.3818738        
DEBUG EVAL: First branch cutoff check: z=26383672.381874, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 21 = 0
ITER 1: row=27, varin=18, theta=0.962165, up=999999999999999983222784.000000
ITER 2: row=4, varin=52, theta=0.300000, up=999999999999999983222784.000000
ITER 3: row=38, varin=43, theta=0.250000, up=999999999999999983222784.000000
ITER 4: row=2, varin=14, theta=0.125000, up=999999999999999983222784.000000
ITER 5: row=14, varin=11, theta=0.333333, up=999999999999999983222784.000000
ITER 6: row=11, varin=12, theta=0.250000, up=999999999999999983222784.000000
ITER 7: row=12, varin=6, theta=0.166667, up=999999999999999983222784.000000
ITER 8: row=6, varin=35, theta=0.500000, up=999999999999999983222784.000000
ITER 9: row=35, varin=38, theta=0.500000, up=999999999999999983222784.000000
ITER 10: row=33, varin=2, theta=0.285714, up=999999999999999983222784.000000
  % 	x21 = 0,	Z0 = 26503453.954829         
DEBUG EVAL: Second branch cutoff check: z=26503453.954829, best_z=INF, threshold=INF
  %   New best:  x21, Z = 26383672.3818738        
DEBUG EVAL: Testing var 8 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=23, varin=45, theta=0.528648, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 8 = 0 gives z=26376455.467479
  % 	x8 = 0,	Z0 = 26376455.4674793        
DEBUG EVAL: First branch cutoff check: z=26376455.467479, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 34 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=34, varin=45, theta=0.528648, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 34 = 0 gives z=26376455.467479
  % 	x34 = 0,	Z0 = 26376455.4674793        
DEBUG EVAL: First branch cutoff check: z=26376455.467479, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 28 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=24, varin=41, theta=0.428990, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 28 = 0 gives z=26349844.934920
  % 	x28 = 0,	Z0 = 26349844.9349204        
DEBUG EVAL: First branch cutoff check: z=26349844.934920, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 7 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=5, varin=52, theta=0.980457, up=999999999999999983222784.000000
ITER 2: row=38, varin=45, theta=1.232747, up=999999999999999983222784.000000
ITER 3: row=36, varin=43, theta=0.719714, up=999999999999999983222784.000000
ITER 4: row=2, varin=14, theta=0.379762, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 7 = 1 gives z=26458049.376591
  % 	x7 = 1,	Z1 = 27202561.3631279        
DEBUG EVAL: First branch cutoff check: z=27202561.363128, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 7 = 0
ITER 1: row=5, varin=110, theta=0.011620, up=1.000000
  % 	x7 = 0,	Z0 = 26340790.3683912        
DEBUG EVAL: Second branch cutoff check: z=26340790.368391, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 23 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=4, varin=110, theta=0.011620, up=1.000000
DEBUG EVAL: Branch var 23 = 0 gives z=26340790.368391
  % 	x23 = 0,	Z0 = 26340790.3683912        
DEBUG EVAL: First branch cutoff check: z=26340790.368391, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 36 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=37, varin=110, theta=0.011620, up=1.000000
DEBUG EVAL: Branch var 36 = 0 gives z=26340790.368391
  % 	x36 = 0,	Z0 = 26340790.3683912        
DEBUG EVAL: First branch cutoff check: z=26340790.368391, best_z=INF, threshold=INF
  % Best branch is x21, Z0 = 26503453.954829         , Z1 = 26383672.3818738        

DEBUG CAREFUL: Final result - returning best.var = 21
DEBUG BB: Branching variable chosen: j=21
 % @NC   11    9	x21 = 1	26383672.381874
 % @NC   12    9	x21 = 0	26503453.954829
 %       9     5 26339347.3031               26345721.1680   x27 D     7     5
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ff1996d600
% @LO 0.02  26.33934730308178018277 99.9000000000
% @LN 0.02  26.34572116804606523033 99.9000000000
% Resuming node 3 at  26.34572116804606523033
DEBUG CONSTRNT: LP rows=54, pool->nlprows=54, pool->npend=0
DEBUG CONSTRNT: Checking 54 LP rows (pool tracks 54, total LP rows 54)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 70
DEBUG CONSTRNT: Pool row 70 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=53, expected 53
 % @PAP adding 62 rows, 227 nz to LP
DEBUG BB: Processing node 3, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 3 LP 12 Solution, length = 26345721.168046, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.071490 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.071490 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.040790 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.071490 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.040790 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.040790 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.040790 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.040790 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.040790 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.071490 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.071490 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.040790 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.071490 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.071490 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.040790 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.071490 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.071490 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.071490 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.071490 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.040790 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.040790 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.040790 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.928510 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.928510 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.959210 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.928510 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.928510 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.959210 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.928510 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.928510 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.959210 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.928510 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.959210 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.959210 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.928510 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.959210 (terminal 19)
 % 22 fractional variables
DEBUG CG: LP optimal, z=26345721.168046, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=26345721.168046, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 3 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 3
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.071490
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.071490)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.071490
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.071490)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.040790
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.040790)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.071490
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.071490)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.040790
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.040790)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.040790
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.040790)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.040790
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.040790)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=1.000000
DEBUG CAREFUL: Skipping var 12: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.040790
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.040790)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.040790
DEBUG CAREFUL: Adding var 20 to fractional list (xi=0.040790)
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.071490
DEBUG CAREFUL: Adding var 23 to fractional list (xi=0.071490)
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.071490
DEBUG CAREFUL: Adding var 24 to fractional list (xi=0.071490)
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.040790
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.040790)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.071490
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.071490)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.071490
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.071490)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.040790
DEBUG CAREFUL: Adding var 31 to fractional list (xi=0.040790)
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.071490
DEBUG CAREFUL: Adding var 32 to fractional list (xi=0.071490)
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.071490
DEBUG CAREFUL: Adding var 33 to fractional list (xi=0.071490)
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.071490
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.071490)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.071490
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.071490)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.040790
DEBUG CAREFUL: Adding var 37 to fractional list (xi=0.040790)
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.040790
DEBUG CAREFUL: Adding var 38 to fractional list (xi=0.040790)
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.040790
DEBUG CAREFUL: Adding var 39 to fractional list (xi=0.040790)
DEBUG CAREFUL: Found 22 fractional variables

  %  Carefully choosing branching variable, nfrac = 22
DEBUG CAREFUL: Testing fvar[0] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 7
DEBUG CAREFUL: New best var: 7
DEBUG CAREFUL: Testing fvar[1] = var 23
DEBUG CAREFUL: Calling compare_branch_vars for var 23
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 23
DEBUG CAREFUL: Testing fvar[2] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 34
DEBUG CAREFUL: Testing fvar[3] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 36
DEBUG CAREFUL: Testing fvar[4] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
DEBUG CAREFUL: Testing fvar[5] = var 24
DEBUG CAREFUL: Calling compare_branch_vars for var 24
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 24
DEBUG CAREFUL: Testing fvar[6] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 29
DEBUG CAREFUL: Testing fvar[7] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[8] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 27
DEBUG CAREFUL: Testing fvar[9] = var 32
DEBUG CAREFUL: Calling compare_branch_vars for var 32
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 32
DEBUG CAREFUL: Testing fvar[10] = var 33
DEBUG CAREFUL: Calling compare_branch_vars for var 33
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 33
DEBUG CAREFUL: Testing fvar[11] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
DEBUG CAREFUL: Testing fvar[12] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[13] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[14] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[15] = var 20
DEBUG CAREFUL: Calling compare_branch_vars for var 20
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 20
DEBUG CAREFUL: New best var: 20
DEBUG CAREFUL: Testing fvar[16] = var 31
DEBUG CAREFUL: Calling compare_branch_vars for var 31
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 31
DEBUG CAREFUL: Testing fvar[17] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 4
DEBUG CAREFUL: Testing fvar[18] = var 38
DEBUG CAREFUL: Calling compare_branch_vars for var 38
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 38
DEBUG CAREFUL: Testing fvar[19] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 11
DEBUG CAREFUL: Testing fvar[20] = var 37
DEBUG CAREFUL: Calling compare_branch_vars for var 37
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 37
DEBUG CAREFUL: Testing fvar[21] = var 39
DEBUG CAREFUL: Calling compare_branch_vars for var 39
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 39
  % Initial guess is x20, Z0 = 26345721.1680461        , Z1 = 29250638.9175699        

DEBUG EVAL: Testing var 7 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=22, varin=61, theta=0.303563, up=999999999999999983222784.000000
ITER 2: row=55, varin=29, theta=0.058139, up=999999999999999983222784.000000
ITER 3: row=37, varin=49, theta=0.083776, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 7 = 0 gives z=26439593.536058
  % 	x7 = 0,	Z0 = 26439593.5360584        
DEBUG EVAL: First branch cutoff check: z=26439593.536058, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 7 = 1
ITER 1: row=22, varin=44, theta=1.388205, up=999999999999999983222784.000000
ITER 2: row=24, varin=41, theta=6.703917, up=999999999999999983222784.000000
  % 	x7 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: Second branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=22, varin=61, theta=0.303563, up=999999999999999983222784.000000
ITER 2: row=55, varin=29, theta=0.058139, up=999999999999999983222784.000000
ITER 3: row=37, varin=49, theta=0.083776, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=62)
DEBUG SOLUTION: LP solution array indices: FST[63-102], not_covered[103-122]
DEBUG SOLUTION: lp->best_solution[0] = 26439593.536058
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
   % @PL 62 rows, 60 cols, 287 nonzeros, 4 slack, 58 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 4 slack rows
   % @PAP adding 4 rows, 17 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=59, varin=57, theta=0.277223, up=999999999999999983222784.000000
ITER 2: row=53, varin=3, theta=0.050784, up=999999999999999983222784.000000
ITER 3: row=61, varin=102, theta=0.457882, up=1.000000
ITER 4: row=58, varin=101, theta=0.403538, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=62)
DEBUG SOLUTION: LP solution array indices: FST[63-102], not_covered[103-122]
DEBUG SOLUTION: lp->best_solution[0] = 26483724.114817
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.801179
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
   % @PL 62 rows, 60 cols, 296 nonzeros, 2 slack, 60 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
   % @PAP adding 4 rows, 22 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=61, varin=40, theta=0.125196, up=999999999999999983222784.000000
ITER 2: row=64, varin=61, theta=0.659786, up=999999999999999983222784.000000
ITER 3: row=34, varin=45, theta=0.036917, up=999999999999999983222784.000000
ITER 4: row=49, varin=103, theta=0.424803, up=1.000000
ITER 5: row=64, varin=58, theta=1.806590, up=999999999999999983222784.000000
ITER 6: row=47, varin=30, theta=0.024388, up=999999999999999983222784.000000
ITER 7: row=19, varin=106, theta=1.110830, up=1.000000
ITER 8: row=19, varin=6, theta=0.027008, up=999999999999999983222784.000000
ITER 9: row=63, varin=61, theta=0.012613, up=999999999999999983222784.000000
ITER 10: row=50, varin=64, theta=0.074419, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=10)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=64)
DEBUG SOLUTION: LP solution array indices: FST[65-104], not_covered[105-124]
DEBUG SOLUTION: lp->best_solution[0] = 26604848.769845
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.961237
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 500000.000000
   % @PL 64 rows, 60 cols, 312 nonzeros, 6 slack, 58 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 6 slack rows
   % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=59, varin=102, theta=0.028315, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=60)
DEBUG SOLUTION: LP solution array indices: FST[61-100], not_covered[101-120]
DEBUG SOLUTION: lp->best_solution[0] = 26608113.225811
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 500000.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 60 rows, 60 cols, 285 nonzeros, 2 slack, 58 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
   % @PAP adding 4 rows, 15 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=59, varin=33, theta=0.046433, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=62)
DEBUG SOLUTION: LP solution array indices: FST[63-102], not_covered[103-122]
DEBUG SOLUTION: lp->best_solution[0] = 26613925.443764
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 500000.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 62 rows, 60 cols, 294 nonzeros, 1 slack, 61 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 3 at  26.61392544376419166952
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ff19984250
% @LO 0.02  26.34572116804606523033 99.9000000000
% @LN 0.02  26.38367238187382213255 99.9000000000
% Resuming node 11 at  26.38367238187382213255
DEBUG CONSTRNT: LP rows=61, pool->nlprows=61, pool->npend=0
DEBUG CONSTRNT: Checking 61 LP rows (pool tracks 61, total LP rows 61)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 105
DEBUG CONSTRNT: Pool row 105 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 130
DEBUG CONSTRNT: Pool row 130 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=56, expected 56
DEBUG CONSTRNT: Checking LP row 57 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=57, expected 57
DEBUG CONSTRNT: Checking LP row 58 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=58, expected 58
DEBUG CONSTRNT: Checking LP row 59 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=59, expected 59
DEBUG CONSTRNT: Checking LP row 60 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=60, expected 60
 % @PAP adding 54 rows, 242 nz to LP
DEBUG BB: Processing node 11, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=27, varin=41, theta=1.643339, up=999999999999999983222784.000000
ITER 2: row=24, varin=110, theta=0.163090, up=1.000000
ITER 3: row=4, varin=45, theta=0.395581, up=999999999999999983222784.000000
ITER 4: row=48, varin=78, theta=0.553509, up=1.000000
ITER 5: row=27, varin=90, theta=0.183760, up=1.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 26383672.381874
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 54 rows, 60 cols, 302 nonzeros, 1 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 5 rows, 26 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=59, varin=41, theta=0.093637, up=999999999999999983222784.000000
ITER 2: row=55, varin=18, theta=0.014778, up=999999999999999983222784.000000
ITER 3: row=57, varin=59, theta=0.670380, up=999999999999999983222784.000000
ITER 4: row=53, varin=4, theta=0.964047, up=999999999999999983222784.000000
ITER 5: row=4, varin=112, theta=0.053643, up=1.000000
ITER 6: row=54, varin=91, theta=0.202680, up=1.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=59)
DEBUG SOLUTION: LP solution array indices: FST[60-99], not_covered[100-119]
DEBUG SOLUTION: lp->best_solution[0] = 26399132.982079
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.800670
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 59 rows, 60 cols, 328 nonzeros, 8 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 8 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=112, theta=0.016492, up=1.000000
ITER 2: row=43, varin=47, theta=0.005406, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 26403219.646622
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.951347
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.951347
  % @PL 52 rows, 60 cols, 294 nonzeros, 4 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 9 rows, 23 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=53, varin=4, theta=0.040722, up=999999999999999983222784.000000
ITER 2: row=52, varin=39, theta=0.155072, up=999999999999999983222784.000000
ITER 3: row=55, varin=11, theta=0.029292, up=999999999999999983222784.000000
ITER 4: row=56, varin=53, theta=0.058492, up=999999999999999983222784.000000
ITER 5: row=41, varin=91, theta=0.237215, up=1.000000
ITER 6: row=38, varin=43, theta=0.257291, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 26431972.101463
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 57 rows, 60 cols, 305 nonzeros, 6 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=42, theta=0.206120, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 26439076.514912
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 276 nonzeros, 1 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 11 LP 1 Solution, length = 26439076.514912, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.041224 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.041224 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.136634 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.136634 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.041224 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.041224 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.041224 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.041224 (FST 20)
  % DEBUG LP_VARS: x[21] = 1.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.041224 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 1.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.041224 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.041224 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.136634 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.136634 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.136634 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.863366 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.958776 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.958776 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.863366 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.863366 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.958776 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.958776 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.958776 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.958776 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.958776 (terminal 19)
 % 14 fractional variables
DEBUG CG: LP optimal, z=26439076.514912, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.02  26.38367238187382213255 99.9000000000
 % @LN 0.02  26.43907651491212718042 99.9000000000
DEBUG CG: Second cutoff check: z=26439076.514912, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 11 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 11
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.041224
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.041224)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.041224
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.041224)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.136634
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.136634)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.136634
DEBUG CAREFUL: Adding var 8 to fractional list (xi=0.136634)
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.041224
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.041224)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.041224
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.041224)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.041224
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.041224)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.041224
DEBUG CAREFUL: Adding var 20 to fractional list (xi=0.041224)
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=1.000000
DEBUG CAREFUL: Skipping var 21: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.041224
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.041224)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=1.000000
DEBUG CAREFUL: Skipping var 25: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.041224
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.041224)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.041224
DEBUG CAREFUL: Adding var 31 to fractional list (xi=0.041224)
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.136634
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.136634)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.136634
DEBUG CAREFUL: Adding var 35 to fractional list (xi=0.136634)
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.136634
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.136634)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 14 fractional variables

  %  Carefully choosing branching variable, nfrac = 14
DEBUG CAREFUL: Testing fvar[0] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[1] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 22
DEBUG CAREFUL: Testing fvar[2] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
DEBUG CAREFUL: Testing fvar[3] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[4] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[5] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[6] = var 20
DEBUG CAREFUL: Calling compare_branch_vars for var 20
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 20
DEBUG CAREFUL: New best var: 20
DEBUG CAREFUL: Testing fvar[7] = var 35
DEBUG CAREFUL: Calling compare_branch_vars for var 35
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 35
DEBUG CAREFUL: Testing fvar[8] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[9] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
DEBUG CAREFUL: Testing fvar[10] = var 31
DEBUG CAREFUL: Calling compare_branch_vars for var 31
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 31
DEBUG CAREFUL: Testing fvar[11] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 36
DEBUG CAREFUL: Testing fvar[12] = var 8
DEBUG CAREFUL: Calling compare_branch_vars for var 8
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 8
DEBUG CAREFUL: Testing fvar[13] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 34
  % Initial guess is x20, Z0 = 26439076.5149121        , Z1 = 29250638.9175699        

DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=8, varin=38, theta=5.517095, up=999999999999999983222784.000000
ITER 2: row=38, varin=40, theta=1.000876, up=999999999999999983222784.000000
ITER 3: row=4, varin=5, theta=0.952340, up=999999999999999983222784.000000
ITER 4: row=46, varin=49, theta=1.918372, up=999999999999999983222784.000000
ITER 5: row=11, varin=47, theta=0.947732, up=999999999999999983222784.000000
ITER 6: row=35, varin=85, theta=2.692910, up=1.000000
ITER 7: row=35, varin=7, theta=1.088403, up=999999999999999983222784.000000
ITER 8: row=7, varin=24, theta=1.480685, up=999999999999999983222784.000000
ITER 9: row=8, varin=85, theta=1.000000, up=1.000000
ITER 10: row=21, varin=32, theta=0.453841, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x3 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=8, varin=7, theta=0.153107, up=999999999999999983222784.000000
ITER 2: row=7, varin=51, theta=0.089041, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 26450386.277301
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 51 rows, 60 cols, 266 nonzeros, 1 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 6 rows, 31 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=25, theta=0.068716, up=999999999999999983222784.000000
ITER 2: row=36, varin=34, theta=0.075698, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 26469313.965185
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.924302
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 56 rows, 60 cols, 295 nonzeros, 3 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 3 slack rows
   % @PAP adding 7 rows, 19 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=54, varin=79, theta=0.134040, up=1.000000
ITER 2: row=51, varin=44, theta=0.019192, up=999999999999999983222784.000000
ITER 3: row=53, varin=36, theta=0.022932, up=999999999999999983222784.000000
ITER 4: row=50, varin=51, theta=0.022940, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=60)
DEBUG SOLUTION: LP solution array indices: FST[61-100], not_covered[101-120]
DEBUG SOLUTION: lp->best_solution[0] = 26497044.853744
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.977060
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 60 rows, 60 cols, 305 nonzeros, 7 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 7 slack rows
   % @PAP adding 5 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=55, varin=48, theta=0.141445, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=58)
DEBUG SOLUTION: LP solution array indices: FST[59-98], not_covered[99-118]
DEBUG SOLUTION: lp->best_solution[0] = 26503553.225808
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
   % @PL 58 rows, 60 cols, 290 nonzeros, 2 slack, 56 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 11 at  26.50355322580813677291
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ff19994590
% @LO 0.02  26.43907651491212718042 99.9000000000
% @LN 0.02  26.50345395482898069872 99.9000000000
% Resuming node 12 at  26.50345395482898069872
DEBUG CONSTRNT: LP rows=56, pool->nlprows=56, pool->npend=0
DEBUG CONSTRNT: Checking 56 LP rows (pool tracks 56, total LP rows 56)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 70
DEBUG CONSTRNT: Pool row 70 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=55, expected 55
 % @PAP adding 54 rows, 242 nz to LP
DEBUG BB: Processing node 12, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=27, varin=18, theta=0.962165, up=999999999999999983222784.000000
ITER 2: row=4, varin=52, theta=0.300000, up=999999999999999983222784.000000
ITER 3: row=38, varin=43, theta=0.250000, up=999999999999999983222784.000000
ITER 4: row=2, varin=14, theta=0.125000, up=999999999999999983222784.000000
ITER 5: row=14, varin=11, theta=0.333333, up=999999999999999983222784.000000
ITER 6: row=11, varin=12, theta=0.250000, up=999999999999999983222784.000000
ITER 7: row=12, varin=6, theta=0.166667, up=999999999999999983222784.000000
ITER 8: row=6, varin=35, theta=0.500000, up=999999999999999983222784.000000
ITER 9: row=35, varin=38, theta=0.500000, up=999999999999999983222784.000000
ITER 10: row=33, varin=2, theta=0.285714, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=17)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 26503453.954829
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 54 rows, 60 cols, 302 nonzeros, 6 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % Node 12 LP 1 Solution, length = 26503453.954829, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.281858 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.281858 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.281858 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.281858 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.718142 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.718142 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.718142 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.718142 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.718142 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=26503453.954829, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.02  26.50345395482898069872 99.9000000000
 % @LN 0.02  26.50345395482898425144 99.9000000000
DEBUG CG: Second cutoff check: z=26503453.954829, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 12 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 12
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.281858
DEBUG CAREFUL: Adding var 8 to fractional list (xi=0.281858)
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.281858
DEBUG CAREFUL: Adding var 25 to fractional list (xi=0.281858)
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.281858
DEBUG CAREFUL: Adding var 28 to fractional list (xi=0.281858)
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.281858
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.281858)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 8
DEBUG CAREFUL: Calling compare_branch_vars for var 8
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 8
DEBUG CAREFUL: New best var: 8
DEBUG CAREFUL: Testing fvar[1] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 34
DEBUG CAREFUL: Testing fvar[2] = var 25
DEBUG CAREFUL: Calling compare_branch_vars for var 25
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 25
DEBUG CAREFUL: Testing fvar[3] = var 28
DEBUG CAREFUL: Calling compare_branch_vars for var 28
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 28
  % Initial guess is x8, Z0 = 26503453.954829         , Z1 = 26503453.954829         

DEBUG EVAL: Testing var 8 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=56, theta=0.376607, up=1.000000
ITER 2: row=35, varin=85, theta=0.726827, up=1.000000
ITER 3: row=38, varin=72, theta=0.251512, up=1.000000
DEBUG EVAL: Branch var 8 = 0 gives z=26618087.725679
  % 	x8 = 0,	Z0 = 26618087.7256792        
DEBUG EVAL: First branch cutoff check: z=26618087.725679, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 8 = 1
ITER 1: row=1, varin=95, theta=2.413478, up=1.000000
ITER 2: row=1, varin=32, theta=1.164824, up=999999999999999983222784.000000
ITER 3: row=22, varin=39, theta=0.538040, up=999999999999999983222784.000000
  % 	x8 = 1,	Z1 = 26713243.5783035        
DEBUG EVAL: Second branch cutoff check: z=26713243.578303, best_z=INF, threshold=INF
  %   New best:  x8, Z = 26618087.7256792        
DEBUG EVAL: Testing var 34 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=25, varin=56, theta=0.376607, up=1.000000
ITER 2: row=35, varin=32, theta=0.441142, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 34 = 0 gives z=26553028.910971
  % 	x34 = 0,	Z0 = 26553028.9109709        
DEBUG EVAL: First branch cutoff check: z=26553028.910971, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 25 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=22, varin=28, theta=0.273220, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 25 = 0 gives z=26513434.720707
  % 	x25 = 0,	Z0 = 26513434.7207073        
DEBUG EVAL: First branch cutoff check: z=26513434.720707, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 28 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=23, varin=56, theta=0.376607, up=1.000000
ITER 2: row=35, varin=39, theta=0.316912, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 28 = 0 gives z=26520983.455289
  % 	x28 = 0,	Z0 = 26520983.4552892        
DEBUG EVAL: First branch cutoff check: z=26520983.455289, best_z=INF, threshold=INF
  % Best branch is x8, Z0 = 26618087.7256792        , Z1 = 26713243.5783035        

DEBUG CAREFUL: Final result - returning best.var = 8
DEBUG BB: Branching variable chosen: j=8
 % @NC   13   12	x8 = 0	26618087.725679
 % @NC   14   12	x8 = 1	26713243.578303
 %      12     6 26503453.9548               26503553.2258   x21 D     9     6
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ff19984250
% @LO 0.02  26.50345395482898425144 99.9000000000
% @LN 0.02  26.50355322580813677291 99.9000000000
% Resuming node 11 at  26.50355322580813677291
DEBUG CONSTRNT: LP rows=48, pool->nlprows=48, pool->npend=0
DEBUG CONSTRNT: Checking 48 LP rows (pool tracks 48, total LP rows 48)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 70
DEBUG CONSTRNT: Pool row 70 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=47, expected 47
 % @PAP adding 56 rows, 216 nz to LP
DEBUG BB: Processing node 11, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 11 LP 2 Solution, length = 26503553.225808, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.047148 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.108555 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.108555 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.047148 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.047148 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.047148 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.047148 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.047148 (FST 20)
  % DEBUG LP_VARS: x[21] = 1.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.047148 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 1.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.047148 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.047148 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.108555 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.108555 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.108555 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.891445 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.952852 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.952852 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.891445 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.891445 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.952852 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.952852 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.952852 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.952852 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.952852 (terminal 19)
 % 14 fractional variables
DEBUG CG: LP optimal, z=26503553.225808, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=26503553.225808, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 11 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 11
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.047148
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.047148)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.108555
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.108555)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.108555
DEBUG CAREFUL: Adding var 8 to fractional list (xi=0.108555)
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.047148
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.047148)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.047148
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.047148)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.047148
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.047148)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.047148
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.047148)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.047148
DEBUG CAREFUL: Adding var 20 to fractional list (xi=0.047148)
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=1.000000
DEBUG CAREFUL: Skipping var 21: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.047148
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.047148)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=1.000000
DEBUG CAREFUL: Skipping var 25: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.047148
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.047148)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.047148
DEBUG CAREFUL: Adding var 31 to fractional list (xi=0.047148)
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.108555
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.108555)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.108555
DEBUG CAREFUL: Adding var 35 to fractional list (xi=0.108555)
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.108555
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.108555)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 14 fractional variables

  %  Carefully choosing branching variable, nfrac = 14
DEBUG CAREFUL: Testing fvar[0] = var 35
DEBUG CAREFUL: Calling compare_branch_vars for var 35
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 35
DEBUG CAREFUL: New best var: 35
DEBUG CAREFUL: Testing fvar[1] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 7
DEBUG CAREFUL: New best var: 7
DEBUG CAREFUL: Testing fvar[2] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 36
DEBUG CAREFUL: Testing fvar[3] = var 8
DEBUG CAREFUL: Calling compare_branch_vars for var 8
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 8
DEBUG CAREFUL: Testing fvar[4] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 34
DEBUG CAREFUL: Testing fvar[5] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
DEBUG CAREFUL: Testing fvar[6] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 22
DEBUG CAREFUL: Testing fvar[7] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[8] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
DEBUG CAREFUL: Testing fvar[9] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[10] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[11] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[12] = var 20
DEBUG CAREFUL: Calling compare_branch_vars for var 20
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 20
DEBUG CAREFUL: Testing fvar[13] = var 31
DEBUG CAREFUL: Calling compare_branch_vars for var 31
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 31
  % Initial guess is x18, Z0 = 26503553.2258081        , Z1 = 29495338.9870639        

DEBUG EVAL: Testing var 35 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=37, varin=54, theta=0.355636, up=999999999999999983222784.000000
ITER 2: row=25, varin=37, theta=0.061227, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 35 = 0 gives z=26541433.181368
  % 	x35 = 0,	Z0 = 26541433.1813679        
DEBUG EVAL: First branch cutoff check: z=26541433.181368, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 35 = 1
ITER 1: row=37, varin=22, theta=3.702375, up=999999999999999983222784.000000
ITER 2: row=19, varin=68, theta=3.133513, up=1.000000
ITER 3: row=19, varin=38, theta=2.086288, up=999999999999999983222784.000000
ITER 4: row=6, varin=2, theta=3.319299, up=999999999999999983222784.000000
ITER 5: row=51, varin=61, theta=1.788227, up=1.000000
ITER 6: row=51, varin=94, theta=1.056502, up=1.000000
ITER 7: row=51, varin=95, theta=0.058747, up=1.000000
ITER 8: row=29, varin=51, theta=5.195535, up=999999999999999983222784.000000
ITER 9: row=34, varin=4, theta=3.878630, up=999999999999999983222784.000000
ITER 10: row=4, varin=46, theta=0.924210, up=999999999999999983222784.000000
  % 	x35 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: Second branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=37, varin=54, theta=0.355636, up=999999999999999983222784.000000
ITER 2: row=25, varin=37, theta=0.061227, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 26541433.181368
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
   % @PL 56 rows, 60 cols, 276 nonzeros, 5 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 5 slack rows
   % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=71, theta=0.037863, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 26542310.199341
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
   % @PL 52 rows, 60 cols, 268 nonzeros, 0 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 11 at  26.54231019934129065518
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ff19984250
% @LO 0.02  26.50355322580813677291 99.9000000000
% @LN 0.02  26.54231019934129065518 99.9000000000
% Resuming node 11 at  26.54231019934129065518
DEBUG CONSTRNT: LP rows=52, pool->nlprows=52, pool->npend=0
DEBUG CONSTRNT: Checking 52 LP rows (pool tracks 52, total LP rows 52)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 70
DEBUG CONSTRNT: Pool row 70 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=51, expected 51
 % @PAP adding 52 rows, 208 nz to LP
DEBUG BB: Processing node 11, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 11 LP 3 Solution, length = 26542310.199341, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.073868 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.073868 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.073868 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.073868 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.073868 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.073868 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.037863 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.073868 (FST 20)
  % DEBUG LP_VARS: x[21] = 1.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.073868 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 1.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.073868 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.073868 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.073868 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.073868 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.926132 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.926132 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.926132 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.926132 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.926132 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.926132 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.926132 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.926132 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.926132 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.926132 (terminal 19)
 % 13 fractional variables
DEBUG CG: LP optimal, z=26542310.199341, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=26542310.199341, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 11 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 11
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.073868
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.073868)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.073868
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.073868)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.073868
DEBUG CAREFUL: Adding var 8 to fractional list (xi=0.073868)
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.073868
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.073868)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.073868
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.073868)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.073868
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.073868)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.037863
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.037863)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.073868
DEBUG CAREFUL: Adding var 20 to fractional list (xi=0.073868)
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=1.000000
DEBUG CAREFUL: Skipping var 21: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.073868
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.073868)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=1.000000
DEBUG CAREFUL: Skipping var 25: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.073868
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.073868)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.073868
DEBUG CAREFUL: Adding var 31 to fractional list (xi=0.073868)
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.073868
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.073868)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.073868
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.073868)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 13 fractional variables

  %  Carefully choosing branching variable, nfrac = 13
DEBUG CAREFUL: Testing fvar[0] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
DEBUG CAREFUL: Testing fvar[1] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 22
DEBUG CAREFUL: Testing fvar[2] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[3] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[4] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[5] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[6] = var 20
DEBUG CAREFUL: Calling compare_branch_vars for var 20
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 20
DEBUG CAREFUL: New best var: 20
DEBUG CAREFUL: Testing fvar[7] = var 31
DEBUG CAREFUL: Calling compare_branch_vars for var 31
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 31
DEBUG CAREFUL: Testing fvar[8] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
DEBUG CAREFUL: Testing fvar[9] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 36
DEBUG CAREFUL: Testing fvar[10] = var 8
DEBUG CAREFUL: Calling compare_branch_vars for var 8
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 8
DEBUG CAREFUL: Testing fvar[11] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 34
DEBUG CAREFUL: Testing fvar[12] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
  % Initial guess is x18, Z0 = 26542310.1993413        , Z1 = 29495338.9870639        

DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=4, varin=44, theta=1.047752, up=999999999999999983222784.000000
ITER 2: row=40, varin=45, theta=1.227518, up=999999999999999983222784.000000
ITER 3: row=6, varin=22, theta=2.029729, up=999999999999999983222784.000000
ITER 4: row=19, varin=25, theta=0.539139, up=999999999999999983222784.000000
ITER 5: row=16, varin=52, theta=0.475010, up=999999999999999983222784.000000
ITER 6: row=8, varin=33, theta=1.065802, up=999999999999999983222784.000000
ITER 7: row=34, varin=64, theta=59.697728, up=1.000000
DEBUG EVAL: Branch var 17 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x17 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=4, varin=52, theta=0.129333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 26546158.386060
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
   % @PL 52 rows, 60 cols, 268 nonzeros, 1 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 8 rows, 42 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=4, theta=0.076044, up=999999999999999983222784.000000
ITER 2: row=57, varin=2, theta=0.283476, up=999999999999999983222784.000000
ITER 3: row=50, varin=34, theta=1.421583, up=999999999999999983222784.000000
ITER 4: row=48, varin=45, theta=0.960176, up=999999999999999983222784.000000
ITER 5: row=59, varin=35, theta=0.032657, up=999999999999999983222784.000000
ITER 6: row=54, varin=59, theta=0.447604, up=999999999999999983222784.000000
ITER 7: row=36, varin=83, theta=0.316308, up=1.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=59)
DEBUG SOLUTION: LP solution array indices: FST[60-99], not_covered[100-119]
DEBUG SOLUTION: lp->best_solution[0] = 26632924.561743
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
   % @PL 59 rows, 60 cols, 308 nonzeros, 1 slack, 58 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 4 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=61, varin=51, theta=0.271412, up=999999999999999983222784.000000
ITER 2: row=60, varin=74, theta=0.112685, up=1.000000
ITER 3: row=59, varin=60, theta=0.115333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=62)
DEBUG SOLUTION: LP solution array indices: FST[63-102], not_covered[103-122]
DEBUG SOLUTION: lp->best_solution[0] = 26653860.821000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.962729
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
   % @PL 62 rows, 60 cols, 316 nonzeros, 10 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 10 slack rows
   % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=54, varin=60, theta=0.237934, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 26662646.368223
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
   % @PL 55 rows, 60 cols, 276 nonzeros, 1 slack, 54 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 5 rows, 23 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=59, varin=4, theta=0.020086, up=999999999999999983222784.000000
ITER 2: row=55, varin=59, theta=0.244221, up=999999999999999983222784.000000
ITER 3: row=41, varin=49, theta=0.177272, up=999999999999999983222784.000000
ITER 4: row=57, varin=21, theta=0.071329, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
ITER 5: row=59, varin=57, theta=0.142857, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=59)
DEBUG SOLUTION: LP solution array indices: FST[60-99], not_covered[100-119]
DEBUG SOLUTION: lp->best_solution[0] = 26683106.313846
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
   % @PL 59 rows, 60 cols, 297 nonzeros, 2 slack, 57 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=66, theta=9.000000, up=1.000000
ITER 2: row=1, varin=92, theta=16.000000, up=1.000000
ITER 3: row=1, varin=87, theta=15.000000, up=1.000000
ITER 4: row=1, varin=65, theta=7.000000, up=1.000000
ITER 5: row=1, varin=67, theta=6.000000, up=1.000000
ITER 6: row=1, varin=83, theta=10.000000, up=1.000000
ITER 7: row=1, varin=94, theta=9.000000, up=1.000000
ITER 8: row=1, varin=60, theta=4.000000, up=1.000000
ITER 9: row=1, varin=86, theta=6.000000, up=1.000000
ITER 10: row=1, varin=78, theta=1.250000, up=1.000000
LP PHASE: Switching to primal (iter=95)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 26683106.313846
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
   % @PL 57 rows, 60 cols, 293 nonzeros, 0 slack, 57 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 11 at  26.68310631384618503148
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ff1997a3c0
% @LO 0.02  26.54231019934129065518 99.9000000000
% @LN 0.02  26.61148064837926696669 99.9000000000
% Resuming node 10 at  26.61148064837926696669
DEBUG CONSTRNT: LP rows=57, pool->nlprows=57, pool->npend=0
DEBUG CONSTRNT: Checking 57 LP rows (pool tracks 57, total LP rows 57)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 70
DEBUG CONSTRNT: Pool row 70 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=56, expected 56
 % @PAP adding 53 rows, 224 nz to LP
DEBUG BB: Processing node 10, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=22, varin=21, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 26611480.648379
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 6.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 53 rows, 60 cols, 284 nonzeros, 1 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 10 LP 1 Solution, length = 26611480.648379, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.446543 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.446543 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.446543 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 1.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.446543 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.446543 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.553457 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.553457 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.553457 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.553457 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.553457 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.553457 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=26611480.648379, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=26611480.648379, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 10 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 10
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.446543
DEBUG CAREFUL: Adding var 8 to fractional list (xi=0.446543)
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.446543
DEBUG CAREFUL: Adding var 21 to fractional list (xi=0.446543)
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.446543
DEBUG CAREFUL: Adding var 25 to fractional list (xi=0.446543)
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=1.000000
DEBUG CAREFUL: Skipping var 27: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.446543
DEBUG CAREFUL: Adding var 28 to fractional list (xi=0.446543)
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.446543
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.446543)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 8
DEBUG CAREFUL: Calling compare_branch_vars for var 8
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 8
DEBUG CAREFUL: New best var: 8
DEBUG CAREFUL: Testing fvar[1] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 34
DEBUG CAREFUL: Testing fvar[2] = var 25
DEBUG CAREFUL: Calling compare_branch_vars for var 25
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 25
DEBUG CAREFUL: Testing fvar[3] = var 21
DEBUG CAREFUL: Calling compare_branch_vars for var 21
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 21
DEBUG CAREFUL: Testing fvar[4] = var 28
DEBUG CAREFUL: Calling compare_branch_vars for var 28
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 28
  % Initial guess is x8, Z0 = 26611480.6483793        , Z1 = 26611480.6483793        

DEBUG EVAL: Testing var 8 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=97, theta=0.236770, up=1.000000
ITER 2: row=27, varin=38, theta=0.168503, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 8 = 0 gives z=26629957.842511
  % 	x8 = 0,	Z0 = 26629957.8425113        
DEBUG EVAL: First branch cutoff check: z=26629957.842511, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 8 = 1
ITER 1: row=1, varin=50, theta=0.646249, up=999999999999999983222784.000000
ITER 2: row=2, varin=18, theta=0.340998, up=999999999999999983222784.000000
ITER 3: row=32, varin=48, theta=1.407747, up=999999999999999983222784.000000
ITER 4: row=45, varin=4, theta=0.624974, up=999999999999999983222784.000000
ITER 5: row=4, varin=15, theta=0.428635, up=999999999999999983222784.000000
ITER 6: row=15, varin=97, theta=0.299498, up=1.000000
ITER 7: row=18, varin=12, theta=0.630341, up=999999999999999983222784.000000
ITER 8: row=12, varin=46, theta=1.693573, up=999999999999999983222784.000000
ITER 9: row=46, varin=85, theta=1.293055, up=1.000000
ITER 10: row=46, varin=33, theta=0.194348, up=999999999999999983222784.000000
  % 	x8 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: Second branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=97, theta=0.236770, up=1.000000
ITER 2: row=27, varin=38, theta=0.168503, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 26629957.842511
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.867401
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.867401
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.867401
DEBUG SOLUTION: lp->best_solution[11] = 5.602203
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 53 rows, 60 cols, 284 nonzeros, 9 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 9 slack rows
   % @PAP adding 12 rows, 53 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=54, varin=78, theta=0.234023, up=1.000000
ITER 2: row=50, varin=32, theta=0.102888, up=999999999999999983222784.000000
ITER 3: row=49, varin=112, theta=0.104677, up=1.000000
ITER 4: row=47, varin=109, theta=0.176629, up=1.000000
ITER 5: row=56, varin=92, theta=1.113009, up=1.000000
ITER 6: row=56, varin=116, theta=0.005056, up=1.000000
ITER 7: row=28, varin=40, theta=0.157024, up=999999999999999983222784.000000
ITER 8: row=48, varin=50, theta=0.622962, up=999999999999999983222784.000000
ITER 9: row=16, varin=47, theta=0.066422, up=999999999999999983222784.000000
ITER 10: row=38, varin=92, theta=0.145596, up=1.000000
LP PHASE: Switching to primal (iter=10)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 26701133.988055
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 56 rows, 60 cols, 309 nonzeros, 2 slack, 54 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
   % @PAP adding 2 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=55, varin=100, theta=0.194894, up=1.000000
ITER 2: row=46, varin=16, theta=0.623096, up=999999999999999983222784.000000
ITER 3: row=4, varin=82, theta=0.130745, up=1.000000
ITER 4: row=5, varin=9, theta=0.016019, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 26727406.318259
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.983981
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.855831
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 56 rows, 60 cols, 311 nonzeros, 10 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 10 slack rows
   % @PAP adding 9 rows, 30 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=59, theta=0.091492, up=1.000000
ITER 2: row=50, varin=79, theta=0.070813, up=1.000000
ITER 3: row=49, varin=50, theta=0.313315, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 26734620.729946
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 55 rows, 60 cols, 317 nonzeros, 2 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 10 at  26.73462072994638916157
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ff1996d600
% @LO 0.02  26.61148064837926696669 99.9000000000
% @LN 0.02  26.61392544376419166952 99.9000000000
% Resuming node 3 at  26.61392544376419166952
DEBUG CONSTRNT: LP rows=53, pool->nlprows=53, pool->npend=0
DEBUG CONSTRNT: Checking 53 LP rows (pool tracks 53, total LP rows 53)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 70
DEBUG CONSTRNT: Pool row 70 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=52, expected 52
 % @PAP adding 61 rows, 232 nz to LP
DEBUG BB: Processing node 3, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 3 LP 13 Solution, length = 26613925.443764, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.075594 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.046433 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.075594 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.075594 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.075594 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.075594 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.075594 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.075594 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.046433 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.075594 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.075594 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.075594 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.924406 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.924406 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.953567 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.924406 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.924406 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.924406 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.924406 (terminal 19)
 % 12 fractional variables
DEBUG CG: LP optimal, z=26613925.443764, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=26613925.443764, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 3 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 3
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.075594
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.075594)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.046433
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.046433)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.075594
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.075594)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.075594
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.075594)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=1.000000
DEBUG CAREFUL: Skipping var 12: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.075594
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.075594)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.075594
DEBUG CAREFUL: Adding var 20 to fractional list (xi=0.075594)
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.075594
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.075594)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.075594
DEBUG CAREFUL: Adding var 31 to fractional list (xi=0.075594)
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.046433
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.046433)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.075594
DEBUG CAREFUL: Adding var 37 to fractional list (xi=0.075594)
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.075594
DEBUG CAREFUL: Adding var 38 to fractional list (xi=0.075594)
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.075594
DEBUG CAREFUL: Adding var 39 to fractional list (xi=0.075594)
DEBUG CAREFUL: Found 12 fractional variables

  %  Carefully choosing branching variable, nfrac = 12
DEBUG CAREFUL: Testing fvar[0] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
DEBUG CAREFUL: Testing fvar[1] = var 20
DEBUG CAREFUL: Calling compare_branch_vars for var 20
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 20
DEBUG CAREFUL: New best var: 20
DEBUG CAREFUL: Testing fvar[2] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[3] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[4] = var 31
DEBUG CAREFUL: Calling compare_branch_vars for var 31
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 31
DEBUG CAREFUL: Testing fvar[5] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 4
DEBUG CAREFUL: Testing fvar[6] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 34
DEBUG CAREFUL: Testing fvar[7] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[8] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 11
DEBUG CAREFUL: Testing fvar[9] = var 37
DEBUG CAREFUL: Calling compare_branch_vars for var 37
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 37
DEBUG CAREFUL: Testing fvar[10] = var 39
DEBUG CAREFUL: Calling compare_branch_vars for var 39
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 39
DEBUG CAREFUL: Testing fvar[11] = var 38
DEBUG CAREFUL: Calling compare_branch_vars for var 38
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 38
  % Initial guess is x20, Z0 = 26613925.4437642        , Z1 = 29250638.9175699        

DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=45, theta=1.139140, up=999999999999999983222784.000000
ITER 2: row=13, varin=58, theta=2.041463, up=999999999999999983222784.000000
ITER 3: row=2, varin=57, theta=4.228057, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x17 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=3, varin=29, theta=0.118183, up=999999999999999983222784.000000
ITER 2: row=35, varin=44, theta=0.355390, up=999999999999999983222784.000000
ITER 3: row=47, varin=46, theta=0.695026, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=61)
DEBUG SOLUTION: LP solution array indices: FST[62-101], not_covered[102-121]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 61 rows, 60 cols, 292 nonzeros, 4 slack, 57 tight.
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 3 at 1000000000000000000.00000000000000000000
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ff19980d00
% @LO 0.02  26.61392544376419166952 99.9000000000
% @LN 0.02  26.61808772567915681861 99.9000000000
% Resuming node 13 at  26.61808772567915681861
DEBUG CONSTRNT: LP rows=61, pool->nlprows=61, pool->npend=0
DEBUG CONSTRNT: Checking 61 LP rows (pool tracks 61, total LP rows 61)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 105
DEBUG CONSTRNT: Pool row 105 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 130
DEBUG CONSTRNT: Pool row 130 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=56, expected 56
DEBUG CONSTRNT: Checking LP row 57 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=57, expected 57
DEBUG CONSTRNT: Checking LP row 58 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=58, expected 58
DEBUG CONSTRNT: Checking LP row 59 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=59, expected 59
DEBUG CONSTRNT: Checking LP row 60 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=60, expected 60
 % @PAP adding 48 rows, 218 nz to LP
DEBUG BB: Processing node 13, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=56, theta=0.376607, up=1.000000
ITER 2: row=35, varin=85, theta=0.726827, up=1.000000
ITER 3: row=38, varin=72, theta=0.251512, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 26618087.725679
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 278 nonzeros, 0 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=38, theta=1.633624, up=999999999999999983222784.000000
ITER 2: row=49, varin=31, theta=0.084567, up=999999999999999983222784.000000
ITER 3: row=50, varin=61, theta=0.249208, up=1.000000
ITER 4: row=11, varin=51, theta=1.010960, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 26633400.483372
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 291 nonzeros, 2 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 13 LP 1 Solution, length = 26633400.483372, 0.01 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.202192 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.202192 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.404384 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.202192 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.202192 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.797808 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.595616 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.797808 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.797808 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.595616 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=26633400.483372, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.03  26.61808772567915681861 99.9000000000
 % @LN 0.03  26.63340048337212451202 99.9000000000
DEBUG CG: Second cutoff check: z=26633400.483372, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 13 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 13
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.202192
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.202192)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.202192
DEBUG CAREFUL: Adding var 23 to fractional list (xi=0.202192)
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.404384
DEBUG CAREFUL: Adding var 25 to fractional list (xi=0.404384)
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.202192
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.202192)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.202192
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.202192)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 25
DEBUG CAREFUL: Calling compare_branch_vars for var 25
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 25
DEBUG CAREFUL: New best var: 25
DEBUG CAREFUL: Testing fvar[1] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 7
DEBUG CAREFUL: New best var: 7
DEBUG CAREFUL: Testing fvar[2] = var 23
DEBUG CAREFUL: Calling compare_branch_vars for var 23
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 23
DEBUG CAREFUL: Testing fvar[3] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 36
DEBUG CAREFUL: Testing fvar[4] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 34
  % Initial guess is x7, Z0 = 26633400.4833721        , Z1 = 27202561.3631279        

DEBUG EVAL: Testing var 25 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=22, varin=11, theta=0.520226, up=999999999999999983222784.000000
ITER 2: row=11, varin=28, theta=0.386838, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 25 = 0 gives z=26641893.306300
  % 	x25 = 0,	Z0 = 26641893.3063004        
DEBUG EVAL: First branch cutoff check: z=26641893.306300, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 25 = 1
ITER 1: row=22, varin=50, theta=0.687452, up=1.000000
ITER 2: row=2, varin=53, theta=0.530723, up=1.000000
ITER 3: row=5, varin=82, theta=1.664210, up=1.000000
ITER 4: row=5, varin=76, theta=0.784809, up=1.000000
ITER 5: row=47, varin=80, theta=0.624353, up=1.000000
ITER 6: row=32, varin=72, theta=0.302212, up=1.000000
ITER 7: row=35, varin=82, theta=1.000000, up=1.000000
ITER 8: row=7, varin=67, theta=0.496698, up=1.000000
ITER 9: row=5, varin=91, theta=0.692266, up=1.000000
ITER 10: row=40, varin=109, theta=0.047105, up=1.000000
  % 	x25 = 1,	Z1 = 26854737.4759445        
DEBUG EVAL: Second branch cutoff check: z=26854737.475944, best_z=INF, threshold=INF
  %   New best:  x25, Z = 26641893.3063004        
DEBUG EVAL: Testing var 7 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=11, theta=1.305019, up=999999999999999983222784.000000
ITER 2: row=11, varin=49, theta=2.867913, up=999999999999999983222784.000000
ITER 3: row=31, varin=96, theta=2.434376, up=1.000000
ITER 4: row=31, varin=31, theta=1.182046, up=999999999999999983222784.000000
ITER 5: row=22, varin=38, theta=0.594257, up=999999999999999983222784.000000
ITER 6: row=23, varin=4, theta=0.910847, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 7 = 1 gives z=27207421.025056
  % 	x7 = 1,	Z1 = 27207421.0250561        
DEBUG EVAL: First branch cutoff check: z=27207421.025056, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 7 = 0
ITER 1: row=1, varin=50, theta=0.457661, up=1.000000
ITER 2: row=2, varin=82, theta=1.031321, up=1.000000
ITER 3: row=2, varin=48, theta=0.012947, up=999999999999999983222784.000000
ITER 4: row=35, varin=82, theta=1.000000, up=1.000000
ITER 5: row=37, varin=53, theta=0.460717, up=1.000000
ITER 6: row=5, varin=80, theta=0.808838, up=1.000000
ITER 7: row=32, varin=91, theta=0.354843, up=1.000000
ITER 8: row=40, varin=28, theta=0.240001, up=999999999999999983222784.000000
ITER 9: row=39, varin=76, theta=2.051674, up=1.000000
ITER 10: row=39, varin=67, theta=0.138379, up=1.000000
  % 	x7 = 0,	Z0 = 26671069.6760165        
DEBUG EVAL: Second branch cutoff check: z=26671069.676016, best_z=INF, threshold=INF
  %   New best:  x7, Z = 26671069.6760165        
DEBUG EVAL: Testing var 23 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=4, varin=11, theta=1.305019, up=999999999999999983222784.000000
ITER 2: row=11, varin=49, theta=2.867913, up=999999999999999983222784.000000
ITER 3: row=31, varin=34, theta=0.708928, up=999999999999999983222784.000000
ITER 4: row=22, varin=72, theta=0.589482, up=1.000000
ITER 5: row=7, varin=76, theta=1.808150, up=1.000000
ITER 6: row=7, varin=53, theta=0.232720, up=1.000000
ITER 7: row=47, varin=76, theta=1.000000, up=1.000000
ITER 8: row=5, varin=96, theta=0.717433, up=1.000000
DEBUG EVAL: Branch var 23 = 1 gives z=26924925.725926
  % 	x23 = 1,	Z1 = 26924925.7259262        
DEBUG EVAL: First branch cutoff check: z=26924925.725926, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 23 = 0
ITER 1: row=4, varin=50, theta=0.457661, up=1.000000
ITER 2: row=2, varin=82, theta=1.031321, up=1.000000
ITER 3: row=2, varin=4, theta=0.006476, up=999999999999999983222784.000000
ITER 4: row=35, varin=82, theta=1.000000, up=1.000000
  % 	x23 = 0,	Z0 = 26649126.6098684        
DEBUG EVAL: Second branch cutoff check: z=26649126.609868, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 36 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=31, varin=11, theta=1.305019, up=999999999999999983222784.000000
ITER 2: row=11, varin=48, theta=1.517547, up=999999999999999983222784.000000
ITER 3: row=37, varin=34, theta=1.486014, up=999999999999999983222784.000000
ITER 4: row=22, varin=96, theta=1.222426, up=1.000000
ITER 5: row=22, varin=38, theta=0.598343, up=999999999999999983222784.000000
ITER 6: row=23, varin=72, theta=0.293547, up=1.000000
ITER 7: row=7, varin=4, theta=0.917110, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 36 = 1 gives z=27209569.701865
  % 	x36 = 1,	Z1 = 27209569.7018654        
DEBUG EVAL: First branch cutoff check: z=27209569.701865, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 36 = 0
ITER 1: row=31, varin=50, theta=0.457661, up=1.000000
ITER 2: row=2, varin=49, theta=0.280116, up=999999999999999983222784.000000
  % 	x36 = 0,	Z0 = 26639888.9683251        
DEBUG EVAL: Second branch cutoff check: z=26639888.968325, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 34 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=25, varin=50, theta=0.457661, up=1.000000
DEBUG EVAL: Branch var 34 = 0 gives z=26635470.798716
  % 	x34 = 0,	Z0 = 26635470.7987164        
DEBUG EVAL: First branch cutoff check: z=26635470.798716, best_z=INF, threshold=INF
  % Best branch is x7, Z0 = 26671069.6760165        , Z1 = 27207421.0250561        

DEBUG CAREFUL: Final result - returning best.var = 7
DEBUG BB: Branching variable chosen: j=7
 % @NC   15   13	x7 = 0	26671069.676016
 % @NC   16   13	x7 = 1	27207421.025056
 %      13     7 26633400.4834               26671069.6760    x8 D    12     7
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ff19994590
% @LO 0.03  26.63340048337212451202 99.9000000000
% @LN 0.03  26.67106967601646871913 99.9000000000
% Resuming node 15 at  26.67106967601646871913
DEBUG CONSTRNT: LP rows=49, pool->nlprows=49, pool->npend=0
DEBUG CONSTRNT: Checking 49 LP rows (pool tracks 49, total LP rows 49)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 70
DEBUG CONSTRNT: Pool row 70 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=48, expected 48
 % @PAP adding 49 rows, 220 nz to LP
DEBUG BB: Processing node 15, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=50, theta=0.457661, up=1.000000
ITER 2: row=2, varin=82, theta=1.031321, up=1.000000
ITER 3: row=2, varin=48, theta=0.012947, up=999999999999999983222784.000000
ITER 4: row=35, varin=82, theta=1.000000, up=1.000000
ITER 5: row=37, varin=53, theta=0.460717, up=1.000000
ITER 6: row=5, varin=80, theta=0.808838, up=1.000000
ITER 7: row=32, varin=91, theta=0.354843, up=1.000000
ITER 8: row=40, varin=28, theta=0.240001, up=999999999999999983222784.000000
ITER 9: row=39, varin=76, theta=2.051674, up=1.000000
ITER 10: row=39, varin=67, theta=0.138379, up=1.000000
LP PHASE: Switching to primal (iter=12)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 26671069.676016
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 280 nonzeros, 5 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=39, theta=0.247187, up=999999999999999983222784.000000
ITER 2: row=50, varin=112, theta=0.030278, up=1.000000
ITER 3: row=6, varin=73, theta=0.189901, up=1.000000
ITER 4: row=14, varin=63, theta=0.500416, up=1.000000
ITER 5: row=12, varin=49, theta=1.031099, up=999999999999999983222784.000000
ITER 6: row=31, varin=105, theta=0.003023, up=1.000000
ITER 7: row=45, varin=34, theta=0.006267, up=999999999999999983222784.000000
ITER 8: row=40, varin=32, theta=0.003097, up=999999999999999983222784.000000
ITER 9: row=51, varin=108, theta=0.000434, up=1.000000
ITER 10: row=18, varin=79, theta=0.002904, up=1.000000
LP PHASE: Switching to primal (iter=10)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 26696785.211811
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.997096
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 287 nonzeros, 9 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 9 slack rows
  % @PAP adding 9 rows, 39 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=87, theta=0.609633, up=1.000000
ITER 2: row=44, varin=33, theta=0.130337, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 26712555.439379
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 304 nonzeros, 8 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 8 slack rows
  % Node 15 LP 1 Solution, length = 26712555.439379, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.130337 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.130337 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.130337 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.260674 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.130337 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.130337 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.130337 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.260674 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.130337 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.869663 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.869663 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.869663 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.869663 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.739326 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.869663 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.739326 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.869663 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.739326 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 9 fractional variables
DEBUG CG: LP optimal, z=26712555.439379, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 15 at  26.71255543937911980379
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ff19975e70
% @LO 0.03  26.67106967601646871913 99.9000000000
% @LN 0.03  26.68050475708297497590 99.9000000000
% Resuming node 6 at  26.68050475708297497590
DEBUG CONSTRNT: LP rows=44, pool->nlprows=44, pool->npend=0
DEBUG CONSTRNT: Checking 44 LP rows (pool tracks 44, total LP rows 44)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 70
DEBUG CONSTRNT: Pool row 70 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=43, expected 43
 % @PAP adding 55 rows, 233 nz to LP
DEBUG BB: Processing node 6, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=14, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=40, varin=16, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=34, varin=42, theta=0.367934, up=999999999999999983222784.000000
ITER 4: row=45, varin=82, theta=0.496740, up=1.000000
ITER 5: row=26, varin=59, theta=0.167785, up=1.000000
ITER 6: row=7, varin=87, theta=0.272094, up=1.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 26680504.757083
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 6.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 55 rows, 60 cols, 293 nonzeros, 5 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % Node 6 LP 1 Solution, length = 26680504.757083, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 1.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.363953 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.363953 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.272094 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.363953 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.636047 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.636047 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=26680504.757083, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.03  26.68050475708297497590 99.9000000000
 % @LN 0.03  26.68050475708301405575 99.9000000000
DEBUG CG: Second cutoff check: z=26680504.757083, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 6 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 6
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=1.000000
DEBUG CAREFUL: Skipping var 1: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.363953
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.363953)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.363953
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.363953)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.272094
DEBUG CAREFUL: Adding var 31 to fractional list (xi=0.272094)
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.363953
DEBUG CAREFUL: Adding var 32 to fractional list (xi=0.363953)
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 31
DEBUG CAREFUL: Calling compare_branch_vars for var 31
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 31
DEBUG CAREFUL: New best var: 31
DEBUG CAREFUL: Testing fvar[1] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[2] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 27
DEBUG CAREFUL: Testing fvar[3] = var 32
DEBUG CAREFUL: Calling compare_branch_vars for var 32
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 32
  % Initial guess is x31, Z0 = 26680504.757083         , Z1 = 26680504.757083         

DEBUG EVAL: Testing var 31 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=37, varin=51, theta=0.824990, up=1.000000
ITER 2: row=2, varin=68, theta=0.213140, up=1.000000
ITER 3: row=9, varin=94, theta=0.116268, up=1.000000
DEBUG EVAL: Branch var 31 = 0 gives z=26732739.873060
  % 	x31 = 0,	Z0 = 26732739.8730603        
DEBUG EVAL: First branch cutoff check: z=26732739.873060, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 31 = 1
ITER 1: row=37, varin=7, theta=0.448858, up=999999999999999983222784.000000
ITER 2: row=7, varin=24, theta=0.664439, up=999999999999999983222784.000000
ITER 3: row=24, varin=99, theta=0.984295, up=1.000000
ITER 4: row=39, varin=76, theta=0.177339, up=1.000000
  % 	x31 = 1,	Z1 = 26939076.1074695        
DEBUG EVAL: Second branch cutoff check: z=26939076.107469, best_z=INF, threshold=INF
  %   New best:  x31, Z = 26732739.8730603        
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=51, theta=1.086127, up=1.000000
ITER 2: row=1, varin=58, theta=0.023889, up=1.000000
ITER 3: row=2, varin=51, theta=1.000000, up=1.000000
ITER 4: row=45, varin=68, theta=0.422366, up=1.000000
ITER 5: row=9, varin=93, theta=0.050964, up=1.000000
ITER 6: row=28, varin=99, theta=0.038557, up=1.000000
DEBUG EVAL: Branch var 2 = 0 gives z=26759508.342943
  % 	x2 = 0,	Z0 = 26759508.3429433        
DEBUG EVAL: First branch cutoff check: z=26759508.342943, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 1
ITER 1: row=1, varin=47, theta=0.858247, up=999999999999999983222784.000000
ITER 2: row=43, varin=42, theta=0.453108, up=999999999999999983222784.000000
ITER 3: row=14, varin=44, theta=0.565486, up=999999999999999983222784.000000
ITER 4: row=44, varin=34, theta=2.561834, up=999999999999999983222784.000000
ITER 5: row=33, varin=7, theta=3.362511, up=999999999999999983222784.000000
  % 	x2 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: Second branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=51, theta=1.086127, up=1.000000
ITER 2: row=1, varin=58, theta=0.023889, up=1.000000
ITER 3: row=2, varin=51, theta=1.000000, up=1.000000
ITER 4: row=45, varin=68, theta=0.422366, up=1.000000
ITER 5: row=9, varin=93, theta=0.050964, up=1.000000
ITER 6: row=28, varin=99, theta=0.038557, up=1.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 26759508.342943
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.953732
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 6.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 50 rows, 60 cols, 282 nonzeros, 1 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 12 rows, 44 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=72, theta=0.428910, up=1.000000
ITER 2: row=15, varin=105, theta=0.146066, up=1.000000
ITER 3: row=52, varin=51, theta=0.951042, up=999999999999999983222784.000000
ITER 4: row=42, varin=13, theta=0.039947, up=999999999999999983222784.000000
ITER 5: row=59, varin=67, theta=0.066529, up=1.000000
ITER 6: row=26, varin=87, theta=0.002559, up=1.000000
ITER 7: row=57, varin=27, theta=0.033799, up=999999999999999983222784.000000
ITER 8: row=38, varin=69, theta=0.072649, up=1.000000
ITER 9: row=60, varin=43, theta=0.006009, up=999999999999999983222784.000000
ITER 10: row=55, varin=60, theta=0.005033, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=12)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=61)
DEBUG SOLUTION: LP solution array indices: FST[62-101], not_covered[102-121]
DEBUG SOLUTION: lp->best_solution[0] = 26859465.588827
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.808454
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.808454
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.808454
DEBUG SOLUTION: lp->best_solution[12] = 5.425361
DEBUG SOLUTION: lp->best_solution[13] = 0.957434
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 61 rows, 60 cols, 324 nonzeros, 9 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 9 slack rows
   % @PAP adding 11 rows, 36 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=61, varin=95, theta=0.733498, up=1.000000
ITER 2: row=56, varin=22, theta=0.028326, up=999999999999999983222784.000000
ITER 3: row=33, varin=84, theta=0.265499, up=1.000000
ITER 4: row=12, varin=46, theta=0.030971, up=999999999999999983222784.000000
ITER 5: row=45, varin=37, theta=0.105185, up=999999999999999983222784.000000
ITER 6: row=53, varin=56, theta=0.018751, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=63)
DEBUG SOLUTION: LP solution array indices: FST[64-103], not_covered[104-123]
DEBUG SOLUTION: lp->best_solution[0] = 26928118.187202
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 5.000000
   % @PL 63 rows, 60 cols, 325 nonzeros, 5 slack, 58 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 5 slack rows
   % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=61, varin=97, theta=1.028460, up=1.000000
ITER 2: row=61, varin=117, theta=0.002867, up=1.000000
ITER 3: row=57, varin=71, theta=0.024568, up=1.000000
ITER 4: row=9, varin=15, theta=0.038339, up=999999999999999983222784.000000
ITER 5: row=28, varin=95, theta=0.087391, up=1.000000
ITER 6: row=9, varin=9, theta=0.029113, up=999999999999999983222784.000000
ITER 7: row=4, varin=15, theta=0.174468, up=999999999999999983222784.000000
ITER 8: row=57, varin=35, theta=0.022922, up=999999999999999983222784.000000
ITER 9: row=50, varin=33, theta=0.054248, up=999999999999999983222784.000000
ITER 10: row=21, varin=46, theta=0.021334, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=61)
DEBUG SOLUTION: LP solution array indices: FST[62-101], not_covered[102-121]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 5.000000
   % @PL 61 rows, 60 cols, 314 nonzeros, 4 slack, 57 tight.
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 6 at 1000000000000000000.00000000000000000000
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ff19984250
% @LO 0.03  26.68050475708301405575 99.9000000000
% @LN 0.03  26.68310631384618503148 99.9000000000
% Resuming node 11 at  26.68310631384618503148
DEBUG CONSTRNT: LP rows=61, pool->nlprows=61, pool->npend=0
DEBUG CONSTRNT: Checking 61 LP rows (pool tracks 61, total LP rows 61)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 70
DEBUG CONSTRNT: Pool row 70 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 143
DEBUG CONSTRNT: Pool row 143 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 60
DEBUG CONSTRNT: Pool row 60 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 62
DEBUG CONSTRNT: Pool row 62 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=56, expected 56
DEBUG CONSTRNT: Checking LP row 57 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=57, expected 57
DEBUG CONSTRNT: Checking LP row 58 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=58, expected 58
DEBUG CONSTRNT: Checking LP row 59 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=59, expected 59
DEBUG CONSTRNT: Checking LP row 60 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=60, expected 60
 % @PAP adding 57 rows, 233 nz to LP
DEBUG BB: Processing node 11, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 11 LP 4 Solution, length = 26683106.313846, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.142857 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.142857 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.142857 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.142857 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 1.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.142857 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.142857 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.347455 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.142857 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.142857 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.142857 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.142857 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.142857 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.142857 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.857143 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.857143 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.857143 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.857143 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.857143 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.857143 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.652545 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.857143 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.857143 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.857143 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 13 fractional variables
DEBUG CG: LP optimal, z=26683106.313846, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=26683106.313846, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 11 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 11
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.142857
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.142857)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.142857
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.142857)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.142857
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.142857)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.142857
DEBUG CAREFUL: Adding var 8 to fractional list (xi=0.142857)
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=1.000000
DEBUG CAREFUL: Skipping var 21: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.142857
DEBUG CAREFUL: Adding var 23 to fractional list (xi=0.142857)
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.142857
DEBUG CAREFUL: Adding var 24 to fractional list (xi=0.142857)
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.347455
DEBUG CAREFUL: Adding var 25 to fractional list (xi=0.347455)
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.142857
DEBUG CAREFUL: Adding var 30 to fractional list (xi=0.142857)
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.142857
DEBUG CAREFUL: Adding var 31 to fractional list (xi=0.142857)
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.142857
DEBUG CAREFUL: Adding var 32 to fractional list (xi=0.142857)
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.142857
DEBUG CAREFUL: Adding var 33 to fractional list (xi=0.142857)
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.142857
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.142857)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.142857
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.142857)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 13 fractional variables

  %  Carefully choosing branching variable, nfrac = 13
DEBUG CAREFUL: Testing fvar[0] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 2
DEBUG CAREFUL: New best var: 2
DEBUG CAREFUL: Testing fvar[1] = var 31
DEBUG CAREFUL: Calling compare_branch_vars for var 31
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 31
DEBUG CAREFUL: Testing fvar[2] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 7
DEBUG CAREFUL: New best var: 7
DEBUG CAREFUL: Testing fvar[3] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 36
DEBUG CAREFUL: Testing fvar[4] = var 8
DEBUG CAREFUL: Calling compare_branch_vars for var 8
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 8
DEBUG CAREFUL: Testing fvar[5] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 34
DEBUG CAREFUL: Testing fvar[6] = var 23
DEBUG CAREFUL: Calling compare_branch_vars for var 23
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 23
DEBUG CAREFUL: Testing fvar[7] = var 30
DEBUG CAREFUL: Calling compare_branch_vars for var 30
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 30
DEBUG CAREFUL: Testing fvar[8] = var 32
DEBUG CAREFUL: Calling compare_branch_vars for var 32
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 32
DEBUG CAREFUL: Testing fvar[9] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
DEBUG CAREFUL: Testing fvar[10] = var 24
DEBUG CAREFUL: Calling compare_branch_vars for var 24
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 24
DEBUG CAREFUL: Testing fvar[11] = var 33
DEBUG CAREFUL: Calling compare_branch_vars for var 33
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 33
DEBUG CAREFUL: Testing fvar[12] = var 25
DEBUG CAREFUL: Calling compare_branch_vars for var 25
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 25
  % Initial guess is x7, Z0 = 26683106.3138462        , Z1 = 27202561.3631279        

DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=57, theta=0.250000, up=999999999999999983222784.000000
ITER 2: row=18, varin=50, theta=0.054235, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 0 gives z=26691766.875987
  % 	x2 = 0,	Z0 = 26691766.8759871        
DEBUG EVAL: First branch cutoff check: z=26691766.875987, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 1
ITER 1: row=2, varin=51, theta=1.000000, up=999999999999999983222784.000000
  % 	x2 = 1,	Z1 = 26700355.1911436        
DEBUG EVAL: Second branch cutoff check: z=26700355.191144, best_z=INF, threshold=INF
  %   New best:  x2, Z = 26691766.8759871        
DEBUG EVAL: Testing var 31 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=35, varin=57, theta=0.250000, up=999999999999999983222784.000000
ITER 2: row=18, varin=50, theta=0.054235, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 31 = 0 gives z=26691766.875987
  % 	x31 = 0,	Z0 = 26691766.8759871        
DEBUG EVAL: First branch cutoff check: z=26691766.875987, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 31 = 1
ITER 1: row=35, varin=51, theta=1.000000, up=999999999999999983222784.000000
  % 	x31 = 1,	Z1 = 26700355.1911436        
DEBUG EVAL: Second branch cutoff check: z=26700355.191144, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 7 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=15, varin=54, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=18, varin=50, theta=2.883849, up=999999999999999983222784.000000
ITER 3: row=1, varin=23, theta=2.728770, up=999999999999999983222784.000000
ITER 4: row=23, varin=36, theta=1.130026, up=999999999999999983222784.000000
ITER 5: row=55, varin=39, theta=2.813507, up=999999999999999983222784.000000
ITER 6: row=48, varin=95, theta=43.025234, up=1.000000
ITER 7: row=48, varin=97, theta=139.753234, up=1.000000
DEBUG EVAL: Branch var 7 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x7 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=15, varin=57, theta=0.250000, up=999999999999999983222784.000000
ITER 2: row=18, varin=51, theta=0.289446, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 26688570.419128
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
   % @PL 57 rows, 60 cols, 293 nonzeros, 4 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 4 slack rows
   % @PAP adding 2 rows, 11 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=54, varin=81, theta=0.657203, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 26700355.191144
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
   % @PL 55 rows, 60 cols, 277 nonzeros, 0 slack, 55 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=56, varin=33, theta=0.038462, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 26720954.066174
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
   % @PL 56 rows, 60 cols, 279 nonzeros, 3 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 3 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 11 at  26.72095406617389912185
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ff19994590
% @LO 0.03  26.68310631384618503148 99.9000000000
% @LN 0.03  26.71255543937911980379 99.9000000000
% Resuming node 15 at  26.71255543937911980379
DEBUG CONSTRNT: LP rows=53, pool->nlprows=53, pool->npend=0
DEBUG CONSTRNT: Checking 53 LP rows (pool tracks 53, total LP rows 53)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 70
DEBUG CONSTRNT: Pool row 70 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 134
DEBUG CONSTRNT: Pool row 134 has lprow=52, expected 52
 % @PAP adding 44 rows, 204 nz to LP
DEBUG BB: Processing node 15, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 15 LP 2 Solution, length = 26712555.439379, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.130337 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.130337 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.130337 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.260674 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.130337 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.130337 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.130337 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.260674 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.130337 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.869663 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.869663 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.869663 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.869663 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.739326 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.869663 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.739326 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.869663 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.739326 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 9 fractional variables
DEBUG CG: LP optimal, z=26712555.439379, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=26712555.439379, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 15 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 15
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.130337
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.130337)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.130337
DEBUG CAREFUL: Adding var 23 to fractional list (xi=0.130337)
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.130337
DEBUG CAREFUL: Adding var 24 to fractional list (xi=0.130337)
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.260674
DEBUG CAREFUL: Adding var 25 to fractional list (xi=0.260674)
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.130337
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.130337)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.130337
DEBUG CAREFUL: Adding var 30 to fractional list (xi=0.130337)
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.130337
DEBUG CAREFUL: Adding var 32 to fractional list (xi=0.130337)
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.260674
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.260674)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.130337
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.130337)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 9 fractional variables

  %  Carefully choosing branching variable, nfrac = 9
DEBUG CAREFUL: Testing fvar[0] = var 32
DEBUG CAREFUL: Calling compare_branch_vars for var 32
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 32
DEBUG CAREFUL: New best var: 32
DEBUG CAREFUL: Testing fvar[1] = var 23
DEBUG CAREFUL: Calling compare_branch_vars for var 23
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 23
DEBUG CAREFUL: New best var: 23
DEBUG CAREFUL: Testing fvar[2] = var 24
DEBUG CAREFUL: Calling compare_branch_vars for var 24
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 24
DEBUG CAREFUL: Testing fvar[3] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
DEBUG CAREFUL: Testing fvar[4] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 36
DEBUG CAREFUL: New best var: 36
DEBUG CAREFUL: Testing fvar[5] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 29
DEBUG CAREFUL: Testing fvar[6] = var 30
DEBUG CAREFUL: Calling compare_branch_vars for var 30
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 30
DEBUG CAREFUL: Testing fvar[7] = var 25
DEBUG CAREFUL: Calling compare_branch_vars for var 25
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 25
DEBUG CAREFUL: Testing fvar[8] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 34
  % Initial guess is x36, Z0 = 26712555.4393791        , Z1 = 27209569.7018654        

DEBUG EVAL: Testing var 32 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=22, varin=88, theta=0.038992, up=1.000000
ITER 2: row=41, varin=38, theta=0.045960, up=999999999999999983222784.000000
ITER 3: row=42, varin=15, theta=0.032605, up=999999999999999983222784.000000
ITER 4: row=44, varin=12, theta=0.010271, up=999999999999999983222784.000000
ITER 5: row=43, varin=34, theta=0.069624, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 32 = 0 gives z=26725121.414153
  % 	x32 = 0,	Z0 = 26725121.4141526        
DEBUG EVAL: First branch cutoff check: z=26725121.414153, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 32 = 1
ITER 1: row=22, varin=38, theta=0.399259, up=999999999999999983222784.000000
ITER 2: row=4, varin=40, theta=1.597198, up=999999999999999983222784.000000
ITER 3: row=25, varin=31, theta=0.641758, up=999999999999999983222784.000000
ITER 4: row=26, varin=67, theta=1.757899, up=1.000000
ITER 5: row=26, varin=32, theta=0.941022, up=999999999999999983222784.000000
ITER 6: row=7, varin=67, theta=1.000000, up=1.000000
ITER 7: row=29, varin=15, theta=2.524640, up=999999999999999983222784.000000
ITER 8: row=44, varin=35, theta=0.760876, up=999999999999999983222784.000000
  % 	x32 = 1,	Z1 = 26891247.6057958        
DEBUG EVAL: Second branch cutoff check: z=26891247.605796, best_z=INF, threshold=INF
  %   New best:  x32, Z = 26725121.4141526        
DEBUG EVAL: Testing var 23 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=38, theta=0.399259, up=999999999999999983222784.000000
ITER 2: row=4, varin=40, theta=1.597198, up=999999999999999983222784.000000
ITER 3: row=25, varin=67, theta=1.757899, up=1.000000
ITER 4: row=25, varin=36, theta=0.543690, up=999999999999999983222784.000000
ITER 5: row=7, varin=67, theta=1.000000, up=1.000000
ITER 6: row=19, varin=15, theta=0.964551, up=999999999999999983222784.000000
ITER 7: row=44, varin=31, theta=0.298837, up=999999999999999983222784.000000
ITER 8: row=1, varin=80, theta=1.055551, up=1.000000
ITER 9: row=1, varin=88, theta=0.013105, up=1.000000
ITER 10: row=11, varin=91, theta=0.286527, up=1.000000
DEBUG EVAL: Branch var 23 = 1 gives z=26938433.029182
  % 	x23 = 1,	Z1 = 26938433.0291816        
DEBUG EVAL: First branch cutoff check: z=26938433.029182, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 23 = 0
ITER 1: row=2, varin=88, theta=0.038992, up=1.000000
ITER 2: row=41, varin=38, theta=0.045960, up=999999999999999983222784.000000
ITER 3: row=42, varin=15, theta=0.032605, up=999999999999999983222784.000000
ITER 4: row=44, varin=12, theta=0.010271, up=999999999999999983222784.000000
ITER 5: row=43, varin=34, theta=0.069624, up=999999999999999983222784.000000
  % 	x23 = 0,	Z0 = 26725121.4141526        
DEBUG EVAL: Second branch cutoff check: z=26725121.414153, best_z=INF, threshold=INF
  %   New best:  x23, Z = 26725121.4141526        
DEBUG EVAL: Testing var 24 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=88, theta=0.038992, up=1.000000
ITER 2: row=41, varin=38, theta=0.045960, up=999999999999999983222784.000000
ITER 3: row=42, varin=15, theta=0.032605, up=999999999999999983222784.000000
ITER 4: row=44, varin=12, theta=0.010271, up=999999999999999983222784.000000
ITER 5: row=43, varin=34, theta=0.069624, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 24 = 0 gives z=26725121.414153
  % 	x24 = 0,	Z0 = 26725121.4141526        
DEBUG EVAL: First branch cutoff check: z=26725121.414153, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 24 = 1
ITER 1: row=3, varin=38, theta=0.399259, up=999999999999999983222784.000000
ITER 2: row=4, varin=40, theta=1.597198, up=999999999999999983222784.000000
ITER 3: row=25, varin=67, theta=1.757899, up=1.000000
ITER 4: row=25, varin=15, theta=2.008843, up=999999999999999983222784.000000
ITER 5: row=44, varin=80, theta=2.010227, up=1.000000
ITER 6: row=44, varin=2, theta=0.349369, up=999999999999999983222784.000000
ITER 7: row=7, varin=67, theta=1.000000, up=1.000000
ITER 8: row=19, varin=88, theta=0.253759, up=1.000000
ITER 9: row=11, varin=91, theta=0.580090, up=1.000000
ITER 10: row=39, varin=80, theta=1.000000, up=1.000000
  % 	x24 = 1,	Z1 = 27090469.0829543        
DEBUG EVAL: Second branch cutoff check: z=27090469.082954, best_z=INF, threshold=INF
  %   New best:  x24, Z = 26725121.4141526        
DEBUG EVAL: Testing var 0 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=38, theta=0.399259, up=999999999999999983222784.000000
ITER 2: row=4, varin=40, theta=1.597198, up=999999999999999983222784.000000
ITER 3: row=25, varin=67, theta=1.757899, up=1.000000
ITER 4: row=25, varin=15, theta=2.008843, up=999999999999999983222784.000000
ITER 5: row=44, varin=80, theta=2.010227, up=1.000000
ITER 6: row=44, varin=91, theta=0.290708, up=1.000000
ITER 7: row=7, varin=88, theta=1.000000, up=1.000000
ITER 8: row=11, varin=67, theta=1.665347, up=1.000000
ITER 9: row=11, varin=80, theta=3.000000, up=1.000000
ITER 10: row=11, varin=3, theta=2.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 0 = 1 gives z=27334601.265302
  % 	x0 = 1,	Z1 = 27334601.2653018        
DEBUG EVAL: First branch cutoff check: z=27334601.265302, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 0 = 0
ITER 1: row=1, varin=88, theta=0.038992, up=1.000000
  % 	x0 = 0,	Z0 = 26716276.1425314        
DEBUG EVAL: Second branch cutoff check: z=26716276.142531, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 36 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=28, varin=38, theta=0.399259, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 36 = 1 gives z=26738194.399116
  % 	x36 = 1,	Z1 = 27209569.7018654        
DEBUG EVAL: First branch cutoff check: z=27209569.701865, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 36 = 0
ITER 1: row=28, varin=88, theta=0.038992, up=1.000000
  % 	x36 = 0,	Z0 = 26716276.1425314        
DEBUG EVAL: Second branch cutoff check: z=26716276.142531, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 29 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=8, varin=88, theta=0.038992, up=1.000000
DEBUG EVAL: Branch var 29 = 0 gives z=26716276.142531
  % 	x29 = 0,	Z0 = 26716276.1425314        
DEBUG EVAL: First branch cutoff check: z=26716276.142531, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 30 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=19, varin=38, theta=0.399259, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 30 = 1 gives z=26738194.399116
  % 	x30 = 1,	Z1 = 27028194.6713256        
DEBUG EVAL: First branch cutoff check: z=27028194.671326, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 30 = 0
ITER 1: row=19, varin=88, theta=0.038992, up=1.000000
  % 	x30 = 0,	Z0 = 26716276.1425312        
DEBUG EVAL: Second branch cutoff check: z=26716276.142531, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 25 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=4, varin=88, theta=0.214822, up=1.000000
DEBUG EVAL: Branch var 25 = 1 gives z=26733054.438396
  % 	x25 = 1,	Z1 = 26854737.4759445        
DEBUG EVAL: First branch cutoff check: z=26854737.475944, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 25 = 0
ITER 1: row=4, varin=38, theta=0.120269, up=999999999999999983222784.000000
  % 	x25 = 0,	Z0 = 26720278.7000406        
DEBUG EVAL: Second branch cutoff check: z=26720278.700041, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 34 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=25, varin=88, theta=0.214822, up=1.000000
DEBUG EVAL: Branch var 34 = 1 gives z=26733054.438396
  % 	x34 = 1,	Z1 = 26733054.4383965        
DEBUG EVAL: First branch cutoff check: z=26733054.438396, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 34 = 0
ITER 1: row=25, varin=40, theta=0.348874, up=999999999999999983222784.000000
  % 	x34 = 0,	Z0 = 26718097.1934846        
DEBUG EVAL: Second branch cutoff check: z=26718097.193485, best_z=INF, threshold=INF
  % Best branch is x24, Z0 = 26725121.4141526        , Z1 = 27090469.0829543        

DEBUG CAREFUL: Final result - returning best.var = 24
DEBUG BB: Branching variable chosen: j=24
 % @NC   17   15	x24 = 0	26725121.414153
 % @NC   18   15	x24 = 1	27090469.082954
 %      15     8 26712555.4394               26713243.5783    x7 D    13     8
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ff1998f740
% @LO 0.03  26.71255543937911980379 99.9000000000
% @LN 0.03  26.71324357830349072174 99.9000000000
% Resuming node 14 at  26.71324357830349072174
DEBUG CONSTRNT: LP rows=44, pool->nlprows=44, pool->npend=0
DEBUG CONSTRNT: Checking 44 LP rows (pool tracks 44, total LP rows 44)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 70
DEBUG CONSTRNT: Pool row 70 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=43, expected 43
 % @PAP adding 48 rows, 218 nz to LP
DEBUG BB: Processing node 14, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=95, theta=2.413478, up=1.000000
ITER 2: row=1, varin=32, theta=1.164824, up=999999999999999983222784.000000
ITER 3: row=22, varin=39, theta=0.538040, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 26713243.578303
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 278 nonzeros, 2 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 16 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=76, theta=1.000000, up=1.000000
ITER 2: row=1, varin=73, theta=1.459873, up=1.000000
ITER 3: row=1, varin=8, theta=0.818260, up=999999999999999983222784.000000
ITER 4: row=7, varin=73, theta=1.000000, up=1.000000
ITER 5: row=8, varin=77, theta=7.182413, up=1.000000
ITER 6: row=8, varin=25, theta=3.041793, up=999999999999999983222784.000000
ITER 7: row=27, varin=54, theta=1.622762, up=1.000000
ITER 8: row=27, varin=82, theta=0.905935, up=1.000000
ITER 9: row=22, varin=9, theta=1.824129, up=999999999999999983222784.000000
ITER 10: row=17, varin=54, theta=4.412173, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 294 nonzeros, 6 slack, 44 tight.
  % Node 14 LP 1 Solution, length = 999999999999999983222784.000000, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.461960 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.538040 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 14 is INFEASIBLE
 %      14     7    infeasible               26720954.0662    x8 U    12     7
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ff19984250
% @LO 0.03  26.71324357830349072174 99.9000000000
% @LN 0.03  26.72095406617389912185 99.9000000000
% Resuming node 11 at  26.72095406617389912185
DEBUG CONSTRNT: LP rows=50, pool->nlprows=50, pool->npend=0
DEBUG CONSTRNT: Checking 50 LP rows (pool tracks 50, total LP rows 50)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 70
DEBUG CONSTRNT: Pool row 70 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 62
DEBUG CONSTRNT: Pool row 62 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 73
DEBUG CONSTRNT: Pool row 73 has lprow=49, expected 49
 % @PAP adding 53 rows, 206 nz to LP
DEBUG BB: Processing node 11, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 11 LP 5 Solution, length = 26720954.066174, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.038462 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.038462 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.038462 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.038462 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.038462 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.038462 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.038462 (FST 20)
  % DEBUG LP_VARS: x[21] = 1.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.038462 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.635234 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.038462 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.500000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.038462 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.961538 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.961538 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.364766 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.961538 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.961538 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.961538 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.961538 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.961538 (terminal 19)
 % 13 fractional variables
DEBUG CG: LP optimal, z=26720954.066174, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=26720954.066174, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 11 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 11
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.500000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.038462
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.038462)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.038462
DEBUG CAREFUL: Adding var 8 to fractional list (xi=0.038462)
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.038462
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.038462)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.038462
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.038462)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.038462
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.038462)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.038462
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.038462)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.038462
DEBUG CAREFUL: Adding var 20 to fractional list (xi=0.038462)
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=1.000000
DEBUG CAREFUL: Skipping var 21: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.038462
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.038462)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.635234
DEBUG CAREFUL: Adding var 25 to fractional list (xi=0.635234)
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.038462
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.038462)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.500000
DEBUG CAREFUL: Adding var 31 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.038462
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.038462)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 13 fractional variables

  %  Carefully choosing branching variable, nfrac = 13
DEBUG CAREFUL: Testing fvar[0] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 2
DEBUG CAREFUL: New best var: 2
DEBUG CAREFUL: Testing fvar[1] = var 31
DEBUG CAREFUL: Calling compare_branch_vars for var 31
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 31
DEBUG CAREFUL: Testing fvar[2] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 22
DEBUG CAREFUL: Testing fvar[3] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[4] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[5] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 9
DEBUG CAREFUL: New best var: 9
DEBUG CAREFUL: Testing fvar[6] = var 20
DEBUG CAREFUL: Calling compare_branch_vars for var 20
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 20
DEBUG CAREFUL: New best var: 20
DEBUG CAREFUL: Testing fvar[7] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 11
DEBUG CAREFUL: Testing fvar[8] = var 8
DEBUG CAREFUL: Calling compare_branch_vars for var 8
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 8
DEBUG CAREFUL: Testing fvar[9] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 34
DEBUG CAREFUL: Testing fvar[10] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
DEBUG CAREFUL: Testing fvar[11] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 4
DEBUG CAREFUL: Testing fvar[12] = var 25
DEBUG CAREFUL: Calling compare_branch_vars for var 25
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 25
  % Initial guess is x18, Z0 = 26720954.0661739        , Z1 = 29495338.9870639        

DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=53, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 0 gives z=26741552.941204
  % 	x2 = 0,	Z0 = 26741552.9412042        
DEBUG EVAL: First branch cutoff check: z=26741552.941204, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 1
ITER 1: row=1, varin=33, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=18, varin=91, theta=2.670460, up=1.000000
ITER 3: row=18, varin=93, theta=2.093297, up=1.000000
ITER 4: row=18, varin=92, theta=0.887136, up=1.000000
ITER 5: row=4, varin=37, theta=0.157568, up=999999999999999983222784.000000
ITER 6: row=7, varin=23, theta=0.915052, up=999999999999999983222784.000000
ITER 7: row=15, varin=47, theta=0.750107, up=999999999999999983222784.000000
ITER 8: row=2, varin=93, theta=10.007719, up=1.000000
ITER 9: row=2, varin=8, theta=0.841112, up=999999999999999983222784.000000
ITER 10: row=18, varin=93, theta=3.774100, up=1.000000
  % 	x2 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: Second branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=53, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 26741552.941204
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
   % @PL 53 rows, 60 cols, 266 nonzeros, 1 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 5 rows, 18 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=57, varin=5, theta=0.038462, up=999999999999999983222784.000000
ITER 2: row=54, varin=48, theta=0.048193, up=999999999999999983222784.000000
ITER 3: row=53, varin=50, theta=0.064516, up=999999999999999983222784.000000
ITER 4: row=55, varin=57, theta=0.307692, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 26849836.353835
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.923077
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
   % @PL 57 rows, 60 cols, 282 nonzeros, 2 slack, 55 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 11 at  26.84983635383500910621
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ff19980d00
% @LO 0.03  26.72095406617389912185 99.9000000000
% @LN 0.03  26.72512141415260344957 99.9000000000
% Resuming node 17 at  26.72512141415260344957
DEBUG CONSTRNT: LP rows=55, pool->nlprows=55, pool->npend=0
DEBUG CONSTRNT: Checking 55 LP rows (pool tracks 55, total LP rows 55)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 70
DEBUG CONSTRNT: Pool row 70 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=54, expected 54
 % @PAP adding 44 rows, 204 nz to LP
DEBUG BB: Processing node 17, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=3, varin=88, theta=0.038992, up=1.000000
ITER 2: row=41, varin=38, theta=0.045960, up=999999999999999983222784.000000
ITER 3: row=42, varin=15, theta=0.032605, up=999999999999999983222784.000000
ITER 4: row=44, varin=12, theta=0.010271, up=999999999999999983222784.000000
ITER 5: row=43, varin=34, theta=0.069624, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 26725121.414153
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.930376
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 264 nonzeros, 4 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=70, theta=0.132481, up=1.000000
ITER 2: row=7, varin=83, theta=0.439000, up=1.000000
LP PHASE: Switching to primal (iter=2)
ITER 3: row=1, varin=7, theta=0.000000, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 26731054.443207
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 270 nonzeros, 0 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=53, theta=0.033120, up=1.000000
ITER 2: row=7, varin=33, theta=0.116730, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 26733382.202729
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 283 nonzeros, 3 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % Node 17 LP 1 Solution, length = 26733382.202729, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.038910 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.038910 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.038910 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.038910 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.038910 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.038910 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.389099 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.038910 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.389099 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.961090 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.610901 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.610901 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.961090 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.961090 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.961090 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.610901 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.961090 (terminal 19)
 % 9 fractional variables
DEBUG CG: LP optimal, z=26733382.202729, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.03  26.72512141415260344957 99.9000000000
 % @LN 0.03  26.73338220272889742546 99.9000000000
DEBUG CG: Second cutoff check: z=26733382.202729, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 17 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 17
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.038910
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.038910)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.038910
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.038910)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.038910
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.038910)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.038910
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.038910)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.038910
DEBUG CAREFUL: Adding var 20 to fractional list (xi=0.038910)
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.038910
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.038910)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.389099
DEBUG CAREFUL: Adding var 25 to fractional list (xi=0.389099)
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.038910
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.038910)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.389099
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.389099)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 9 fractional variables

  %  Carefully choosing branching variable, nfrac = 9
DEBUG CAREFUL: Testing fvar[0] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 22
DEBUG CAREFUL: New best var: 22
DEBUG CAREFUL: Testing fvar[1] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 10
DEBUG CAREFUL: New best var: 10
DEBUG CAREFUL: Testing fvar[2] = var 20
DEBUG CAREFUL: Calling compare_branch_vars for var 20
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 20
DEBUG CAREFUL: New best var: 20
DEBUG CAREFUL: Testing fvar[3] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[4] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[5] = var 25
DEBUG CAREFUL: Calling compare_branch_vars for var 25
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 25
DEBUG CAREFUL: Testing fvar[6] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[7] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[8] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 34
  % Initial guess is x20, Z0 = 26733382.2027289        , Z1 = 29250638.9175699        

DEBUG EVAL: Testing var 22 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=5, theta=1.308970, up=999999999999999983222784.000000
ITER 2: row=43, varin=45, theta=10.843483, up=999999999999999983222784.000000
ITER 3: row=45, varin=38, theta=1.539834, up=999999999999999983222784.000000
ITER 4: row=44, varin=6, theta=0.969256, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 22 = 1 gives z=27108521.528381
  % 	x22 = 1,	Z1 = 27108521.5283814        
DEBUG EVAL: First branch cutoff check: z=27108521.528381, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 22 = 0
ITER 1: row=7, varin=31, theta=0.370783, up=999999999999999983222784.000000
ITER 2: row=26, varin=7, theta=0.041317, up=999999999999999983222784.000000
  % 	x22 = 0,	Z0 = 26734203.9904317        
DEBUG EVAL: Second branch cutoff check: z=26734203.990432, best_z=INF, threshold=INF
  %   New best:  x22, Z = 26734203.9904317        
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=11, varin=45, theta=10.843483, up=999999999999999983222784.000000
ITER 2: row=45, varin=40, theta=1.096750, up=999999999999999983222784.000000
ITER 3: row=12, varin=13, theta=1.311112, up=999999999999999983222784.000000
ITER 4: row=17, varin=37, theta=1.187116, up=999999999999999983222784.000000
ITER 5: row=22, varin=2, theta=0.864343, up=999999999999999983222784.000000
ITER 6: row=2, varin=82, theta=14.950881, up=1.000000
ITER 7: row=2, varin=93, theta=1.017630, up=1.000000
ITER 8: row=2, varin=30, theta=0.047427, up=999999999999999983222784.000000
ITER 9: row=11, varin=82, theta=1.000000, up=1.000000
ITER 10: row=25, varin=45, theta=2.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=27591451.621805
  % 	x10 = 1,	Z1 = 27591451.621805         
DEBUG EVAL: First branch cutoff check: z=27591451.621805, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=11, varin=31, theta=0.370783, up=999999999999999983222784.000000
ITER 2: row=26, varin=5, theta=0.146406, up=999999999999999983222784.000000
ITER 3: row=43, varin=13, theta=0.271578, up=999999999999999983222784.000000
  % 	x10 = 0,	Z0 = 26741266.6245442        
DEBUG EVAL: Second branch cutoff check: z=26741266.624544, best_z=INF, threshold=INF
  %   New best:  x10, Z = 26741266.6245442        
DEBUG EVAL: Testing var 20 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=13, varin=45, theta=10.843483, up=999999999999999983222784.000000
ITER 2: row=45, varin=7, theta=16.493735, up=999999999999999983222784.000000
ITER 3: row=7, varin=42, theta=2.457164, up=999999999999999983222784.000000
ITER 4: row=36, varin=37, theta=23.924448, up=999999999999999983222784.000000
ITER 5: row=22, varin=39, theta=7.119968, up=999999999999999983222784.000000
ITER 6: row=11, varin=6, theta=3.358660, up=999999999999999983222784.000000
ITER 7: row=17, varin=2, theta=1.948205, up=999999999999999983222784.000000
ITER 8: row=2, varin=69, theta=4.498680, up=1.000000
ITER 9: row=2, varin=11, theta=4.464808, up=999999999999999983222784.000000
ITER 10: row=5, varin=93, theta=1.818370, up=1.000000
DEBUG EVAL: Branch var 20 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x20 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=13, varin=31, theta=0.370783, up=999999999999999983222784.000000
ITER 2: row=26, varin=5, theta=0.146406, up=999999999999999983222784.000000
ITER 3: row=43, varin=13, theta=0.271578, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 26741266.624544
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.728422
DEBUG SOLUTION: lp->best_solution[13] = 0.728422
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 46 rows, 60 cols, 258 nonzeros, 2 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 17 at  26.74126662454423808413
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ff1997a3c0
% @LO 0.03  26.73338220272889742546 99.9000000000
% @LN 0.03  26.73462072994638916157 99.9000000000
% Resuming node 10 at  26.73462072994638916157
DEBUG CONSTRNT: LP rows=44, pool->nlprows=44, pool->npend=0
DEBUG CONSTRNT: Checking 44 LP rows (pool tracks 44, total LP rows 44)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 70
DEBUG CONSTRNT: Pool row 70 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=43, expected 43
 % @PAP adding 53 rows, 246 nz to LP
DEBUG BB: Processing node 10, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 10 LP 2 Solution, length = 26734620.729946, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.313315 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.626630 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.313315 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.626630 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 1.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.313315 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.313315 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.686685 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.373370 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.686685 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.686685 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.373370 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.373370 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=26734620.729946, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=26734620.729946, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 10 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 10
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.313315
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.313315)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.626630
DEBUG CAREFUL: Adding var 21 to fractional list (xi=0.626630)
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.313315
DEBUG CAREFUL: Adding var 23 to fractional list (xi=0.313315)
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.626630
DEBUG CAREFUL: Adding var 25 to fractional list (xi=0.626630)
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=1.000000
DEBUG CAREFUL: Skipping var 27: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.313315
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.313315)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.313315
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.313315)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 7
DEBUG CAREFUL: New best var: 7
DEBUG CAREFUL: Testing fvar[1] = var 23
DEBUG CAREFUL: Calling compare_branch_vars for var 23
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 23
DEBUG CAREFUL: Testing fvar[2] = var 25
DEBUG CAREFUL: Calling compare_branch_vars for var 25
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 25
DEBUG CAREFUL: Testing fvar[3] = var 21
DEBUG CAREFUL: Calling compare_branch_vars for var 21
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 21
DEBUG CAREFUL: Testing fvar[4] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 36
DEBUG CAREFUL: Testing fvar[5] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 34
  % Initial guess is x7, Z0 = 26734620.7299464        , Z1 = 27202561.3631279        

DEBUG EVAL: Testing var 7 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=5, varin=49, theta=0.133680, up=999999999999999983222784.000000
ITER 2: row=48, varin=47, theta=0.176730, up=999999999999999983222784.000000
ITER 3: row=10, varin=45, theta=2.439353, up=999999999999999983222784.000000
ITER 4: row=45, varin=12, theta=0.451353, up=999999999999999983222784.000000
ITER 5: row=12, varin=6, theta=0.579069, up=999999999999999983222784.000000
ITER 6: row=6, varin=11, theta=1.310390, up=999999999999999983222784.000000
ITER 7: row=11, varin=15, theta=3.468304, up=999999999999999983222784.000000
ITER 8: row=15, varin=5, theta=1.192062, up=999999999999999983222784.000000
ITER 9: row=1, varin=7, theta=5.404927, up=999999999999999983222784.000000
ITER 10: row=7, varin=38, theta=1.142762, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 7 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x7 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=5, varin=47, theta=0.130942, up=999999999999999983222784.000000
ITER 2: row=23, varin=25, theta=0.025436, up=999999999999999983222784.000000
ITER 3: row=51, varin=49, theta=0.012904, up=999999999999999983222784.000000
ITER 4: row=37, varin=41, theta=0.053914, up=999999999999999983222784.000000
ITER 5: row=35, varin=11, theta=0.033462, up=999999999999999983222784.000000
ITER 6: row=52, varin=34, theta=0.031796, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 26745557.227423
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 53 rows, 60 cols, 306 nonzeros, 9 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 9 slack rows
   % @PAP adding 10 rows, 28 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=54, varin=39, theta=0.583748, up=999999999999999983222784.000000
ITER 2: row=47, varin=37, theta=0.138240, up=999999999999999983222784.000000
ITER 3: row=8, varin=112, theta=0.110004, up=1.000000
ITER 4: row=45, varin=84, theta=0.348173, up=1.000000
ITER 5: row=52, varin=5, theta=0.073150, up=999999999999999983222784.000000
ITER 6: row=46, varin=54, theta=0.108621, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 26816701.708519
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 54 rows, 60 cols, 303 nonzeros, 8 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 8 slack rows
   % @PAP adding 4 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=82, theta=0.387879, up=1.000000
ITER 2: row=50, varin=49, theta=0.041137, up=999999999999999983222784.000000
ITER 3: row=18, varin=35, theta=0.304107, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 26833205.655071
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 50 rows, 60 cols, 285 nonzeros, 4 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 4 slack rows
   % @PAP adding 5 rows, 10 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=73, theta=0.084067, up=1.000000
ITER 2: row=48, varin=35, theta=0.255673, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 26858049.008986
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 51 rows, 60 cols, 274 nonzeros, 1 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 10 at  26.85804900898568448042
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ff19980d00
% @LO 0.03  26.73462072994638916157 99.9000000000
% @LN 0.03  26.74126662454423808413 99.9000000000
% Resuming node 17 at  26.74126662454423808413
DEBUG CONSTRNT: LP rows=50, pool->nlprows=50, pool->npend=0
DEBUG CONSTRNT: Checking 50 LP rows (pool tracks 50, total LP rows 50)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 70
DEBUG CONSTRNT: Pool row 70 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=49, expected 49
 % @PAP adding 44 rows, 194 nz to LP
DEBUG BB: Processing node 17, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 17 LP 2 Solution, length = 26741266.624544, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.271578 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.271578 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.271578 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.728422 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.728422 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.728422 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.728422 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=26741266.624544, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=26741266.624544, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 17 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 17
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.271578
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.271578)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.271578
DEBUG CAREFUL: Adding var 25 to fractional list (xi=0.271578)
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.271578
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.271578)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 3 fractional variables

  %  Carefully choosing branching variable, nfrac = 3
DEBUG CAREFUL: Testing fvar[0] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 9
DEBUG CAREFUL: New best var: 9
DEBUG CAREFUL: Testing fvar[1] = var 25
DEBUG CAREFUL: Calling compare_branch_vars for var 25
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 25
DEBUG CAREFUL: Testing fvar[2] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 34
  % Initial guess is x9, Z0 = 26741266.6245442        , Z1 = 26892924.7403142        

DEBUG EVAL: Testing var 9 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=41, theta=0.392689, up=999999999999999983222784.000000
ITER 2: row=5, varin=24, theta=0.994507, up=999999999999999983222784.000000
ITER 3: row=24, varin=43, theta=1.177477, up=999999999999999983222784.000000
ITER 4: row=43, varin=7, theta=1.791030, up=999999999999999983222784.000000
ITER 5: row=7, varin=40, theta=0.284041, up=999999999999999983222784.000000
ITER 6: row=43, varin=30, theta=3.127281, up=999999999999999983222784.000000
ITER 7: row=8, varin=35, theta=1.881250, up=999999999999999983222784.000000
ITER 8: row=22, varin=74, theta=16.266036, up=1.000000
ITER 9: row=22, varin=37, theta=0.842308, up=999999999999999983222784.000000
ITER 10: row=37, varin=6, theta=0.462262, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 9 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x9 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=3, theta=0.210050, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 26749229.676252
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.789950
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 44 rows, 60 cols, 254 nonzeros, 1 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 17 at  26.74922967625190040053
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ff19980d00
% @LO 0.03  26.74126662454423808413 99.9000000000
% @LN 0.03  26.74922967625190040053 99.9000000000
% Resuming node 17 at  26.74922967625190040053
DEBUG CONSTRNT: LP rows=43, pool->nlprows=43, pool->npend=0
DEBUG CONSTRNT: Checking 43 LP rows (pool tracks 43, total LP rows 43)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 70
DEBUG CONSTRNT: Pool row 70 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=42, expected 42
 % @PAP adding 43 rows, 192 nz to LP
DEBUG BB: Processing node 17, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 17 LP 3 Solution, length = 26749229.676252, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.210050 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.210050 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.210050 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.210050 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.210050 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.210050 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.789950 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.789950 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.789950 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.789950 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.789950 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.789950 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.789950 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=26749229.676252, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=26749229.676252, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 17 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 17
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.210050
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.210050)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.210050
DEBUG CAREFUL: Adding var 25 to fractional list (xi=0.210050)
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.210050
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.210050)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.210050
DEBUG CAREFUL: Adding var 30 to fractional list (xi=0.210050)
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.210050
DEBUG CAREFUL: Adding var 32 to fractional list (xi=0.210050)
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.210050
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.210050)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 32
DEBUG CAREFUL: Calling compare_branch_vars for var 32
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 32
DEBUG CAREFUL: New best var: 32
DEBUG CAREFUL: Testing fvar[1] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 0
DEBUG CAREFUL: New best var: 0
DEBUG CAREFUL: Testing fvar[2] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 29
DEBUG CAREFUL: Testing fvar[3] = var 30
DEBUG CAREFUL: Calling compare_branch_vars for var 30
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 30
DEBUG CAREFUL: Testing fvar[4] = var 25
DEBUG CAREFUL: Calling compare_branch_vars for var 25
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 25
DEBUG CAREFUL: Testing fvar[5] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 34
  % Initial guess is x0, Z0 = 26749229.6762519        , Z1 = 27334601.2653018        

DEBUG EVAL: Testing var 32 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=19, varin=29, theta=1.287296, up=999999999999999983222784.000000
ITER 2: row=21, varin=34, theta=0.865425, up=999999999999999983222784.000000
ITER 3: row=22, varin=35, theta=0.414201, up=999999999999999983222784.000000
ITER 4: row=1, varin=30, theta=0.760876, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 32 = 1 gives z=26891247.605796
  % 	x32 = 1,	Z1 = 26891247.6057958        
DEBUG EVAL: First branch cutoff check: z=26891247.605796, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 32 = 0
ITER 1: row=19, varin=35, theta=0.103525, up=999999999999999983222784.000000
ITER 2: row=41, varin=37, theta=0.077891, up=999999999999999983222784.000000
  % 	x32 = 0,	Z0 = 26763469.2386347        
DEBUG EVAL: Second branch cutoff check: z=26763469.238635, best_z=INF, threshold=INF
  %   New best:  x32, Z = 26763469.2386347        
DEBUG EVAL: Testing var 0 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=40, theta=0.550602, up=999999999999999983222784.000000
ITER 2: row=2, varin=23, theta=3.531448, up=999999999999999983222784.000000
ITER 3: row=28, varin=34, theta=1.530163, up=999999999999999983222784.000000
ITER 4: row=22, varin=90, theta=1.405723, up=1.000000
ITER 5: row=22, varin=27, theta=1.091425, up=999999999999999983222784.000000
ITER 6: row=17, varin=75, theta=1.451657, up=1.000000
ITER 7: row=17, varin=7, theta=0.314763, up=999999999999999983222784.000000
ITER 8: row=5, varin=42, theta=2.000000, up=999999999999999983222784.000000
ITER 9: row=42, varin=18, theta=2.000000, up=999999999999999983222784.000000
ITER 10: row=3, varin=36, theta=1.333333, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 0 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x0 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=35, theta=0.103525, up=999999999999999983222784.000000
ITER 2: row=41, varin=29, theta=0.543678, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 26759117.154132
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
   % @PL 43 rows, 60 cols, 252 nonzeros, 2 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 17 at  26.75911715413217351056
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ff19980d00
% @LO 0.03  26.74922967625190040053 99.9000000000
% @LN 0.03  26.75911715413217351056 99.9000000000
% Resuming node 17 at  26.75911715413217351056
DEBUG CONSTRNT: LP rows=41, pool->nlprows=41, pool->npend=0
DEBUG CONSTRNT: Checking 41 LP rows (pool tracks 41, total LP rows 41)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 70
DEBUG CONSTRNT: Pool row 70 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=40, expected 40
 % @PAP adding 41 rows, 188 nz to LP
DEBUG BB: Processing node 17, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 17 LP 4 Solution, length = 26759117.154132, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.543678 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.543678 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.543678 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.456322 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.456322 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.456322 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=26759117.154132, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=26759117.154132, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 17 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 17
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.543678
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.543678)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.543678
DEBUG CAREFUL: Adding var 30 to fractional list (xi=0.543678)
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.543678
DEBUG CAREFUL: Adding var 32 to fractional list (xi=0.543678)
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 3 fractional variables

  %  Carefully choosing branching variable, nfrac = 3
DEBUG CAREFUL: Testing fvar[0] = var 32
DEBUG CAREFUL: Calling compare_branch_vars for var 32
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 32
DEBUG CAREFUL: New best var: 32
DEBUG CAREFUL: Testing fvar[1] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 29
DEBUG CAREFUL: Testing fvar[2] = var 30
DEBUG CAREFUL: Calling compare_branch_vars for var 30
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 30
  % Initial guess is x32, Z0 = 26763469.2386347        , Z1 = 26891247.6057958        

DEBUG EVAL: Testing var 32 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=19, varin=35, theta=0.077891, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 32 = 0 gives z=26763469.238635
  % 	x32 = 0,	Z0 = 26763469.2386347        
DEBUG EVAL: First branch cutoff check: z=26763469.238635, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 32 = 1
ITER 1: row=19, varin=39, theta=0.086891, up=999999999999999983222784.000000
ITER 2: row=1, varin=32, theta=0.865425, up=999999999999999983222784.000000
ITER 3: row=22, varin=28, theta=0.760876, up=999999999999999983222784.000000
  % 	x32 = 1,	Z1 = 26891247.6057958        
DEBUG EVAL: Second branch cutoff check: z=26891247.605796, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 29 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=39, theta=0.086891, up=999999999999999983222784.000000
ITER 2: row=21, varin=32, theta=0.865425, up=999999999999999983222784.000000
ITER 3: row=22, varin=23, theta=2.974946, up=999999999999999983222784.000000
ITER 4: row=16, varin=73, theta=1.286367, up=1.000000
ITER 5: row=16, varin=88, theta=0.117497, up=1.000000
DEBUG EVAL: Branch var 29 = 1 gives z=26982509.097161
  % 	x29 = 1,	Z1 = 26982509.097161         
DEBUG EVAL: First branch cutoff check: z=26982509.097161, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 29 = 0
ITER 1: row=7, varin=35, theta=0.077891, up=999999999999999983222784.000000
  % 	x29 = 0,	Z0 = 26763469.2386347        
DEBUG EVAL: Second branch cutoff check: z=26763469.238635, best_z=INF, threshold=INF
  %   New best:  x29, Z = 26763469.2386347        
DEBUG EVAL: Testing var 30 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=16, varin=39, theta=0.086891, up=999999999999999983222784.000000
ITER 2: row=21, varin=32, theta=0.865425, up=999999999999999983222784.000000
ITER 3: row=22, varin=73, theta=1.937710, up=1.000000
ITER 4: row=22, varin=88, theta=0.384744, up=1.000000
ITER 5: row=5, varin=73, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 30 = 1 gives z=27027486.066718
  % 	x30 = 1,	Z1 = 27028194.6713256        
DEBUG EVAL: First branch cutoff check: z=27028194.671326, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 30 = 0
ITER 1: row=16, varin=35, theta=0.077891, up=999999999999999983222784.000000
  % 	x30 = 0,	Z0 = 26763469.2386347        
DEBUG EVAL: Second branch cutoff check: z=26763469.238635, best_z=INF, threshold=INF
  %   New best:  x30, Z = 26763469.2386347        
  % Best branch is x30, Z0 = 26763469.2386347        , Z1 = 27028194.6713256        

DEBUG CAREFUL: Final result - returning best.var = 30
DEBUG BB: Branching variable chosen: j=30
 % @NC   19   17	x30 = 0	26763469.238635
 % @NC   20   17	x30 = 1	27028194.671326
 %      17     8 26759117.1541               26763469.2386   x24 D    15     9
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ff1998f740
% @LO 0.03  26.75911715413217351056 99.9000000000
% @LN 0.03  26.76346923863472326843 99.9000000000
% Resuming node 19 at  26.76346923863472326843
DEBUG CONSTRNT: LP rows=41, pool->nlprows=41, pool->npend=0
DEBUG CONSTRNT: Checking 41 LP rows (pool tracks 41, total LP rows 41)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 70
DEBUG CONSTRNT: Pool row 70 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=40, expected 40
 % @PAP adding 41 rows, 188 nz to LP
DEBUG BB: Processing node 19, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=16, varin=35, theta=0.077891, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 26763469.238635
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 41 rows, 60 cols, 248 nonzeros, 3 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=38, theta=0.353462, up=999999999999999983222784.000000
ITER 2: row=4, varin=62, theta=0.130155, up=1.000000
ITER 3: row=43, varin=34, theta=0.106943, up=999999999999999983222784.000000
ITER 4: row=13, varin=10, theta=0.023646, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 26794837.540740
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.976354
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 43 rows, 60 cols, 256 nonzeros, 4 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=39, theta=0.155921, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 26798070.422313
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 42 rows, 60 cols, 254 nonzeros, 1 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 19 LP 1 Solution, length = 26798070.422313, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.051974 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.051974 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.051974 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.051974 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.051974 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.363816 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.051974 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.363816 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.948026 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.636184 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.636184 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.948026 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.948026 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.948026 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.636184 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.948026 (terminal 19)
 % 8 fractional variables
DEBUG CG: LP optimal, z=26798070.422313, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.03  26.76346923863472326843 99.9000000000
 % @LN 0.03  26.79807042231272262711 99.9000000000
DEBUG CG: Second cutoff check: z=26798070.422313, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 19 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 19
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.051974
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.051974)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.051974
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.051974)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.051974
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.051974)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.051974
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.051974)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.051974
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.051974)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.363816
DEBUG CAREFUL: Adding var 25 to fractional list (xi=0.363816)
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.051974
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.051974)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.363816
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.363816)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 8 fractional variables

  %  Carefully choosing branching variable, nfrac = 8
DEBUG CAREFUL: Testing fvar[0] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
DEBUG CAREFUL: Testing fvar[1] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 22
DEBUG CAREFUL: Testing fvar[2] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[3] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[4] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[5] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[6] = var 25
DEBUG CAREFUL: Calling compare_branch_vars for var 25
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 25
DEBUG CAREFUL: Testing fvar[7] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 34
  % Initial guess is x18, Z0 = 26798070.4223127        , Z1 = 29495338.9870639        

DEBUG EVAL: Testing var 18 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=13, varin=12, theta=0.975352, up=999999999999999983222784.000000
ITER 2: row=40, varin=22, theta=21.267476, up=999999999999999983222784.000000
ITER 3: row=7, varin=33, theta=1.634989, up=999999999999999983222784.000000
ITER 4: row=41, varin=36, theta=7.631068, up=999999999999999983222784.000000
ITER 5: row=36, varin=6, theta=11.607416, up=999999999999999983222784.000000
ITER 6: row=6, varin=35, theta=1.682238, up=999999999999999983222784.000000
ITER 7: row=15, varin=71, theta=2.715522, up=1.000000
ITER 8: row=15, varin=64, theta=2.987284, up=1.000000
ITER 9: row=15, varin=30, theta=1.768714, up=999999999999999983222784.000000
ITER 10: row=18, varin=88, theta=1.624874, up=1.000000
DEBUG EVAL: Branch var 18 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x18 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=13, varin=39, theta=0.086525, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 26802013.611300
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
   % @PL 41 rows, 60 cols, 248 nonzeros, 3 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 3 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 19 at  26.80201361130011150635
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ff1998f740
% @LO 0.03  26.79807042231272262711 99.9000000000
% @LN 0.03  26.80201361130011150635 99.9000000000
% Resuming node 19 at  26.80201361130011150635
DEBUG CONSTRNT: LP rows=38, pool->nlprows=38, pool->npend=0
DEBUG CONSTRNT: Checking 38 LP rows (pool tracks 38, total LP rows 38)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 70
DEBUG CONSTRNT: Pool row 70 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=37, expected 37
 % @PAP adding 38 rows, 182 nz to LP
DEBUG BB: Processing node 19, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 19 LP 2 Solution, length = 26802013.611300, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.086525 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.086525 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.086525 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.086525 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.346100 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.086525 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.346100 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.913475 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.653900 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.653900 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.913475 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.913475 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.913475 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.653900 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.913475 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=26802013.611300, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=26802013.611300, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 19 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 19
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.086525
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.086525)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.086525
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.086525)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.086525
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.086525)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.086525
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.086525)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.346100
DEBUG CAREFUL: Adding var 25 to fractional list (xi=0.346100)
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.086525
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.086525)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.346100
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.346100)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 7 fractional variables

  %  Carefully choosing branching variable, nfrac = 7
DEBUG CAREFUL: Testing fvar[0] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 22
DEBUG CAREFUL: New best var: 22
DEBUG CAREFUL: Testing fvar[1] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[2] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 10
DEBUG CAREFUL: New best var: 10
DEBUG CAREFUL: Testing fvar[3] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
DEBUG CAREFUL: Testing fvar[4] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[5] = var 25
DEBUG CAREFUL: Calling compare_branch_vars for var 25
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 25
DEBUG CAREFUL: Testing fvar[6] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 34
  % Initial guess is x17, Z0 = 26802013.6113001        , Z1 = 27635870.4427801        

DEBUG EVAL: Testing var 22 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=32, theta=3.321019, up=999999999999999983222784.000000
ITER 2: row=30, varin=4, theta=2.607990, up=999999999999999983222784.000000
ITER 3: row=34, varin=5, theta=0.904007, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 22 = 1 gives z=27141444.231306
  % 	x22 = 1,	Z1 = 27141444.2313059        
DEBUG EVAL: First branch cutoff check: z=27141444.231306, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 22 = 0
ITER 1: row=6, varin=72, theta=0.445435, up=1.000000
  % 	x22 = 0,	Z0 = 26809721.5853643        
DEBUG EVAL: Second branch cutoff check: z=26809721.585364, best_z=INF, threshold=INF
  %   New best:  x22, Z = 26809721.5853643        
DEBUG EVAL: Testing var 26 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=12, varin=32, theta=0.119354, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 0 gives z=26805716.761707
  % 	x26 = 0,	Z0 = 26805716.7617074        
DEBUG EVAL: First branch cutoff check: z=26805716.761707, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=4, varin=12, theta=0.564520, up=999999999999999983222784.000000
ITER 2: row=31, varin=4, theta=3.731629, up=999999999999999983222784.000000
ITER 3: row=34, varin=35, theta=1.092956, up=999999999999999983222784.000000
ITER 4: row=21, varin=70, theta=2.072949, up=1.000000
ITER 5: row=21, varin=85, theta=0.440232, up=1.000000
ITER 6: row=5, varin=70, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 10 = 1 gives z=27591451.621805
  % 	x10 = 1,	Z1 = 27591451.621805         
DEBUG EVAL: First branch cutoff check: z=27591451.621805, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=4, varin=32, theta=0.119354, up=999999999999999983222784.000000
  % 	x10 = 0,	Z0 = 26805716.7617074        
DEBUG EVAL: Second branch cutoff check: z=26805716.761707, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=5, varin=32, theta=3.321019, up=999999999999999983222784.000000
ITER 2: row=30, varin=4, theta=2.607990, up=999999999999999983222784.000000
ITER 3: row=34, varin=36, theta=3.239120, up=999999999999999983222784.000000
ITER 4: row=36, varin=6, theta=4.926940, up=999999999999999983222784.000000
ITER 5: row=6, varin=30, theta=6.063733, up=999999999999999983222784.000000
ITER 6: row=21, varin=38, theta=1.563753, up=999999999999999983222784.000000
ITER 7: row=4, varin=12, theta=4.042994, up=999999999999999983222784.000000
ITER 8: row=12, varin=33, theta=1.815764, up=999999999999999983222784.000000
ITER 9: row=6, varin=61, theta=3.175811, up=1.000000
ITER 10: row=6, varin=25, theta=4.174775, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x17 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=5, varin=72, theta=0.445435, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 26809721.585364
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
   % @PL 38 rows, 60 cols, 242 nonzeros, 0 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 4 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=74, theta=0.504614, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 26817064.690519
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
   % @PL 42 rows, 60 cols, 256 nonzeros, 0 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=28, theta=0.757193, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 26817257.593540
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
   % @PL 43 rows, 60 cols, 258 nonzeros, 2 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
   % @PAP adding 2 rows, 11 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=55, theta=0.128898, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 26829633.775098
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
   % @PL 43 rows, 60 cols, 264 nonzeros, 1 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 4 rows, 22 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=12, theta=0.174401, up=999999999999999983222784.000000
ITER 2: row=29, varin=51, theta=0.127231, up=1.000000
ITER 3: row=46, varin=29, theta=0.200289, up=999999999999999983222784.000000
ITER 4: row=13, varin=33, theta=0.016153, up=999999999999999983222784.000000
ITER 5: row=43, varin=57, theta=0.017570, up=1.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 26846203.941728
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
   % @PL 46 rows, 60 cols, 277 nonzeros, 2 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
   % @PAP adding 3 rows, 11 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=5, theta=0.048718, up=999999999999999983222784.000000
ITER 2: row=47, varin=12, theta=0.069029, up=999999999999999983222784.000000
ITER 3: row=29, varin=45, theta=0.060603, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 26852326.967085
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.927276
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
   % @PL 47 rows, 60 cols, 284 nonzeros, 5 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 5 slack rows
   % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=41, theta=0.228498, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 26862454.285894
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 500000.000000
   % @PL 43 rows, 60 cols, 265 nonzeros, 1 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 19 at  26.86245428589374739659
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ff19984250
% @LO 0.03  26.80201361130011150635 99.9000000000
% @LN 0.03  26.84983635383500910621 99.9000000000
% Resuming node 11 at  26.84983635383500910621
DEBUG CONSTRNT: LP rows=42, pool->nlprows=42, pool->npend=0
DEBUG CONSTRNT: Checking 42 LP rows (pool tracks 42, total LP rows 42)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 70
DEBUG CONSTRNT: Pool row 70 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 134
DEBUG CONSTRNT: Pool row 134 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=41, expected 41
 % @PAP adding 55 rows, 210 nz to LP
DEBUG BB: Processing node 11, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 11 LP 6 Solution, length = 26849836.353835, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.076923 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.076923 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.076923 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.076923 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.076923 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.076923 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.076923 (FST 20)
  % DEBUG LP_VARS: x[21] = 1.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.076923 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.754485 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.076923 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.076923 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.076923 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.923077 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.923077 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.923077 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.245515 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.923077 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.923077 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.923077 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.923077 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.923077 (terminal 19)
 % 12 fractional variables
DEBUG CG: LP optimal, z=26849836.353835, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=26849836.353835, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 11 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 11
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.076923
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.076923)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.076923
DEBUG CAREFUL: Adding var 8 to fractional list (xi=0.076923)
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.076923
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.076923)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.076923
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.076923)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.076923
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.076923)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.076923
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.076923)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.076923
DEBUG CAREFUL: Adding var 20 to fractional list (xi=0.076923)
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=1.000000
DEBUG CAREFUL: Skipping var 21: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.076923
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.076923)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.754485
DEBUG CAREFUL: Adding var 25 to fractional list (xi=0.754485)
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.076923
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.076923)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.076923
DEBUG CAREFUL: Adding var 31 to fractional list (xi=0.076923)
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.076923
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.076923)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 12 fractional variables

  %  Carefully choosing branching variable, nfrac = 12
DEBUG CAREFUL: Testing fvar[0] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 22
DEBUG CAREFUL: New best var: 22
DEBUG CAREFUL: Testing fvar[1] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[2] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[3] = var 20
DEBUG CAREFUL: Calling compare_branch_vars for var 20
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 20
DEBUG CAREFUL: New best var: 20
DEBUG CAREFUL: Testing fvar[4] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[5] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 11
DEBUG CAREFUL: Testing fvar[6] = var 8
DEBUG CAREFUL: Calling compare_branch_vars for var 8
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 8
DEBUG CAREFUL: Testing fvar[7] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 34
DEBUG CAREFUL: Testing fvar[8] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
DEBUG CAREFUL: Testing fvar[9] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 4
DEBUG CAREFUL: Testing fvar[10] = var 31
DEBUG CAREFUL: Calling compare_branch_vars for var 31
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 31
DEBUG CAREFUL: Testing fvar[11] = var 25
DEBUG CAREFUL: Calling compare_branch_vars for var 25
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 25
  % Initial guess is x18, Z0 = 26849836.353835         , Z1 = 29495338.9870639        

DEBUG EVAL: Testing var 22 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=4, varin=93, theta=1.000000, up=1.000000
ITER 2: row=17, varin=8, theta=0.065787, up=999999999999999983222784.000000
ITER 3: row=44, varin=4, theta=0.048084, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 22 = 0 gives z=26947652.514866
  % 	x22 = 0,	Z0 = 26947652.5148661        
DEBUG EVAL: First branch cutoff check: z=26947652.514866, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 22 = 1
ITER 1: row=4, varin=36, theta=0.923077, up=999999999999999983222784.000000
ITER 2: row=31, varin=7, theta=1.500000, up=999999999999999983222784.000000
ITER 3: row=17, varin=93, theta=10.822514, up=1.000000
ITER 4: row=17, varin=6, theta=1.893987, up=999999999999999983222784.000000
ITER 5: row=55, varin=93, theta=4.636179, up=1.000000
ITER 6: row=55, varin=46, theta=2.545033, up=999999999999999983222784.000000
ITER 7: row=2, varin=37, theta=0.475496, up=999999999999999983222784.000000
ITER 8: row=6, varin=22, theta=2.706655, up=999999999999999983222784.000000
ITER 9: row=14, varin=93, theta=8.597480, up=1.000000
ITER 10: row=14, varin=94, theta=7.863251, up=1.000000
  % 	x22 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: Second branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=4, varin=93, theta=1.000000, up=1.000000
ITER 2: row=17, varin=8, theta=0.065787, up=999999999999999983222784.000000
ITER 3: row=44, varin=4, theta=0.048084, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 26947652.514866
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.951916
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 500000.000000
   % @PL 55 rows, 60 cols, 270 nonzeros, 2 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
   % @PAP adding 4 rows, 20 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=54, varin=52, theta=0.170574, up=999999999999999983222784.000000
ITER 2: row=57, varin=97, theta=0.334766, up=1.000000
ITER 3: row=47, varin=57, theta=0.087011, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 26983385.157296
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 500000.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 57 rows, 60 cols, 286 nonzeros, 1 slack, 56 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 4 rows, 21 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=57, varin=86, theta=0.426263, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=60)
DEBUG SOLUTION: LP solution array indices: FST[61-100], not_covered[101-120]
DEBUG SOLUTION: lp->best_solution[0] = 26992604.336433
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 500000.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 60 rows, 60 cols, 297 nonzeros, 2 slack, 58 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 11 at  26.99260433643284429195
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ff1997a3c0
% @LO 0.04  26.84983635383500910621 99.9000000000
% @LN 0.04  26.85804900898568448042 99.9000000000
% Resuming node 10 at  26.85804900898568448042
DEBUG CONSTRNT: LP rows=58, pool->nlprows=58, pool->npend=0
DEBUG CONSTRNT: Checking 58 LP rows (pool tracks 58, total LP rows 58)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 70
DEBUG CONSTRNT: Pool row 70 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=56, expected 56
DEBUG CONSTRNT: Checking LP row 57 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=57, expected 57
 % @PAP adding 50 rows, 206 nz to LP
DEBUG BB: Processing node 10, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 10 LP 3 Solution, length = 26858049.008986, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.085224 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.085224 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.085224 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.085224 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.085224 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.852242 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.085224 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.852242 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.085224 (FST 26)
  % DEBUG LP_VARS: x[27] = 1.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.085224 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.085224 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.914776 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.914776 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.147758 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.914776 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.914776 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.914776 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.914776 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.147758 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.147758 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.914776 (terminal 19)
 % 11 fractional variables
DEBUG CG: LP optimal, z=26858049.008986, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=26858049.008986, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 10 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 10
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.085224
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.085224)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.085224
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.085224)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.085224
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.085224)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.085224
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.085224)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.085224
DEBUG CAREFUL: Adding var 20 to fractional list (xi=0.085224)
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.852242
DEBUG CAREFUL: Adding var 21 to fractional list (xi=0.852242)
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.085224
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.085224)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.852242
DEBUG CAREFUL: Adding var 25 to fractional list (xi=0.852242)
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.085224
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.085224)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=1.000000
DEBUG CAREFUL: Skipping var 27: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.085224
DEBUG CAREFUL: Adding var 31 to fractional list (xi=0.085224)
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.085224
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.085224)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 11 fractional variables

  %  Carefully choosing branching variable, nfrac = 11
DEBUG CAREFUL: Testing fvar[0] = var 25
DEBUG CAREFUL: Calling compare_branch_vars for var 25
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 25
DEBUG CAREFUL: New best var: 25
DEBUG CAREFUL: Testing fvar[1] = var 21
DEBUG CAREFUL: Calling compare_branch_vars for var 21
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 21
DEBUG CAREFUL: New best var: 21
DEBUG CAREFUL: Testing fvar[2] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[3] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[4] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[5] = var 20
DEBUG CAREFUL: Calling compare_branch_vars for var 20
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 20
DEBUG CAREFUL: New best var: 20
DEBUG CAREFUL: Testing fvar[6] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[7] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 22
DEBUG CAREFUL: Testing fvar[8] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[9] = var 31
DEBUG CAREFUL: Calling compare_branch_vars for var 31
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 31
DEBUG CAREFUL: Testing fvar[10] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 34
  % Initial guess is x20, Z0 = 26858049.0089857        , Z1 = 29250638.9175699        

DEBUG EVAL: Testing var 25 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=21, varin=84, theta=0.588490, up=1.000000
DEBUG EVAL: Branch var 25 = 1 gives z=26869857.047054
  % 	x25 = 1,	Z1 = 26869857.0470541        
DEBUG EVAL: First branch cutoff check: z=26869857.047054, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 25 = 0
ITER 1: row=21, varin=46, theta=2.211227, up=999999999999999983222784.000000
ITER 2: row=22, varin=34, theta=1.514200, up=999999999999999983222784.000000
ITER 3: row=8, varin=29, theta=0.611711, up=999999999999999983222784.000000
ITER 4: row=40, varin=12, theta=0.414823, up=999999999999999983222784.000000
ITER 5: row=2, varin=42, theta=0.584855, up=999999999999999983222784.000000
  % 	x25 = 0,	Z0 = 27023126.8759854        
DEBUG EVAL: Second branch cutoff check: z=27023126.875985, best_z=INF, threshold=INF
  %   New best:  x25, Z = 26869857.0470541        
DEBUG EVAL: Testing var 21 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=18, varin=84, theta=0.588490, up=1.000000
DEBUG EVAL: Branch var 21 = 1 gives z=26869857.047054
  % 	x21 = 1,	Z1 = 26869857.0470541        
DEBUG EVAL: First branch cutoff check: z=26869857.047054, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 21 = 0
ITER 1: row=18, varin=46, theta=2.211227, up=999999999999999983222784.000000
ITER 2: row=22, varin=34, theta=1.514200, up=999999999999999983222784.000000
ITER 3: row=8, varin=29, theta=0.611711, up=999999999999999983222784.000000
ITER 4: row=40, varin=12, theta=0.414823, up=999999999999999983222784.000000
ITER 5: row=2, varin=42, theta=0.584855, up=999999999999999983222784.000000
  % 	x21 = 0,	Z0 = 27023126.8759854        
DEBUG EVAL: Second branch cutoff check: z=27023126.875985, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=16, varin=84, theta=1.137962, up=1.000000
ITER 2: row=16, varin=37, theta=0.012131, up=999999999999999983222784.000000
ITER 3: row=18, varin=29, theta=0.104131, up=999999999999999983222784.000000
ITER 4: row=40, varin=84, theta=0.127263, up=1.000000
DEBUG EVAL: Branch var 10 = 0 gives z=26886319.091266
  % 	x10 = 0,	Z0 = 26886319.0912663        
DEBUG EVAL: First branch cutoff check: z=26886319.091266, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 1
ITER 1: row=16, varin=38, theta=1.042533, up=999999999999999983222784.000000
ITER 2: row=11, varin=46, theta=14.884468, up=999999999999999983222784.000000
ITER 3: row=22, varin=47, theta=2.553038, up=999999999999999983222784.000000
ITER 4: row=11, varin=12, theta=1.827393, up=999999999999999983222784.000000
ITER 5: row=22, varin=43, theta=0.960169, up=999999999999999983222784.000000
ITER 6: row=2, varin=41, theta=1.023904, up=999999999999999983222784.000000
ITER 7: row=18, varin=10, theta=1.164973, up=999999999999999983222784.000000
ITER 8: row=10, varin=32, theta=0.579925, up=999999999999999983222784.000000
ITER 9: row=19, varin=4, theta=0.888880, up=999999999999999983222784.000000
ITER 10: row=20, varin=40, theta=0.364050, up=999999999999999983222784.000000
  % 	x10 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: Second branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=16, varin=84, theta=1.137962, up=1.000000
ITER 2: row=16, varin=37, theta=0.012131, up=999999999999999983222784.000000
ITER 3: row=18, varin=29, theta=0.104131, up=999999999999999983222784.000000
ITER 4: row=40, varin=84, theta=0.127263, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 26886319.091266
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 50 rows, 60 cols, 266 nonzeros, 1 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 6 rows, 25 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=77, theta=0.339435, up=1.000000
ITER 2: row=54, varin=99, theta=0.068796, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 26907410.421468
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.931204
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 55 rows, 60 cols, 289 nonzeros, 5 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 5 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 10 at  26.90741042146777672883
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ff1998f740
% @LO 0.04  26.85804900898568448042 99.9000000000
% @LN 0.04  26.86245428589374739659 99.9000000000
% Resuming node 19 at  26.86245428589374739659
DEBUG CONSTRNT: LP rows=50, pool->nlprows=50, pool->npend=0
DEBUG CONSTRNT: Checking 50 LP rows (pool tracks 50, total LP rows 50)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 70
DEBUG CONSTRNT: Pool row 70 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=49, expected 49
 % @PAP adding 42 rows, 195 nz to LP
DEBUG BB: Processing node 19, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 19 LP 3 Solution, length = 26862454.285894, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.045700 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.045700 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.045700 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.045700 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.045700 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.228498 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.228498 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.045700 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.228498 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.228498 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.771502 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.954300 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.771502 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.771502 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.954300 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.954300 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.954300 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.771502 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.771502 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.954300 (terminal 19)
 % 10 fractional variables
DEBUG CG: LP optimal, z=26862454.285894, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=26862454.285894, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 19 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 19
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.045700
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.045700)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.045700
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.045700)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.045700
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.045700)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.045700
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.045700)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.045700
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.045700)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.228498
DEBUG CAREFUL: Adding var 23 to fractional list (xi=0.228498)
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.228498
DEBUG CAREFUL: Adding var 25 to fractional list (xi=0.228498)
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.045700
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.045700)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.228498
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.228498)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.228498
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.228498)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 10 fractional variables

  %  Carefully choosing branching variable, nfrac = 10
DEBUG CAREFUL: Testing fvar[0] = var 25
DEBUG CAREFUL: Calling compare_branch_vars for var 25
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 25
DEBUG CAREFUL: New best var: 25
DEBUG CAREFUL: Testing fvar[1] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 34
DEBUG CAREFUL: Testing fvar[2] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[3] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 10
DEBUG CAREFUL: New best var: 10
DEBUG CAREFUL: Testing fvar[4] = var 23
DEBUG CAREFUL: Calling compare_branch_vars for var 23
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 23
DEBUG CAREFUL: Testing fvar[5] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 36
DEBUG CAREFUL: Testing fvar[6] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 22
DEBUG CAREFUL: Testing fvar[7] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[8] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 4
DEBUG CAREFUL: New best var: 4
DEBUG CAREFUL: Testing fvar[9] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 11
  % Initial guess is x4, Z0 = 26862454.2858937        , Z1 = 28066998.0655834        

DEBUG EVAL: Testing var 25 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=17, varin=17, theta=0.245990, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 25 = 0 gives z=26963559.705349
  % 	x25 = 0,	Z0 = 26963559.7053485        
DEBUG EVAL: First branch cutoff check: z=26963559.705349, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 25 = 1
ITER 1: row=17, varin=39, theta=2.556593, up=999999999999999983222784.000000
ITER 2: row=3, varin=28, theta=3.028696, up=999999999999999983222784.000000
ITER 3: row=12, varin=89, theta=0.962615, up=1.000000
ITER 4: row=11, varin=53, theta=0.006947, up=1.000000
  % 	x25 = 1,	Z1 = 27208832.3358741        
DEBUG EVAL: Second branch cutoff check: z=27208832.335874, best_z=INF, threshold=INF
  %   New best:  x25, Z = 26963559.7053485        
DEBUG EVAL: Testing var 34 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=20, varin=27, theta=0.479409, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 34 = 0 gives z=26968380.685500
  % 	x34 = 0,	Z0 = 26968380.6854996        
DEBUG EVAL: First branch cutoff check: z=26968380.685500, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 34 = 1
ITER 1: row=20, varin=39, theta=2.556593, up=999999999999999983222784.000000
ITER 2: row=3, varin=28, theta=3.028696, up=999999999999999983222784.000000
ITER 3: row=12, varin=89, theta=0.962615, up=1.000000
ITER 4: row=11, varin=53, theta=0.006947, up=1.000000
  % 	x34 = 1,	Z1 = 27208832.3358741        
DEBUG EVAL: Second branch cutoff check: z=27208832.335874, best_z=INF, threshold=INF
  %   New best:  x34, Z = 26968380.6854996        
DEBUG EVAL: Testing var 26 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=28, varin=29, theta=0.049384, up=999999999999999983222784.000000
ITER 2: row=10, varin=28, theta=0.057529, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 0 gives z=26878726.713979
  % 	x26 = 0,	Z0 = 26878726.7139793        
DEBUG EVAL: First branch cutoff check: z=26878726.713979, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=12, varin=42, theta=1.722315, up=999999999999999983222784.000000
ITER 2: row=1, varin=41, theta=1.114241, up=999999999999999983222784.000000
ITER 3: row=16, varin=24, theta=0.382789, up=999999999999999983222784.000000
ITER 4: row=17, varin=89, theta=0.533455, up=1.000000
ITER 5: row=4, varin=40, theta=0.275034, up=999999999999999983222784.000000
ITER 6: row=14, varin=34, theta=0.680756, up=999999999999999983222784.000000
ITER 7: row=34, varin=38, theta=0.850533, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=27591451.621805
  % 	x10 = 1,	Z1 = 27591451.621805         
DEBUG EVAL: First branch cutoff check: z=27591451.621805, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=12, varin=28, theta=0.052590, up=999999999999999983222784.000000
ITER 2: row=11, varin=29, theta=0.057529, up=999999999999999983222784.000000
  % 	x10 = 0,	Z0 = 26878726.7139793        
DEBUG EVAL: Second branch cutoff check: z=26878726.713979, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 23 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=28, theta=4.974417, up=999999999999999983222784.000000
ITER 2: row=12, varin=89, theta=1.629994, up=1.000000
ITER 3: row=12, varin=24, theta=0.531482, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 23 = 1 gives z=27424970.963207
  % 	x23 = 1,	Z1 = 27424970.9632075        
DEBUG EVAL: First branch cutoff check: z=27424970.963207, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 23 = 0
ITER 1: row=3, varin=39, theta=0.327253, up=999999999999999983222784.000000
  % 	x23 = 0,	Z0 = 26881987.9378027        
DEBUG EVAL: Second branch cutoff check: z=26881987.937803, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 36 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=24, varin=28, theta=4.974417, up=999999999999999983222784.000000
ITER 2: row=12, varin=89, theta=1.629994, up=1.000000
ITER 3: row=12, varin=20, theta=0.973176, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 36 = 1 gives z=27716384.864550
  % 	x36 = 1,	Z1 = 27716384.8645496        
DEBUG EVAL: First branch cutoff check: z=27716384.864550, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 36 = 0
ITER 1: row=24, varin=39, theta=0.327253, up=999999999999999983222784.000000
  % 	x36 = 0,	Z0 = 26881987.9378027        
DEBUG EVAL: Second branch cutoff check: z=26881987.937803, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 22 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=5, varin=40, theta=1.192190, up=999999999999999983222784.000000
ITER 2: row=14, varin=41, theta=0.428302, up=999999999999999983222784.000000
ITER 3: row=4, varin=28, theta=1.174184, up=999999999999999983222784.000000
ITER 4: row=12, varin=39, theta=2.548966, up=999999999999999983222784.000000
ITER 5: row=3, varin=38, theta=1.032273, up=999999999999999983222784.000000
ITER 6: row=38, varin=34, theta=0.911212, up=999999999999999983222784.000000
ITER 7: row=34, varin=4, theta=0.723067, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 22 = 1 gives z=27162868.215186
  % 	x22 = 1,	Z1 = 27162868.2151859        
DEBUG EVAL: First branch cutoff check: z=27162868.215186, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 22 = 0
ITER 1: row=5, varin=5, theta=0.052455, up=999999999999999983222784.000000
  % 	x22 = 0,	Z0 = 26876767.9526231        
DEBUG EVAL: Second branch cutoff check: z=26876767.952623, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 3 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=42, theta=0.102484, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 0 gives z=26879580.261283
  % 	x3 = 0,	Z0 = 26879580.2612827        
DEBUG EVAL: First branch cutoff check: z=26879580.261283, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 4 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=4, varin=42, theta=1.722315, up=999999999999999983222784.000000
ITER 2: row=1, varin=28, theta=3.054678, up=999999999999999983222784.000000
ITER 3: row=12, varin=40, theta=0.759297, up=999999999999999983222784.000000
ITER 4: row=14, varin=38, theta=1.783767, up=999999999999999983222784.000000
ITER 5: row=38, varin=39, theta=4.460379, up=999999999999999983222784.000000
ITER 6: row=3, varin=34, theta=1.741506, up=999999999999999983222784.000000
ITER 7: row=34, varin=31, theta=1.716348, up=999999999999999983222784.000000
ITER 8: row=31, varin=5, theta=2.610691, up=999999999999999983222784.000000
ITER 9: row=5, varin=27, theta=4.031264, up=999999999999999983222784.000000
ITER 10: row=38, varin=29, theta=5.036693, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 4 = 1 gives z=28435876.226926
  % 	x4 = 1,	Z1 = 28435876.2269263        
DEBUG EVAL: First branch cutoff check: z=28435876.226926, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 4 = 0
ITER 1: row=4, varin=41, theta=0.071315, up=999999999999999983222784.000000
  % 	x4 = 0,	Z0 = 26875433.7728056        
DEBUG EVAL: Second branch cutoff check: z=26875433.772806, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 11 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=14, varin=41, theta=2.656838, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 11 = 1 gives z=27346005.310986
  % 	x11 = 1,	Z1 = 27879833.5763612        
DEBUG EVAL: First branch cutoff check: z=27879833.576361, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 11 = 0
ITER 1: row=14, varin=42, theta=0.102484, up=999999999999999983222784.000000
  % 	x11 = 0,	Z0 = 26879580.2612827        
DEBUG EVAL: Second branch cutoff check: z=26879580.261283, best_z=INF, threshold=INF
  % Best branch is x34, Z0 = 26968380.6854996        , Z1 = 27208832.3358741        

DEBUG CAREFUL: Final result - returning best.var = 34
DEBUG BB: Branching variable chosen: j=34
 % @NC   21   19	x34 = 0	26968380.685500
 % @NC   22   19	x34 = 1	27208832.335874
 %      19     9 26862454.2859               26907410.4215   x30 D    17    10
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ff1997a3c0
% @LO 0.04  26.86245428589374739659 99.9000000000
% @LN 0.04  26.90741042146777672883 99.9000000000
% Resuming node 10 at  26.90741042146777672883
DEBUG CONSTRNT: LP rows=42, pool->nlprows=42, pool->npend=0
DEBUG CONSTRNT: Checking 42 LP rows (pool tracks 42, total LP rows 42)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 70
DEBUG CONSTRNT: Pool row 70 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 134
DEBUG CONSTRNT: Pool row 134 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=41, expected 41
 % @PAP adding 50 rows, 208 nz to LP
DEBUG BB: Processing node 10, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 10 LP 4 Solution, length = 26907410.421468, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.068796 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.068796 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.068796 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.068796 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.068796 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.756755 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.068796 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.068796 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.068796 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.756755 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 1.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.068796 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.068796 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.068796 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.068796 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.068796 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.068796 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.068796 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.931204 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.931204 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.931204 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.931204 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.931204 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.931204 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.243245 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.931204 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.931204 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.931204 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.931204 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.931204 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.243245 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.243245 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.931204 (terminal 19)
 % 17 fractional variables
DEBUG CG: LP optimal, z=26907410.421468, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=26907410.421468, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 10 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 10
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.068796
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.068796)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.068796
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.068796)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.068796
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.068796)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.068796
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.068796)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.068796
DEBUG CAREFUL: Adding var 20 to fractional list (xi=0.068796)
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.756755
DEBUG CAREFUL: Adding var 21 to fractional list (xi=0.756755)
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.068796
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.068796)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.068796
DEBUG CAREFUL: Adding var 23 to fractional list (xi=0.068796)
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.068796
DEBUG CAREFUL: Adding var 24 to fractional list (xi=0.068796)
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.756755
DEBUG CAREFUL: Adding var 25 to fractional list (xi=0.756755)
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=1.000000
DEBUG CAREFUL: Skipping var 27: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.068796
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.068796)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.068796
DEBUG CAREFUL: Adding var 30 to fractional list (xi=0.068796)
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.068796
DEBUG CAREFUL: Adding var 31 to fractional list (xi=0.068796)
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.068796
DEBUG CAREFUL: Adding var 32 to fractional list (xi=0.068796)
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.068796
DEBUG CAREFUL: Adding var 33 to fractional list (xi=0.068796)
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.068796
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.068796)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.068796
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.068796)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 17 fractional variables

  %  Carefully choosing branching variable, nfrac = 17
DEBUG CAREFUL: Testing fvar[0] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 29
DEBUG CAREFUL: New best var: 29
DEBUG CAREFUL: Testing fvar[1] = var 30
DEBUG CAREFUL: Calling compare_branch_vars for var 30
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 30
DEBUG CAREFUL: New best var: 30
DEBUG CAREFUL: Testing fvar[2] = var 32
DEBUG CAREFUL: Calling compare_branch_vars for var 32
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 32
DEBUG CAREFUL: Testing fvar[3] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
DEBUG CAREFUL: Testing fvar[4] = var 24
DEBUG CAREFUL: Calling compare_branch_vars for var 24
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 24
DEBUG CAREFUL: Testing fvar[5] = var 23
DEBUG CAREFUL: Calling compare_branch_vars for var 23
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 23
DEBUG CAREFUL: Testing fvar[6] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 36
DEBUG CAREFUL: Testing fvar[7] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[8] = var 20
DEBUG CAREFUL: Calling compare_branch_vars for var 20
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 20
DEBUG CAREFUL: New best var: 20
DEBUG CAREFUL: Testing fvar[9] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 22
DEBUG CAREFUL: Testing fvar[10] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[11] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[12] = var 25
DEBUG CAREFUL: Calling compare_branch_vars for var 25
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 25
DEBUG CAREFUL: Testing fvar[13] = var 21
DEBUG CAREFUL: Calling compare_branch_vars for var 21
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 21
DEBUG CAREFUL: Testing fvar[14] = var 31
DEBUG CAREFUL: Calling compare_branch_vars for var 31
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 31
DEBUG CAREFUL: Testing fvar[15] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 34
DEBUG CAREFUL: Testing fvar[16] = var 33
DEBUG CAREFUL: Calling compare_branch_vars for var 33
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 33
  % Initial guess is x20, Z0 = 26907410.4214678        , Z1 = 29250638.9175699        

DEBUG EVAL: Testing var 29 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=8, varin=50, theta=0.100058, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 29 = 0 gives z=26910916.108507
  % 	x29 = 0,	Z0 = 26910916.1085074        
DEBUG EVAL: First branch cutoff check: z=26910916.108507, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 29 = 1
ITER 1: row=8, varin=32, theta=1.041486, up=999999999999999983222784.000000
ITER 2: row=47, varin=49, theta=0.975526, up=999999999999999983222784.000000
  % 	x29 = 1,	Z1 = 26947433.4905914        
DEBUG EVAL: Second branch cutoff check: z=26947433.490591, best_z=INF, threshold=INF
  %   New best:  x29, Z = 26910916.1085074        
DEBUG EVAL: Testing var 30 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=21, varin=32, theta=1.041486, up=999999999999999983222784.000000
ITER 2: row=47, varin=49, theta=0.975526, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 30 = 1 gives z=26947433.490591
  % 	x30 = 1,	Z1 = 27028194.6713256        
DEBUG EVAL: First branch cutoff check: z=27028194.671326, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 30 = 0
ITER 1: row=21, varin=50, theta=0.100058, up=999999999999999983222784.000000
  % 	x30 = 0,	Z0 = 26910916.1085076        
DEBUG EVAL: Second branch cutoff check: z=26910916.108508, best_z=INF, threshold=INF
  %   New best:  x30, Z = 26910916.1085076        
DEBUG EVAL: Testing var 32 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=28, varin=50, theta=0.100058, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 32 = 0 gives z=26910916.108507
  % 	x32 = 0,	Z0 = 26910916.1085074        
DEBUG EVAL: First branch cutoff check: z=26910916.108507, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 32 = 1
ITER 1: row=28, varin=38, theta=1.437900, up=999999999999999983222784.000000
ITER 2: row=22, varin=31, theta=0.514281, up=999999999999999983222784.000000
ITER 3: row=25, varin=49, theta=0.820333, up=999999999999999983222784.000000
ITER 4: row=36, varin=36, theta=0.174436, up=999999999999999983222784.000000
ITER 5: row=2, varin=108, theta=0.294126, up=1.000000
  % 	x32 = 1,	Z1 = 27194794.6541701        
DEBUG EVAL: Second branch cutoff check: z=27194794.654170, best_z=INF, threshold=INF
  %   New best:  x32, Z = 26910916.1085074        
DEBUG EVAL: Testing var 0 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=50, theta=0.100058, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 0 = 0 gives z=26910916.108507
  % 	x0 = 0,	Z0 = 26910916.1085074        
DEBUG EVAL: First branch cutoff check: z=26910916.108507, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 0 = 1
ITER 1: row=1, varin=38, theta=1.437900, up=999999999999999983222784.000000
ITER 2: row=22, varin=69, theta=1.815566, up=1.000000
ITER 3: row=22, varin=3, theta=0.390115, up=999999999999999983222784.000000
ITER 4: row=25, varin=69, theta=1.612806, up=1.000000
ITER 5: row=25, varin=36, theta=0.485765, up=999999999999999983222784.000000
ITER 6: row=44, varin=41, theta=0.615344, up=999999999999999983222784.000000
ITER 7: row=46, varin=49, theta=1.483361, up=999999999999999983222784.000000
ITER 8: row=1, varin=37, theta=0.171950, up=999999999999999983222784.000000
ITER 9: row=6, varin=35, theta=0.258276, up=999999999999999983222784.000000
ITER 10: row=10, varin=30, theta=2.154381, up=999999999999999983222784.000000
  % 	x0 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: Second branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=50, theta=0.100058, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 26910916.108507
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 50 rows, 60 cols, 268 nonzeros, 1 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 10 at  26.91091610850741844274
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ff1997a3c0
% @LO 0.04  26.90741042146777672883 99.9000000000
% @LN 0.04  26.91091610850741844274 99.9000000000
% Resuming node 10 at  26.91091610850741844274
DEBUG CONSTRNT: LP rows=49, pool->nlprows=49, pool->npend=0
DEBUG CONSTRNT: Checking 49 LP rows (pool tracks 49, total LP rows 49)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 70
DEBUG CONSTRNT: Pool row 70 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=48, expected 48
 % @PAP adding 49 rows, 206 nz to LP
DEBUG BB: Processing node 10, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 10 LP 5 Solution, length = 26910916.108507, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.100058 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.100058 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.100058 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.100058 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.800465 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.100058 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.800465 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 1.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.100058 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.100058 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.899942 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.899942 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.199535 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.899942 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.899942 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.899942 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.199535 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.199535 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.899942 (terminal 19)
 % 9 fractional variables
DEBUG CG: LP optimal, z=26910916.108507, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=26910916.108507, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 10 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 10
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.100058
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.100058)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.100058
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.100058)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.100058
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.100058)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.100058
DEBUG CAREFUL: Adding var 20 to fractional list (xi=0.100058)
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.800465
DEBUG CAREFUL: Adding var 21 to fractional list (xi=0.800465)
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.100058
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.100058)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.800465
DEBUG CAREFUL: Adding var 25 to fractional list (xi=0.800465)
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=1.000000
DEBUG CAREFUL: Skipping var 27: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.100058
DEBUG CAREFUL: Adding var 31 to fractional list (xi=0.100058)
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.100058
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.100058)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 9 fractional variables

  %  Carefully choosing branching variable, nfrac = 9
DEBUG CAREFUL: Testing fvar[0] = var 25
DEBUG CAREFUL: Calling compare_branch_vars for var 25
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 25
DEBUG CAREFUL: New best var: 25
DEBUG CAREFUL: Testing fvar[1] = var 21
DEBUG CAREFUL: Calling compare_branch_vars for var 21
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 21
DEBUG CAREFUL: Testing fvar[2] = var 20
DEBUG CAREFUL: Calling compare_branch_vars for var 20
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 20
DEBUG CAREFUL: New best var: 20
DEBUG CAREFUL: Testing fvar[3] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[4] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[5] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 22
DEBUG CAREFUL: Testing fvar[6] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[7] = var 31
DEBUG CAREFUL: Calling compare_branch_vars for var 31
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 31
DEBUG CAREFUL: Testing fvar[8] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 34
  % Initial guess is x20, Z0 = 26910916.1085074        , Z1 = 29250638.9175699        

DEBUG EVAL: Testing var 25 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=20, varin=68, theta=0.458333, up=1.000000
ITER 2: row=21, varin=36, theta=0.044104, up=999999999999999983222784.000000
ITER 3: row=44, varin=41, theta=0.049230, up=999999999999999983222784.000000
ITER 4: row=46, varin=30, theta=0.289353, up=999999999999999983222784.000000
ITER 5: row=30, varin=37, theta=0.065949, up=999999999999999983222784.000000
ITER 6: row=1, varin=44, theta=0.078112, up=999999999999999983222784.000000
ITER 7: row=5, varin=8, theta=0.268209, up=999999999999999983222784.000000
ITER 8: row=9, varin=10, theta=0.140023, up=999999999999999983222784.000000
ITER 9: row=10, varin=3, theta=0.323906, up=999999999999999983222784.000000
ITER 10: row=3, varin=6, theta=0.266400, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 25 = 1 gives z=27179526.708653
  % 	x25 = 1,	Z1 = 27179526.7086534        
DEBUG EVAL: First branch cutoff check: z=27179526.708653, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 25 = 0
ITER 1: row=20, varin=32, theta=3.449403, up=999999999999999983222784.000000
ITER 2: row=47, varin=49, theta=1.514200, up=999999999999999983222784.000000
ITER 3: row=8, varin=47, theta=0.916536, up=999999999999999983222784.000000
ITER 4: row=49, varin=42, theta=0.642990, up=999999999999999983222784.000000
ITER 5: row=21, varin=11, theta=0.341257, up=999999999999999983222784.000000
ITER 6: row=37, varin=38, theta=0.584855, up=999999999999999983222784.000000
  % 	x25 = 0,	Z0 = 27023126.8759854        
DEBUG EVAL: Second branch cutoff check: z=27023126.875985, best_z=INF, threshold=INF
  %   New best:  x25, Z = 27023126.8759854        
DEBUG EVAL: Testing var 21 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=17, varin=68, theta=0.458333, up=1.000000
ITER 2: row=21, varin=36, theta=0.044104, up=999999999999999983222784.000000
ITER 3: row=44, varin=41, theta=0.049230, up=999999999999999983222784.000000
ITER 4: row=46, varin=30, theta=0.289353, up=999999999999999983222784.000000
ITER 5: row=30, varin=37, theta=0.065949, up=999999999999999983222784.000000
ITER 6: row=1, varin=44, theta=0.078112, up=999999999999999983222784.000000
ITER 7: row=5, varin=8, theta=0.268209, up=999999999999999983222784.000000
ITER 8: row=9, varin=10, theta=0.140023, up=999999999999999983222784.000000
ITER 9: row=10, varin=3, theta=0.323906, up=999999999999999983222784.000000
ITER 10: row=3, varin=23, theta=0.364877, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 21 = 1 gives z=27032707.407598
  % 	x21 = 1,	Z1 = 27032707.4075977        
DEBUG EVAL: First branch cutoff check: z=27032707.407598, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 21 = 0
ITER 1: row=17, varin=32, theta=3.449403, up=999999999999999983222784.000000
ITER 2: row=47, varin=49, theta=1.514200, up=999999999999999983222784.000000
ITER 3: row=8, varin=47, theta=0.916536, up=999999999999999983222784.000000
ITER 4: row=49, varin=42, theta=0.642990, up=999999999999999983222784.000000
ITER 5: row=21, varin=11, theta=0.341257, up=999999999999999983222784.000000
ITER 6: row=37, varin=38, theta=0.584855, up=999999999999999983222784.000000
  % 	x21 = 0,	Z0 = 27023126.8759854        
DEBUG EVAL: Second branch cutoff check: z=27023126.875985, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 20 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=11, varin=49, theta=10.235043, up=999999999999999983222784.000000
ITER 2: row=49, varin=42, theta=12.472209, up=999999999999999983222784.000000
ITER 3: row=21, varin=43, theta=2.109478, up=999999999999999983222784.000000
ITER 4: row=17, varin=81, theta=5.436527, up=1.000000
ITER 5: row=17, varin=30, theta=4.896775, up=999999999999999983222784.000000
ITER 6: row=18, varin=10, theta=1.741700, up=999999999999999983222784.000000
ITER 7: row=49, varin=81, theta=0.780721, up=1.000000
ITER 8: row=38, varin=3, theta=2.293693, up=999999999999999983222784.000000
ITER 9: row=3, varin=8, theta=3.160605, up=999999999999999983222784.000000
ITER 10: row=9, varin=83, theta=16.076225, up=1.000000
DEBUG EVAL: Branch var 20 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x20 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=11, varin=68, theta=0.312115, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 26915988.855463
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 49 rows, 60 cols, 266 nonzeros, 0 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 8 rows, 42 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=32, theta=0.649697, up=999999999999999983222784.000000
ITER 2: row=47, varin=36, theta=0.158308, up=999999999999999983222784.000000
ITER 3: row=55, varin=41, theta=0.072139, up=999999999999999983222784.000000
ITER 4: row=57, varin=55, theta=4.884032, up=999999999999999983222784.000000
ITER 5: row=51, varin=35, theta=0.016315, up=999999999999999983222784.000000
ITER 6: row=5, varin=51, theta=0.668606, up=999999999999999983222784.000000
ITER 7: row=52, varin=49, theta=1.514200, up=999999999999999983222784.000000
ITER 8: row=8, varin=11, theta=0.034658, up=999999999999999983222784.000000
ITER 9: row=46, varin=52, theta=0.146384, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=9)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 26978411.115427
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.853616
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 57 rows, 60 cols, 308 nonzeros, 5 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 5 slack rows
   % @PAP adding 2 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=53, varin=84, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 26995675.481179
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
   % @PL 54 rows, 60 cols, 301 nonzeros, 0 slack, 54 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 10 at  26.99567548117894233428
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ff19980d00
% @LO 0.04  26.91091610850741844274 99.9000000000
% @LN 0.04  26.96838068549956091147 99.9000000000
% Resuming node 21 at  26.96838068549956091147
DEBUG CONSTRNT: LP rows=54, pool->nlprows=54, pool->npend=0
DEBUG CONSTRNT: Checking 54 LP rows (pool tracks 54, total LP rows 54)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 70
DEBUG CONSTRNT: Pool row 70 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=53, expected 53
 % @PAP adding 42 rows, 195 nz to LP
DEBUG BB: Processing node 21, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=20, varin=27, theta=0.479409, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
ITER 2: row=14, varin=22, theta=0.719790, up=999999999999999983222784.000000
ITER 3: row=4, varin=41, theta=0.000000, up=999999999999999983222784.000000
ITER 4: row=17, varin=38, theta=0.000000, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 26917705.393481
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 500000.000000
  % @PL 42 rows, 60 cols, 255 nonzeros, 2 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 16 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=21, theta=0.889648, up=999999999999999983222784.000000
ITER 2: row=38, varin=70, theta=0.783007, up=1.000000
ITER 3: row=37, varin=49, theta=0.165090, up=1.000000
ITER 4: row=41, varin=56, theta=0.057551, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 26948122.007566
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 500000.000000
  % @PL 44 rows, 60 cols, 271 nonzeros, 4 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 21 LP 1 Solution, length = 26948122.007566, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.057551 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.057551 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.057551 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.057551 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.057551 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.287753 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.057551 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.287753 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.287753 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.942449 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.712247 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.712247 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.712247 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.942449 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.942449 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.942449 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.712247 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.942449 (terminal 19)
 % 9 fractional variables
DEBUG CG: LP optimal, z=26948122.007566, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=26948122.007566, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 21 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 21
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.057551
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.057551)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.057551
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.057551)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.057551
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.057551)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.057551
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.057551)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.057551
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.057551)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.287753
DEBUG CAREFUL: Adding var 25 to fractional list (xi=0.287753)
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.057551
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.057551)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.287753
DEBUG CAREFUL: Adding var 28 to fractional list (xi=0.287753)
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.287753
DEBUG CAREFUL: Adding var 35 to fractional list (xi=0.287753)
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 9 fractional variables

  %  Carefully choosing branching variable, nfrac = 9
DEBUG CAREFUL: Testing fvar[0] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 26
DEBUG CAREFUL: New best var: 26
DEBUG CAREFUL: Testing fvar[1] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 10
DEBUG CAREFUL: New best var: 10
DEBUG CAREFUL: Testing fvar[2] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 22
DEBUG CAREFUL: Testing fvar[3] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[4] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 4
DEBUG CAREFUL: New best var: 4
DEBUG CAREFUL: Testing fvar[5] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 11
DEBUG CAREFUL: Testing fvar[6] = var 25
DEBUG CAREFUL: Calling compare_branch_vars for var 25
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 25
DEBUG CAREFUL: New best var: 25
DEBUG CAREFUL: Testing fvar[7] = var 28
DEBUG CAREFUL: Calling compare_branch_vars for var 28
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 28
DEBUG CAREFUL: Testing fvar[8] = var 35
DEBUG CAREFUL: Calling compare_branch_vars for var 35
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 35
  % Initial guess is x25, Z0 = 26963559.7053485        , Z1 = 27208832.3358741        

DEBUG EVAL: Testing var 26 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=28, varin=29, theta=0.061752, up=999999999999999983222784.000000
ITER 2: row=10, varin=28, theta=0.072582, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 0 gives z=26969418.156404
  % 	x26 = 0,	Z0 = 26969418.1564044        
DEBUG EVAL: First branch cutoff check: z=26969418.156404, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 1
ITER 1: row=28, varin=42, theta=1.738285, up=999999999999999983222784.000000
ITER 2: row=44, varin=43, theta=0.402859, up=999999999999999983222784.000000
ITER 3: row=32, varin=39, theta=0.510876, up=999999999999999983222784.000000
ITER 4: row=30, varin=28, theta=4.000000, up=999999999999999983222784.000000
ITER 5: row=12, varin=41, theta=0.750000, up=999999999999999983222784.000000
ITER 6: row=11, varin=55, theta=1.000000, up=1.000000
ITER 7: row=3, varin=91, theta=0.533455, up=1.000000
ITER 8: row=4, varin=34, theta=0.672050, up=999999999999999983222784.000000
ITER 9: row=34, varin=40, theta=0.275034, up=999999999999999983222784.000000
ITER 10: row=14, varin=4, theta=0.471801, up=999999999999999983222784.000000
  % 	x26 = 1,	Z1 = 27534891.8252199        
DEBUG EVAL: Second branch cutoff check: z=27534891.825220, best_z=INF, threshold=INF
  %   New best:  x26, Z = 26969418.1564044        
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=12, varin=42, theta=1.738285, up=999999999999999983222784.000000
ITER 2: row=44, varin=43, theta=0.402859, up=999999999999999983222784.000000
ITER 3: row=32, varin=39, theta=0.510876, up=999999999999999983222784.000000
ITER 4: row=30, varin=41, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=16, varin=91, theta=0.533455, up=1.000000
ITER 6: row=4, varin=34, theta=0.672050, up=999999999999999983222784.000000
ITER 7: row=34, varin=40, theta=0.275034, up=999999999999999983222784.000000
ITER 8: row=14, varin=4, theta=0.471801, up=999999999999999983222784.000000
ITER 9: row=41, varin=25, theta=1.587394, up=999999999999999983222784.000000
ITER 10: row=40, varin=31, theta=0.615596, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=27591451.621805
  % 	x10 = 1,	Z1 = 27591451.621805         
DEBUG EVAL: First branch cutoff check: z=27591451.621805, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=12, varin=28, theta=0.066847, up=999999999999999983222784.000000
ITER 2: row=11, varin=29, theta=0.072582, up=999999999999999983222784.000000
  % 	x10 = 0,	Z0 = 26969418.1564044        
DEBUG EVAL: Second branch cutoff check: z=26969418.156404, best_z=INF, threshold=INF
  %   New best:  x10, Z = 26969418.1564044        
DEBUG EVAL: Testing var 22 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=5, varin=40, theta=1.177209, up=999999999999999983222784.000000
ITER 2: row=29, varin=41, theta=0.406967, up=999999999999999983222784.000000
ITER 3: row=4, varin=38, theta=1.026636, up=999999999999999983222784.000000
ITER 4: row=38, varin=37, theta=7.720840, up=999999999999999983222784.000000
ITER 5: row=44, varin=43, theta=0.789159, up=999999999999999983222784.000000
ITER 6: row=32, varin=42, theta=0.349268, up=999999999999999983222784.000000
ITER 7: row=14, varin=34, theta=0.856322, up=999999999999999983222784.000000
ITER 8: row=34, varin=4, theta=0.602591, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 22 = 1 gives z=27199942.471869
  % 	x22 = 1,	Z1 = 27199942.4718687        
DEBUG EVAL: First branch cutoff check: z=27199942.471869, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 22 = 0
ITER 1: row=5, varin=5, theta=0.064687, up=999999999999999983222784.000000
  % 	x22 = 0,	Z0 = 26957138.620257         
DEBUG EVAL: Second branch cutoff check: z=26957138.620257, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 3 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=42, theta=0.125704, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 0 gives z=26958307.597136
  % 	x3 = 0,	Z0 = 26958307.5971361        
DEBUG EVAL: First branch cutoff check: z=26958307.597136, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 4 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=4, varin=42, theta=1.738285, up=999999999999999983222784.000000
ITER 2: row=44, varin=43, theta=0.402859, up=999999999999999983222784.000000
ITER 3: row=32, varin=39, theta=0.510876, up=999999999999999983222784.000000
ITER 4: row=30, varin=28, theta=4.000000, up=999999999999999983222784.000000
ITER 5: row=12, varin=40, theta=0.750000, up=999999999999999983222784.000000
ITER 6: row=14, varin=34, theta=2.000000, up=999999999999999983222784.000000
ITER 7: row=34, varin=38, theta=1.500000, up=999999999999999983222784.000000
ITER 8: row=38, varin=4, theta=1.500000, up=999999999999999983222784.000000
ITER 9: row=1, varin=44, theta=18.000000, up=999999999999999983222784.000000
ITER 10: row=3, varin=31, theta=1.656794, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 4 = 1 gives z=28071465.056454
  % 	x4 = 1,	Z1 = 28435876.2269263        
DEBUG EVAL: First branch cutoff check: z=28435876.226926, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 4 = 0
ITER 1: row=4, varin=41, theta=0.088350, up=999999999999999983222784.000000
  % 	x4 = 0,	Z0 = 26957442.3543005        
DEBUG EVAL: Second branch cutoff check: z=26957442.354300, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 11 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=14, varin=41, theta=2.703507, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 11 = 1 gives z=27233325.827106
  % 	x11 = 1,	Z1 = 27879833.5763612        
DEBUG EVAL: First branch cutoff check: z=27879833.576361, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 11 = 0
ITER 1: row=14, varin=42, theta=0.125704, up=999999999999999983222784.000000
  % 	x11 = 0,	Z0 = 26958307.5971361        
DEBUG EVAL: Second branch cutoff check: z=26958307.597136, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 25 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=17, varin=37, theta=1.819778, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 25 = 0 gives z=26961274.829558
  % 	x25 = 0,	Z0 = 26963559.7053485        
DEBUG EVAL: First branch cutoff check: z=26963559.705349, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 28 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=15, varin=37, theta=1.819778, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 28 = 0 gives z=26961274.829558
  % 	x28 = 0,	Z0 = 26961274.8295579        
DEBUG EVAL: First branch cutoff check: z=26961274.829558, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 35 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=31, varin=37, theta=1.819778, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 35 = 0 gives z=26961274.829558
  % 	x35 = 0,	Z0 = 26961274.8295579        
DEBUG EVAL: First branch cutoff check: z=26961274.829558, best_z=INF, threshold=INF
  % Best branch is x10, Z0 = 26969418.1564044        , Z1 = 27591451.621805         

DEBUG CAREFUL: Final result - returning best.var = 10
DEBUG BB: Branching variable chosen: j=10
 % @NC   23   21	x10 = 0	26969418.156404
 % @NC   24   21	x10 = 1	27591451.621805
 %      21    10 26948122.0076               26969418.1564   x34 D    19    11
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ff1998f740
% @LO 0.04  26.96838068549956091147 99.9000000000
% @LN 0.04  26.96941815640437312140 99.9000000000
% Resuming node 23 at  26.96941815640437312140
DEBUG CONSTRNT: LP rows=44, pool->nlprows=44, pool->npend=0
DEBUG CONSTRNT: Checking 44 LP rows (pool tracks 44, total LP rows 44)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 70
DEBUG CONSTRNT: Pool row 70 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 134
DEBUG CONSTRNT: Pool row 134 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 72
DEBUG CONSTRNT: Pool row 72 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 73
DEBUG CONSTRNT: Pool row 73 has lprow=43, expected 43
 % @PAP adding 44 rows, 211 nz to LP
DEBUG BB: Processing node 23, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=12, varin=28, theta=0.066847, up=999999999999999983222784.000000
ITER 2: row=11, varin=29, theta=0.072582, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 26969418.156404
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 500000.000000
  % @PL 44 rows, 60 cols, 271 nonzeros, 6 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % Node 23 LP 1 Solution, length = 26969418.156404, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.072582 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.072582 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.072582 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.072582 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.290327 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.290327 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.290327 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.927418 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.709673 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.709673 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.709673 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.927418 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.709673 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.927418 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=26969418.156404, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.04  26.96941815640437312140 99.9000000000
 % @LN 0.04  26.96941815640441220125 99.9000000000
DEBUG CG: Second cutoff check: z=26969418.156404, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 23 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 23
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.072582
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.072582)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.072582
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.072582)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.072582
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.072582)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.072582
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.072582)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.290327
DEBUG CAREFUL: Adding var 25 to fractional list (xi=0.290327)
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.290327
DEBUG CAREFUL: Adding var 28 to fractional list (xi=0.290327)
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.290327
DEBUG CAREFUL: Adding var 35 to fractional list (xi=0.290327)
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 7 fractional variables

  %  Carefully choosing branching variable, nfrac = 7
DEBUG CAREFUL: Testing fvar[0] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 22
DEBUG CAREFUL: New best var: 22
DEBUG CAREFUL: Testing fvar[1] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[2] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 4
DEBUG CAREFUL: New best var: 4
DEBUG CAREFUL: Testing fvar[3] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 11
DEBUG CAREFUL: Testing fvar[4] = var 25
DEBUG CAREFUL: Calling compare_branch_vars for var 25
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 25
DEBUG CAREFUL: Testing fvar[5] = var 28
DEBUG CAREFUL: Calling compare_branch_vars for var 28
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 28
DEBUG CAREFUL: Testing fvar[6] = var 35
DEBUG CAREFUL: Calling compare_branch_vars for var 35
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 35
  % Initial guess is x4, Z0 = 26969418.1564044        , Z1 = 28435876.2269263        

DEBUG EVAL: Testing var 22 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=5, varin=35, theta=1.239043, up=999999999999999983222784.000000
ITER 2: row=38, varin=33, theta=1.026636, up=999999999999999983222784.000000
ITER 3: row=33, varin=36, theta=0.406967, up=999999999999999983222784.000000
ITER 4: row=4, varin=32, theta=7.720840, up=999999999999999983222784.000000
ITER 5: row=6, varin=37, theta=0.199474, up=999999999999999983222784.000000
ITER 6: row=17, varin=38, theta=0.855108, up=999999999999999983222784.000000
ITER 7: row=15, varin=68, theta=0.698535, up=1.000000
ITER 8: row=14, varin=29, theta=0.856322, up=999999999999999983222784.000000
ITER 9: row=29, varin=4, theta=0.602591, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 22 = 1 gives z=27199942.471869
  % 	x22 = 1,	Z1 = 27199942.4718687        
DEBUG EVAL: First branch cutoff check: z=27199942.471869, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 22 = 0
ITER 1: row=5, varin=5, theta=0.084313, up=999999999999999983222784.000000
  % 	x22 = 0,	Z0 = 26984612.4351172        
DEBUG EVAL: Second branch cutoff check: z=26984612.435117, best_z=INF, threshold=INF
  %   New best:  x22, Z = 26984612.4351172        
DEBUG EVAL: Testing var 3 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=76, theta=0.334714, up=1.000000
DEBUG EVAL: Branch var 3 = 0 gives z=27026619.238047
  % 	x3 = 0,	Z0 = 27026619.2380472        
DEBUG EVAL: First branch cutoff check: z=27026619.238047, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 1
ITER 1: row=1, varin=35, theta=1.239043, up=999999999999999983222784.000000
ITER 2: row=38, varin=33, theta=1.026636, up=999999999999999983222784.000000
ITER 3: row=33, varin=36, theta=0.406967, up=999999999999999983222784.000000
ITER 4: row=4, varin=32, theta=7.720840, up=999999999999999983222784.000000
ITER 5: row=6, varin=37, theta=0.199474, up=999999999999999983222784.000000
ITER 6: row=17, varin=38, theta=0.855108, up=999999999999999983222784.000000
ITER 7: row=15, varin=68, theta=0.698535, up=1.000000
ITER 8: row=14, varin=29, theta=0.856322, up=999999999999999983222784.000000
ITER 9: row=29, varin=64, theta=10.591342, up=1.000000
ITER 10: row=29, varin=34, theta=0.814611, up=999999999999999983222784.000000
  % 	x3 = 1,	Z1 = 27454735.5677624        
DEBUG EVAL: Second branch cutoff check: z=27454735.567762, best_z=INF, threshold=INF
  %   New best:  x3, Z = 27026619.2380472        
DEBUG EVAL: Testing var 4 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=4, varin=37, theta=1.356320, up=999999999999999983222784.000000
ITER 2: row=26, varin=33, theta=1.397989, up=999999999999999983222784.000000
ITER 3: row=33, varin=32, theta=10.513611, up=999999999999999983222784.000000
ITER 4: row=6, varin=35, theta=0.349194, up=999999999999999983222784.000000
ITER 5: row=19, varin=38, theta=1.496931, up=999999999999999983222784.000000
ITER 6: row=15, varin=68, theta=1.222839, up=1.000000
ITER 7: row=15, varin=70, theta=0.657204, up=1.000000
ITER 8: row=14, varin=34, theta=0.723602, up=999999999999999983222784.000000
ITER 9: row=15, varin=29, theta=1.000000, up=999999999999999983222784.000000
ITER 10: row=29, varin=4, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 4 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x4 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=4, varin=35, theta=0.288590, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 26973626.944136
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 500000.000000
   % @PL 38 rows, 60 cols, 238 nonzeros, 1 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 23 at  26.97362694413608963373
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ff1998f740
% @LO 0.04  26.96941815640441220125 99.9000000000
% @LN 0.04  26.97362694413608963373 99.9000000000
% Resuming node 23 at  26.97362694413608963373
DEBUG CONSTRNT: LP rows=37, pool->nlprows=37, pool->npend=0
DEBUG CONSTRNT: Checking 37 LP rows (pool tracks 37, total LP rows 37)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 70
DEBUG CONSTRNT: Pool row 70 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 134
DEBUG CONSTRNT: Pool row 134 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 72
DEBUG CONSTRNT: Pool row 72 has lprow=36, expected 36
 % @PAP adding 37 rows, 176 nz to LP
DEBUG BB: Processing node 23, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 23 LP 2 Solution, length = 26973626.944136, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.288590 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.288590 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.288590 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.288590 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.288590 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.711410 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.711410 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.711410 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.711410 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.711410 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.711410 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=26973626.944136, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=26973626.944136, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 23 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 23
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.288590
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.288590)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.288590
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.288590)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.288590
DEBUG CAREFUL: Adding var 25 to fractional list (xi=0.288590)
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.288590
DEBUG CAREFUL: Adding var 28 to fractional list (xi=0.288590)
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.288590
DEBUG CAREFUL: Adding var 35 to fractional list (xi=0.288590)
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 22
DEBUG CAREFUL: New best var: 22
DEBUG CAREFUL: Testing fvar[1] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[2] = var 25
DEBUG CAREFUL: Calling compare_branch_vars for var 25
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 25
DEBUG CAREFUL: Testing fvar[3] = var 28
DEBUG CAREFUL: Calling compare_branch_vars for var 28
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 28
DEBUG CAREFUL: Testing fvar[4] = var 35
DEBUG CAREFUL: Calling compare_branch_vars for var 35
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 35
  % Initial guess is x3, Z0 = 27026619.2380472        , Z1 = 27454735.5677624        

DEBUG EVAL: Testing var 22 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=4, varin=25, theta=1.358286, up=999999999999999983222784.000000
ITER 2: row=22, varin=35, theta=0.061990, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 22 = 0 gives z=27001877.911153
  % 	x22 = 0,	Z0 = 27001877.9111525        
DEBUG EVAL: First branch cutoff check: z=27001877.911153, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 3 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=25, theta=1.358286, up=999999999999999983222784.000000
ITER 2: row=22, varin=35, theta=0.061990, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 0 gives z=27001877.911153
  % 	x3 = 0,	Z0 = 27026619.2380472        
DEBUG EVAL: First branch cutoff check: z=27026619.238047, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 1
ITER 1: row=1, varin=32, theta=7.720840, up=999999999999999983222784.000000
ITER 2: row=24, varin=33, theta=1.056899, up=999999999999999983222784.000000
ITER 3: row=33, varin=36, theta=0.349268, up=999999999999999983222784.000000
ITER 4: row=36, varin=29, theta=0.856322, up=999999999999999983222784.000000
ITER 5: row=29, varin=37, theta=10.591342, up=999999999999999983222784.000000
ITER 6: row=1, varin=34, theta=0.814611, up=999999999999999983222784.000000
ITER 7: row=3, varin=5, theta=2.038619, up=999999999999999983222784.000000
ITER 8: row=5, varin=27, theta=0.702392, up=999999999999999983222784.000000
ITER 9: row=15, varin=11, theta=1.225944, up=999999999999999983222784.000000
ITER 10: row=11, varin=23, theta=0.646261, up=999999999999999983222784.000000
  % 	x3 = 1,	Z1 = 27454735.5677624        
DEBUG EVAL: Second branch cutoff check: z=27454735.567762, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 25 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=5, varin=37, theta=1.774372, up=999999999999999983222784.000000
ITER 2: row=24, varin=34, theta=0.814611, up=999999999999999983222784.000000
ITER 3: row=3, varin=84, theta=0.507551, up=1.000000
DEBUG EVAL: Branch var 25 = 1 gives z=27277248.494342
  % 	x25 = 1,	Z1 = 27277248.4943418        
DEBUG EVAL: First branch cutoff check: z=27277248.494342, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 25 = 0
ITER 1: row=5, varin=25, theta=1.358286, up=999999999999999983222784.000000
ITER 2: row=22, varin=32, theta=0.482228, up=999999999999999983222784.000000
  % 	x25 = 0,	Z0 = 26996768.2482615        
DEBUG EVAL: Second branch cutoff check: z=26996768.248261, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 28 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=14, varin=25, theta=1.358286, up=999999999999999983222784.000000
ITER 2: row=22, varin=32, theta=0.482228, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 28 = 0 gives z=26996768.248261
  % 	x28 = 0,	Z0 = 26996768.2482614        
DEBUG EVAL: First branch cutoff check: z=26996768.248261, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 35 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=15, varin=25, theta=1.358286, up=999999999999999983222784.000000
ITER 2: row=22, varin=32, theta=0.482228, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 35 = 0 gives z=26996768.248261
  % 	x35 = 0,	Z0 = 26996768.2482615        
DEBUG EVAL: First branch cutoff check: z=26996768.248261, best_z=INF, threshold=INF
  % 5 consecutive failures: giving up.
  % Best branch is x3, Z0 = 27026619.2380472        , Z1 = 27454735.5677624        

DEBUG CAREFUL: Final result - returning best.var = 3
DEBUG BB: Branching variable chosen: j=3
 % @NC   25   23	x3 = 0	27026619.238047
 % @NC   26   23	x3 = 1	27454735.567762
 %      23    11 26973626.9441               26992604.3364   x10 D    21    12
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ff19984250
% @LO 0.04  26.97362694413608963373 99.9000000000
% @LN 0.04  26.99260433643284429195 99.9000000000
% Resuming node 11 at  26.99260433643284429195
DEBUG CONSTRNT: LP rows=37, pool->nlprows=37, pool->npend=0
DEBUG CONSTRNT: Checking 37 LP rows (pool tracks 37, total LP rows 37)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 70
DEBUG CONSTRNT: Pool row 70 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 134
DEBUG CONSTRNT: Pool row 134 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 72
DEBUG CONSTRNT: Pool row 72 has lprow=36, expected 36
 % @PAP adding 58 rows, 220 nz to LP
DEBUG BB: Processing node 11, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 11 LP 7 Solution, length = 26992604.336433, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.071429 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.071429 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.071429 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.071429 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.071429 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.071429 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.071429 (FST 20)
  % DEBUG LP_VARS: x[21] = 1.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.573737 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.071429 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.071429 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.071429 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.071429 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.071429 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.928571 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.928571 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.928571 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.426263 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.928571 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.928571 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.928571 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.928571 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.928571 (terminal 19)
 % 13 fractional variables
DEBUG CG: LP optimal, z=26992604.336433, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=26992604.336433, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 11 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 11
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.071429
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.071429)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.071429
DEBUG CAREFUL: Adding var 8 to fractional list (xi=0.071429)
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.071429
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.071429)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.071429
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.071429)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.071429
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.071429)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.071429
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.071429)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.071429
DEBUG CAREFUL: Adding var 20 to fractional list (xi=0.071429)
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=1.000000
DEBUG CAREFUL: Skipping var 21: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.573737
DEBUG CAREFUL: Adding var 25 to fractional list (xi=0.573737)
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.071429
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.071429)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.071429
DEBUG CAREFUL: Adding var 31 to fractional list (xi=0.071429)
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.071429
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.071429)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.071429
DEBUG CAREFUL: Adding var 37 to fractional list (xi=0.071429)
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.071429
DEBUG CAREFUL: Adding var 39 to fractional list (xi=0.071429)
DEBUG CAREFUL: Found 13 fractional variables

  %  Carefully choosing branching variable, nfrac = 13
DEBUG CAREFUL: Testing fvar[0] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 26
DEBUG CAREFUL: New best var: 26
DEBUG CAREFUL: Testing fvar[1] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[2] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[3] = var 20
DEBUG CAREFUL: Calling compare_branch_vars for var 20
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 20
DEBUG CAREFUL: New best var: 20
DEBUG CAREFUL: Testing fvar[4] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 11
DEBUG CAREFUL: Testing fvar[5] = var 8
DEBUG CAREFUL: Calling compare_branch_vars for var 8
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 8
DEBUG CAREFUL: Testing fvar[6] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 34
DEBUG CAREFUL: Testing fvar[7] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
DEBUG CAREFUL: Testing fvar[8] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 4
DEBUG CAREFUL: Testing fvar[9] = var 31
DEBUG CAREFUL: Calling compare_branch_vars for var 31
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 31
DEBUG CAREFUL: Testing fvar[10] = var 37
DEBUG CAREFUL: Calling compare_branch_vars for var 37
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 37
DEBUG CAREFUL: Testing fvar[11] = var 39
DEBUG CAREFUL: Calling compare_branch_vars for var 39
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 39
DEBUG CAREFUL: Testing fvar[12] = var 25
DEBUG CAREFUL: Calling compare_branch_vars for var 25
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 25
  % Initial guess is x18, Z0 = 26992604.3364328        , Z1 = 29495338.9870639        

DEBUG EVAL: Testing var 26 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=11, varin=15, theta=0.200000, up=999999999999999983222784.000000
ITER 2: row=39, varin=33, theta=0.074074, up=999999999999999983222784.000000
ITER 3: row=9, varin=42, theta=0.142857, up=999999999999999983222784.000000
ITER 4: row=7, varin=29, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=36, varin=97, theta=1.000000, up=1.000000
ITER 6: row=16, varin=25, theta=0.146430, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 0 gives z=27117884.621174
  % 	x26 = 0,	Z0 = 27117884.6211744        
DEBUG EVAL: First branch cutoff check: z=27117884.621174, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 1
ITER 1: row=11, varin=57, theta=13.000000, up=999999999999999983222784.000000
ITER 2: row=16, varin=47, theta=7.970929, up=999999999999999983222784.000000
ITER 3: row=58, varin=31, theta=1.819561, up=999999999999999983222784.000000
ITER 4: row=55, varin=54, theta=4.603768, up=999999999999999983222784.000000
ITER 5: row=47, varin=43, theta=1.360089, up=999999999999999983222784.000000
ITER 6: row=11, varin=58, theta=1.817077, up=999999999999999983222784.000000
ITER 7: row=16, varin=97, theta=2.833548, up=1.000000
ITER 8: row=16, varin=5, theta=0.647988, up=999999999999999983222784.000000
ITER 9: row=24, varin=96, theta=7.645768, up=1.000000
  % 	x26 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: Second branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=11, varin=15, theta=0.200000, up=999999999999999983222784.000000
ITER 2: row=39, varin=33, theta=0.074074, up=999999999999999983222784.000000
ITER 3: row=9, varin=42, theta=0.142857, up=999999999999999983222784.000000
ITER 4: row=7, varin=29, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=36, varin=97, theta=1.000000, up=1.000000
ITER 6: row=16, varin=25, theta=0.146430, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=58)
DEBUG SOLUTION: LP solution array indices: FST[59-98], not_covered[99-118]
DEBUG SOLUTION: lp->best_solution[0] = 27117884.621175
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 500000.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 58 rows, 60 cols, 280 nonzeros, 1 slack, 57 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 8 rows, 39 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=62, varin=91, theta=1.066156, up=1.000000
ITER 2: row=62, varin=6, theta=0.013005, up=999999999999999983222784.000000
ITER 3: row=60, varin=91, theta=0.396302, up=1.000000
ITER 4: row=65, varin=11, theta=0.054348, up=999999999999999983222784.000000
ITER 5: row=31, varin=65, theta=0.142857, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=65)
DEBUG SOLUTION: LP solution array indices: FST[66-105], not_covered[106-125]
DEBUG SOLUTION: lp->best_solution[0] = 27151223.322092
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.928571
DEBUG SOLUTION: lp->best_solution[11] = 1.928571
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 500000.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 65 rows, 60 cols, 317 nonzeros, 7 slack, 58 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 7 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 11 at  27.15122332209177713480
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ff1997a3c0
% @LO 0.04  26.99260433643284429195 99.9000000000
% @LN 0.04  26.99567548117894233428 99.9000000000
% Resuming node 10 at  26.99567548117894233428
DEBUG CONSTRNT: LP rows=58, pool->nlprows=58, pool->npend=0
DEBUG CONSTRNT: Checking 58 LP rows (pool tracks 58, total LP rows 58)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 70
DEBUG CONSTRNT: Pool row 70 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 105
DEBUG CONSTRNT: Pool row 105 has lprow=56, expected 56
DEBUG CONSTRNT: Checking LP row 57 -> pool row 130
DEBUG CONSTRNT: Pool row 130 has lprow=57, expected 57
 % @PAP adding 54 rows, 241 nz to LP
DEBUG BB: Processing node 10, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 10 LP 6 Solution, length = 26995675.481179, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.431067 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.431067 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.431067 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 1.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.431067 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.568933 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.568933 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.568933 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.568933 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.568933 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=26995675.481179, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=26995675.481179, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 10 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 10
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.431067
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.431067)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.431067
DEBUG CAREFUL: Adding var 21 to fractional list (xi=0.431067)
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.431067
DEBUG CAREFUL: Adding var 25 to fractional list (xi=0.431067)
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=1.000000
DEBUG CAREFUL: Skipping var 27: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.431067
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.431067)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 9
DEBUG CAREFUL: New best var: 9
DEBUG CAREFUL: Testing fvar[1] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 34
DEBUG CAREFUL: Testing fvar[2] = var 25
DEBUG CAREFUL: Calling compare_branch_vars for var 25
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 25
DEBUG CAREFUL: New best var: 25
DEBUG CAREFUL: Testing fvar[3] = var 21
DEBUG CAREFUL: Calling compare_branch_vars for var 21
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 21
  % Initial guess is x25, Z0 = 27023126.8759854        , Z1 = 27179526.7086534        

DEBUG EVAL: Testing var 9 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=5, varin=66, theta=0.315701, up=1.000000
ITER 2: row=50, varin=52, theta=0.293215, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 9 = 0 gives z=27035179.960434
  % 	x9 = 0,	Z0 = 27035179.9604339        
DEBUG EVAL: First branch cutoff check: z=27035179.960434, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 1
ITER 1: row=5, varin=53, theta=1.998476, up=999999999999999983222784.000000
ITER 2: row=9, varin=44, theta=0.137269, up=999999999999999983222784.000000
ITER 3: row=48, varin=5, theta=0.484491, up=999999999999999983222784.000000
ITER 4: row=50, varin=47, theta=0.273188, up=999999999999999983222784.000000
ITER 5: row=10, varin=45, theta=1.501907, up=999999999999999983222784.000000
ITER 6: row=45, varin=40, theta=1.060558, up=999999999999999983222784.000000
ITER 7: row=20, varin=35, theta=0.371711, up=999999999999999983222784.000000
ITER 8: row=35, varin=31, theta=1.468974, up=999999999999999983222784.000000
ITER 9: row=31, varin=3, theta=1.032830, up=999999999999999983222784.000000
ITER 10: row=3, varin=13, theta=2.088606, up=999999999999999983222784.000000
  % 	x9 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: Second branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=5, varin=66, theta=0.315701, up=1.000000
ITER 2: row=50, varin=52, theta=0.293215, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 27035179.960435
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
   % @PL 54 rows, 60 cols, 301 nonzeros, 4 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 4 slack rows
   % @PAP adding 5 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=47, theta=0.213302, up=999999999999999983222784.000000
ITER 2: row=52, varin=60, theta=0.455868, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 27064481.897202
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
   % @PL 55 rows, 60 cols, 291 nonzeros, 0 slack, 55 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 6 rows, 33 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=61, varin=45, theta=0.046452, up=999999999999999983222784.000000
ITER 2: row=56, varin=61, theta=0.717186, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=61)
DEBUG SOLUTION: LP solution array indices: FST[62-101], not_covered[102-121]
DEBUG SOLUTION: lp->best_solution[0] = 27095886.908358
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
   % @PL 61 rows, 60 cols, 324 nonzeros, 7 slack, 54 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 7 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 10 at  27.09588690835839486226
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ff19980d00
% @LO 0.04  26.99567548117894233428 99.9000000000
% @LN 0.04  27.02661923804720345288 99.9000000000
% Resuming node 25 at  27.02661923804720345288
DEBUG CONSTRNT: LP rows=54, pool->nlprows=54, pool->npend=0
DEBUG CONSTRNT: Checking 54 LP rows (pool tracks 54, total LP rows 54)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 70
DEBUG CONSTRNT: Pool row 70 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=53, expected 53
 % @PAP adding 37 rows, 176 nz to LP
DEBUG BB: Processing node 25, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=25, theta=1.358286, up=999999999999999983222784.000000
ITER 2: row=22, varin=35, theta=0.061990, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 27001877.911153
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 500000.000000
  % @PL 37 rows, 60 cols, 236 nonzeros, 2 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 10 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=77, theta=0.088290, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 27003334.153662
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 500000.000000
  % @PL 39 rows, 60 cols, 246 nonzeros, 1 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 20 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=83, theta=0.086608, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 27004477.092741
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 500000.000000
  % @PL 43 rows, 60 cols, 266 nonzeros, 1 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 9 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=26, theta=0.009971, up=999999999999999983222784.000000
ITER 2: row=40, varin=84, theta=0.079650, up=1.000000
ITER 3: row=39, varin=43, theta=0.025723, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 27029375.136950
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 500000.000000
  % @PL 45 rows, 60 cols, 275 nonzeros, 5 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=4, theta=0.060340, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 27033658.199640
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.939660
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 500000.000000
  % @PL 42 rows, 60 cols, 261 nonzeros, 2 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=35, theta=0.119774, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 27038242.387401
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 500000.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 41 rows, 60 cols, 254 nonzeros, 1 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 25 LP 1 Solution, length = 27038242.387401, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.029944 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.029944 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.059887 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.059887 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 1.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.059887 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.029944 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.029944 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.970056 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.940113 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.940113 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.940113 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.970056 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.940113 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.970056 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=27038242.387401, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 25 at  27.03824238740117991142
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ff19994590
% @LO 0.04  27.02661923804720345288 99.9000000000
% @LN 0.04  27.02819467132557207378 99.9000000000
% Resuming node 20 at  27.02819467132557207378
DEBUG CONSTRNT: LP rows=40, pool->nlprows=40, pool->npend=0
DEBUG CONSTRNT: Checking 40 LP rows (pool tracks 40, total LP rows 40)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 70
DEBUG CONSTRNT: Pool row 70 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 134
DEBUG CONSTRNT: Pool row 134 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 72
DEBUG CONSTRNT: Pool row 72 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 105
DEBUG CONSTRNT: Pool row 105 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 130
DEBUG CONSTRNT: Pool row 130 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=39, expected 39
 % @PAP adding 41 rows, 188 nz to LP
DEBUG BB: Processing node 20, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=16, varin=39, theta=0.086891, up=999999999999999983222784.000000
ITER 2: row=21, varin=32, theta=0.865425, up=999999999999999983222784.000000
ITER 3: row=22, varin=73, theta=1.937710, up=1.000000
ITER 4: row=22, varin=88, theta=0.384744, up=1.000000
ITER 5: row=5, varin=73, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 27027486.066718
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 41 rows, 60 cols, 248 nonzeros, 0 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=27, theta=2.138729, up=999999999999999983222784.000000
ITER 2: row=17, varin=5, theta=0.553609, up=999999999999999983222784.000000
ITER 3: row=8, varin=25, theta=0.646280, up=999999999999999983222784.000000
ITER 4: row=5, varin=40, theta=0.316868, up=999999999999999983222784.000000
ITER 5: row=40, varin=75, theta=0.230863, up=1.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 27311840.517686
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 43 rows, 60 cols, 254 nonzeros, 2 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=78, theta=1.177455, up=1.000000
ITER 2: row=42, varin=60, theta=0.066420, up=1.000000
ITER 3: row=39, varin=78, theta=1.000000, up=1.000000
ITER 4: row=4, varin=7, theta=0.693699, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 27375793.554161
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.306301
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 42 rows, 60 cols, 250 nonzeros, 1 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 20 LP 1 Solution, length = 27375793.554161, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.306301 (FST 29)
  % DEBUG LP_VARS: x[30] = 1.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.500000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.500000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.693699 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=27375793.554161, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 20 at  27.37579355416137971702
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ff19980d00
% @LO 0.04  27.02819467132557207378 99.9000000000
% @LN 0.04  27.03824238740117991142 99.9000000000
% Resuming node 25 at  27.03824238740117991142
DEBUG CONSTRNT: LP rows=41, pool->nlprows=41, pool->npend=0
DEBUG CONSTRNT: Checking 41 LP rows (pool tracks 41, total LP rows 41)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 70
DEBUG CONSTRNT: Pool row 70 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=40, expected 40
 % @PAP adding 40 rows, 186 nz to LP
DEBUG BB: Processing node 25, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 25 LP 2 Solution, length = 27038242.387401, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.029944 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.029944 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.059887 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.059887 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 1.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.059887 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.029944 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.029944 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.970056 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.940113 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.940113 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.940113 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.970056 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.940113 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.970056 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=27038242.387401, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27038242.387401, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 25 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 25
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=1.000000
DEBUG CAREFUL: Skipping var 2: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.029944
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.029944)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.029944
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.029944)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.059887
DEBUG CAREFUL: Adding var 25 to fractional list (xi=0.059887)
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.059887
DEBUG CAREFUL: Adding var 28 to fractional list (xi=0.059887)
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=1.000000
DEBUG CAREFUL: Skipping var 32: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.059887
DEBUG CAREFUL: Adding var 35 to fractional list (xi=0.059887)
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.029944
DEBUG CAREFUL: Adding var 38 to fractional list (xi=0.029944)
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.029944
DEBUG CAREFUL: Adding var 39 to fractional list (xi=0.029944)
DEBUG CAREFUL: Found 7 fractional variables

  %  Carefully choosing branching variable, nfrac = 7
DEBUG CAREFUL: Testing fvar[0] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 11
DEBUG CAREFUL: New best var: 11
DEBUG CAREFUL: Testing fvar[1] = var 25
DEBUG CAREFUL: Calling compare_branch_vars for var 25
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 25
DEBUG CAREFUL: Testing fvar[2] = var 38
DEBUG CAREFUL: Calling compare_branch_vars for var 38
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 38
DEBUG CAREFUL: Testing fvar[3] = var 28
DEBUG CAREFUL: Calling compare_branch_vars for var 28
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 28
DEBUG CAREFUL: Testing fvar[4] = var 35
DEBUG CAREFUL: Calling compare_branch_vars for var 35
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 35
DEBUG CAREFUL: Testing fvar[5] = var 39
DEBUG CAREFUL: Calling compare_branch_vars for var 39
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 39
DEBUG CAREFUL: Testing fvar[6] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 22
  % Initial guess is x11, Z0 = 27038242.3874012        , Z1 = 27879833.5763612        

DEBUG EVAL: Testing var 11 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=40, theta=2.619554, up=999999999999999983222784.000000
ITER 2: row=4, varin=38, theta=1.765564, up=999999999999999983222784.000000
ITER 3: row=18, varin=73, theta=3.111644, up=1.000000
ITER 4: row=18, varin=87, theta=0.943975, up=1.000000
ITER 5: row=24, varin=33, theta=1.119013, up=999999999999999983222784.000000
ITER 6: row=14, varin=31, theta=1.177161, up=999999999999999983222784.000000
ITER 7: row=3, varin=37, theta=0.914402, up=999999999999999983222784.000000
ITER 8: row=32, varin=35, theta=0.946707, up=999999999999999983222784.000000
ITER 9: row=35, varin=26, theta=1.163595, up=999999999999999983222784.000000
ITER 10: row=26, varin=30, theta=1.472624, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 11 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x11 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=11, theta=0.794989, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 27049007.490409
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.205011
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.205011
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 500000.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 40 rows, 60 cols, 246 nonzeros, 2 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
   % @PAP adding 2 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=32, theta=0.057922, up=999999999999999983222784.000000
ITER 2: row=37, varin=87, theta=0.196048, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 27076624.418104
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 500000.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 40 rows, 60 cols, 253 nonzeros, 0 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=11, theta=64158.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 27112842.714444
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 435842.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 41 rows, 60 cols, 255 nonzeros, 1 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 25 at  27.11284271444413107588
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ff19996dd0
% @LO 0.04  27.03824238740117991142 99.9000000000
% @LN 0.04  27.09046908295431421720 99.9000000000
% Resuming node 18 at  27.09046908295431421720
DEBUG CONSTRNT: LP rows=40, pool->nlprows=40, pool->npend=0
DEBUG CONSTRNT: Checking 40 LP rows (pool tracks 40, total LP rows 40)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 70
DEBUG CONSTRNT: Pool row 70 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 134
DEBUG CONSTRNT: Pool row 134 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 72
DEBUG CONSTRNT: Pool row 72 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 105
DEBUG CONSTRNT: Pool row 105 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 130
DEBUG CONSTRNT: Pool row 130 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=39, expected 39
 % @PAP adding 44 rows, 204 nz to LP
DEBUG BB: Processing node 18, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=3, varin=38, theta=0.399259, up=999999999999999983222784.000000
ITER 2: row=4, varin=40, theta=1.597198, up=999999999999999983222784.000000
ITER 3: row=25, varin=67, theta=1.757899, up=1.000000
ITER 4: row=25, varin=15, theta=2.008843, up=999999999999999983222784.000000
ITER 5: row=44, varin=80, theta=2.010227, up=1.000000
ITER 6: row=44, varin=2, theta=0.349369, up=999999999999999983222784.000000
ITER 7: row=7, varin=67, theta=1.000000, up=1.000000
ITER 8: row=19, varin=88, theta=0.253759, up=1.000000
ITER 9: row=11, varin=91, theta=0.580090, up=1.000000
ITER 10: row=39, varin=80, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=10)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 27090469.082954
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 0.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 264 nonzeros, 1 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 2 rows, 11 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=28, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 27262045.784604
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 273 nonzeros, 1 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 4 rows, 29 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=37, theta=0.665347, up=999999999999999983222784.000000
ITER 2: row=15, varin=42, theta=0.024911, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 27275859.174256
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 300 nonzeros, 6 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 4 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=56, theta=0.122004, up=1.000000
ITER 2: row=38, varin=81, theta=0.019929, up=1.000000
ITER 3: row=42, varin=39, theta=0.162117, up=999999999999999983222784.000000
ITER 4: row=39, varin=72, theta=0.011762, up=1.000000
ITER 5: row=43, varin=46, theta=0.014414, up=999999999999999983222784.000000
ITER 6: row=36, varin=82, theta=0.098361, up=1.000000
ITER 7: row=40, varin=24, theta=0.008501, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 27296189.162294
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 291 nonzeros, 3 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 8 rows, 21 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=27, theta=0.566929, up=999999999999999983222784.000000
ITER 2: row=19, varin=40, theta=1.309091, up=999999999999999983222784.000000
ITER 3: row=44, varin=4, theta=0.049724, up=999999999999999983222784.000000
ITER 4: row=47, varin=82, theta=0.500000, up=1.000000
ITER 5: row=1, varin=83, theta=0.240685, up=1.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 27326326.692709
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 306 nonzeros, 0 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 18 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=54, varin=44, theta=0.633548, up=999999999999999983222784.000000
ITER 2: row=30, varin=58, theta=0.170497, up=1.000000
ITER 3: row=42, varin=25, theta=0.074512, up=999999999999999983222784.000000
ITER 4: row=40, varin=87, theta=0.496453, up=1.000000
ITER 5: row=52, varin=46, theta=0.039446, up=999999999999999983222784.000000
ITER 6: row=38, varin=10, theta=0.092798, up=999999999999999983222784.000000
ITER 7: row=48, varin=30, theta=0.172569, up=999999999999999983222784.000000
ITER 8: row=49, varin=48, theta=0.081381, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 27348254.698232
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.983724
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 55 rows, 60 cols, 324 nonzeros, 7 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 7 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=19, theta=0.998362, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 27352773.369730
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 291 nonzeros, 2 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 18 LP 1 Solution, length = 27352773.369730, 0.01 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.333333 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.333333 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.001638 (FST 23)
  % DEBUG LP_VARS: x[24] = 1.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.333333 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.333333 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.333333 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.333333 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.998362 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.666667 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.666667 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.666667 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.666667 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.666667 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=27352773.369730, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 18 at  27.35277336973021178324
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ff1997a3c0
% @LO 0.05  27.09046908295431421720 99.9000000000
% @LN 0.05  27.09588690835839486226 99.9000000000
% Resuming node 10 at  27.09588690835839486226
DEBUG CONSTRNT: LP rows=47, pool->nlprows=47, pool->npend=0
DEBUG CONSTRNT: Checking 47 LP rows (pool tracks 47, total LP rows 47)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 70
DEBUG CONSTRNT: Pool row 70 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 85
DEBUG CONSTRNT: Pool row 85 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 73
DEBUG CONSTRNT: Pool row 73 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=46, expected 46
 % @PAP adding 54 rows, 223 nz to LP
DEBUG BB: Processing node 10, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 10 LP 7 Solution, length = 27095886.908358, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.119531 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.119531 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.119531 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.119531 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.836716 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.119531 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.836716 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 1.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.119531 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.880469 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.880469 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.163284 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.880469 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.163284 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.163284 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.880469 (terminal 19)
 % 8 fractional variables
DEBUG CG: LP optimal, z=27095886.908358, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27095886.908358, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 10 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 10
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.119531
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.119531)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.119531
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.119531)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.119531
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.119531)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.119531
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.119531)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.836716
DEBUG CAREFUL: Adding var 21 to fractional list (xi=0.836716)
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.119531
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.119531)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.836716
DEBUG CAREFUL: Adding var 25 to fractional list (xi=0.836716)
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=1.000000
DEBUG CAREFUL: Skipping var 27: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.119531
DEBUG CAREFUL: Adding var 31 to fractional list (xi=0.119531)
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 8 fractional variables

  %  Carefully choosing branching variable, nfrac = 8
DEBUG CAREFUL: Testing fvar[0] = var 25
DEBUG CAREFUL: Calling compare_branch_vars for var 25
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 25
DEBUG CAREFUL: New best var: 25
DEBUG CAREFUL: Testing fvar[1] = var 21
DEBUG CAREFUL: Calling compare_branch_vars for var 21
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 21
DEBUG CAREFUL: Testing fvar[2] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 22
DEBUG CAREFUL: Testing fvar[3] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
DEBUG CAREFUL: Testing fvar[4] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[5] = var 31
DEBUG CAREFUL: Calling compare_branch_vars for var 31
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 31
DEBUG CAREFUL: Testing fvar[6] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 11
DEBUG CAREFUL: New best var: 11
DEBUG CAREFUL: Testing fvar[7] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 4
DEBUG CAREFUL: New best var: 4
  % Initial guess is x4, Z0 = 27095886.9083584        , Z1 = 28066998.0655834        

DEBUG EVAL: Testing var 25 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=19, varin=45, theta=0.295493, up=999999999999999983222784.000000
ITER 2: row=8, varin=29, theta=0.830595, up=999999999999999983222784.000000
ITER 3: row=17, varin=92, theta=1.587831, up=1.000000
ITER 4: row=17, varin=94, theta=0.819403, up=1.000000
ITER 5: row=49, varin=92, theta=1.000000, up=1.000000
ITER 6: row=17, varin=93, theta=0.891071, up=1.000000
ITER 7: row=34, varin=21, theta=0.927506, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 25 = 1 gives z=27805010.649705
  % 	x25 = 1,	Z1 = 27805010.6497054        
DEBUG EVAL: First branch cutoff check: z=27805010.649705, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 25 = 0
ITER 1: row=19, varin=35, theta=1.722262, up=999999999999999983222784.000000
ITER 2: row=23, varin=2, theta=0.635573, up=999999999999999983222784.000000
ITER 3: row=34, varin=52, theta=0.276568, up=999999999999999983222784.000000
ITER 4: row=5, varin=30, theta=0.380834, up=999999999999999983222784.000000
  % 	x25 = 0,	Z0 = 27171441.3240235        
DEBUG EVAL: Second branch cutoff check: z=27171441.324023, best_z=INF, threshold=INF
  %   New best:  x25, Z = 27171441.3240235        
DEBUG EVAL: Testing var 21 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=20, varin=45, theta=0.295493, up=999999999999999983222784.000000
ITER 2: row=8, varin=29, theta=0.830595, up=999999999999999983222784.000000
ITER 3: row=17, varin=22, theta=1.047388, up=999999999999999983222784.000000
ITER 4: row=19, varin=92, theta=0.071839, up=1.000000
ITER 5: row=49, varin=94, theta=0.100140, up=1.000000
DEBUG EVAL: Branch var 21 = 1 gives z=27476846.040104
  % 	x21 = 1,	Z1 = 27476846.0401041        
DEBUG EVAL: First branch cutoff check: z=27476846.040104, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 21 = 0
ITER 1: row=20, varin=35, theta=1.722262, up=999999999999999983222784.000000
ITER 2: row=23, varin=2, theta=0.635573, up=999999999999999983222784.000000
ITER 3: row=34, varin=52, theta=0.276568, up=999999999999999983222784.000000
ITER 4: row=5, varin=30, theta=0.380834, up=999999999999999983222784.000000
  % 	x21 = 0,	Z0 = 27171441.3240235        
DEBUG EVAL: Second branch cutoff check: z=27171441.324023, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 22 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=7, theta=0.126028, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 22 = 0 gives z=27149083.128818
  % 	x22 = 0,	Z0 = 27149083.1288176        
DEBUG EVAL: First branch cutoff check: z=27149083.128818, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=52, theta=3.357941, up=999999999999999983222784.000000
ITER 2: row=5, varin=47, theta=2.425231, up=999999999999999983222784.000000
ITER 3: row=16, varin=45, theta=4.602663, up=999999999999999983222784.000000
ITER 4: row=8, varin=5, theta=2.474304, up=999999999999999983222784.000000
ITER 5: row=40, varin=48, theta=0.948725, up=999999999999999983222784.000000
ITER 6: row=48, varin=43, theta=3.459024, up=999999999999999983222784.000000
ITER 7: row=43, varin=38, theta=4.215094, up=999999999999999983222784.000000
ITER 8: row=38, varin=31, theta=2.580542, up=999999999999999983222784.000000
ITER 9: row=31, varin=3, theta=1.814370, up=999999999999999983222784.000000
ITER 10: row=3, varin=29, theta=9.868196, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x17 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=6, varin=6, theta=0.281553, up=999999999999999983222784.000000
ITER 2: row=33, varin=2, theta=0.539091, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
ITER 3: row=5, varin=33, theta=0.000000, up=999999999999999983222784.000000
ITER 4: row=23, varin=35, theta=1.000000, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 27130917.600984
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 0.773922
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
   % @PL 54 rows, 60 cols, 283 nonzeros, 3 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 3 slack rows
   % @PAP adding 3 rows, 10 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=89, theta=18.000000, up=1.000000
ITER 2: row=1, varin=84, theta=17.000000, up=1.000000
ITER 3: row=1, varin=76, theta=16.000000, up=1.000000
ITER 4: row=1, varin=80, theta=15.000000, up=1.000000
ITER 5: row=1, varin=91, theta=14.000000, up=1.000000
ITER 6: row=1, varin=57, theta=6.500000, up=1.000000
ITER 7: row=1, varin=83, theta=11.000000, up=1.000000
ITER 8: row=1, varin=73, theta=3.333333, up=1.000000
ITER 9: row=1, varin=87, theta=7.000000, up=1.000000
ITER 10: row=1, varin=90, theta=6.000000, up=1.000000
LP PHASE: Switching to primal (iter=89)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 27164543.488188
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
   % @PL 54 rows, 60 cols, 285 nonzeros, 3 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 3 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 10 at  27.16454348818755804018
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55ff19980d00
% @LO 0.05  27.09588690835839486226 99.9000000000
% @LN 0.05  27.11284271444413107588 99.9000000000
% Resuming node 25 at  27.11284271444413107588
DEBUG CONSTRNT: LP rows=51, pool->nlprows=51, pool->npend=0
DEBUG CONSTRNT: Checking 51 LP rows (pool tracks 51, total LP rows 51)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 70
DEBUG CONSTRNT: Pool row 70 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=50, expected 50
 % @PAP adding 40 rows, 155 nz to LP
DEBUG BB: Processing node 25, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 25 LP 3 Solution, length = 27112842.714444, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 1.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 0 fractional variables
DEBUG CG: LP optimal, z=27112842.714444, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG IFS: Budget mode - accepting integer solution with 2 edges covering 4 vertices
DEBUG CG: integer_feasible_solution returned: TRUE
DEBUG CG: Solution is integer feasible, returning LB_INTEGRAL
DEBUG BB: compute_good_lower_bound returned status=3
DEBUG BB: Node 25 is INTEGRAL (integer solution found)
 %  	=== 10 nodes cut off ===
 % @UO 0.05   3.11284271444413151997 -770.9994433267
 % @UN 0.05   3.11284271444413151997 -770.9994433267
DEBUG BB: Calling heuristic UB for integer solution, current best_z=3112842.714444
DEBUG BB: Heuristic did not improve integer solution
 % *    25     0  3112842.7144  3112842.7144                  x3 D    23    13
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=(nil)
DEBUG BB: No more nodes to process, exiting

 % Certificate of solution:
 % @C	.4767008182741058	.2081993675729823
%%Page: 1 1
BeginPlot
	Plot_Terminals
 % fs2: 13 0 6
	13 T	.4767008182741058	.2081993675729823	S
	.4767008182741058	.2081993675729823	0 T	S
	.4767008182741058	.2081993675729823	6 T	S
 % fs32: 13 4
	13 T	4 T	S
  (Euclidean SMT:  20 points,  length = 3.112842714444131,  0.05 seconds)
EndPlot

% @0 Euclidean SMT
% N M Nodes LPs P1CPU P2CPU TotCPU
% @1 20 40 23 61 0.00 0.05 0.05
% Z RootZ %Gap RootLPs RootCPU RedMST
% @2 3.112842714444131 25158957.535892 -708.23093 2 0.00 0.4456
% InitPRows InitPNZ InitLPRows InitLPNZ
% @3 163 594 135 555
% RootPRows RootPNZ RootLPRows RootLPNZ
% @4 163 594 55 296
% FinalPRows FinalPNZ FinalLPRows FinalLPNZ
% @5 163 594 40 215
% SMTFSTs SMTAvgFSTSz SMTMaxFSTSz #2FSTs #3FSTs ... #10FSTS #>10FSTs
% @6 2 2.500000 3 1 1 0 0 0 0 0 0 0 0
