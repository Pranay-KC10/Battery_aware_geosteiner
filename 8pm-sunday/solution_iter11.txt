 % ./bb
 % Args:
DEBUG P1READ: Terminal 0 battery=100.00
DEBUG P1READ: Terminal 1 battery=88.60
DEBUG P1READ: Terminal 2 battery=97.70
DEBUG P1READ: Terminal 3 battery=96.00
DEBUG P1READ: Terminal 4 battery=96.00
DEBUG P1READ: Terminal 5 battery=78.50
DEBUG P1READ: Terminal 6 battery=100.00
DEBUG P1READ: Terminal 7 battery=100.00
DEBUG P1READ: Terminal 8 battery=100.00
DEBUG P1READ: Terminal 9 battery=100.00
DEBUG P1READ: Terminal 10 battery=81.20
DEBUG P1READ: Terminal 11 battery=52.00
DEBUG P1READ: Terminal 12 battery=69.00
DEBUG P1READ: Terminal 13 battery=100.00
DEBUG P1READ: Terminal 14 battery=76.30
DEBUG P1READ: Terminal 15 battery=96.00
DEBUG P1READ: Terminal 16 battery=74.00
DEBUG P1READ: Terminal 17 battery=100.00
DEBUG P1READ: Terminal 18 battery=100.00
DEBUG P1READ: Terminal 19 battery=93.60
DEBUG HG: num_verts=20, num_edges=40
 % Phase 1: 0.00 seconds

%%BeginSetup

0 1 0 1 SetAxes

20 DefineTerminals
	.4588350000000000	.2373240000000000	DT
	.1270640000000000	.3509960000000000	DT
	.1544540000000000	.4808220000000000	DT
	.9474030000000000	.1441120000000000	DT
	.2867390000000000	.0565890000000000	DT
	.1326890000000000	.1166050000000000	DT
	.6273950000000000	.2122140000000000	DT
	.0794880000000000	.7970990000000000	DT
	.0327480000000000	.8803250000000000	DT
	.3110550000000000	.8689670000000000	DT
	.0916180000000000	.0221720000000000	DT
	.3600710000000000	.6382240000000000	DT
	.7197120000000000	.7181670000000000	DT
	.4424420000000000	.1450340000000000	DT
	.9983770000000000	.5729870000000000	DT
	.9654920000000000	.1935700000000000	DT
	.1600100000000000	.4187950000000000	DT
	.2909450000000000	.9620800000000000	DT
	.3330000000000000	.9414120000000000	DT
	.9512590000000000	.5074670000000000	DT

%%EndSetup

DEBUG ALGO: num_verts=20 <= 8? NO, num_edges=40 <= 12? NO
DEBUG ALGO: Forcing BRANCH-AND-CUT for multi-objective optimization (vertices=20 > 1)
DEBUG SPANNING: Adding modified spanning constraint for budget mode
DEBUG SPANNING: Added modified spanning constraint: Σ(|FST|-1)*x + Σnot_covered = 19
DEBUG CONSTRAINT: Adding soft cutset constraints with not_covered variables
DEBUG CONSTRAINT: Added constraint x[2] + not_covered[0] ≤ 1 for terminal 0
DEBUG CONSTRAINT: Added constraint x[27] + not_covered[0] ≤ 1 for terminal 0
DEBUG CONSTRAINT: Added constraint x[31] + not_covered[0] ≤ 1 for terminal 0
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 3·not_covered[0] ≤ 3 for terminal 0
DEBUG CONSTRAINT: Added constraint x[0] + not_covered[1] ≤ 1 for terminal 1
DEBUG CONSTRAINT: Added constraint x[24] + not_covered[1] ≤ 1 for terminal 1
DEBUG CONSTRAINT: Added constraint x[33] + not_covered[1] ≤ 1 for terminal 1
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 3·not_covered[1] ≤ 3 for terminal 1
DEBUG CONSTRAINT: Added constraint x[5] + not_covered[2] ≤ 1 for terminal 2
DEBUG CONSTRAINT: Added constraint x[7] + not_covered[2] ≤ 1 for terminal 2
DEBUG CONSTRAINT: Added constraint x[16] + not_covered[2] ≤ 1 for terminal 2
DEBUG CONSTRAINT: Added constraint x[23] + not_covered[2] ≤ 1 for terminal 2
DEBUG CONSTRAINT: Added constraint x[36] + not_covered[2] ≤ 1 for terminal 2
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 5·not_covered[2] ≤ 5 for terminal 2
DEBUG CONSTRAINT: Added constraint x[3] + not_covered[3] ≤ 1 for terminal 3
DEBUG CONSTRAINT: Added constraint x[4] + not_covered[3] ≤ 1 for terminal 3
DEBUG CONSTRAINT: Added constraint x[17] + not_covered[3] ≤ 1 for terminal 3
DEBUG CONSTRAINT: Added constraint x[20] + not_covered[3] ≤ 1 for terminal 3
DEBUG CONSTRAINT: Added constraint x[22] + not_covered[3] ≤ 1 for terminal 3
DEBUG CONSTRAINT: Added constraint x[39] + not_covered[3] ≤ 1 for terminal 3
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 6·not_covered[3] ≤ 6 for terminal 3
DEBUG CONSTRAINT: Added constraint x[0] + not_covered[4] ≤ 1 for terminal 4
DEBUG CONSTRAINT: Added constraint x[1] + not_covered[4] ≤ 1 for terminal 4
DEBUG CONSTRAINT: Added constraint x[30] + not_covered[4] ≤ 1 for terminal 4
DEBUG CONSTRAINT: Added constraint x[32] + not_covered[4] ≤ 1 for terminal 4
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 4·not_covered[4] ≤ 4 for terminal 4
DEBUG CONSTRAINT: Added constraint x[0] + not_covered[5] ≤ 1 for terminal 5
DEBUG CONSTRAINT: Added constraint x[1] + not_covered[5] ≤ 1 for terminal 5
DEBUG CONSTRAINT: Added constraint x[29] + not_covered[5] ≤ 1 for terminal 5
DEBUG CONSTRAINT: Added constraint x[30] + not_covered[5] ≤ 1 for terminal 5
DEBUG CONSTRAINT: Added constraint x[33] + not_covered[5] ≤ 1 for terminal 5
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 5·not_covered[5] ≤ 5 for terminal 5
DEBUG CONSTRAINT: Added constraint x[2] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[3] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[4] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[11] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[17] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[18] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[20] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[31] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint x[39] + not_covered[6] ≤ 1 for terminal 6
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 9·not_covered[6] ≤ 9 for terminal 6
DEBUG CONSTRAINT: Added constraint x[5] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[6] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[8] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[13] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[14] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[15] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[16] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[19] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[28] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint x[35] + not_covered[7] ≤ 1 for terminal 7
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 10·not_covered[7] ≤ 10 for terminal 7
DEBUG CONSTRAINT: Added constraint x[6] + not_covered[8] ≤ 1 for terminal 8
DEBUG CONSTRAINT: Added constraint x[13] + not_covered[8] ≤ 1 for terminal 8
DEBUG CONSTRAINT: Added constraint x[14] + not_covered[8] ≤ 1 for terminal 8
DEBUG CONSTRAINT: Added constraint x[19] + not_covered[8] ≤ 1 for terminal 8
DEBUG CONSTRAINT: Added constraint x[28] + not_covered[8] ≤ 1 for terminal 8
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 5·not_covered[8] ≤ 5 for terminal 8
DEBUG CONSTRAINT: Added constraint x[6] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[7] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[8] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[9] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[12] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[13] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[14] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[15] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[16] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[19] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[25] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[34] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint x[35] + not_covered[9] ≤ 1 for terminal 9
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 13·not_covered[9] ≤ 13 for terminal 9
DEBUG CONSTRAINT: Added constraint x[1] + not_covered[10] ≤ 1 for terminal 10
DEBUG CONSTRAINT: Added constraint x[29] + not_covered[10] ≤ 1 for terminal 10
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 2·not_covered[10] ≤ 2 for terminal 10
DEBUG CONSTRAINT: Added constraint x[5] + not_covered[11] ≤ 1 for terminal 11
DEBUG CONSTRAINT: Added constraint x[7] + not_covered[11] ≤ 1 for terminal 11
DEBUG CONSTRAINT: Added constraint x[8] + not_covered[11] ≤ 1 for terminal 11
DEBUG CONSTRAINT: Added constraint x[9] + not_covered[11] ≤ 1 for terminal 11
DEBUG CONSTRAINT: Added constraint x[13] + not_covered[11] ≤ 1 for terminal 11
DEBUG CONSTRAINT: Added constraint x[16] + not_covered[11] ≤ 1 for terminal 11
DEBUG CONSTRAINT: Added constraint x[34] + not_covered[11] ≤ 1 for terminal 11
DEBUG CONSTRAINT: Added constraint x[36] + not_covered[11] ≤ 1 for terminal 11
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 8·not_covered[11] ≤ 8 for terminal 11
DEBUG CONSTRAINT: Added constraint x[9] + not_covered[12] ≤ 1 for terminal 12
DEBUG CONSTRAINT: Added constraint x[10] + not_covered[12] ≤ 1 for terminal 12
DEBUG CONSTRAINT: Added constraint x[18] + not_covered[12] ≤ 1 for terminal 12
DEBUG CONSTRAINT: Added constraint x[20] + not_covered[12] ≤ 1 for terminal 12
DEBUG CONSTRAINT: Added constraint x[37] + not_covered[12] ≤ 1 for terminal 12
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 5·not_covered[12] ≤ 5 for terminal 12
DEBUG CONSTRAINT: Added constraint x[2] + not_covered[13] ≤ 1 for terminal 13
DEBUG CONSTRAINT: Added constraint x[27] + not_covered[13] ≤ 1 for terminal 13
DEBUG CONSTRAINT: Added constraint x[32] + not_covered[13] ≤ 1 for terminal 13
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 3·not_covered[13] ≤ 3 for terminal 13
DEBUG CONSTRAINT: Added constraint x[10] + not_covered[14] ≤ 1 for terminal 14
DEBUG CONSTRAINT: Added constraint x[26] + not_covered[14] ≤ 1 for terminal 14
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 2·not_covered[14] ≤ 2 for terminal 14
DEBUG CONSTRAINT: Added constraint x[3] + not_covered[15] ≤ 1 for terminal 15
DEBUG CONSTRAINT: Added constraint x[11] + not_covered[15] ≤ 1 for terminal 15
DEBUG CONSTRAINT: Added constraint x[17] + not_covered[15] ≤ 1 for terminal 15
DEBUG CONSTRAINT: Added constraint x[18] + not_covered[15] ≤ 1 for terminal 15
DEBUG CONSTRAINT: Added constraint x[20] + not_covered[15] ≤ 1 for terminal 15
DEBUG CONSTRAINT: Added constraint x[22] + not_covered[15] ≤ 1 for terminal 15
DEBUG CONSTRAINT: Added constraint x[38] + not_covered[15] ≤ 1 for terminal 15
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 7·not_covered[15] ≤ 7 for terminal 15
DEBUG CONSTRAINT: Added constraint x[23] + not_covered[16] ≤ 1 for terminal 16
DEBUG CONSTRAINT: Added constraint x[24] + not_covered[16] ≤ 1 for terminal 16
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 2·not_covered[16] ≤ 2 for terminal 16
DEBUG CONSTRAINT: Added constraint x[12] + not_covered[17] ≤ 1 for terminal 17
DEBUG CONSTRAINT: Added constraint x[15] + not_covered[17] ≤ 1 for terminal 17
DEBUG CONSTRAINT: Added constraint x[19] + not_covered[17] ≤ 1 for terminal 17
DEBUG CONSTRAINT: Added constraint x[21] + not_covered[17] ≤ 1 for terminal 17
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 4·not_covered[17] ≤ 4 for terminal 17
DEBUG CONSTRAINT: Added constraint x[12] + not_covered[18] ≤ 1 for terminal 18
DEBUG CONSTRAINT: Added constraint x[14] + not_covered[18] ≤ 1 for terminal 18
DEBUG CONSTRAINT: Added constraint x[15] + not_covered[18] ≤ 1 for terminal 18
DEBUG CONSTRAINT: Added constraint x[19] + not_covered[18] ≤ 1 for terminal 18
DEBUG CONSTRAINT: Added constraint x[21] + not_covered[18] ≤ 1 for terminal 18
DEBUG CONSTRAINT: Added constraint x[25] + not_covered[18] ≤ 1 for terminal 18
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 6·not_covered[18] ≤ 6 for terminal 18
DEBUG CONSTRAINT: Added constraint x[4] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint x[10] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint x[11] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint x[17] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint x[18] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint x[20] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint x[26] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint x[37] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint x[38] + not_covered[19] ≤ 1 for terminal 19
DEBUG CONSTRAINT: Added constraint Σx[FSTs] + 9·not_covered[19] ≤ 9 for terminal 19
DEBUG CONSTRAINT: Added source terminal constraint: not_covered[0] = 0
DEBUG BUDGET: Adding budget constraint ≤ 1000000.000 to constraint pool
DEBUG BUDGET: Using raw tree costs directly
DEBUG BUDGET: Budget limit: 1000000.000
DEBUG BUDGET: Building raw cost constraint coefficients:
DEBUG BUDGET:   x[0] coefficient = 398991 (raw=398991.100)
DEBUG BUDGET:   x[1] coefficient = 260889 (raw=260889.712)
DEBUG BUDGET:   x[2] coefficient = 256773 (raw=256773.057)
DEBUG BUDGET:   x[3] coefficient = 376541 (raw=376541.557)
DEBUG BUDGET:   x[4] coefficient = 646084 (raw=646084.462)
DEBUG BUDGET:   x[5] coefficient = 520973 (raw=520973.020)
DEBUG BUDGET:   x[6] coefficient = 334575 (raw=334575.182)
DEBUG BUDGET:   x[7] coefficient = 494448 (raw=494448.457)
DEBUG BUDGET:   x[8] coefficient = 455905 (raw=455905.519)
DEBUG BUDGET:   x[9] coefficient = 584020 (raw=584020.499)
DEBUG BUDGET:   x[10] coefficient = 380918 (raw=380918.244)
DEBUG BUDGET:   x[11] coefficient = 621357 (raw=621357.781)
DEBUG BUDGET:   x[12] coefficient = 120675 (raw=120675.719)
DEBUG BUDGET:   x[13] coefficient = 551354 (raw=551354.477)
DEBUG BUDGET:   x[14] coefficient = 410262 (raw=410262.679)
DEBUG BUDGET:   x[15] coefficient = 362962 (raw=362962.653)
DEBUG BUDGET:   x[16] coefficient = 702244 (raw=702244.403)
DEBUG BUDGET:   x[17] coefficient = 673894 (raw=673894.542)
DEBUG BUDGET:   x[18] coefficient = 933994 (raw=933994.022)
DEBUG BUDGET:   x[19] coefficient = 454199 (raw=454199.906)
DEBUG BUDGET:   x[20] coefficient = 986439 (raw=986439.144)
DEBUG BUDGET:   x[21] coefficient = 46859 (raw=46859.249)
DEBUG BUDGET:   x[22] coefficient = 52662 (raw=52662.185)
DEBUG BUDGET:   x[23] coefficient = 62275 (raw=62275.339)
DEBUG BUDGET:   x[24] coefficient = 75379 (raw=75379.993)
DEBUG BUDGET:   x[25] coefficient = 75695 (raw=75695.846)
DEBUG BUDGET:   x[26] coefficient = 80703 (raw=80703.013)
DEBUG BUDGET:   x[27] coefficient = 93734 (raw=93734.596)
DEBUG BUDGET:   x[28] coefficient = 95452 (raw=95452.578)
DEBUG BUDGET:   x[29] coefficient = 102977 (raw=102977.757)
DEBUG BUDGET:   x[30] coefficient = 165327 (raw=165327.925)
DEBUG BUDGET:   x[31] coefficient = 170420 (raw=170420.027)
DEBUG BUDGET:   x[32] coefficient = 179069 (raw=179069.657)
DEBUG BUDGET:   x[33] coefficient = 234458 (raw=234458.486)
DEBUG BUDGET:   x[34] coefficient = 235891 (raw=235891.713)
DEBUG BUDGET:   x[35] coefficient = 242462 (raw=242462.956)
DEBUG BUDGET:   x[36] coefficient = 258947 (raw=258947.370)
DEBUG BUDGET:   x[37] coefficient = 313063 (raw=313063.098)
DEBUG BUDGET:   x[38] coefficient = 314219 (raw=314219.517)
DEBUG BUDGET:   x[39] coefficient = 327174 (raw=327174.269)
DEBUG BUDGET: Constraint: Σ tree_cost[i] * x[i] ≤ 1000000
DEBUG BUDGET: Budget constraint added to pool with 40 FSTs
DEBUG CONSTRAINT: Adding 'at least one FST' constraint: Σ x[i] ≥ 1
DEBUG CONSTRAINT: Added 'at least one FST' constraint: Σ x[i] ≥ 1
 % _gst_initialize_constraint_pool: 0.00 seconds.
 % Constraint pool initialized with:
 % 	1	Total degree rows	40	coeffs.
 % 	20	Cutset rows		111	coeffs.
 % 	0	Incompatibility rows	0	coeffs.
 % 	29	2-terminal SEC rows	102	coeffs.
 % 	1	At least one FST rows	40	coeffs.
 % 	163	Total rows in pool	135	in LP
 % @PMEM 163 rows, 1 blocks, 415 nzfree, 0 nzwasted, 1172 nztotal
DEBUG SOFT: Found 20 terminals, 40 FSTs
DEBUG SOFT: Adding space for 20 not_covered variables in soft constraints, total ncoeff=514
DEBUG LP_SETUP: Created LP with 0 rows, 60 columns (nedges=40 + nterms=20)
DEBUG SOFT: Set bounds for 40 FST vars [1-40] and 20 coverage vars [41-60]
DEBUG OBJ: Using raw costs - alpha=10000.0 (battery weight), beta=1500000 (coverage penalty)
DEBUG OBJ: Allocated rowvec[0-60] for ncols=60 LP variables
DEBUG OBJ: Full_trees battery_score=0.000 for FST 0
DEBUG OBJ: Recalculating for FST 0 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 5): battery=78.50, running_total=78.50
DEBUG OBJ: Terminal 1 (idx 1): battery=88.60, running_total=167.10
DEBUG OBJ: Terminal 2 (idx 4): battery=96.00, running_total=263.10
DEBUG OBJ: Recalculated battery_score=263.100 for FST 0
DEBUG OBJ: FST 0: tree_cost=398991.100, battery_cost=263.100 (weighted=2631000.0), combined=3029991.1
DEBUG OBJ: Full_trees battery_score=0.000 for FST 1
DEBUG OBJ: Recalculating for FST 1 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 10): battery=81.20, running_total=81.20
DEBUG OBJ: Terminal 1 (idx 5): battery=78.50, running_total=159.70
DEBUG OBJ: Terminal 2 (idx 4): battery=96.00, running_total=255.70
DEBUG OBJ: Recalculated battery_score=255.700 for FST 1
DEBUG OBJ: FST 1: tree_cost=260889.712, battery_cost=255.700 (weighted=2557000.0), combined=2817889.7
DEBUG OBJ: Full_trees battery_score=0.000 for FST 2
DEBUG OBJ: Recalculating for FST 2 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 13): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 0): battery=100.00, running_total=200.00
DEBUG OBJ: Terminal 2 (idx 6): battery=100.00, running_total=300.00
DEBUG OBJ: Recalculated battery_score=300.000 for FST 2
DEBUG OBJ: FST 2: tree_cost=256773.057, battery_cost=300.000 (weighted=3000000.0), combined=3256773.1
DEBUG OBJ: Full_trees battery_score=0.000 for FST 3
DEBUG OBJ: Recalculating for FST 3 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 15): battery=96.00, running_total=96.00
DEBUG OBJ: Terminal 1 (idx 3): battery=96.00, running_total=192.00
DEBUG OBJ: Terminal 2 (idx 6): battery=100.00, running_total=292.00
DEBUG OBJ: Recalculated battery_score=292.000 for FST 3
DEBUG OBJ: FST 3: tree_cost=376541.557, battery_cost=292.000 (weighted=2920000.0), combined=3296541.6
DEBUG OBJ: Full_trees battery_score=0.000 for FST 4
DEBUG OBJ: Recalculating for FST 4 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 19): battery=93.60, running_total=93.60
DEBUG OBJ: Terminal 1 (idx 3): battery=96.00, running_total=189.60
DEBUG OBJ: Terminal 2 (idx 6): battery=100.00, running_total=289.60
DEBUG OBJ: Recalculated battery_score=289.600 for FST 4
DEBUG OBJ: FST 4: tree_cost=646084.462, battery_cost=289.600 (weighted=2896000.0), combined=3542084.5
DEBUG OBJ: Full_trees battery_score=0.000 for FST 5
DEBUG OBJ: Recalculating for FST 5 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 11): battery=52.00, running_total=52.00
DEBUG OBJ: Terminal 1 (idx 2): battery=97.70, running_total=149.70
DEBUG OBJ: Terminal 2 (idx 7): battery=100.00, running_total=249.70
DEBUG OBJ: Recalculated battery_score=249.700 for FST 5
DEBUG OBJ: FST 5: tree_cost=520973.020, battery_cost=249.700 (weighted=2497000.0), combined=3017973.0
DEBUG OBJ: Full_trees battery_score=0.000 for FST 6
DEBUG OBJ: Recalculating for FST 6 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 9): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 7): battery=100.00, running_total=200.00
DEBUG OBJ: Terminal 2 (idx 8): battery=100.00, running_total=300.00
DEBUG OBJ: Recalculated battery_score=300.000 for FST 6
DEBUG OBJ: FST 6: tree_cost=334575.182, battery_cost=300.000 (weighted=3000000.0), combined=3334575.2
DEBUG OBJ: Full_trees battery_score=0.000 for FST 7
DEBUG OBJ: Recalculating for FST 7 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 11): battery=52.00, running_total=52.00
DEBUG OBJ: Terminal 1 (idx 2): battery=97.70, running_total=149.70
DEBUG OBJ: Terminal 2 (idx 9): battery=100.00, running_total=249.70
DEBUG OBJ: Recalculated battery_score=249.700 for FST 7
DEBUG OBJ: FST 7: tree_cost=494448.457, battery_cost=249.700 (weighted=2497000.0), combined=2991448.5
DEBUG OBJ: Full_trees battery_score=0.000 for FST 8
DEBUG OBJ: Recalculating for FST 8 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 11): battery=52.00, running_total=52.00
DEBUG OBJ: Terminal 1 (idx 7): battery=100.00, running_total=152.00
DEBUG OBJ: Terminal 2 (idx 9): battery=100.00, running_total=252.00
DEBUG OBJ: Recalculated battery_score=252.000 for FST 8
DEBUG OBJ: FST 8: tree_cost=455905.519, battery_cost=252.000 (weighted=2520000.0), combined=2975905.5
DEBUG OBJ: Full_trees battery_score=0.000 for FST 9
DEBUG OBJ: Recalculating for FST 9 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 12): battery=69.00, running_total=69.00
DEBUG OBJ: Terminal 1 (idx 11): battery=52.00, running_total=121.00
DEBUG OBJ: Terminal 2 (idx 9): battery=100.00, running_total=221.00
DEBUG OBJ: Recalculated battery_score=221.000 for FST 9
DEBUG OBJ: FST 9: tree_cost=584020.499, battery_cost=221.000 (weighted=2210000.0), combined=2794020.5
DEBUG OBJ: Full_trees battery_score=0.000 for FST 10
DEBUG OBJ: Recalculating for FST 10 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 19): battery=93.60, running_total=93.60
DEBUG OBJ: Terminal 1 (idx 12): battery=69.00, running_total=162.60
DEBUG OBJ: Terminal 2 (idx 14): battery=76.30, running_total=238.90
DEBUG OBJ: Recalculated battery_score=238.900 for FST 10
DEBUG OBJ: FST 10: tree_cost=380918.244, battery_cost=238.900 (weighted=2389000.0), combined=2769918.2
DEBUG OBJ: Full_trees battery_score=0.000 for FST 11
DEBUG OBJ: Recalculating for FST 11 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 19): battery=93.60, running_total=93.60
DEBUG OBJ: Terminal 1 (idx 15): battery=96.00, running_total=189.60
DEBUG OBJ: Terminal 2 (idx 6): battery=100.00, running_total=289.60
DEBUG OBJ: Recalculated battery_score=289.600 for FST 11
DEBUG OBJ: FST 11: tree_cost=621357.781, battery_cost=289.600 (weighted=2896000.0), combined=3517357.8
DEBUG OBJ: Full_trees battery_score=0.000 for FST 12
DEBUG OBJ: Recalculating for FST 12 with 3 terminals
DEBUG OBJ: Terminal 0 (idx 18): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 9): battery=100.00, running_total=200.00
DEBUG OBJ: Terminal 2 (idx 17): battery=100.00, running_total=300.00
DEBUG OBJ: Recalculated battery_score=300.000 for FST 12
DEBUG OBJ: FST 12: tree_cost=120675.719, battery_cost=300.000 (weighted=3000000.0), combined=3120675.7
DEBUG OBJ: Full_trees battery_score=0.000 for FST 13
DEBUG OBJ: Recalculating for FST 13 with 4 terminals
DEBUG OBJ: Terminal 0 (idx 11): battery=52.00, running_total=52.00
DEBUG OBJ: Terminal 1 (idx 7): battery=100.00, running_total=152.00
DEBUG OBJ: Terminal 2 (idx 8): battery=100.00, running_total=252.00
DEBUG OBJ: Terminal 3 (idx 9): battery=100.00, running_total=352.00
DEBUG OBJ: Recalculated battery_score=352.000 for FST 13
DEBUG OBJ: FST 13: tree_cost=551354.477, battery_cost=352.000 (weighted=3520000.0), combined=4071354.5
DEBUG OBJ: Full_trees battery_score=0.000 for FST 14
DEBUG OBJ: Recalculating for FST 14 with 4 terminals
DEBUG OBJ: Terminal 0 (idx 18): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 9): battery=100.00, running_total=200.00
DEBUG OBJ: Terminal 2 (idx 7): battery=100.00, running_total=300.00
DEBUG OBJ: Terminal 3 (idx 8): battery=100.00, running_total=400.00
DEBUG OBJ: Recalculated battery_score=400.000 for FST 14
DEBUG OBJ: FST 14: tree_cost=410262.679, battery_cost=400.000 (weighted=4000000.0), combined=4410262.7
DEBUG OBJ: Full_trees battery_score=0.000 for FST 15
DEBUG OBJ: Recalculating for FST 15 with 4 terminals
DEBUG OBJ: Terminal 0 (idx 18): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 9): battery=100.00, running_total=200.00
DEBUG OBJ: Terminal 2 (idx 7): battery=100.00, running_total=300.00
DEBUG OBJ: Terminal 3 (idx 17): battery=100.00, running_total=400.00
DEBUG OBJ: Recalculated battery_score=400.000 for FST 15
DEBUG OBJ: FST 15: tree_cost=362962.653, battery_cost=400.000 (weighted=4000000.0), combined=4362962.7
DEBUG OBJ: Full_trees battery_score=0.000 for FST 16
DEBUG OBJ: Recalculating for FST 16 with 4 terminals
DEBUG OBJ: Terminal 0 (idx 11): battery=52.00, running_total=52.00
DEBUG OBJ: Terminal 1 (idx 2): battery=97.70, running_total=149.70
DEBUG OBJ: Terminal 2 (idx 7): battery=100.00, running_total=249.70
DEBUG OBJ: Terminal 3 (idx 9): battery=100.00, running_total=349.70
DEBUG OBJ: Recalculated battery_score=349.700 for FST 16
DEBUG OBJ: FST 16: tree_cost=702244.403, battery_cost=349.700 (weighted=3497000.0), combined=4199244.4
DEBUG OBJ: Full_trees battery_score=0.000 for FST 17
DEBUG OBJ: Recalculating for FST 17 with 4 terminals
DEBUG OBJ: Terminal 0 (idx 19): battery=93.60, running_total=93.60
DEBUG OBJ: Terminal 1 (idx 15): battery=96.00, running_total=189.60
DEBUG OBJ: Terminal 2 (idx 3): battery=96.00, running_total=285.60
DEBUG OBJ: Terminal 3 (idx 6): battery=100.00, running_total=385.60
DEBUG OBJ: Recalculated battery_score=385.600 for FST 17
DEBUG OBJ: FST 17: tree_cost=673894.542, battery_cost=385.600 (weighted=3856000.0), combined=4529894.5
DEBUG OBJ: Full_trees battery_score=0.000 for FST 18
DEBUG OBJ: Recalculating for FST 18 with 4 terminals
DEBUG OBJ: Terminal 0 (idx 19): battery=93.60, running_total=93.60
DEBUG OBJ: Terminal 1 (idx 15): battery=96.00, running_total=189.60
DEBUG OBJ: Terminal 2 (idx 6): battery=100.00, running_total=289.60
DEBUG OBJ: Terminal 3 (idx 12): battery=69.00, running_total=358.60
DEBUG OBJ: Recalculated battery_score=358.600 for FST 18
DEBUG OBJ: FST 18: tree_cost=933994.022, battery_cost=358.600 (weighted=3586000.0), combined=4519994.0
DEBUG OBJ: Full_trees battery_score=0.000 for FST 19
DEBUG OBJ: Recalculating for FST 19 with 5 terminals
DEBUG OBJ: Terminal 0 (idx 18): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 9): battery=100.00, running_total=200.00
DEBUG OBJ: Terminal 2 (idx 7): battery=100.00, running_total=300.00
DEBUG OBJ: Terminal 3 (idx 8): battery=100.00, running_total=400.00
DEBUG OBJ: Terminal 4 (idx 17): battery=100.00, running_total=500.00
DEBUG OBJ: Recalculated battery_score=500.000 for FST 19
DEBUG OBJ: FST 19: tree_cost=454199.906, battery_cost=500.000 (weighted=5000000.0), combined=5454199.9
DEBUG OBJ: Full_trees battery_score=0.000 for FST 20
DEBUG OBJ: Recalculating for FST 20 with 5 terminals
DEBUG OBJ: Terminal 0 (idx 19): battery=93.60, running_total=93.60
DEBUG OBJ: Terminal 1 (idx 15): battery=96.00, running_total=189.60
DEBUG OBJ: Terminal 2 (idx 3): battery=96.00, running_total=285.60
DEBUG OBJ: Terminal 3 (idx 6): battery=100.00, running_total=385.60
DEBUG OBJ: Terminal 4 (idx 12): battery=69.00, running_total=454.60
DEBUG OBJ: Recalculated battery_score=454.600 for FST 20
DEBUG OBJ: FST 20: tree_cost=986439.144, battery_cost=454.600 (weighted=4546000.0), combined=5532439.1
DEBUG OBJ: Full_trees battery_score=0.000 for FST 21
DEBUG OBJ: Recalculating for FST 21 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 18): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 17): battery=100.00, running_total=200.00
DEBUG OBJ: Recalculated battery_score=200.000 for FST 21
DEBUG OBJ: FST 21: tree_cost=46859.249, battery_cost=200.000 (weighted=2000000.0), combined=2046859.2
DEBUG OBJ: Full_trees battery_score=0.000 for FST 22
DEBUG OBJ: Recalculating for FST 22 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 15): battery=96.00, running_total=96.00
DEBUG OBJ: Terminal 1 (idx 3): battery=96.00, running_total=192.00
DEBUG OBJ: Recalculated battery_score=192.000 for FST 22
DEBUG OBJ: FST 22: tree_cost=52662.185, battery_cost=192.000 (weighted=1920000.0), combined=1972662.2
DEBUG OBJ: Full_trees battery_score=0.000 for FST 23
DEBUG OBJ: Recalculating for FST 23 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 16): battery=74.00, running_total=74.00
DEBUG OBJ: Terminal 1 (idx 2): battery=97.70, running_total=171.70
DEBUG OBJ: Recalculated battery_score=171.700 for FST 23
DEBUG OBJ: FST 23: tree_cost=62275.339, battery_cost=171.700 (weighted=1717000.0), combined=1779275.3
DEBUG OBJ: Full_trees battery_score=0.000 for FST 24
DEBUG OBJ: Recalculating for FST 24 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 16): battery=74.00, running_total=74.00
DEBUG OBJ: Terminal 1 (idx 1): battery=88.60, running_total=162.60
DEBUG OBJ: Recalculated battery_score=162.600 for FST 24
DEBUG OBJ: FST 24: tree_cost=75379.993, battery_cost=162.600 (weighted=1626000.0), combined=1701380.0
DEBUG OBJ: Full_trees battery_score=0.000 for FST 25
DEBUG OBJ: Recalculating for FST 25 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 18): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 9): battery=100.00, running_total=200.00
DEBUG OBJ: Recalculated battery_score=200.000 for FST 25
DEBUG OBJ: FST 25: tree_cost=75695.846, battery_cost=200.000 (weighted=2000000.0), combined=2075695.8
DEBUG OBJ: Full_trees battery_score=0.000 for FST 26
DEBUG OBJ: Recalculating for FST 26 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 14): battery=76.30, running_total=76.30
DEBUG OBJ: Terminal 1 (idx 19): battery=93.60, running_total=169.90
DEBUG OBJ: Recalculated battery_score=169.900 for FST 26
DEBUG OBJ: FST 26: tree_cost=80703.013, battery_cost=169.900 (weighted=1699000.0), combined=1779703.0
DEBUG OBJ: Full_trees battery_score=0.000 for FST 27
DEBUG OBJ: Recalculating for FST 27 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 0): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 13): battery=100.00, running_total=200.00
DEBUG OBJ: Recalculated battery_score=200.000 for FST 27
DEBUG OBJ: FST 27: tree_cost=93734.596, battery_cost=200.000 (weighted=2000000.0), combined=2093734.6
DEBUG OBJ: Full_trees battery_score=0.000 for FST 28
DEBUG OBJ: Recalculating for FST 28 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 8): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 7): battery=100.00, running_total=200.00
DEBUG OBJ: Recalculated battery_score=200.000 for FST 28
DEBUG OBJ: FST 28: tree_cost=95452.578, battery_cost=200.000 (weighted=2000000.0), combined=2095452.6
DEBUG OBJ: Full_trees battery_score=0.000 for FST 29
DEBUG OBJ: Recalculating for FST 29 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 5): battery=78.50, running_total=78.50
DEBUG OBJ: Terminal 1 (idx 10): battery=81.20, running_total=159.70
DEBUG OBJ: Recalculated battery_score=159.700 for FST 29
DEBUG OBJ: FST 29: tree_cost=102977.757, battery_cost=159.700 (weighted=1597000.0), combined=1699977.8
DEBUG OBJ: Full_trees battery_score=0.000 for FST 30
DEBUG OBJ: Recalculating for FST 30 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 4): battery=96.00, running_total=96.00
DEBUG OBJ: Terminal 1 (idx 5): battery=78.50, running_total=174.50
DEBUG OBJ: Recalculated battery_score=174.500 for FST 30
DEBUG OBJ: FST 30: tree_cost=165327.925, battery_cost=174.500 (weighted=1745000.0), combined=1910327.9
DEBUG OBJ: Full_trees battery_score=0.000 for FST 31
DEBUG OBJ: Recalculating for FST 31 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 6): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 0): battery=100.00, running_total=200.00
DEBUG OBJ: Recalculated battery_score=200.000 for FST 31
DEBUG OBJ: FST 31: tree_cost=170420.027, battery_cost=200.000 (weighted=2000000.0), combined=2170420.0
DEBUG OBJ: Full_trees battery_score=0.000 for FST 32
DEBUG OBJ: Recalculating for FST 32 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 13): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 4): battery=96.00, running_total=196.00
DEBUG OBJ: Recalculated battery_score=196.000 for FST 32
DEBUG OBJ: FST 32: tree_cost=179069.657, battery_cost=196.000 (weighted=1960000.0), combined=2139069.7
DEBUG OBJ: Full_trees battery_score=0.000 for FST 33
DEBUG OBJ: Recalculating for FST 33 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 5): battery=78.50, running_total=78.50
DEBUG OBJ: Terminal 1 (idx 1): battery=88.60, running_total=167.10
DEBUG OBJ: Recalculated battery_score=167.100 for FST 33
DEBUG OBJ: FST 33: tree_cost=234458.486, battery_cost=167.100 (weighted=1671000.0), combined=1905458.5
DEBUG OBJ: Full_trees battery_score=0.000 for FST 34
DEBUG OBJ: Recalculating for FST 34 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 11): battery=52.00, running_total=52.00
DEBUG OBJ: Terminal 1 (idx 9): battery=100.00, running_total=152.00
DEBUG OBJ: Recalculated battery_score=152.000 for FST 34
DEBUG OBJ: FST 34: tree_cost=235891.713, battery_cost=152.000 (weighted=1520000.0), combined=1755891.7
DEBUG OBJ: Full_trees battery_score=0.000 for FST 35
DEBUG OBJ: Recalculating for FST 35 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 9): battery=100.00, running_total=100.00
DEBUG OBJ: Terminal 1 (idx 7): battery=100.00, running_total=200.00
DEBUG OBJ: Recalculated battery_score=200.000 for FST 35
DEBUG OBJ: FST 35: tree_cost=242462.956, battery_cost=200.000 (weighted=2000000.0), combined=2242463.0
DEBUG OBJ: Full_trees battery_score=0.000 for FST 36
DEBUG OBJ: Recalculating for FST 36 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 2): battery=97.70, running_total=97.70
DEBUG OBJ: Terminal 1 (idx 11): battery=52.00, running_total=149.70
DEBUG OBJ: Recalculated battery_score=149.700 for FST 36
DEBUG OBJ: FST 36: tree_cost=258947.370, battery_cost=149.700 (weighted=1497000.0), combined=1755947.4
DEBUG OBJ: Full_trees battery_score=0.000 for FST 37
DEBUG OBJ: Recalculating for FST 37 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 19): battery=93.60, running_total=93.60
DEBUG OBJ: Terminal 1 (idx 12): battery=69.00, running_total=162.60
DEBUG OBJ: Recalculated battery_score=162.600 for FST 37
DEBUG OBJ: FST 37: tree_cost=313063.098, battery_cost=162.600 (weighted=1626000.0), combined=1939063.1
DEBUG OBJ: Full_trees battery_score=0.000 for FST 38
DEBUG OBJ: Recalculating for FST 38 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 15): battery=96.00, running_total=96.00
DEBUG OBJ: Terminal 1 (idx 19): battery=93.60, running_total=189.60
DEBUG OBJ: Recalculated battery_score=189.600 for FST 38
DEBUG OBJ: FST 38: tree_cost=314219.517, battery_cost=189.600 (weighted=1896000.0), combined=2210219.5
DEBUG OBJ: Full_trees battery_score=0.000 for FST 39
DEBUG OBJ: Recalculating for FST 39 with 2 terminals
DEBUG OBJ: Terminal 0 (idx 3): battery=96.00, running_total=96.00
DEBUG OBJ: Terminal 1 (idx 6): battery=100.00, running_total=196.00
DEBUG OBJ: Recalculated battery_score=196.000 for FST 39
DEBUG OBJ: FST 39: tree_cost=327174.269, battery_cost=196.000 (weighted=1960000.0), combined=2287174.3
DEBUG OBJ: Added penalty terms beta=1500000 for 20 not_covered variables [41-60]
DEBUG LP_MATRIX: LP has 0 rows, 60 columns after setup
DEBUG EXTRA_COEFF: Calculated extra_coeff=1 for 135 rows
DEBUG SOFT: Added not_covered_0 (RC_var 43 -> matrix_idx 40) to soft constraint 134
DEBUG MATRIX_CHECK: nzi=495, ncoeff=514, extra_coeff=1, expected=515
ERROR: Matrix coefficient count mismatch! nzi=495 != ncoeff=514 + extra_coeff=1
WARNING: Allowing discrepancy in budget mode (nzi=495 vs expected=515)
DEBUG MATRIX: Total matrix has 495 entries (nzi=495)
DEBUG MATRIX: matbeg[135] = 495 (should equal nzi)
DEBUG LP: Calling add_rows with 135 rows
DEBUG LP: Before add_rows: LP has 0 rows, 60 cols, 60 nonzeros
DEBUG LP: After add_rows: LP has 135 rows, 60 cols, 555 nonzeros
DEBUG NLPROWS: nrows=135, extra_rows=0, setting nlprows=135
 % _gst_build_initial_formulation: 0.00 seconds.
DEBUG BB: Expected nlprows=135, total rows=163
DEBUG BB: Row 0 (uid=0) has lprow=0 (included, j=0)
DEBUG BB: Row 1 (uid=1) has lprow=1 (included, j=1)
DEBUG BB: Row 2 (uid=2) has lprow=2 (included, j=2)
DEBUG BB: Row 3 (uid=3) has lprow=3 (included, j=3)
DEBUG BB: Row 4 (uid=4) has lprow=4 (included, j=4)
DEBUG BB: Row 5 (uid=5) has lprow=5 (included, j=5)
DEBUG BB: Row 6 (uid=6) has lprow=6 (included, j=6)
DEBUG BB: Row 7 (uid=7) has lprow=7 (included, j=7)
DEBUG BB: Row 8 (uid=8) has lprow=8 (included, j=8)
DEBUG BB: Row 9 (uid=9) has lprow=9 (included, j=9)
DEBUG BB: Row 10 (uid=10) has lprow=10 (included, j=10)
DEBUG BB: Row 11 (uid=11) has lprow=11 (included, j=11)
DEBUG BB: Row 12 (uid=12) has lprow=12 (included, j=12)
DEBUG BB: Row 13 (uid=13) has lprow=13 (included, j=13)
DEBUG BB: Row 14 (uid=14) has lprow=14 (included, j=14)
DEBUG BB: Row 15 (uid=15) has lprow=15 (included, j=15)
DEBUG BB: Row 16 (uid=16) has lprow=16 (included, j=16)
DEBUG BB: Row 17 (uid=17) has lprow=17 (included, j=17)
DEBUG BB: Row 18 (uid=18) has lprow=18 (included, j=18)
DEBUG BB: Row 19 (uid=19) has lprow=19 (included, j=19)
DEBUG BB: Row 20 (uid=20) has lprow=20 (included, j=20)
DEBUG BB: Row 21 (uid=21) has lprow=21 (included, j=21)
DEBUG BB: Row 22 (uid=22) has lprow=22 (included, j=22)
DEBUG BB: Row 23 (uid=23) has lprow=23 (included, j=23)
DEBUG BB: Row 24 (uid=24) has lprow=24 (included, j=24)
DEBUG BB: Row 25 (uid=25) has lprow=25 (included, j=25)
DEBUG BB: Row 26 (uid=26) has lprow=26 (included, j=26)
DEBUG BB: Row 27 (uid=27) has lprow=27 (included, j=27)
DEBUG BB: Row 28 (uid=28) has lprow=28 (included, j=28)
DEBUG BB: Row 29 (uid=29) has lprow=29 (included, j=29)
DEBUG BB: Row 30 (uid=30) has lprow=30 (included, j=30)
DEBUG BB: Row 31 (uid=31) has lprow=31 (included, j=31)
DEBUG BB: Row 32 (uid=32) has lprow=32 (included, j=32)
DEBUG BB: Row 33 (uid=33) has lprow=33 (included, j=33)
DEBUG BB: Row 34 (uid=34) has lprow=34 (included, j=34)
DEBUG BB: Row 35 (uid=35) has lprow=35 (included, j=35)
DEBUG BB: Row 36 (uid=36) has lprow=36 (included, j=36)
DEBUG BB: Row 37 (uid=37) has lprow=37 (included, j=37)
DEBUG BB: Row 38 (uid=38) has lprow=38 (included, j=38)
DEBUG BB: Row 39 (uid=39) has lprow=39 (included, j=39)
DEBUG BB: Row 40 (uid=40) has lprow=40 (included, j=40)
DEBUG BB: Row 41 (uid=41) has lprow=41 (included, j=41)
DEBUG BB: Row 42 (uid=42) has lprow=42 (included, j=42)
DEBUG BB: Row 43 (uid=43) has lprow=43 (included, j=43)
DEBUG BB: Row 44 (uid=44) has lprow=44 (included, j=44)
DEBUG BB: Row 45 (uid=45) has lprow=45 (included, j=45)
DEBUG BB: Row 46 (uid=46) has lprow=46 (included, j=46)
DEBUG BB: Row 47 (uid=47) has lprow=47 (included, j=47)
DEBUG BB: Row 48 (uid=48) has lprow=48 (included, j=48)
DEBUG BB: Row 49 (uid=49) has lprow=49 (included, j=49)
DEBUG BB: Row 50 (uid=50) has lprow=50 (included, j=50)
DEBUG BB: Row 51 (uid=51) has lprow=51 (included, j=51)
DEBUG BB: Row 52 (uid=52) has lprow=52 (included, j=52)
DEBUG BB: Row 53 (uid=53) has lprow=53 (included, j=53)
DEBUG BB: Row 54 (uid=54) has lprow=54 (included, j=54)
DEBUG BB: Row 55 (uid=55) has lprow=55 (included, j=55)
DEBUG BB: Row 56 (uid=56) has lprow=56 (included, j=56)
DEBUG BB: Row 57 (uid=57) has lprow=57 (included, j=57)
DEBUG BB: Row 58 (uid=58) has lprow=58 (included, j=58)
DEBUG BB: Row 59 (uid=59) has lprow=59 (included, j=59)
DEBUG BB: Row 60 (uid=60) has lprow=60 (included, j=60)
DEBUG BB: Row 61 (uid=61) has lprow=61 (included, j=61)
DEBUG BB: Row 62 (uid=62) has lprow=62 (included, j=62)
DEBUG BB: Row 63 (uid=63) has lprow=63 (included, j=63)
DEBUG BB: Row 64 (uid=64) has lprow=64 (included, j=64)
DEBUG BB: Row 65 (uid=65) has lprow=65 (included, j=65)
DEBUG BB: Row 66 (uid=66) has lprow=66 (included, j=66)
DEBUG BB: Row 67 (uid=67) has lprow=67 (included, j=67)
DEBUG BB: Row 68 (uid=68) has lprow=68 (included, j=68)
DEBUG BB: Row 69 (uid=69) has lprow=69 (included, j=69)
DEBUG BB: Row 70 (uid=70) has lprow=70 (included, j=70)
DEBUG BB: Row 71 (uid=71) has lprow=71 (included, j=71)
DEBUG BB: Row 72 (uid=72) has lprow=72 (included, j=72)
DEBUG BB: Row 73 (uid=73) has lprow=73 (included, j=73)
DEBUG BB: Row 74 (uid=74) has lprow=74 (included, j=74)
DEBUG BB: Row 75 (uid=75) has lprow=75 (included, j=75)
DEBUG BB: Row 76 (uid=76) has lprow=76 (included, j=76)
DEBUG BB: Row 77 (uid=77) has lprow=77 (included, j=77)
DEBUG BB: Row 78 (uid=78) has lprow=78 (included, j=78)
DEBUG BB: Row 79 (uid=79) has lprow=79 (included, j=79)
DEBUG BB: Row 80 (uid=80) has lprow=80 (included, j=80)
DEBUG BB: Row 81 (uid=81) has lprow=81 (included, j=81)
DEBUG BB: Row 82 (uid=82) has lprow=82 (included, j=82)
DEBUG BB: Row 83 (uid=83) has lprow=83 (included, j=83)
DEBUG BB: Row 84 (uid=84) has lprow=84 (included, j=84)
DEBUG BB: Row 85 (uid=85) has lprow=85 (included, j=85)
DEBUG BB: Row 86 (uid=86) has lprow=86 (included, j=86)
DEBUG BB: Row 87 (uid=87) has lprow=87 (included, j=87)
DEBUG BB: Row 88 (uid=88) has lprow=88 (included, j=88)
DEBUG BB: Row 89 (uid=89) has lprow=89 (included, j=89)
DEBUG BB: Row 90 (uid=90) has lprow=90 (included, j=90)
DEBUG BB: Row 91 (uid=91) has lprow=91 (included, j=91)
DEBUG BB: Row 92 (uid=92) has lprow=92 (included, j=92)
DEBUG BB: Row 93 (uid=93) has lprow=93 (included, j=93)
DEBUG BB: Row 94 (uid=94) has lprow=94 (included, j=94)
DEBUG BB: Row 95 (uid=95) has lprow=95 (included, j=95)
DEBUG BB: Row 96 (uid=96) has lprow=96 (included, j=96)
DEBUG BB: Row 97 (uid=97) has lprow=97 (included, j=97)
DEBUG BB: Row 98 (uid=98) has lprow=98 (included, j=98)
DEBUG BB: Row 99 (uid=99) has lprow=99 (included, j=99)
DEBUG BB: Row 100 (uid=100) has lprow=100 (included, j=100)
DEBUG BB: Row 101 (uid=101) has lprow=101 (included, j=101)
DEBUG BB: Row 102 (uid=102) has lprow=102 (included, j=102)
DEBUG BB: Row 103 (uid=103) has lprow=103 (included, j=103)
DEBUG BB: Row 104 (uid=104) has lprow=104 (included, j=104)
DEBUG BB: Row 105 (uid=105) has lprow=105 (included, j=105)
DEBUG BB: Row 106 (uid=106) has lprow=106 (included, j=106)
DEBUG BB: Row 107 (uid=107) has lprow=107 (included, j=107)
DEBUG BB: Row 108 (uid=108) has lprow=108 (included, j=108)
DEBUG BB: Row 109 (uid=109) has lprow=109 (included, j=109)
DEBUG BB: Row 110 (uid=110) has lprow=110 (included, j=110)
DEBUG BB: Row 111 (uid=111) has lprow=111 (included, j=111)
DEBUG BB: Row 112 (uid=112) has lprow=112 (included, j=112)
DEBUG BB: Row 113 (uid=113) has lprow=113 (included, j=113)
DEBUG BB: Row 114 (uid=114) has lprow=114 (included, j=114)
DEBUG BB: Row 115 (uid=115) has lprow=115 (included, j=115)
DEBUG BB: Row 116 (uid=116) has lprow=116 (included, j=116)
DEBUG BB: Row 117 (uid=117) has lprow=117 (included, j=117)
DEBUG BB: Row 118 (uid=118) has lprow=118 (included, j=118)
DEBUG BB: Row 119 (uid=119) has lprow=119 (included, j=119)
DEBUG BB: Row 120 (uid=120) has lprow=120 (included, j=120)
DEBUG BB: Row 121 (uid=121) has lprow=121 (included, j=121)
DEBUG BB: Row 122 (uid=122) has lprow=122 (included, j=122)
DEBUG BB: Row 123 (uid=123) has lprow=123 (included, j=123)
DEBUG BB: Row 124 (uid=124) has lprow=124 (included, j=124)
DEBUG BB: Row 125 (uid=125) has lprow=125 (included, j=125)
DEBUG BB: Row 126 (uid=126) has lprow=126 (included, j=126)
DEBUG BB: Row 127 (uid=127) has lprow=127 (included, j=127)
DEBUG BB: Row 128 (uid=128) has lprow=128 (included, j=128)
DEBUG BB: Row 129 (uid=129) has lprow=129 (included, j=129)
DEBUG BB: Row 130 (uid=130) has lprow=130 (included, j=130)
DEBUG BB: Row 131 (uid=131) has lprow=131 (included, j=131)
DEBUG BB: Row 132 (uid=132) has lprow=132 (included, j=132)
DEBUG BB: Row 133 (uid=133) has lprow=-1 (skipped)
DEBUG BB: Row 134 (uid=134) has lprow=-1 (skipped)
DEBUG BB: Row 135 (uid=135) has lprow=-1 (skipped)
DEBUG BB: Row 136 (uid=136) has lprow=-1 (skipped)
DEBUG BB: Row 137 (uid=137) has lprow=-1 (skipped)
DEBUG BB: Row 138 (uid=138) has lprow=-1 (skipped)
DEBUG BB: Row 139 (uid=139) has lprow=-1 (skipped)
DEBUG BB: Row 140 (uid=140) has lprow=-1 (skipped)
DEBUG BB: Row 141 (uid=141) has lprow=-1 (skipped)
DEBUG BB: Row 142 (uid=142) has lprow=-1 (skipped)
DEBUG BB: Row 143 (uid=143) has lprow=-1 (skipped)
DEBUG BB: Row 144 (uid=144) has lprow=-1 (skipped)
DEBUG BB: Row 145 (uid=145) has lprow=-1 (skipped)
DEBUG BB: Row 146 (uid=146) has lprow=-1 (skipped)
DEBUG BB: Row 147 (uid=147) has lprow=-1 (skipped)
DEBUG BB: Row 148 (uid=148) has lprow=-1 (skipped)
DEBUG BB: Row 149 (uid=149) has lprow=-1 (skipped)
DEBUG BB: Row 150 (uid=150) has lprow=-1 (skipped)
DEBUG BB: Row 151 (uid=151) has lprow=-1 (skipped)
DEBUG BB: Row 152 (uid=152) has lprow=-1 (skipped)
DEBUG BB: Row 153 (uid=153) has lprow=-1 (skipped)
DEBUG BB: Row 154 (uid=154) has lprow=-1 (skipped)
DEBUG BB: Row 155 (uid=155) has lprow=-1 (skipped)
DEBUG BB: Row 156 (uid=156) has lprow=-1 (skipped)
DEBUG BB: Row 157 (uid=157) has lprow=-1 (skipped)
DEBUG BB: Row 158 (uid=158) has lprow=-1 (skipped)
DEBUG BB: Row 159 (uid=159) has lprow=-1 (skipped)
DEBUG BB: Row 160 (uid=160) has lprow=-1 (skipped)
DEBUG BB: Row 161 (uid=161) has lprow=133 (included, j=133)
DEBUG BB: Row 162 (uid=162) has lprow=134 (included, j=134)
DEBUG BB: Found 135 actual LP rows, expected 135
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e737600
% Resuming node 0
DEBUG CONSTRNT: LP rows=135, pool->nlprows=135, pool->npend=0
DEBUG CONSTRNT: Checking 135 LP rows (pool tracks 135, total LP rows 135)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 1
DEBUG CONSTRNT: Pool row 1 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 2
DEBUG CONSTRNT: Pool row 2 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 3
DEBUG CONSTRNT: Pool row 3 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 4
DEBUG CONSTRNT: Pool row 4 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 41
DEBUG CONSTRNT: Pool row 41 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 52
DEBUG CONSTRNT: Pool row 52 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=56, expected 56
DEBUG CONSTRNT: Checking LP row 57 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=57, expected 57
DEBUG CONSTRNT: Checking LP row 58 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=58, expected 58
DEBUG CONSTRNT: Checking LP row 59 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=59, expected 59
DEBUG CONSTRNT: Checking LP row 60 -> pool row 60
DEBUG CONSTRNT: Pool row 60 has lprow=60, expected 60
DEBUG CONSTRNT: Checking LP row 61 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=61, expected 61
DEBUG CONSTRNT: Checking LP row 62 -> pool row 62
DEBUG CONSTRNT: Pool row 62 has lprow=62, expected 62
DEBUG CONSTRNT: Checking LP row 63 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=63, expected 63
DEBUG CONSTRNT: Checking LP row 64 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=64, expected 64
DEBUG CONSTRNT: Checking LP row 65 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=65, expected 65
DEBUG CONSTRNT: Checking LP row 66 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=66, expected 66
DEBUG CONSTRNT: Checking LP row 67 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=67, expected 67
DEBUG CONSTRNT: Checking LP row 68 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=68, expected 68
DEBUG CONSTRNT: Checking LP row 69 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=69, expected 69
DEBUG CONSTRNT: Checking LP row 70 -> pool row 70
DEBUG CONSTRNT: Pool row 70 has lprow=70, expected 70
DEBUG CONSTRNT: Checking LP row 71 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=71, expected 71
DEBUG CONSTRNT: Checking LP row 72 -> pool row 72
DEBUG CONSTRNT: Pool row 72 has lprow=72, expected 72
DEBUG CONSTRNT: Checking LP row 73 -> pool row 73
DEBUG CONSTRNT: Pool row 73 has lprow=73, expected 73
DEBUG CONSTRNT: Checking LP row 74 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=74, expected 74
DEBUG CONSTRNT: Checking LP row 75 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=75, expected 75
DEBUG CONSTRNT: Checking LP row 76 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=76, expected 76
DEBUG CONSTRNT: Checking LP row 77 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=77, expected 77
DEBUG CONSTRNT: Checking LP row 78 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=78, expected 78
DEBUG CONSTRNT: Checking LP row 79 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=79, expected 79
DEBUG CONSTRNT: Checking LP row 80 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=80, expected 80
DEBUG CONSTRNT: Checking LP row 81 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=81, expected 81
DEBUG CONSTRNT: Checking LP row 82 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=82, expected 82
DEBUG CONSTRNT: Checking LP row 83 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=83, expected 83
DEBUG CONSTRNT: Checking LP row 84 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=84, expected 84
DEBUG CONSTRNT: Checking LP row 85 -> pool row 85
DEBUG CONSTRNT: Pool row 85 has lprow=85, expected 85
DEBUG CONSTRNT: Checking LP row 86 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=86, expected 86
DEBUG CONSTRNT: Checking LP row 87 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=87, expected 87
DEBUG CONSTRNT: Checking LP row 88 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=88, expected 88
DEBUG CONSTRNT: Checking LP row 89 -> pool row 89
DEBUG CONSTRNT: Pool row 89 has lprow=89, expected 89
DEBUG CONSTRNT: Checking LP row 90 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=90, expected 90
DEBUG CONSTRNT: Checking LP row 91 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=91, expected 91
DEBUG CONSTRNT: Checking LP row 92 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=92, expected 92
DEBUG CONSTRNT: Checking LP row 93 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=93, expected 93
DEBUG CONSTRNT: Checking LP row 94 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=94, expected 94
DEBUG CONSTRNT: Checking LP row 95 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=95, expected 95
DEBUG CONSTRNT: Checking LP row 96 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=96, expected 96
DEBUG CONSTRNT: Checking LP row 97 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=97, expected 97
DEBUG CONSTRNT: Checking LP row 98 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=98, expected 98
DEBUG CONSTRNT: Checking LP row 99 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=99, expected 99
DEBUG CONSTRNT: Checking LP row 100 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=100, expected 100
DEBUG CONSTRNT: Checking LP row 101 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=101, expected 101
DEBUG CONSTRNT: Checking LP row 102 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=102, expected 102
DEBUG CONSTRNT: Checking LP row 103 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=103, expected 103
DEBUG CONSTRNT: Checking LP row 104 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=104, expected 104
DEBUG CONSTRNT: Checking LP row 105 -> pool row 105
DEBUG CONSTRNT: Pool row 105 has lprow=105, expected 105
DEBUG CONSTRNT: Checking LP row 106 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=106, expected 106
DEBUG CONSTRNT: Checking LP row 107 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=107, expected 107
DEBUG CONSTRNT: Checking LP row 108 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=108, expected 108
DEBUG CONSTRNT: Checking LP row 109 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=109, expected 109
DEBUG CONSTRNT: Checking LP row 110 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=110, expected 110
DEBUG CONSTRNT: Checking LP row 111 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=111, expected 111
DEBUG CONSTRNT: Checking LP row 112 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=112, expected 112
DEBUG CONSTRNT: Checking LP row 113 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=113, expected 113
DEBUG CONSTRNT: Checking LP row 114 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=114, expected 114
DEBUG CONSTRNT: Checking LP row 115 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=115, expected 115
DEBUG CONSTRNT: Checking LP row 116 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=116, expected 116
DEBUG CONSTRNT: Checking LP row 117 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=117, expected 117
DEBUG CONSTRNT: Checking LP row 118 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=118, expected 118
DEBUG CONSTRNT: Checking LP row 119 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=119, expected 119
DEBUG CONSTRNT: Checking LP row 120 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=120, expected 120
DEBUG CONSTRNT: Checking LP row 121 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=121, expected 121
DEBUG CONSTRNT: Checking LP row 122 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=122, expected 122
DEBUG CONSTRNT: Checking LP row 123 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=123, expected 123
DEBUG CONSTRNT: Checking LP row 124 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=124, expected 124
DEBUG CONSTRNT: Checking LP row 125 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=125, expected 125
DEBUG CONSTRNT: Checking LP row 126 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=126, expected 126
DEBUG CONSTRNT: Checking LP row 127 -> pool row 127
DEBUG CONSTRNT: Pool row 127 has lprow=127, expected 127
DEBUG CONSTRNT: Checking LP row 128 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=128, expected 128
DEBUG CONSTRNT: Checking LP row 129 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=129, expected 129
DEBUG CONSTRNT: Checking LP row 130 -> pool row 130
DEBUG CONSTRNT: Pool row 130 has lprow=130, expected 130
DEBUG CONSTRNT: Checking LP row 131 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=131, expected 131
DEBUG CONSTRNT: Checking LP row 132 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=132, expected 132
DEBUG CONSTRNT: Checking LP row 133 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=133, expected 133
DEBUG CONSTRNT: Checking LP row 134 -> pool row 162
DEBUG CONSTRNT: Pool row 162 has lprow=134, expected 134
 % @PAP adding 135 rows, 494 nz to LP
DEBUG BB: Processing node 0, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=149, theta=6.333333, up=1.000000
ITER 2: row=1, varin=155, theta=4.000000, up=1.000000
ITER 3: row=1, varin=156, theta=3.000000, up=1.000000
ITER 4: row=1, varin=146, theta=4.000000, up=1.000000
ITER 5: row=1, varin=145, theta=3.000000, up=1.000000
ITER 6: row=1, varin=152, theta=1.333333, up=1.000000
ITER 7: row=1, varin=137, theta=0.500000, up=1.000000
ITER 8: row=134, varin=145, theta=8.633088, up=1.000000
ITER 9: row=134, varin=152, theta=7.933111, up=1.000000
ITER 10: row=134, varin=156, theta=4.639031, up=1.000000
LP PHASE: Switching to primal (iter=43)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=135)
DEBUG SOLUTION: LP solution array indices: FST[136-175], not_covered[176-195]
DEBUG SOLUTION: lp->best_solution[0] = 27529871.515735
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 0.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 3.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 135 rows, 60 cols, 554 nonzeros, 61 slack, 74 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 61 slack rows
  % @PAP adding 3 rows, 17 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=75, varin=79, theta=2.092081, up=1.000000
ITER 2: row=75, varin=88, theta=0.747962, up=1.000000
ITER 3: row=20, varin=122, theta=1.000000, up=1.000000
ITER 4: row=25, varin=123, theta=1.000000, up=1.000000
ITER 5: row=43, varin=128, theta=1.000000, up=1.000000
ITER 6: row=1, varin=79, theta=0.543625, up=1.000000
ITER 7: row=48, varin=52, theta=6.310122, up=999999999999999983222784.000000
ITER 8: row=29, varin=25, theta=0.418210, up=999999999999999983222784.000000
ITER 9: row=23, varin=98, theta=0.110670, up=1.000000
ITER 10: row=57, varin=23, theta=2.788678, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=15)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=77)
DEBUG SOLUTION: LP solution array indices: FST[78-117], not_covered[118-137]
DEBUG SOLUTION: lp->best_solution[0] = 27690679.795156
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 5.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 77 rows, 60 cols, 361 nonzeros, 7 slack, 70 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 7 slack rows
  % @PAP adding 3 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=72, varin=128, theta=1.000000, up=1.000000
ITER 2: row=71, varin=18, theta=2.408634, up=999999999999999983222784.000000
ITER 3: row=73, varin=133, theta=0.055961, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=73)
DEBUG SOLUTION: LP solution array indices: FST[74-113], not_covered[114-133]
DEBUG SOLUTION: lp->best_solution[0] = 27721197.232108
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 5.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.552313
DEBUG SOLUTION: lp->best_solution[13] = 0.552313
DEBUG SOLUTION: lp->best_solution[14] = 0.552313
  % @PL 73 rows, 60 cols, 356 nonzeros, 22 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 22 slack rows
  % @PAP adding 4 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=53, varin=51, theta=2.096718, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 27727469.233615
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 5.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 55 rows, 60 cols, 305 nonzeros, 3 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % Node 0 LP 1 Solution, length = 27727469.233615, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.200000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.299531 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.200000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.800000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.299531 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.700469 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.700469 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.200000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.200000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.200000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.800000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.700469 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.700469 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.700469 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.200000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.200000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.700469 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=27727469.233615, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.00  27.72746923361545512421 99.9000000000
 % @LN 0.00  27.72746923361545512421 99.9000000000
DEBUG CG: Second cutoff check: z=27727469.233615, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 0 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 0
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.200000
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.200000)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.299531
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.299531)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.200000
DEBUG CAREFUL: Adding var 13 to fractional list (xi=0.200000)
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.800000
DEBUG CAREFUL: Adding var 19 to fractional list (xi=0.800000)
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.299531
DEBUG CAREFUL: Adding var 20 to fractional list (xi=0.299531)
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 13
DEBUG CAREFUL: Calling compare_branch_vars for var 13
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 13
DEBUG CAREFUL: New best var: 13
DEBUG CAREFUL: Testing fvar[1] = var 20
DEBUG CAREFUL: Calling compare_branch_vars for var 20
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 20
DEBUG CAREFUL: New best var: 20
DEBUG CAREFUL: Testing fvar[2] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[3] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[4] = var 19
DEBUG CAREFUL: Calling compare_branch_vars for var 19
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 19
  % Initial guess is x20, Z0 = 27727469.2336155        , Z1 = 27829209.3515165        

DEBUG EVAL: Testing var 13 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=31, varin=68, theta=0.250000, up=1.000000
DEBUG EVAL: Branch var 13 = 0 gives z=27766278.544636
  % 	x13 = 0,	Z0 = 27766278.5446356        
DEBUG EVAL: First branch cutoff check: z=27766278.544636, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 13 = 1
ITER 1: row=31, varin=23, theta=16.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=49, theta=1.500000, up=999999999999999983222784.000000
ITER 3: row=14, varin=51, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=24, varin=12, theta=0.110487, up=999999999999999983222784.000000
ITER 5: row=12, varin=31, theta=0.507093, up=999999999999999983222784.000000
ITER 6: row=45, varin=26, theta=0.507093, up=999999999999999983222784.000000
  % 	x13 = 1,	Z1 = 27775835.3707984        
DEBUG EVAL: Second branch cutoff check: z=27775835.370798, best_z=INF, threshold=INF
  %   New best:  x13, Z = 27766278.5446356        
DEBUG EVAL: Testing var 20 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=12, varin=23, theta=-9.647274, up=999999999999999983222784.000000
ITER 2: row=12, varin=49, theta=3.074277, up=999999999999999983222784.000000
ITER 3: row=14, varin=32, theta=2.241797, up=999999999999999983222784.000000
ITER 4: row=52, varin=19, theta=2.555122, up=999999999999999983222784.000000
ITER 5: row=17, varin=50, theta=2.450101, up=999999999999999983222784.000000
ITER 6: row=32, varin=14, theta=1.559405, up=999999999999999983222784.000000
ITER 7: row=1, varin=46, theta=1.038686, up=999999999999999983222784.000000
ITER 8: row=25, varin=68, theta=0.564821, up=1.000000
ITER 9: row=31, varin=65, theta=0.885628, up=1.000000
ITER 10: row=25, varin=74, theta=3.470453, up=1.000000
DEBUG EVAL: Branch var 20 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x20 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=12, varin=51, theta=0.791963, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
ITER 2: row=1, varin=23, theta=4.000000, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 27730596.789380
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 5.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 52 rows, 60 cols, 287 nonzeros, 13 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 13 slack rows
   % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=55, theta=6.333333, up=1.000000
ITER 2: row=1, varin=61, theta=4.000000, up=1.000000
ITER 3: row=1, varin=52, theta=6.000000, up=1.000000
ITER 4: row=1, varin=51, theta=5.000000, up=1.000000
ITER 5: row=1, varin=58, theta=2.666667, up=1.000000
ITER 6: row=1, varin=43, theta=2.500000, up=1.000000
ITER 7: row=1, varin=57, theta=1.000000, up=1.000000
ITER 8: row=34, varin=51, theta=6.714274, up=1.000000
ITER 9: row=34, varin=82, theta=16.154920, up=1.000000
ITER 10: row=34, varin=83, theta=15.154920, up=1.000000
LP PHASE: Switching to primal (iter=57)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 27735063.344511
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 5.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 41 rows, 60 cols, 261 nonzeros, 1 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 0 at  27.73506334451108301664
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e737600
% @LO 0.00  27.72746923361545512421 99.9000000000
% @LN 0.00  27.73506334451108301664 99.9000000000
% Resuming node 0 at  27.73506334451108301664
DEBUG CONSTRNT: LP rows=40, pool->nlprows=40, pool->npend=0
DEBUG CONSTRNT: Checking 40 LP rows (pool tracks 40, total LP rows 40)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=39, expected 39
 % @PAP adding 40 rows, 195 nz to LP
DEBUG BB: Processing node 0, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 0 LP 2 Solution, length = 27735063.344511, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.532430 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.383108 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.383108 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.383108 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.616892 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.467570 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.467570 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.383108 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.383108 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.383108 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.467570 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.616892 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.616892 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.616892 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.383108 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.383108 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.616892 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=27735063.344511, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27735063.344511, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 0 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 0
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.532430
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.532430)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.383108
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.383108)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.383108
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.383108)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.383108
DEBUG CAREFUL: Adding var 13 to fractional list (xi=0.383108)
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.616892
DEBUG CAREFUL: Adding var 19 to fractional list (xi=0.616892)
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 9
DEBUG CAREFUL: New best var: 9
DEBUG CAREFUL: Testing fvar[1] = var 19
DEBUG CAREFUL: Calling compare_branch_vars for var 19
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 19
DEBUG CAREFUL: Testing fvar[2] = var 13
DEBUG CAREFUL: Calling compare_branch_vars for var 13
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 13
DEBUG CAREFUL: New best var: 13
DEBUG CAREFUL: Testing fvar[3] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[4] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x13, Z0 = 27766278.5446356        , Z1 = 27775835.3707984        

DEBUG EVAL: Testing var 9 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=13, varin=20, theta=1.138728, up=999999999999999983222784.000000
ITER 2: row=14, varin=21, theta=1.164098, up=999999999999999983222784.000000
ITER 3: row=38, varin=13, theta=0.239595, up=999999999999999983222784.000000
ITER 4: row=19, varin=26, theta=0.175274, up=999999999999999983222784.000000
ITER 5: row=21, varin=14, theta=0.264191, up=999999999999999983222784.000000
ITER 6: row=34, varin=35, theta=0.130636, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 9 = 1 gives z=27844984.063877
  % 	x9 = 1,	Z1 = 27844984.0638767        
DEBUG EVAL: First branch cutoff check: z=27844984.063877, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 0
ITER 1: row=13, varin=38, theta=0.916879, up=999999999999999983222784.000000
ITER 2: row=1, varin=40, theta=0.532641, up=999999999999999983222784.000000
  % 	x9 = 0,	Z0 = 27748442.1884278        
DEBUG EVAL: Second branch cutoff check: z=27748442.188428, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 19 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=16, varin=20, theta=0.836002, up=999999999999999983222784.000000
ITER 2: row=14, varin=53, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 19 = 1 gives z=27795153.904716
  % 	x19 = 1,	Z1 = 27795153.9047164        
DEBUG EVAL: First branch cutoff check: z=27795153.904716, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 19 = 0
ITER 1: row=16, varin=38, theta=1.059659, up=999999999999999983222784.000000
ITER 2: row=1, varin=40, theta=0.856477, up=999999999999999983222784.000000
ITER 3: row=13, varin=20, theta=0.507093, up=999999999999999983222784.000000
ITER 4: row=35, varin=16, theta=0.507093, up=999999999999999983222784.000000
  % 	x19 = 0,	Z0 = 27775835.3707984        
DEBUG EVAL: Second branch cutoff check: z=27775835.370798, best_z=INF, threshold=INF
  %   New best:  x19, Z = 27775835.3707984        
DEBUG EVAL: Testing var 13 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=20, varin=20, theta=0.836002, up=999999999999999983222784.000000
ITER 2: row=14, varin=53, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 13 = 0 gives z=27795153.904716
  % 	x13 = 0,	Z0 = 27795153.9047164        
DEBUG EVAL: First branch cutoff check: z=27795153.904716, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 13 = 1
ITER 1: row=20, varin=38, theta=1.059659, up=999999999999999983222784.000000
ITER 2: row=1, varin=40, theta=0.856477, up=999999999999999983222784.000000
ITER 3: row=13, varin=20, theta=0.507093, up=999999999999999983222784.000000
ITER 4: row=35, varin=16, theta=0.507093, up=999999999999999983222784.000000
  % 	x13 = 1,	Z1 = 27775835.3707984        
DEBUG EVAL: Second branch cutoff check: z=27775835.370798, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 1 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=38, theta=0.351915, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 1 gives z=27738035.739409
  % 	x1 = 1,	Z1 = 27738035.7394088        
DEBUG EVAL: First branch cutoff check: z=27738035.739409, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=21, varin=38, theta=0.916879, up=999999999999999983222784.000000
ITER 2: row=1, varin=21, theta=0.399072, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 0 gives z=27752407.680961
  % 	x10 = 0,	Z0 = 27752407.6809611        
DEBUG EVAL: First branch cutoff check: z=27752407.680961, best_z=INF, threshold=INF
  % Best branch is x19, Z0 = 27775835.3707984        , Z1 = 27795153.9047164        

DEBUG CAREFUL: Final result - returning best.var = 19
DEBUG BB: Branching variable chosen: j=19
 % @NC    1    0	x19 = 0	27775835.370798
 % @NC    2    0	x19 = 1	27795153.904716
 %       0     2 27735063.3445               27775835.3708
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e743b80
% @LO 0.00  27.73506334451108301664 99.9000000000
% @LN 0.00  27.77583537079840425577 99.9000000000
% Resuming node 1 at  27.77583537079840425577
DEBUG CONSTRNT: LP rows=40, pool->nlprows=40, pool->npend=0
DEBUG CONSTRNT: Checking 40 LP rows (pool tracks 40, total LP rows 40)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=39, expected 39
 % @PAP adding 40 rows, 195 nz to LP
DEBUG BB: Processing node 1, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=16, varin=38, theta=1.059659, up=999999999999999983222784.000000
ITER 2: row=1, varin=40, theta=0.856477, up=999999999999999983222784.000000
ITER 3: row=13, varin=20, theta=0.507093, up=999999999999999983222784.000000
ITER 4: row=35, varin=16, theta=0.507093, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 27775835.370798
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 5.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 255 nonzeros, 3 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 5 rows, 26 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=17, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=41, varin=97, theta=1.492907, up=1.000000
ITER 3: row=41, varin=55, theta=0.139507, up=1.000000
ITER 4: row=45, varin=18, theta=0.089605, up=999999999999999983222784.000000
ITER 5: row=20, varin=97, theta=1.000000, up=1.000000
ITER 6: row=44, varin=45, theta=11.294432, up=999999999999999983222784.000000
ITER 7: row=40, varin=61, theta=0.430350, up=1.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 27893251.217151
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 5.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 281 nonzeros, 8 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 8 slack rows
  % @PAP adding 4 rows, 16 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=43, theta=1.421179, up=1.000000
ITER 2: row=38, varin=58, theta=0.146846, up=1.000000
ITER 3: row=8, varin=28, theta=0.167453, up=999999999999999983222784.000000
ITER 4: row=40, varin=56, theta=0.129046, up=1.000000
ITER 5: row=41, varin=11, theta=0.752633, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 27905502.366296
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.811842
DEBUG SOLUTION: lp->best_solution[7] = 0.811842
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.811842
DEBUG SOLUTION: lp->best_solution[10] = 0.811842
DEBUG SOLUTION: lp->best_solution[11] = 4.247367
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 41 rows, 60 cols, 260 nonzeros, 5 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 1 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=37, varin=24, theta=0.114223, up=999999999999999983222784.000000
ITER 2: row=6, varin=39, theta=0.628352, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 27920274.530667
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 37 rows, 60 cols, 252 nonzeros, 3 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=35, varin=33, theta=0.769664, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=35)
DEBUG SOLUTION: LP solution array indices: FST[36-75], not_covered[76-95]
DEBUG SOLUTION: lp->best_solution[0] = 27926648.307409
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 35 rows, 60 cols, 245 nonzeros, 1 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 1 LP 1 Solution, length = 27926648.307409, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.539328 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.384832 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.384832 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.615168 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.192416 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.192416 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.460672 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.460672 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.384832 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.384832 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.384832 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.460672 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.384832 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.615168 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.615168 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.807584 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.807584 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.615168 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=27926648.307409, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 1 at  27.92664830740919867935
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e747c80
% @LO 0.00  27.77583537079840425577 99.9000000000
% @LN 0.00  27.79515390471636138159 99.9000000000
% Resuming node 2 at  27.79515390471636138159
DEBUG CONSTRNT: LP rows=34, pool->nlprows=34, pool->npend=0
DEBUG CONSTRNT: Checking 34 LP rows (pool tracks 34, total LP rows 34)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=33, expected 33
 % @PAP adding 40 rows, 195 nz to LP
DEBUG BB: Processing node 2, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=16, varin=20, theta=0.836002, up=999999999999999983222784.000000
ITER 2: row=14, varin=53, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 27795153.904716
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 5.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 255 nonzeros, 1 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=44, theta=0.500000, up=1.000000
ITER 2: row=2, varin=61, theta=0.333333, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 27819026.258634
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 5.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 267 nonzeros, 1 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 7 rows, 33 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=57, theta=0.555556, up=1.000000
ITER 2: row=7, varin=55, theta=0.444444, up=1.000000
ITER 3: row=6, varin=68, theta=0.333333, up=1.000000
ITER 4: row=46, varin=96, theta=0.038462, up=1.000000
ITER 5: row=48, varin=11, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 27863647.935364
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.666667
DEBUG SOLUTION: lp->best_solution[9] = 0.666667
DEBUG SOLUTION: lp->best_solution[10] = 0.666667
DEBUG SOLUTION: lp->best_solution[11] = 4.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 298 nonzeros, 5 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=102, theta=0.018585, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 27865393.755917
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.985545
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 288 nonzeros, 4 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=47, theta=0.103930, up=1.000000
ITER 2: row=16, varin=8, theta=0.194243, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 27875993.082630
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.805757
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 284 nonzeros, 3 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=14, theta=0.300114, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 27881037.306394
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.699886
  % @PL 43 rows, 60 cols, 277 nonzeros, 1 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 2 LP 1 Solution, length = 27881037.306394, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.333333 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.333333 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.333333 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.033220 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.666667 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.666667 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.666667 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.966780 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.966780 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=27881037.306394, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.00  27.79515390471636138159 99.9000000000
 % @LN 0.00  27.88103730639400268387 99.9000000000
DEBUG CG: Second cutoff check: z=27881037.306394, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 2 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 2
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.333333
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.333333
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.333333
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.033220
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.033220)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 9
DEBUG CAREFUL: New best var: 9
DEBUG CAREFUL: Testing fvar[1] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 5
DEBUG CAREFUL: New best var: 5
DEBUG CAREFUL: Testing fvar[2] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
DEBUG CAREFUL: Testing fvar[3] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x5, Z0 = 27881037.306394         , Z1 = 27952870.6060613        

DEBUG EVAL: Testing var 9 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=72, theta=1.000000, up=1.000000
ITER 2: row=18, varin=84, theta=0.209132, up=1.000000
DEBUG EVAL: Branch var 9 = 0 gives z=27888546.257883
  % 	x9 = 0,	Z0 = 27888546.2578834        
DEBUG EVAL: First branch cutoff check: z=27888546.257883, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 1
ITER 1: row=7, varin=41, theta=0.837607, up=999999999999999983222784.000000
ITER 2: row=25, varin=14, theta=0.896000, up=999999999999999983222784.000000
ITER 3: row=18, varin=40, theta=1.346908, up=999999999999999983222784.000000
ITER 4: row=29, varin=38, theta=1.286630, up=999999999999999983222784.000000
ITER 5: row=17, varin=8, theta=1.443881, up=999999999999999983222784.000000
ITER 6: row=8, varin=72, theta=1.599567, up=1.000000
ITER 7: row=8, varin=96, theta=0.174483, up=1.000000
ITER 8: row=25, varin=69, theta=0.547758, up=1.000000
ITER 9: row=35, varin=14, theta=0.717268, up=999999999999999983222784.000000
ITER 10: row=14, varin=6, theta=0.392683, up=999999999999999983222784.000000
  % 	x9 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: Second branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=7, varin=72, theta=1.000000, up=1.000000
ITER 2: row=18, varin=84, theta=0.209132, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 27888546.257883
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.790868
DEBUG SOLUTION: lp->best_solution[4] = 0.790868
DEBUG SOLUTION: lp->best_solution[5] = 2.581736
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 42 rows, 60 cols, 275 nonzeros, 3 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 3 slack rows
   % @PAP adding 9 rows, 30 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=33, theta=1.884615, up=999999999999999983222784.000000
ITER 2: row=48, varin=59, theta=1.269231, up=1.000000
ITER 3: row=48, varin=3, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=36, varin=52, theta=0.538462, up=1.000000
ITER 5: row=40, varin=28, theta=0.076628, up=999999999999999983222784.000000
ITER 6: row=39, varin=26, theta=0.581041, up=999999999999999983222784.000000
ITER 7: row=36, varin=44, theta=0.094113, up=999999999999999983222784.000000
ITER 8: row=32, varin=59, theta=0.078951, up=1.000000
ITER 9: row=47, varin=11, theta=0.050208, up=999999999999999983222784.000000
ITER 10: row=11, varin=48, theta=0.171457, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=10)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 27949250.257617
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 3.000000
   % @PL 48 rows, 60 cols, 297 nonzeros, 3 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 3 slack rows
   % @PAP adding 1 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=36, theta=0.016960, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 27949273.521088
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 3.000000
   % @PL 46 rows, 60 cols, 291 nonzeros, 2 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
   % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=31, theta=0.069239, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 27950043.075342
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 3.000000
   % @PL 45 rows, 60 cols, 281 nonzeros, 1 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 2 at  27.95004307534177812045
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e743b80
% @LO 0.00  27.88103730639400268387 99.9000000000
% @LN 0.00  27.92664830740919867935 99.9000000000
% Resuming node 1 at  27.92664830740919867935
DEBUG CONSTRNT: LP rows=44, pool->nlprows=44, pool->npend=0
DEBUG CONSTRNT: Checking 44 LP rows (pool tracks 44, total LP rows 44)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=43, expected 43
 % @PAP adding 34 rows, 178 nz to LP
DEBUG BB: Processing node 1, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 1 LP 2 Solution, length = 27926648.307409, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.539328 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.384832 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.384832 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.615168 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.192416 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.192416 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.460672 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.460672 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.384832 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.384832 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.384832 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.460672 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.384832 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.615168 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.615168 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.807584 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.807584 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.615168 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=27926648.307409, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27926648.307409, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 1 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 1
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.539328
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.539328)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.384832
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.384832)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.384832
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.384832)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.615168
DEBUG CAREFUL: Adding var 13 to fractional list (xi=0.615168)
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.192416
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.192416)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.192416
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.192416)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 14
DEBUG CAREFUL: New best var: 14
DEBUG CAREFUL: Testing fvar[1] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[2] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[3] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[4] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 15
DEBUG CAREFUL: Testing fvar[5] = var 13
DEBUG CAREFUL: Calling compare_branch_vars for var 13
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 13
  % Initial guess is x14, Z0 = 27926648.3074092        , Z1 = 28029521.3066641        

DEBUG EVAL: Testing var 14 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=24, varin=32, theta=1.636155, up=999999999999999983222784.000000
ITER 2: row=25, varin=33, theta=0.944560, up=999999999999999983222784.000000
ITER 3: row=1, varin=27, theta=0.961312, up=999999999999999983222784.000000
ITER 4: row=8, varin=12, theta=0.136693, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 14 = 1 gives z=28029521.306664
  % 	x14 = 1,	Z1 = 28029521.3066641        
DEBUG EVAL: First branch cutoff check: z=28029521.306664, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 14 = 0
ITER 1: row=24, varin=51, theta=0.760034, up=1.000000
ITER 2: row=1, varin=34, theta=0.139316, up=999999999999999983222784.000000
  % 	x14 = 0,	Z0 = 27936562.4992874        
DEBUG EVAL: Second branch cutoff check: z=27936562.499287, best_z=INF, threshold=INF
  %   New best:  x14, Z = 27936562.4992874        
DEBUG EVAL: Testing var 1 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=51, theta=0.472649, up=1.000000
DEBUG EVAL: Branch var 1 = 1 gives z=27932112.850093
  % 	x1 = 1,	Z1 = 27932112.8500934        
DEBUG EVAL: First branch cutoff check: z=27932112.850093, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=13, varin=51, theta=0.760034, up=1.000000
ITER 2: row=1, varin=13, theta=0.399666, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 0 gives z=27950028.115793
  % 	x10 = 0,	Z0 = 27950028.1157934        
DEBUG EVAL: First branch cutoff check: z=27950028.115793, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 1
ITER 1: row=13, varin=27, theta=0.658004, up=999999999999999983222784.000000
ITER 2: row=9, varin=33, theta=0.240166, up=999999999999999983222784.000000
  % 	x10 = 1,	Z1 = 27944951.4679715        
DEBUG EVAL: Second branch cutoff check: z=27944951.467972, best_z=INF, threshold=INF
  %   New best:  x10, Z = 27944951.4679715        
DEBUG EVAL: Testing var 9 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=8, varin=51, theta=0.760034, up=1.000000
ITER 2: row=1, varin=27, theta=0.202135, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 9 = 0 gives z=27936613.535012
  % 	x9 = 0,	Z0 = 27936613.5350121        
DEBUG EVAL: First branch cutoff check: z=27936613.535012, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 15 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=25, varin=34, theta=1.399230, up=999999999999999983222784.000000
ITER 2: row=24, varin=33, theta=0.693147, up=999999999999999983222784.000000
ITER 3: row=1, varin=27, theta=0.279487, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 15 = 1 gives z=27994674.180123
  % 	x15 = 1,	Z1 = 27994674.1801235        
DEBUG EVAL: First branch cutoff check: z=27994674.180123, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 15 = 0
ITER 1: row=25, varin=51, theta=0.760034, up=1.000000
ITER 2: row=1, varin=27, theta=0.202135, up=999999999999999983222784.000000
  % 	x15 = 0,	Z0 = 27936613.5350121        
DEBUG EVAL: Second branch cutoff check: z=27936613.535012, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 13 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=12, varin=47, theta=1.104415, up=1.000000
ITER 2: row=12, varin=27, theta=0.558882, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 13 = 1 gives z=27983109.537543
  % 	x13 = 1,	Z1 = 27983109.5375433        
DEBUG EVAL: First branch cutoff check: z=27983109.537543, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 13 = 0
ITER 1: row=12, varin=51, theta=1.246125, up=1.000000
ITER 2: row=12, varin=33, theta=0.182752, up=999999999999999983222784.000000
ITER 3: row=1, varin=27, theta=0.744363, up=999999999999999983222784.000000
ITER 4: row=8, varin=25, theta=0.299579, up=999999999999999983222784.000000
ITER 5: row=32, varin=34, theta=0.221537, up=999999999999999983222784.000000
ITER 6: row=24, varin=51, theta=0.234995, up=1.000000
  % 	x13 = 0,	Z0 = 27965864.2960561        
DEBUG EVAL: Second branch cutoff check: z=27965864.296056, best_z=INF, threshold=INF
  %   New best:  x13, Z = 27965864.2960561        
  % Best branch is x13, Z0 = 27965864.2960561        , Z1 = 27983109.5375433        

DEBUG CAREFUL: Final result - returning best.var = 13
DEBUG BB: Branching variable chosen: j=13
 % @NC    3    1	x13 = 0	27965864.296056
 % @NC    4    1	x13 = 1	27983109.537543
 %       1     3 27926648.3074               27950043.0753   x19 D     0     1
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e747c80
% @LO 0.00  27.92664830740919867935 99.9000000000
% @LN 0.00  27.95004307534177812045 99.9000000000
% Resuming node 2 at  27.95004307534177812045
DEBUG CONSTRNT: LP rows=34, pool->nlprows=34, pool->npend=0
DEBUG CONSTRNT: Checking 34 LP rows (pool tracks 34, total LP rows 34)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=33, expected 33
 % @PAP adding 44 rows, 213 nz to LP
DEBUG BB: Processing node 2, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 2 LP 2 Solution, length = 27950043.075342, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.500000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.500000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.041544 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.013848 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.013848 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.986152 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.986152 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.958456 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.958456 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.986152 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.958456 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=27950043.075342, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=27950043.075342, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 2 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 2
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.500000
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.500000
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.041544
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.041544)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.013848
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.013848)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.013848
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.013848)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 5
DEBUG CAREFUL: New best var: 5
DEBUG CAREFUL: Testing fvar[1] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
DEBUG CAREFUL: Testing fvar[2] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
DEBUG CAREFUL: Testing fvar[3] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[4] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x18, Z0 = 27950043.0753418        , Z1 = 28275991.3055268        

DEBUG EVAL: Testing var 5 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=32, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=3, varin=4, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=15, varin=47, theta=0.627042, up=1.000000
ITER 4: row=11, varin=48, theta=0.735039, up=1.000000
ITER 5: row=22, varin=44, theta=0.293195, up=999999999999999983222784.000000
ITER 6: row=33, varin=35, theta=0.775636, up=999999999999999983222784.000000
ITER 7: row=35, varin=74, theta=1.916236, up=1.000000
ITER 8: row=35, varin=5, theta=0.299549, up=999999999999999983222784.000000
ITER 9: row=39, varin=33, theta=0.388348, up=999999999999999983222784.000000
ITER 10: row=38, varin=74, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 5 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x5 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=43, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 27968539.036936
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 3.000000
   % @PL 44 rows, 60 cols, 273 nonzeros, 1 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 5 rows, 22 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=51, theta=0.074873, up=1.000000
ITER 2: row=46, varin=48, theta=1.445981, up=999999999999999983222784.000000
ITER 3: row=11, varin=52, theta=0.278243, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 27996751.578829
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 3.000000
   % @PL 48 rows, 60 cols, 291 nonzeros, 2 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
   % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=79, theta=0.093242, up=1.000000
ITER 2: row=38, varin=76, theta=0.089175, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28005635.664457
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 3.000000
   % @PL 49 rows, 60 cols, 281 nonzeros, 0 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 2 at  28.00563566445710250719
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e737600
% @LO 0.00  27.95004307534177812045 99.9000000000
% @LN 0.00  27.96586429605614299021 99.9000000000
% Resuming node 3 at  27.96586429605614299021
DEBUG CONSTRNT: LP rows=49, pool->nlprows=49, pool->npend=0
DEBUG CONSTRNT: Checking 49 LP rows (pool tracks 49, total LP rows 49)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=48, expected 48
 % @PAP adding 34 rows, 178 nz to LP
DEBUG BB: Processing node 3, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=12, varin=51, theta=1.246125, up=1.000000
ITER 2: row=12, varin=33, theta=0.182752, up=999999999999999983222784.000000
ITER 3: row=1, varin=27, theta=0.744363, up=999999999999999983222784.000000
ITER 4: row=8, varin=25, theta=0.299579, up=999999999999999983222784.000000
ITER 5: row=32, varin=34, theta=0.221537, up=999999999999999983222784.000000
ITER 6: row=24, varin=51, theta=0.234995, up=1.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=34)
DEBUG SOLUTION: LP solution array indices: FST[35-74], not_covered[75-94]
DEBUG SOLUTION: lp->best_solution[0] = 27965864.296056
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 34 rows, 60 cols, 238 nonzeros, 3 slack, 31 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 6 rows, 40 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=32, varin=52, theta=0.721196, up=1.000000
ITER 2: row=31, varin=95, theta=0.487627, up=1.000000
ITER 3: row=33, varin=26, theta=0.098083, up=999999999999999983222784.000000
ITER 4: row=35, varin=28, theta=0.077435, up=999999999999999983222784.000000
ITER 5: row=36, varin=32, theta=0.103605, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 27995917.301846
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 37 rows, 60 cols, 262 nonzeros, 4 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 9 rows, 32 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=52, theta=0.850727, up=1.000000
ITER 2: row=33, varin=12, theta=0.109467, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 27997435.073489
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.890533
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 286 nonzeros, 8 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 8 slack rows
  % @PAP adding 5 rows, 10 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=32, theta=6.883157, up=999999999999999983222784.000000
ITER 2: row=37, varin=28, theta=1.260561, up=999999999999999983222784.000000
ITER 3: row=26, varin=30, theta=1.266980, up=999999999999999983222784.000000
ITER 4: row=35, varin=25, theta=0.140648, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 28010127.036346
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 39 rows, 60 cols, 270 nonzeros, 6 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 7 rows, 24 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=37, varin=32, theta=0.948156, up=999999999999999983222784.000000
ITER 2: row=33, varin=98, theta=0.904984, up=1.000000
ITER 3: row=36, varin=27, theta=2.188069, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28031012.927167
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 259 nonzeros, 4 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=37, varin=39, theta=0.069211, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 28031527.090714
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 37 rows, 60 cols, 234 nonzeros, 0 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 3 LP 1 Solution, length = 28031527.090714, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.930789 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.310263 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.310263 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.310263 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.310263 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.310263 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.689737 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.069211 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.069211 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.689737 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.689737 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.689737 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.069211 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.689737 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.689737 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.689737 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.689737 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.689737 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.689737 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28031527.090714, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 3 at  28.03152709071384407480
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e74a950
% @LO 0.00  27.96586429605614299021 99.9000000000
% @LN 0.00  27.98310953754325680620 99.9000000000
% Resuming node 4 at  27.98310953754325680620
DEBUG CONSTRNT: LP rows=37, pool->nlprows=37, pool->npend=0
DEBUG CONSTRNT: Checking 37 LP rows (pool tracks 37, total LP rows 37)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=36, expected 36
 % @PAP adding 34 rows, 178 nz to LP
DEBUG BB: Processing node 4, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=12, varin=47, theta=1.104415, up=1.000000
ITER 2: row=12, varin=27, theta=0.558882, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
ITER 3: row=1, varin=47, theta=0.059996, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=34)
DEBUG SOLUTION: LP solution array indices: FST[35-74], not_covered[75-94]
DEBUG SOLUTION: lp->best_solution[0] = 27982316.300192
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 34 rows, 60 cols, 238 nonzeros, 1 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 16 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=37, varin=39, theta=0.714632, up=1.000000
ITER 2: row=2, varin=56, theta=0.456645, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 27999890.094162
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 38 rows, 60 cols, 254 nonzeros, 1 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 7 rows, 33 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=50, theta=0.646678, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28015481.493439
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 285 nonzeros, 1 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 3 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=65, theta=0.399453, up=1.000000
ITER 2: row=41, varin=93, theta=0.045307, up=1.000000
ITER 3: row=43, varin=31, theta=1.784371, up=999999999999999983222784.000000
ITER 4: row=35, varin=102, theta=0.059853, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28045102.781184
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.953448
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 295 nonzeros, 4 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 4 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=7, theta=0.522893, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28067016.757746
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.477107
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 295 nonzeros, 5 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=36, theta=1.921096, up=999999999999999983222784.000000
ITER 2: row=44, varin=86, theta=0.851211, up=1.000000
ITER 3: row=43, varin=44, theta=0.063668, up=999999999999999983222784.000000
ITER 4: row=44, varin=42, theta=0.022109, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28088782.567041
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 286 nonzeros, 6 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 5 rows, 17 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=85, theta=1.000000, up=1.000000
ITER 2: row=43, varin=33, theta=1.507946, up=999999999999999983222784.000000
ITER 3: row=1, varin=3, theta=5.825124, up=999999999999999983222784.000000
ITER 4: row=43, varin=46, theta=0.092116, up=1.000000
ITER 5: row=36, varin=33, theta=1.309610, up=999999999999999983222784.000000
ITER 6: row=9, varin=27, theta=0.461261, up=999999999999999983222784.000000
ITER 7: row=28, varin=47, theta=0.125566, up=1.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28121043.344382
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 3.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 281 nonzeros, 1 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 5 rows, 22 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=58, theta=0.054914, up=1.000000
ITER 2: row=43, varin=47, theta=0.968980, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28142634.159657
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 3.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 295 nonzeros, 2 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=42, theta=0.197202, up=999999999999999983222784.000000
ITER 2: row=44, varin=78, theta=0.292184, up=1.000000
ITER 3: row=41, varin=50, theta=0.177212, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28164335.754528
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 3.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 285 nonzeros, 1 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 3 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=77, theta=0.279439, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28170473.315514
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 3.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 287 nonzeros, 0 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=5, theta=0.091295, up=999999999999999983222784.000000
ITER 2: row=1, varin=107, theta=0.174516, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28181552.317454
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.825484
DEBUG SOLUTION: lp->best_solution[11] = 0.825484
DEBUG SOLUTION: lp->best_solution[12] = 2.650968
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 53 rows, 60 cols, 294 nonzeros, 3 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=88, theta=0.009526, up=1.000000
ITER 2: row=31, varin=74, theta=0.004586, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28181827.339974
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 51 rows, 60 cols, 288 nonzeros, 0 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 4 LP 1 Solution, length = 28181827.339974, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.165902 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.165902 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.165902 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.165902 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.165902 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.004586 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.165902 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.834098 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.834098 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.834098 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.834098 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.834098 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.834098 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.834098 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=28181827.339974, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 4 at  28.18182733997376487878
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e747c80
% @LO 0.00  27.98310953754325680620 99.9000000000
% @LN 0.00  28.00563566445710250719 99.9000000000
% Resuming node 2 at  28.00563566445710250719
DEBUG CONSTRNT: LP rows=51, pool->nlprows=51, pool->npend=0
DEBUG CONSTRNT: Checking 51 LP rows (pool tracks 51, total LP rows 51)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=50, expected 50
 % @PAP adding 49 rows, 221 nz to LP
DEBUG BB: Processing node 2, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 2 LP 3 Solution, length = 28005635.664457, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.227706 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.227706 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.227706 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.227706 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.089175 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.772294 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.772294 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.772294 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.772294 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.772294 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.772294 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28005635.664457, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28005635.664457, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 2 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 2
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.227706
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.227706)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.227706
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.227706)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.227706
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.227706)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.227706
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.227706)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.089175
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.089175)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[1] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
DEBUG CAREFUL: Testing fvar[2] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[3] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[4] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
  % Initial guess is x18, Z0 = 28005635.6644571        , Z1 = 28275991.3055268        

DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=30, theta=0.903097, up=999999999999999983222784.000000
ITER 2: row=48, varin=26, theta=4.141146, up=999999999999999983222784.000000
ITER 3: row=44, varin=32, theta=3.812583, up=999999999999999983222784.000000
ITER 4: row=4, varin=33, theta=0.946844, up=999999999999999983222784.000000
ITER 5: row=49, varin=35, theta=4.956005, up=999999999999999983222784.000000
ITER 6: row=2, varin=5, theta=5.570774, up=999999999999999983222784.000000
ITER 7: row=39, varin=43, theta=1.470388, up=999999999999999983222784.000000
ITER 8: row=26, varin=34, theta=0.984675, up=999999999999999983222784.000000
ITER 9: row=33, varin=72, theta=0.873736, up=1.000000
DEBUG EVAL: Branch var 3 = 1 gives z=28945313.681720
  % 	x3 = 1,	Z1 = 28945313.6817197        
DEBUG EVAL: First branch cutoff check: z=28945313.681720, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=1, varin=47, theta=0.254514, up=999999999999999983222784.000000
  % 	x3 = 0,	Z0 = 28045664.9209567        
DEBUG EVAL: Second branch cutoff check: z=28045664.920957, best_z=INF, threshold=INF
  %   New best:  x3, Z = 28045664.9209567        
DEBUG EVAL: Testing var 18 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=30, varin=26, theta=4.141146, up=999999999999999983222784.000000
ITER 2: row=44, varin=34, theta=1.951486, up=999999999999999983222784.000000
ITER 3: row=46, varin=32, theta=3.812583, up=999999999999999983222784.000000
ITER 4: row=4, varin=35, theta=4.956005, up=999999999999999983222784.000000
ITER 5: row=2, varin=5, theta=5.570774, up=999999999999999983222784.000000
ITER 6: row=39, varin=45, theta=2.167932, up=999999999999999983222784.000000
ITER 7: row=33, varin=72, theta=4.047760, up=1.000000
ITER 8: row=33, varin=71, theta=2.965784, up=1.000000
ITER 9: row=33, varin=42, theta=3.584821, up=999999999999999983222784.000000
ITER 10: row=15, varin=74, theta=5.468148, up=1.000000
DEBUG EVAL: Branch var 18 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x18 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=30, varin=43, theta=0.366234, up=999999999999999983222784.000000
ITER 2: row=48, varin=94, theta=0.681808, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28075829.541247
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 3.000000
   % @PL 49 rows, 60 cols, 281 nonzeros, 2 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
   % @PAP adding 6 rows, 22 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=45, theta=0.117576, up=999999999999999983222784.000000
ITER 2: row=48, varin=88, theta=0.448393, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28096972.795030
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 3.000000
   % @PL 53 rows, 60 cols, 292 nonzeros, 6 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 6 slack rows
   % @PAP adding 4 rows, 23 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=88, theta=0.460187, up=1.000000
ITER 2: row=51, varin=105, theta=0.459048, up=1.000000
ITER 3: row=49, varin=33, theta=0.055556, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28102808.270481
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.588935
DEBUG SOLUTION: lp->best_solution[13] = 0.588935
DEBUG SOLUTION: lp->best_solution[14] = 2.177871
   % @PL 51 rows, 60 cols, 295 nonzeros, 5 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 5 slack rows
   % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=28, theta=0.071149, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28105230.814472
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.928851
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 49 rows, 60 cols, 289 nonzeros, 4 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 4 slack rows
   % @PAP adding 4 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=61, theta=0.212850, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28106736.607574
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
   % @PL 49 rows, 60 cols, 293 nonzeros, 1 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 7 rows, 28 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=60, theta=0.212296, up=1.000000
ITER 2: row=55, varin=42, theta=1.385590, up=999999999999999983222784.000000
ITER 3: row=49, varin=40, theta=0.118413, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 28119220.903345
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
   % @PL 55 rows, 60 cols, 319 nonzeros, 3 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 3 slack rows
   % @PAP adding 4 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=53, varin=81, theta=0.709219, up=1.000000
ITER 2: row=13, varin=52, theta=0.376878, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 28129938.970846
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
   % @PL 56 rows, 60 cols, 319 nonzeros, 3 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 3 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 2 at  28.12993897084554717480
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e737600
% @LO 0.00  28.00563566445710250719 99.9000000000
% @LN 0.00  28.03152709071384407480 99.9000000000
% Resuming node 3 at  28.03152709071384407480
DEBUG CONSTRNT: LP rows=53, pool->nlprows=53, pool->npend=0
DEBUG CONSTRNT: Checking 53 LP rows (pool tracks 53, total LP rows 53)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 85
DEBUG CONSTRNT: Pool row 85 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=52, expected 52
 % @PAP adding 37 rows, 174 nz to LP
DEBUG BB: Processing node 3, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 3 LP 2 Solution, length = 28031527.090714, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.930789 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.310263 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.310263 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.310263 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.310263 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.310263 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.689737 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.069211 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.069211 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.689737 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.689737 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.689737 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.069211 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.689737 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.689737 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.689737 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.689737 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.689737 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.689737 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28031527.090714, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28031527.090714, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 3 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 3
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.930789
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.930789)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.310263
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.310263)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.310263
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.310263)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.310263
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.310263)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.310263
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.310263)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.310263
DEBUG CAREFUL: Adding var 16 to fractional list (xi=0.310263)
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 1
DEBUG CAREFUL: New best var: 1
DEBUG CAREFUL: Testing fvar[1] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[2] = var 16
DEBUG CAREFUL: Calling compare_branch_vars for var 16
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 16
DEBUG CAREFUL: Testing fvar[3] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 14
DEBUG CAREFUL: Testing fvar[4] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[5] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 15
  % Initial guess is x1, Z0 = 28038441.8255406        , Z1 = 28031527.0907138        

DEBUG EVAL: Testing var 1 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=30, theta=0.087099, up=999999999999999983222784.000000
ITER 2: row=33, varin=50, theta=0.049366, up=1.000000
DEBUG EVAL: Branch var 1 = 1 gives z=28034362.012203
  % 	x1 = 1,	Z1 = 28034362.0122033        
DEBUG EVAL: First branch cutoff check: z=28034362.012203, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 0
ITER 1: row=1, varin=37, theta=0.837250, up=999999999999999983222784.000000
ITER 2: row=17, varin=35, theta=0.168221, up=999999999999999983222784.000000
  % 	x1 = 0,	Z0 = 28039940.5787103        
DEBUG EVAL: Second branch cutoff check: z=28039940.578710, best_z=INF, threshold=INF
  %   New best:  x1, Z = 28034362.0122033        
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=12, varin=30, theta=0.772200, up=999999999999999983222784.000000
ITER 2: row=33, varin=12, theta=0.351846, up=999999999999999983222784.000000
ITER 3: row=1, varin=33, theta=0.087726, up=999999999999999983222784.000000
ITER 4: row=12, varin=32, theta=0.074924, up=999999999999999983222784.000000
ITER 5: row=31, varin=35, theta=0.054652, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28051565.646870
  % 	x10 = 0,	Z0 = 28051565.6468702        
DEBUG EVAL: First branch cutoff check: z=28051565.646870, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 1
ITER 1: row=12, varin=37, theta=0.716417, up=999999999999999983222784.000000
  % 	x10 = 1,	Z1 = 28037443.8822313        
DEBUG EVAL: Second branch cutoff check: z=28037443.882231, best_z=INF, threshold=INF
  %   New best:  x10, Z = 28037443.8822313        
DEBUG EVAL: Testing var 16 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=30, theta=0.772200, up=999999999999999983222784.000000
ITER 2: row=33, varin=27, theta=1.036336, up=999999999999999983222784.000000
ITER 3: row=6, varin=35, theta=0.753069, up=999999999999999983222784.000000
ITER 4: row=34, varin=29, theta=0.500237, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 16 = 0 gives z=28077326.335163
  % 	x16 = 0,	Z0 = 28077326.3351634        
DEBUG EVAL: First branch cutoff check: z=28077326.335163, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 16 = 1
ITER 1: row=6, varin=32, theta=0.881882, up=999999999999999983222784.000000
ITER 2: row=31, varin=35, theta=2.385169, up=999999999999999983222784.000000
ITER 3: row=1, varin=30, theta=1.085819, up=999999999999999983222784.000000
ITER 4: row=8, varin=36, theta=0.413138, up=999999999999999983222784.000000
  % 	x16 = 1,	Z1 = 28100285.4526056        
DEBUG EVAL: Second branch cutoff check: z=28100285.452606, best_z=INF, threshold=INF
  %   New best:  x16, Z = 28077326.3351634        
DEBUG EVAL: Testing var 14 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=23, varin=35, theta=0.436484, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 14 = 0 gives z=28039088.049830
  % 	x14 = 0,	Z0 = 28039088.0498305        
DEBUG EVAL: First branch cutoff check: z=28039088.049830, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 9 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=8, varin=30, theta=0.772200, up=999999999999999983222784.000000
ITER 2: row=33, varin=32, theta=0.500689, up=999999999999999983222784.000000
ITER 3: row=1, varin=37, theta=0.001231, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 9 = 0 gives z=28053516.680898
  % 	x9 = 0,	Z0 = 28053516.6808975        
DEBUG EVAL: First branch cutoff check: z=28053516.680898, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 15 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=25, varin=36, theta=0.384731, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 15 = 0 gives z=28041872.625468
  % 	x15 = 0,	Z0 = 28041872.6254685        
DEBUG EVAL: First branch cutoff check: z=28041872.625468, best_z=INF, threshold=INF
  % Best branch is x16, Z0 = 28077326.3351634        , Z1 = 28100285.4526056        

DEBUG CAREFUL: Final result - returning best.var = 16
DEBUG BB: Branching variable chosen: j=16
 % @NC    5    3	x16 = 0	28077326.335163
 % @NC    6    3	x16 = 1	28100285.452606
 %       3     4 28031527.0907               28077326.3352   x13 D     1     2
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e743b80
% @LO 0.00  28.03152709071384407480 99.9000000000
% @LN 0.00  28.07732633516344478153 99.9000000000
% Resuming node 5 at  28.07732633516344478153
DEBUG CONSTRNT: LP rows=37, pool->nlprows=37, pool->npend=0
DEBUG CONSTRNT: Checking 37 LP rows (pool tracks 37, total LP rows 37)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=36, expected 36
 % @PAP adding 37 rows, 174 nz to LP
DEBUG BB: Processing node 5, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=6, varin=30, theta=0.772200, up=999999999999999983222784.000000
ITER 2: row=33, varin=27, theta=1.036336, up=999999999999999983222784.000000
ITER 3: row=6, varin=35, theta=0.753069, up=999999999999999983222784.000000
ITER 4: row=34, varin=29, theta=0.500237, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 28077326.335163
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 37 rows, 60 cols, 234 nonzeros, 3 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 3 rows, 16 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=35, varin=34, theta=0.003953, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 28077337.252469
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 37 rows, 60 cols, 244 nonzeros, 1 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 5 LP 1 Solution, length = 28077337.252469, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.496047 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.500000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.503953 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.500000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.500000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.503953 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.503953 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.500000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.503953 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.496047 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.496047 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.496047 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28077337.252469, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.01  28.07732633516344478153 99.9000000000
 % @LN 0.01  28.07733725246869838088 99.9000000000
DEBUG CG: Second cutoff check: z=28077337.252469, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 5 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 5
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.496047
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.496047)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.500000
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.503953
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.503953)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.500000
DEBUG CAREFUL: Adding var 14 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.500000
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 14
DEBUG CAREFUL: Calling compare_branch_vars for var 14
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 14
DEBUG CAREFUL: New best var: 14
DEBUG CAREFUL: Testing fvar[1] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[2] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 15
DEBUG CAREFUL: Testing fvar[3] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[4] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
  % Initial guess is x14, Z0 = 28077337.2524687        , Z1 = 28077337.2524687        

DEBUG EVAL: Testing var 14 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=23, varin=31, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=9, varin=49, theta=0.236620, up=1.000000
ITER 3: row=32, varin=33, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=9, varin=81, theta=3.125911, up=1.000000
ITER 5: row=9, varin=28, theta=0.264443, up=999999999999999983222784.000000
ITER 6: row=17, varin=81, theta=0.302010, up=1.000000
DEBUG EVAL: Branch var 14 = 1 gives z=28139379.902079
  % 	x14 = 1,	Z1 = 28139379.9020792        
DEBUG EVAL: First branch cutoff check: z=28139379.902079, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 14 = 0
ITER 1: row=23, varin=34, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=9, varin=45, theta=0.821193, up=1.000000
ITER 3: row=17, varin=81, theta=0.800115, up=1.000000
  % 	x14 = 0,	Z0 = 28102522.6199342        
DEBUG EVAL: Second branch cutoff check: z=28102522.619934, best_z=INF, threshold=INF
  %   New best:  x14, Z = 28102522.6199342        
DEBUG EVAL: Testing var 9 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=8, varin=31, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=9, varin=45, theta=0.489543, up=1.000000
ITER 3: row=32, varin=34, theta=0.178807, up=999999999999999983222784.000000
ITER 4: row=12, varin=81, theta=0.800115, up=1.000000
DEBUG EVAL: Branch var 9 = 0 gives z=28102522.619934
  % 	x9 = 0,	Z0 = 28102522.6199342        
DEBUG EVAL: First branch cutoff check: z=28102522.619934, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 1
ITER 1: row=8, varin=33, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=1, varin=34, theta=0.301644, up=999999999999999983222784.000000
ITER 3: row=12, varin=38, theta=0.357561, up=1.000000
  % 	x9 = 1,	Z1 = 28104181.2544911        
DEBUG EVAL: Second branch cutoff check: z=28104181.254491, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 15 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=25, varin=31, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=9, varin=45, theta=0.489543, up=1.000000
ITER 3: row=32, varin=34, theta=0.178807, up=999999999999999983222784.000000
ITER 4: row=17, varin=81, theta=0.800115, up=1.000000
DEBUG EVAL: Branch var 15 = 0 gives z=28102522.619934
  % 	x15 = 0,	Z0 = 28102522.6199342        
DEBUG EVAL: First branch cutoff check: z=28102522.619934, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 15 = 1
ITER 1: row=25, varin=30, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=9, varin=49, theta=0.060076, up=1.000000
ITER 3: row=36, varin=44, theta=0.042202, up=1.000000
  % 	x15 = 1,	Z1 = 28137202.3269622        
DEBUG EVAL: Second branch cutoff check: z=28137202.326962, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=12, varin=34, theta=0.063373, up=999999999999999983222784.000000
ITER 2: row=9, varin=49, theta=0.048149, up=1.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28080188.452202
  % 	x10 = 1,	Z1 = 28080188.4522017        
DEBUG EVAL: First branch cutoff check: z=28080188.452202, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=34, theta=0.056194, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 0 gives z=28078629.556169
  % 	x1 = 0,	Z0 = 28078629.5561691        
DEBUG EVAL: First branch cutoff check: z=28078629.556169, best_z=INF, threshold=INF
  % Best branch is x14, Z0 = 28102522.6199342        , Z1 = 28139379.9020792        

DEBUG CAREFUL: Final result - returning best.var = 14
DEBUG BB: Branching variable chosen: j=14
 % @NC    7    5	x14 = 0	28102522.619934
 % @NC    8    5	x14 = 1	28139379.902079
 %       5     5 28077337.2525               28100285.4526   x16 D     3     3
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e754ad0
% @LO 0.01  28.07733725246869838088 99.9000000000
% @LN 0.01  28.10028545260558985319 99.9000000000
% Resuming node 6 at  28.10028545260558985319
DEBUG CONSTRNT: LP rows=36, pool->nlprows=36, pool->npend=0
DEBUG CONSTRNT: Checking 36 LP rows (pool tracks 36, total LP rows 36)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 150
DEBUG CONSTRNT: Pool row 150 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=35, expected 35
 % @PAP adding 37 rows, 174 nz to LP
DEBUG BB: Processing node 6, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=6, varin=32, theta=0.881882, up=999999999999999983222784.000000
ITER 2: row=31, varin=35, theta=2.385169, up=999999999999999983222784.000000
ITER 3: row=1, varin=30, theta=1.085819, up=999999999999999983222784.000000
ITER 4: row=8, varin=36, theta=0.413138, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 28100285.452606
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 37 rows, 60 cols, 234 nonzeros, 6 slack, 31 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=48, theta=0.272936, up=1.000000
ITER 2: row=26, varin=51, theta=0.368772, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 28129298.968014
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 38 rows, 60 cols, 242 nonzeros, 6 slack, 32 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 5 rows, 22 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=33, varin=95, theta=0.748328, up=1.000000
ITER 2: row=28, varin=38, theta=0.435815, up=1.000000
ITER 3: row=2, varin=12, theta=1.751511, up=999999999999999983222784.000000
ITER 4: row=37, varin=45, theta=1.000000, up=1.000000
ITER 5: row=2, varin=55, theta=0.368399, up=1.000000
ITER 6: row=37, varin=86, theta=0.483449, up=1.000000
ITER 7: row=36, varin=31, theta=0.120758, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 28182628.467019
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 37 rows, 60 cols, 252 nonzeros, 1 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 7 rows, 33 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=37, varin=35, theta=7.469563, up=999999999999999983222784.000000
ITER 2: row=31, varin=49, theta=0.529053, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28195383.935329
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 283 nonzeros, 1 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 3 rows, 10 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=64, theta=0.326797, up=1.000000
ITER 2: row=40, varin=92, theta=0.037066, up=1.000000
ITER 3: row=42, varin=101, theta=0.048966, up=1.000000
ITER 4: row=17, varin=25, theta=0.193069, up=999999999999999983222784.000000
ITER 5: row=34, varin=12, theta=0.111229, up=999999999999999983222784.000000
ITER 6: row=23, varin=48, theta=0.109854, up=1.000000
ITER 7: row=13, varin=75, theta=0.178661, up=1.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28240952.755820
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.966767
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 291 nonzeros, 4 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 10 rows, 37 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=7, theta=0.394215, up=999999999999999983222784.000000
ITER 2: row=51, varin=106, theta=0.044946, up=1.000000
ITER 3: row=42, varin=55, theta=0.334732, up=1.000000
ITER 4: row=11, varin=104, theta=0.027187, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28304562.581884
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.809690
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 320 nonzeros, 5 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 6 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=21, theta=0.351308, up=999999999999999983222784.000000
ITER 2: row=52, varin=79, theta=0.497903, up=1.000000
ITER 3: row=49, varin=52, theta=0.076277, up=999999999999999983222784.000000
ITER 4: row=45, varin=46, theta=0.538884, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
ITER 5: row=41, varin=94, theta=0.000000, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28345152.251906
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 3.000000
  % @PL 52 rows, 60 cols, 313 nonzeros, 4 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 5 rows, 11 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=8, theta=0.865144, up=999999999999999983222784.000000
ITER 2: row=2, varin=44, theta=8.626451, up=999999999999999983222784.000000
ITER 3: row=53, varin=35, theta=3.665533, up=999999999999999983222784.000000
ITER 4: row=15, varin=107, theta=0.975043, up=1.000000
ITER 5: row=53, varin=95, theta=0.965074, up=1.000000
ITER 6: row=42, varin=35, theta=0.126290, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28413058.858475
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.314699
DEBUG SOLUTION: lp->best_solution[13] = 0.314699
DEBUG SOLUTION: lp->best_solution[14] = 1.629397
  % @PL 53 rows, 60 cols, 308 nonzeros, 6 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 5 rows, 18 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=38, theta=0.186087, up=999999999999999983222784.000000
ITER 2: row=5, varin=74, theta=0.177607, up=1.000000
ITER 3: row=51, varin=77, theta=1.041552, up=1.000000
ITER 4: row=51, varin=5, theta=0.052977, up=999999999999999983222784.000000
ITER 5: row=14, varin=77, theta=1.000000, up=1.000000
ITER 6: row=27, varin=47, theta=1.014372, up=999999999999999983222784.000000
ITER 7: row=51, varin=75, theta=0.357745, up=1.000000
ITER 8: row=40, varin=5, theta=1.300960, up=999999999999999983222784.000000
ITER 9: row=39, varin=105, theta=0.102788, up=1.000000
ITER 10: row=49, varin=40, theta=0.037639, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=11)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28445905.837107
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 304 nonzeros, 2 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 4 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=18, theta=4.910290, up=999999999999999983222784.000000
ITER 2: row=40, varin=78, theta=0.459556, up=1.000000
ITER 3: row=3, varin=80, theta=0.380065, up=1.000000
ITER 4: row=29, varin=22, theta=0.076685, up=999999999999999983222784.000000
ITER 5: row=52, varin=40, theta=0.571914, up=999999999999999983222784.000000
ITER 6: row=51, varin=43, theta=0.053271, up=999999999999999983222784.000000
ITER 7: row=22, varin=36, theta=0.111547, up=999999999999999983222784.000000
ITER 8: row=46, varin=20, theta=0.000353, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 28483463.707044
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.445424
DEBUG SOLUTION: lp->best_solution[5] = 2.445424
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.889085
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 54 rows, 60 cols, 300 nonzeros, 6 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 6 rows, 15 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=108, theta=0.105983, up=1.000000
ITER 2: row=52, varin=66, theta=0.566354, up=1.000000
ITER 3: row=36, varin=15, theta=0.541961, up=999999999999999983222784.000000
ITER 4: row=34, varin=82, theta=0.220148, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 28490577.180681
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1000000.000000
  % @PL 54 rows, 60 cols, 301 nonzeros, 0 slack, 54 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 5 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=56, varin=22, theta=0.064151, up=999999999999999983222784.000000
ITER 2: row=59, varin=34, theta=0.554179, up=999999999999999983222784.000000
ITER 3: row=15, varin=36, theta=0.027875, up=999999999999999983222784.000000
ITER 4: row=54, varin=15, theta=0.417762, up=999999999999999983222784.000000
ITER 5: row=59, varin=88, theta=0.192686, up=1.000000
ITER 6: row=58, varin=59, theta=0.036264, up=999999999999999983222784.000000
ITER 7: row=44, varin=34, theta=0.552488, up=999999999999999983222784.000000
ITER 8: row=41, varin=27, theta=0.160810, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=59)
DEBUG SOLUTION: LP solution array indices: FST[60-99], not_covered[100-119]
DEBUG SOLUTION: lp->best_solution[0] = 28495754.705500
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1000000.000000
  % @PL 59 rows, 60 cols, 313 nonzeros, 2 slack, 57 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=58, varin=11, theta=0.221573, up=999999999999999983222784.000000
ITER 2: row=10, varin=40, theta=0.430343, up=999999999999999983222784.000000
ITER 3: row=33, varin=45, theta=0.139096, up=999999999999999983222784.000000
ITER 4: row=57, varin=24, theta=0.328031, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=59)
DEBUG SOLUTION: LP solution array indices: FST[60-99], not_covered[100-119]
DEBUG SOLUTION: lp->best_solution[0] = 28509930.656422
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1000000.000000
  % @PL 59 rows, 60 cols, 309 nonzeros, 2 slack, 57 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 6 LP 1 Solution, length = 28509930.656422, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.078131 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.078131 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.078131 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.078131 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.109344 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 1.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.078131 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.078131 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.109344 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.078131 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.109344 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.078131 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.078131 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.921869 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.921869 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.921869 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.921869 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.921869 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.921869 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.890656 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.890656 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.921869 (terminal 19)
 % 12 fractional variables
DEBUG CG: LP optimal, z=28509930.656422, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 6 at  28.50993065642243706748
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e737600
% @LO 0.01  28.10028545260558985319 99.9000000000
% @LN 0.01  28.10252261993424838238 99.9000000000
% Resuming node 7 at  28.10252261993424838238
DEBUG CONSTRNT: LP rows=57, pool->nlprows=57, pool->npend=0
DEBUG CONSTRNT: Checking 57 LP rows (pool tracks 57, total LP rows 57)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 137
DEBUG CONSTRNT: Pool row 137 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=56, expected 56
 % @PAP adding 36 rows, 182 nz to LP
DEBUG BB: Processing node 7, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=23, varin=34, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=9, varin=45, theta=0.821193, up=1.000000
ITER 3: row=17, varin=81, theta=0.800115, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=36)
DEBUG SOLUTION: LP solution array indices: FST[37-76], not_covered[77-96]
DEBUG SOLUTION: lp->best_solution[0] = 28102522.619934
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 36 rows, 60 cols, 242 nonzeros, 3 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 6 rows, 40 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=34, varin=30, theta=0.457207, up=999999999999999983222784.000000
ITER 2: row=1, varin=52, theta=0.064234, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 28117695.053188
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 39 rows, 60 cols, 266 nonzeros, 5 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % Node 7 LP 1 Solution, length = 28117695.053188, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.435766 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.435766 (FST 9)
  % DEBUG LP_VARS: x[10] = 1.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.064234 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.435766 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.564234 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.564234 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.564234 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.564234 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.564234 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28117695.053188, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.01  28.10252261993424838238 99.9000000000
 % @LN 0.01  28.11769505318842021779 99.9000000000
DEBUG CG: Second cutoff check: z=28117695.053188, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 7 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 7
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.435766
DEBUG CAREFUL: Adding var 8 to fractional list (xi=0.435766)
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.435766
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.435766)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=1.000000
DEBUG CAREFUL: Skipping var 10: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.064234
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.064234)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.435766
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.435766)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 12
DEBUG CAREFUL: New best var: 12
DEBUG CAREFUL: Testing fvar[1] = var 8
DEBUG CAREFUL: Calling compare_branch_vars for var 8
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 8
DEBUG CAREFUL: New best var: 8
DEBUG CAREFUL: Testing fvar[2] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 9
DEBUG CAREFUL: Testing fvar[3] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 15
DEBUG CAREFUL: New best var: 15
  % Initial guess is x15, Z0 = 28117695.0531884        , Z1 = 28137202.3269622        

DEBUG EVAL: Testing var 12 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=28, varin=87, theta=0.076094, up=1.000000
DEBUG EVAL: Branch var 12 = 0 gives z=28117838.014507
  % 	x12 = 0,	Z0 = 28117838.0145068        
DEBUG EVAL: First branch cutoff check: z=28117838.014507, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 1
ITER 1: row=28, varin=36, theta=1.246815, up=1.000000
ITER 2: row=28, varin=32, theta=0.250816, up=999999999999999983222784.000000
  % 	x12 = 1,	Z1 = 28122449.648149         
DEBUG EVAL: Second branch cutoff check: z=28122449.648149, best_z=INF, threshold=INF
  %   New best:  x12, Z = 28117838.0145068        
DEBUG EVAL: Testing var 8 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=36, theta=-2.252204, up=1.000000
ITER 2: row=1, varin=87, theta=1.639566, up=1.000000
ITER 3: row=1, varin=30, theta=0.318292, up=999999999999999983222784.000000
ITER 4: row=28, varin=36, theta=1.234467, up=1.000000
ITER 5: row=28, varin=87, theta=0.213274, up=1.000000
ITER 6: row=33, varin=28, theta=1.082654, up=999999999999999983222784.000000
ITER 7: row=34, varin=31, theta=1.404385, up=999999999999999983222784.000000
ITER 8: row=12, varin=36, theta=0.482189, up=1.000000
ITER 9: row=25, varin=29, theta=0.272033, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 8 = 1 gives z=28242929.201126
  % 	x8 = 1,	Z1 = 28242929.2011264        
DEBUG EVAL: First branch cutoff check: z=28242929.201126, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 8 = 0
ITER 1: row=1, varin=87, theta=-1.266261, up=1.000000
ITER 2: row=1, varin=36, theta=1.739410, up=1.000000
ITER 3: row=1, varin=32, theta=0.250816, up=999999999999999983222784.000000
  % 	x8 = 0,	Z0 = 28122449.648149         
DEBUG EVAL: Second branch cutoff check: z=28122449.648149, best_z=INF, threshold=INF
  %   New best:  x8, Z = 28122449.648149         
DEBUG EVAL: Testing var 9 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=23, varin=87, theta=-1.266261, up=1.000000
ITER 2: row=17, varin=36, theta=1.739410, up=1.000000
ITER 3: row=17, varin=42, theta=0.635461, up=1.000000
DEBUG EVAL: Branch var 9 = 0 gives z=28126364.847147
  % 	x9 = 0,	Z0 = 28126364.8471474        
DEBUG EVAL: First branch cutoff check: z=28126364.847147, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 1
ITER 1: row=23, varin=36, theta=-2.252204, up=1.000000
ITER 2: row=8, varin=87, theta=1.639566, up=1.000000
ITER 3: row=8, varin=31, theta=0.404204, up=999999999999999983222784.000000
ITER 4: row=28, varin=87, theta=0.526323, up=1.000000
  % 	x9 = 1,	Z1 = 28130519.5536359        
DEBUG EVAL: Second branch cutoff check: z=28130519.553636, best_z=INF, threshold=INF
  %   New best:  x9, Z = 28126364.8471474        
DEBUG EVAL: Testing var 15 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=25, varin=36, theta=-2.252204, up=1.000000
ITER 2: row=8, varin=87, theta=1.639566, up=1.000000
ITER 3: row=8, varin=32, theta=0.841846, up=999999999999999983222784.000000
ITER 4: row=28, varin=87, theta=0.087076, up=1.000000
DEBUG EVAL: Branch var 15 = 1 gives z=28135899.531177
  % 	x15 = 1,	Z1 = 28137202.3269622        
DEBUG EVAL: First branch cutoff check: z=28137202.326962, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 15 = 0
ITER 1: row=25, varin=87, theta=-1.266261, up=1.000000
ITER 2: row=12, varin=36, theta=1.739410, up=1.000000
ITER 3: row=12, varin=31, theta=0.406695, up=999999999999999983222784.000000
  % 	x15 = 0,	Z0 = 28124712.8475864        
DEBUG EVAL: Second branch cutoff check: z=28124712.847586, best_z=INF, threshold=INF
  % Best branch is x9, Z0 = 28126364.8471474        , Z1 = 28130519.5536359        

DEBUG CAREFUL: Final result - returning best.var = 9
DEBUG BB: Branching variable chosen: j=9
 % @NC    9    7	x9 = 0	28126364.847147
 % @NC   10    7	x9 = 1	28130519.553636
 %       7     6 28117695.0532               28126364.8471   x14 D     5     4
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e743b80
% @LO 0.01  28.11769505318842021779 99.9000000000
% @LN 0.01  28.12636484714744256053 99.9000000000
% Resuming node 9 at  28.12636484714744256053
DEBUG CONSTRNT: LP rows=34, pool->nlprows=34, pool->npend=0
DEBUG CONSTRNT: Checking 34 LP rows (pool tracks 34, total LP rows 34)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 62
DEBUG CONSTRNT: Pool row 62 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=33, expected 33
 % @PAP adding 34 rows, 168 nz to LP
DEBUG BB: Processing node 9, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=23, varin=87, theta=-1.266261, up=1.000000
ITER 2: row=17, varin=36, theta=1.739410, up=1.000000
ITER 3: row=17, varin=42, theta=0.635461, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=34)
DEBUG SOLUTION: LP solution array indices: FST[35-74], not_covered[75-94]
DEBUG SOLUTION: lp->best_solution[0] = 28126364.847147
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 34 rows, 60 cols, 228 nonzeros, 0 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 11 rows, 53 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=28, theta=0.086957, up=999999999999999983222784.000000
ITER 2: row=41, varin=46, theta=0.833382, up=1.000000
ITER 3: row=2, varin=29, theta=0.066529, up=999999999999999983222784.000000
ITER 4: row=38, varin=63, theta=1.306261, up=1.000000
ITER 5: row=38, varin=47, theta=0.081818, up=1.000000
ITER 6: row=1, varin=63, theta=0.395857, up=1.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28140027.190085
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 281 nonzeros, 0 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 31 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=59, theta=0.763483, up=1.000000
ITER 2: row=35, varin=106, theta=-7.331320, up=1.000000
ITER 3: row=1, varin=39, theta=4.914775, up=999999999999999983222784.000000
ITER 4: row=34, varin=57, theta=0.655367, up=1.000000
ITER 5: row=36, varin=6, theta=0.138468, up=999999999999999983222784.000000
ITER 6: row=17, varin=53, theta=0.537123, up=1.000000
ITER 7: row=40, varin=35, theta=0.042060, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28178643.489527
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.852792
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 312 nonzeros, 7 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 7 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=36, theta=1.288036, up=999999999999999983222784.000000
ITER 2: row=45, varin=66, theta=0.512606, up=1.000000
ITER 3: row=42, varin=46, theta=0.246904, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28182579.108043
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 284 nonzeros, 3 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=92, theta=0.057935, up=1.000000
ITER 2: row=43, varin=101, theta=0.076169, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28196053.371919
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.940757
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 273 nonzeros, 4 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 3 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=30, theta=0.809936, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28197820.272170
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 3.000000
  % @PL 44 rows, 60 cols, 273 nonzeros, 1 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 9 LP 1 Solution, length = 28197820.272170, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.349894 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.269979 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.269979 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.269979 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 1.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.269979 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.269979 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.730021 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.650106 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.650106 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.730021 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.730021 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.650106 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.730021 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.730021 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.730021 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28197820.272170, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 9 at  28.19782027216982456252
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e747c80
% @LO 0.01  28.12636484714744256053 99.9000000000
% @LN 0.01  28.12993897084554717480 99.9000000000
% Resuming node 2 at  28.12993897084554717480
DEBUG CONSTRNT: LP rows=43, pool->nlprows=43, pool->npend=0
DEBUG CONSTRNT: Checking 43 LP rows (pool tracks 43, total LP rows 43)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 62
DEBUG CONSTRNT: Pool row 62 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=42, expected 42
 % @PAP adding 53 rows, 232 nz to LP
DEBUG BB: Processing node 2, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 2 LP 4 Solution, length = 28129938.970846, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.340464 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.340464 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.094219 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.094219 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.094219 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.094219 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.094219 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.094219 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.094219 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.340464 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.659536 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.905781 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.659536 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.659536 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.905781 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.659536 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.905781 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.905781 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.905781 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.905781 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.905781 (terminal 19)
 % 10 fractional variables
DEBUG CG: LP optimal, z=28129938.970846, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28129938.970846, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 3 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 2 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 2
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.340464
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.340464)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.340464
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.340464)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.094219
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.094219)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.094219
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.094219)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.094219
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.094219)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.094219
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.094219)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.094219
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.094219)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.094219
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.094219)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.094219
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.094219)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.340464
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.340464)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 10 fractional variables

  %  Carefully choosing branching variable, nfrac = 10
DEBUG CAREFUL: Testing fvar[0] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[1] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[2] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[3] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 4
DEBUG CAREFUL: Testing fvar[4] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[5] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[6] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
DEBUG CAREFUL: Testing fvar[7] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 29
DEBUG CAREFUL: Testing fvar[8] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 11
DEBUG CAREFUL: Testing fvar[9] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
  % Initial guess is x3, Z0 = 28129938.9708455        , Z1 = 28945313.6817197        

DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=10, varin=13, theta=3.409045, up=999999999999999983222784.000000
ITER 2: row=13, varin=51, theta=2.372217, up=999999999999999983222784.000000
ITER 3: row=18, varin=43, theta=1.974888, up=999999999999999983222784.000000
ITER 4: row=41, varin=49, theta=1.334697, up=999999999999999983222784.000000
ITER 5: row=1, varin=76, theta=2.331909, up=1.000000
ITER 6: row=1, varin=26, theta=0.668383, up=999999999999999983222784.000000
ITER 7: row=36, varin=76, theta=0.830103, up=1.000000
ITER 8: row=48, varin=40, theta=3.773794, up=999999999999999983222784.000000
ITER 9: row=40, varin=27, theta=2.181220, up=999999999999999983222784.000000
ITER 10: row=44, varin=22, theta=2.733047, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 1 gives z=29258565.336169
  % 	x3 = 1,	Z1 = 29258565.3361687        
DEBUG EVAL: First branch cutoff check: z=29258565.336169, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=10, varin=76, theta=0.305629, up=1.000000
  % 	x3 = 0,	Z0 = 28131890.6673819        
DEBUG EVAL: Second branch cutoff check: z=28131890.667382, best_z=INF, threshold=INF
  %   New best:  x3, Z = 28131890.6673819        
DEBUG EVAL: Testing var 17 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=26, varin=76, theta=0.305629, up=1.000000
DEBUG EVAL: Branch var 17 = 0 gives z=28131890.667382
  % 	x17 = 0,	Z0 = 28131890.6673819        
DEBUG EVAL: First branch cutoff check: z=28131890.667382, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 1
ITER 1: row=26, varin=13, theta=3.409045, up=999999999999999983222784.000000
ITER 2: row=13, varin=46, theta=2.338271, up=999999999999999983222784.000000
ITER 3: row=52, varin=51, theta=1.177561, up=999999999999999983222784.000000
ITER 4: row=1, varin=76, theta=2.138468, up=1.000000
ITER 5: row=1, varin=78, theta=3.597869, up=1.000000
ITER 6: row=1, varin=52, theta=34.399178, up=999999999999999983222784.000000
ITER 7: row=18, varin=84, theta=1.525226, up=1.000000
ITER 8: row=18, varin=75, theta=0.294600, up=1.000000
ITER 9: row=47, varin=43, theta=4.685997, up=999999999999999983222784.000000
ITER 10: row=41, varin=49, theta=1.717681, up=999999999999999983222784.000000
  % 	x17 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: Second branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=26, varin=76, theta=0.305629, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28131890.667382
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
   % @PL 53 rows, 60 cols, 292 nonzeros, 0 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 6 rows, 24 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=58, varin=41, theta=0.780811, up=999999999999999983222784.000000
ITER 2: row=54, varin=90, theta=0.178992, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=59)
DEBUG SOLUTION: LP solution array indices: FST[60-99], not_covered[100-119]
DEBUG SOLUTION: lp->best_solution[0] = 28150592.224777
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
   % @PL 59 rows, 60 cols, 316 nonzeros, 3 slack, 56 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 3 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 2 at  28.15059222477673017693
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e74ccf0
% @LO 0.01  28.12993897084554717480 99.9000000000
% @LN 0.01  28.13051955363585321379 99.9000000000
% Resuming node 10 at  28.13051955363585321379
DEBUG CONSTRNT: LP rows=56, pool->nlprows=56, pool->npend=0
DEBUG CONSTRNT: Checking 56 LP rows (pool tracks 56, total LP rows 56)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=55, expected 55
 % @PAP adding 34 rows, 168 nz to LP
DEBUG BB: Processing node 10, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=23, varin=36, theta=-2.252204, up=1.000000
ITER 2: row=8, varin=87, theta=1.639566, up=1.000000
ITER 3: row=8, varin=31, theta=0.404204, up=999999999999999983222784.000000
ITER 4: row=28, varin=87, theta=0.526323, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=34)
DEBUG SOLUTION: LP solution array indices: FST[35-74], not_covered[75-94]
DEBUG SOLUTION: lp->best_solution[0] = 28130519.553636
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 34 rows, 60 cols, 228 nonzeros, 3 slack, 31 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=35, varin=49, theta=0.536201, up=1.000000
ITER 2: row=1, varin=12, theta=0.066354, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=36)
DEBUG SOLUTION: LP solution array indices: FST[37-76], not_covered[77-96]
DEBUG SOLUTION: lp->best_solution[0] = 28139543.488461
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.933646
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 36 rows, 60 cols, 236 nonzeros, 4 slack, 32 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 4 rows, 16 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=33, varin=45, theta=0.250000, up=1.000000
ITER 2: row=32, varin=37, theta=0.500000, up=1.000000
ITER 3: row=2, varin=30, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=36)
DEBUG SOLUTION: LP solution array indices: FST[37-76], not_covered[77-96]
DEBUG SOLUTION: lp->best_solution[0] = 28180642.809359
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 36 rows, 60 cols, 244 nonzeros, 3 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % Node 10 LP 1 Solution, length = 28180642.809359, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.457215 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.500000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.542785 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.542785 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28180642.809359, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 10 at  28.18064280935943699546
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e74b550
% @LO 0.01  28.13051955363585321379 99.9000000000
% @LN 0.01  28.13937990207923789399 99.9000000000
% Resuming node 8 at  28.13937990207923789399
DEBUG CONSTRNT: LP rows=33, pool->nlprows=33, pool->npend=0
DEBUG CONSTRNT: Checking 33 LP rows (pool tracks 33, total LP rows 33)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 39
DEBUG CONSTRNT: Pool row 39 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 103
DEBUG CONSTRNT: Pool row 103 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=32, expected 32
 % @PAP adding 36 rows, 182 nz to LP
DEBUG BB: Processing node 8, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=23, varin=31, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=9, varin=49, theta=0.236620, up=1.000000
ITER 3: row=32, varin=33, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=9, varin=81, theta=3.125911, up=1.000000
ITER 5: row=9, varin=28, theta=0.264443, up=999999999999999983222784.000000
ITER 6: row=17, varin=81, theta=0.302010, up=1.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=36)
DEBUG SOLUTION: LP solution array indices: FST[37-76], not_covered[77-96]
DEBUG SOLUTION: lp->best_solution[0] = 28139379.902079
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 36 rows, 60 cols, 242 nonzeros, 3 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 4 rows, 17 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=26, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=34, varin=90, theta=0.881535, up=1.000000
ITER 3: row=1, varin=50, theta=0.500000, up=1.000000
ITER 4: row=33, varin=38, theta=0.500000, up=1.000000
ITER 5: row=2, varin=45, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 28251202.780826
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 37 rows, 60 cols, 253 nonzeros, 3 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 3 rows, 10 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=35, varin=55, theta=0.333333, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 28255233.638291
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 37 rows, 60 cols, 248 nonzeros, 1 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 6 rows, 31 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=37, varin=48, theta=0.500000, up=1.000000
ITER 2: row=36, varin=6, theta=0.111111, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28280257.415263
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.888889
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 277 nonzeros, 1 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=62, theta=0.333333, up=1.000000
ITER 2: row=39, varin=90, theta=0.038462, up=1.000000
ITER 3: row=41, varin=35, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=43, varin=99, theta=0.011442, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28300930.150512
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.991100
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 279 nonzeros, 5 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=49, theta=0.063600, up=1.000000
ITER 2: row=22, varin=6, theta=0.119588, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
ITER 3: row=11, varin=43, theta=0.000000, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28307455.753909
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.880412
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 3.000000
  % @PL 40 rows, 60 cols, 269 nonzeros, 3 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=9, theta=0.184769, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 28310561.291141
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.815231
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 39 rows, 60 cols, 262 nonzeros, 1 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 8 LP 1 Solution, length = 28310561.291141, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.333333 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.333333 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.333333 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.148565 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 1.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.666667 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.666667 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.666667 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.851435 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.851435 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28310561.291141, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 8 at  28.31056129114076469477
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e747c80
% @LO 0.01  28.13937990207923789399 99.9000000000
% @LN 0.01  28.15059222477673017693 99.9000000000
% Resuming node 2 at  28.15059222477673017693
DEBUG CONSTRNT: LP rows=38, pool->nlprows=38, pool->npend=0
DEBUG CONSTRNT: Checking 38 LP rows (pool tracks 38, total LP rows 38)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 150
DEBUG CONSTRNT: Pool row 150 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=37, expected 37
 % @PAP adding 56 rows, 239 nz to LP
DEBUG BB: Processing node 2, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 2 LP 5 Solution, length = 28150592.224777, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.410504 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.410504 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.205252 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.410504 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.178992 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.205252 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.205252 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.589496 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.794748 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.589496 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.589496 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.589496 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.794748 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=28150592.224777, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28150592.224777, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 2 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 2
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.410504
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.410504)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.410504
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.410504)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.205252
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.205252)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.410504
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.410504)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.178992
DEBUG CAREFUL: Adding var 30 to fractional list (xi=0.178992)
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.205252
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.205252)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.205252
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.205252)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 7 fractional variables

  %  Carefully choosing branching variable, nfrac = 7
DEBUG CAREFUL: Testing fvar[0] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 7
DEBUG CAREFUL: New best var: 7
DEBUG CAREFUL: Testing fvar[1] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 34
DEBUG CAREFUL: Testing fvar[2] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 36
DEBUG CAREFUL: Testing fvar[3] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[4] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
DEBUG CAREFUL: Testing fvar[5] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 29
DEBUG CAREFUL: Testing fvar[6] = var 30
DEBUG CAREFUL: Calling compare_branch_vars for var 30
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 30
DEBUG CAREFUL: New best var: 30
  % Initial guess is x30, Z0 = 28150592.2247767        , Z1 = 28289933.9452696        

DEBUG EVAL: Testing var 7 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=90, theta=0.570716, up=1.000000
ITER 2: row=18, varin=52, theta=0.259321, up=999999999999999983222784.000000
ITER 3: row=52, varin=26, theta=0.081843, up=999999999999999983222784.000000
ITER 4: row=55, varin=28, theta=0.012267, up=999999999999999983222784.000000
ITER 5: row=51, varin=35, theta=0.042775, up=999999999999999983222784.000000
ITER 6: row=46, varin=55, theta=0.165469, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 7 = 0 gives z=28182200.192143
  % 	x7 = 0,	Z0 = 28182200.1921428        
DEBUG EVAL: First branch cutoff check: z=28182200.192143, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 7 = 1
ITER 1: row=3, varin=56, theta=2.465513, up=999999999999999983222784.000000
ITER 2: row=18, varin=52, theta=0.449696, up=999999999999999983222784.000000
ITER 3: row=5, varin=13, theta=3.984087, up=999999999999999983222784.000000
ITER 4: row=4, varin=44, theta=0.740209, up=999999999999999983222784.000000
ITER 5: row=10, varin=49, theta=0.722729, up=999999999999999983222784.000000
ITER 6: row=49, varin=47, theta=0.757360, up=999999999999999983222784.000000
ITER 7: row=47, varin=22, theta=0.955653, up=999999999999999983222784.000000
ITER 8: row=11, varin=42, theta=1.894578, up=999999999999999983222784.000000
ITER 9: row=53, varin=81, theta=3.411400, up=1.000000
ITER 10: row=53, varin=78, theta=0.615044, up=1.000000
  % 	x7 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: Second branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=3, varin=90, theta=0.570716, up=1.000000
ITER 2: row=18, varin=52, theta=0.259321, up=999999999999999983222784.000000
ITER 3: row=52, varin=26, theta=0.081843, up=999999999999999983222784.000000
ITER 4: row=55, varin=28, theta=0.012267, up=999999999999999983222784.000000
ITER 5: row=51, varin=35, theta=0.042775, up=999999999999999983222784.000000
ITER 6: row=46, varin=55, theta=0.165469, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=6)
ITER 7: row=53, varin=18, theta=47143.500000, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 28434435.243133
DEBUG SOLUTION: lp->best_solution[1] = 19.132375
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
   % @PL 56 rows, 60 cols, 299 nonzeros, 6 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 6 slack rows
   % @PAP adding 1 rows, 40 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=65, theta=5.000000, up=1.000000
ITER 2: row=1, varin=62, theta=6.000000, up=1.000000
ITER 3: row=1, varin=68, theta=3.333333, up=1.000000
ITER 4: row=1, varin=53, theta=3.500000, up=1.000000
ITER 5: row=1, varin=67, theta=1.666667, up=1.000000
ITER 6: row=1, varin=66, theta=0.666667, up=1.000000
ITER 7: row=51, varin=92, theta=14.522968, up=1.000000
ITER 8: row=51, varin=93, theta=13.522968, up=1.000000
ITER 9: row=51, varin=94, theta=12.522968, up=1.000000
ITER 10: row=51, varin=95, theta=11.522968, up=1.000000
LP PHASE: Switching to primal (iter=68)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28180858.433560
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
   % @PL 51 rows, 60 cols, 289 nonzeros, 1 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 2 at  28.18085843355959596579
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e74ccf0
% @LO 0.01  28.15059222477673017693 99.9000000000
% @LN 0.01  28.18064280935943699546 99.9000000000
% Resuming node 10 at  28.18064280935943699546
DEBUG CONSTRNT: LP rows=51, pool->nlprows=51, pool->npend=0
DEBUG CONSTRNT: Checking 51 LP rows (pool tracks 51, total LP rows 51)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=50, expected 50
 % @PAP adding 33 rows, 170 nz to LP
DEBUG BB: Processing node 10, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 10 LP 2 Solution, length = 28180642.809359, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.457215 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.500000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.542785 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.542785 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28180642.809359, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28180642.809359, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 10 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 10
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=1.000000
DEBUG CAREFUL: Skipping var 9: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.457215
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.457215)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.500000
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.500000
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 3 fractional variables

  %  Carefully choosing branching variable, nfrac = 3
DEBUG CAREFUL: Testing fvar[0] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 12
DEBUG CAREFUL: New best var: 12
DEBUG CAREFUL: Testing fvar[1] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 15
DEBUG CAREFUL: Testing fvar[2] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x12, Z0 = 28180642.8093594        , Z1 = 28180642.8093594        

DEBUG EVAL: Testing var 12 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=16, varin=2, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=2, varin=31, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=31, varin=24, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=33, varin=25, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 12 = 1 gives z=28277425.672793
  % 	x12 = 1,	Z1 = 28277425.672793         
DEBUG EVAL: First branch cutoff check: z=28277425.672793, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 0
ITER 1: row=16, varin=51, theta=0.333333, up=1.000000
  % 	x12 = 0,	Z0 = 28188407.0927936        
DEBUG EVAL: Second branch cutoff check: z=28188407.092794, best_z=INF, threshold=INF
  %   New best:  x12, Z = 28188407.0927936        
DEBUG EVAL: Testing var 15 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=22, varin=51, theta=0.333333, up=1.000000
DEBUG EVAL: Branch var 15 = 0 gives z=28188407.092794
  % 	x15 = 0,	Z0 = 28188407.0927936        
DEBUG EVAL: First branch cutoff check: z=28188407.092794, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 15 = 1
ITER 1: row=22, varin=2, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=2, varin=31, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=31, varin=32, theta=0.500000, up=999999999999999983222784.000000
ITER 4: row=1, varin=8, theta=0.028056, up=999999999999999983222784.000000
ITER 5: row=8, varin=55, theta=0.543050, up=1.000000
  % 	x15 = 1,	Z1 = 28481526.4737016        
DEBUG EVAL: Second branch cutoff check: z=28481526.473702, best_z=INF, threshold=INF
  %   New best:  x15, Z = 28188407.0927936        
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=2, theta=2.057528, up=999999999999999983222784.000000
ITER 2: row=2, varin=78, theta=0.346447, up=1.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28219913.906314
  % 	x10 = 0,	Z0 = 28219913.9063142        
DEBUG EVAL: First branch cutoff check: z=28219913.906314, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 1
ITER 1: row=1, varin=8, theta=0.792508, up=999999999999999983222784.000000
ITER 2: row=8, varin=51, theta=4.009901, up=1.000000
ITER 3: row=8, varin=24, theta=1.281084, up=999999999999999983222784.000000
ITER 4: row=22, varin=51, theta=1.274516, up=1.000000
ITER 5: row=22, varin=31, theta=0.399026, up=999999999999999983222784.000000
ITER 6: row=33, varin=36, theta=0.968656, up=1.000000
ITER 7: row=12, varin=63, theta=1.543427, up=1.000000
ITER 8: row=12, varin=60, theta=0.461224, up=1.000000
ITER 9: row=31, varin=2, theta=0.285856, up=999999999999999983222784.000000
ITER 10: row=2, varin=12, theta=0.712144, up=999999999999999983222784.000000
  % 	x10 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: Second branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=2, theta=2.057528, up=999999999999999983222784.000000
ITER 2: row=2, varin=78, theta=0.346447, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=33)
DEBUG SOLUTION: LP solution array indices: FST[34-73], not_covered[74-93]
DEBUG SOLUTION: lp->best_solution[0] = 28219913.906314
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 33 rows, 60 cols, 230 nonzeros, 0 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 3 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=34, varin=37, theta=0.189148, up=1.000000
ITER 2: row=2, varin=54, theta=0.119570, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=36)
DEBUG SOLUTION: LP solution array indices: FST[37-76], not_covered[77-96]
DEBUG SOLUTION: lp->best_solution[0] = 28224089.216798
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 36 rows, 60 cols, 242 nonzeros, 0 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 8 rows, 43 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=37, varin=50, theta=0.167021, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28228009.010996
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 44 rows, 60 cols, 285 nonzeros, 0 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=65, theta=0.101454, up=1.000000
ITER 2: row=40, varin=93, theta=0.011466, up=1.000000
ITER 3: row=42, varin=102, theta=0.015075, up=1.000000
ITER 4: row=44, varin=23, theta=0.011935, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28236445.485192
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.988065
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 46 rows, 60 cols, 293 nonzeros, 6 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 6 slack rows
   % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=7, theta=0.133651, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28242359.868456
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.866349
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 3.000000
   % @PL 43 rows, 60 cols, 287 nonzeros, 3 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 3 slack rows
   % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=36, theta=0.896015, up=999999999999999983222784.000000
ITER 2: row=39, varin=85, theta=0.263929, up=1.000000
LP PHASE: Switching to primal (iter=2)
ITER 3: row=20, varin=39, theta=0.000000, up=999999999999999983222784.000000
ITER 4: row=28, varin=34, theta=0.000000, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28245691.013266
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.736071
DEBUG SOLUTION: lp->best_solution[4] = 0.736071
DEBUG SOLUTION: lp->best_solution[5] = 2.472142
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 43 rows, 60 cols, 282 nonzeros, 3 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 3 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 10 at  28.24569101326601838764
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e747c80
% @LO 0.01  28.18064280935943699546 99.9000000000
% @LN 0.01  28.18085843355959596579 99.9000000000
% Resuming node 2 at  28.18085843355959596579
DEBUG CONSTRNT: LP rows=40, pool->nlprows=40, pool->npend=0
DEBUG CONSTRNT: Checking 40 LP rows (pool tracks 40, total LP rows 40)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=39, expected 39
 % @PAP adding 51 rows, 229 nz to LP
DEBUG BB: Processing node 2, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 2 LP 6 Solution, length = 28180858.433560, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.500000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.500000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.500000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.500000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28180858.433560, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28180858.433560, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 2 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 2
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.500000
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.500000
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.500000
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.500000
DEBUG CAREFUL: Adding var 33 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 33
DEBUG CAREFUL: Calling compare_branch_vars for var 33
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 33
DEBUG CAREFUL: New best var: 33
DEBUG CAREFUL: Testing fvar[1] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[2] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
DEBUG CAREFUL: Testing fvar[3] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 29
  % Initial guess is x33, Z0 = 28434435.2431331        , Z1 = 28434435.2431331        

DEBUG EVAL: Testing var 33 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=78, theta=0.125000, up=1.000000
ITER 2: row=51, varin=43, theta=0.825694, up=999999999999999983222784.000000
ITER 3: row=32, varin=89, theta=0.471747, up=1.000000
DEBUG EVAL: Branch var 33 = 0 gives z=28196997.689184
  % 	x33 = 0,	Z0 = 28434435.2431331        
DEBUG EVAL: First branch cutoff check: z=28434435.243133, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 33 = 1
ITER 1: row=1, varin=44, theta=0.125000, up=999999999999999983222784.000000
ITER 2: row=49, varin=13, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=13, varin=43, theta=0.178571, up=999999999999999983222784.000000
ITER 4: row=10, varin=42, theta=0.150000, up=999999999999999983222784.000000
ITER 5: row=48, varin=41, theta=0.269231, up=999999999999999983222784.000000
ITER 6: row=44, varin=45, theta=0.184211, up=999999999999999983222784.000000
ITER 7: row=45, varin=10, theta=0.500000, up=999999999999999983222784.000000
ITER 8: row=41, varin=38, theta=0.500000, up=999999999999999983222784.000000
ITER 9: row=38, varin=36, theta=0.500000, up=999999999999999983222784.000000
ITER 10: row=36, varin=34, theta=0.500000, up=999999999999999983222784.000000
  % 	x33 = 1,	Z1 = 28434435.2431331        
DEBUG EVAL: Second branch cutoff check: z=28434435.243133, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=4, varin=50, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 0 gives z=28359658.391435
  % 	x1 = 0,	Z0 = 28434435.2431331        
DEBUG EVAL: First branch cutoff check: z=28434435.243133, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 1
ITER 1: row=4, varin=26, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=51, varin=44, theta=0.054545, up=999999999999999983222784.000000
ITER 3: row=49, varin=11, theta=0.052718, up=999999999999999983222784.000000
ITER 4: row=21, varin=43, theta=0.087277, up=999999999999999983222784.000000
ITER 5: row=1, varin=74, theta=0.139658, up=1.000000
ITER 6: row=48, varin=49, theta=0.187433, up=999999999999999983222784.000000
ITER 7: row=32, varin=75, theta=0.415953, up=1.000000
ITER 8: row=1, varin=40, theta=0.044540, up=999999999999999983222784.000000
ITER 9: row=48, varin=73, theta=0.578479, up=1.000000
ITER 10: row=24, varin=85, theta=0.542571, up=1.000000
  % 	x1 = 1,	Z1 = 28434435.2431331        
DEBUG EVAL: Second branch cutoff check: z=28434435.243133, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 0 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=26, varin=50, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 0 = 0 gives z=28359658.391435
  % 	x0 = 0,	Z0 = 28434435.2431331        
DEBUG EVAL: First branch cutoff check: z=28434435.243133, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 0 = 1
ITER 1: row=26, varin=4, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=51, varin=44, theta=0.091023, up=999999999999999983222784.000000
ITER 3: row=27, varin=5, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=29, varin=28, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=1, varin=11, theta=0.454992, up=999999999999999983222784.000000
ITER 6: row=47, varin=74, theta=1.234145, up=1.000000
ITER 7: row=47, varin=89, theta=0.414085, up=1.000000
ITER 8: row=49, varin=75, theta=2.152116, up=1.000000
ITER 9: row=49, varin=43, theta=0.413111, up=999999999999999983222784.000000
ITER 10: row=47, varin=74, theta=0.319785, up=1.000000
  % 	x0 = 1,	Z1 = 29291415.1996965        
DEBUG EVAL: Second branch cutoff check: z=29291415.199697, best_z=INF, threshold=INF
  %   New best:  x0, Z = 28434435.2431331        
DEBUG EVAL: Testing var 29 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=28, varin=28, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 29 = 0 gives z=28283598.797672
  % 	x29 = 0,	Z0 = 28434435.2431331        
DEBUG EVAL: First branch cutoff check: z=28434435.243133, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 29 = 1
ITER 1: row=28, varin=5, theta=0.500000, up=999999999999999983222784.000000
  % 	x29 = 1,	Z1 = 28434435.2431331        
DEBUG EVAL: Second branch cutoff check: z=28434435.243133, best_z=INF, threshold=INF
  % Best branch is x0, Z0 = 28434435.2431331        , Z1 = 29291415.1996965        

DEBUG CAREFUL: Final result - returning best.var = 0
DEBUG BB: Branching variable chosen: j=0
 % @NC   11    2	x0 = 0	28434435.243133
 % @NC   12    2	x0 = 1	29291415.199697
 %       2     7 28180858.4336               28181827.3400   x19 U     0     1
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e74a950
% @LO 0.01  28.18085843355959596579 99.9000000000
% @LN 0.01  28.18182733997376487878 99.9000000000
% Resuming node 4 at  28.18182733997376487878
DEBUG CONSTRNT: LP rows=51, pool->nlprows=51, pool->npend=0
DEBUG CONSTRNT: Checking 51 LP rows (pool tracks 51, total LP rows 51)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=50, expected 50
 % @PAP adding 51 rows, 228 nz to LP
DEBUG BB: Processing node 4, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 4 LP 2 Solution, length = 28181827.339974, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.165902 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.165902 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.165902 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.165902 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.165902 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.004586 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.165902 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.834098 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.834098 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.834098 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.834098 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.834098 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.834098 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.834098 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=28181827.339974, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28181827.339974, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 4 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 4
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.165902
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.165902)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.165902
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.165902)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.165902
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.165902)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=1.000000
DEBUG CAREFUL: Skipping var 13: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.165902
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.165902)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.165902
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.165902)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.004586
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.004586)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.165902
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.165902)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 7 fractional variables

  %  Carefully choosing branching variable, nfrac = 7
DEBUG CAREFUL: Testing fvar[0] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 2
DEBUG CAREFUL: New best var: 2
DEBUG CAREFUL: Testing fvar[1] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 22
DEBUG CAREFUL: New best var: 22
DEBUG CAREFUL: Testing fvar[2] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[3] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[4] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 18
DEBUG CAREFUL: Testing fvar[5] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[6] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
  % Initial guess is x22, Z0 = 28181827.3399738        , Z1 = 28452175.7298175        

DEBUG EVAL: Testing var 2 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=32, theta=1.539190, up=999999999999999983222784.000000
ITER 2: row=31, varin=33, theta=0.934645, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 1 gives z=28641328.917477
  % 	x2 = 1,	Z1 = 28641328.9174775        
DEBUG EVAL: First branch cutoff check: z=28641328.917477, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 0
ITER 1: row=1, varin=51, theta=0.181416, up=999999999999999983222784.000000
  % 	x2 = 0,	Z0 = 28187124.2675568        
DEBUG EVAL: Second branch cutoff check: z=28187124.267557, best_z=INF, threshold=INF
  %   New best:  x2, Z = 28187124.2675568        
DEBUG EVAL: Testing var 22 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=33, varin=31, theta=2.067548, up=999999999999999983222784.000000
ITER 2: row=31, varin=51, theta=2.044342, up=999999999999999983222784.000000
ITER 3: row=1, varin=52, theta=1.782439, up=1.000000
ITER 4: row=1, varin=48, theta=0.425514, up=999999999999999983222784.000000
ITER 5: row=42, varin=45, theta=0.596505, up=999999999999999983222784.000000
ITER 6: row=5, varin=52, theta=1.491784, up=1.000000
ITER 7: row=5, varin=32, theta=5.627670, up=999999999999999983222784.000000
ITER 8: row=33, varin=37, theta=0.810845, up=999999999999999983222784.000000
ITER 9: row=37, varin=40, theta=0.547260, up=999999999999999983222784.000000
ITER 10: row=38, varin=42, theta=0.491215, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 22 = 1 gives z=28451830.543124
  % 	x22 = 1,	Z1 = 28452175.7298175        
DEBUG EVAL: First branch cutoff check: z=28452175.729818, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 22 = 0
ITER 1: row=33, varin=76, theta=0.012175, up=1.000000
ITER 2: row=12, varin=63, theta=0.006526, up=1.000000
  % 	x22 = 0,	Z0 = 28182114.6455123        
DEBUG EVAL: Second branch cutoff check: z=28182114.645512, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=8, varin=51, theta=9.753845, up=999999999999999983222784.000000
ITER 2: row=1, varin=32, theta=1.381387, up=999999999999999983222784.000000
ITER 3: row=31, varin=39, theta=2.156173, up=999999999999999983222784.000000
ITER 4: row=43, varin=40, theta=1.038136, up=999999999999999983222784.000000
ITER 5: row=33, varin=54, theta=0.468458, up=1.000000
ITER 6: row=8, varin=76, theta=0.589265, up=1.000000
ITER 7: row=12, varin=77, theta=0.220378, up=1.000000
ITER 8: row=28, varin=73, theta=0.089091, up=1.000000
ITER 9: row=16, varin=21, theta=0.045111, up=999999999999999983222784.000000
ITER 10: row=33, varin=43, theta=0.081755, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x10 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=8, varin=76, theta=8.073397, up=1.000000
ITER 2: row=8, varin=63, theta=0.672314, up=1.000000
ITER 3: row=33, varin=76, theta=2.725451, up=1.000000
ITER 4: row=33, varin=52, theta=0.344325, up=1.000000
ITER 5: row=5, varin=37, theta=0.610235, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28265708.432456
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
   % @PL 51 rows, 60 cols, 288 nonzeros, 1 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 6 rows, 34 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=17, theta=0.661109, up=999999999999999983222784.000000
ITER 2: row=52, varin=8, theta=0.117897, up=999999999999999983222784.000000
ITER 3: row=42, varin=52, theta=0.733032, up=999999999999999983222784.000000
ITER 4: row=25, varin=42, theta=0.295559, up=999999999999999983222784.000000
ITER 5: row=56, varin=61, theta=0.047718, up=1.000000
ITER 6: row=37, varin=56, theta=0.723009, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 28273678.206634
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.864110
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
   % @PL 56 rows, 60 cols, 316 nonzeros, 6 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 6 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 4 at  28.27367820663385700186
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e743b80
% @LO 0.01  28.18182733997376487878 99.9000000000
% @LN 0.01  28.19782027216982456252 99.9000000000
% Resuming node 9 at  28.19782027216982456252
DEBUG CONSTRNT: LP rows=50, pool->nlprows=50, pool->npend=0
DEBUG CONSTRNT: Checking 50 LP rows (pool tracks 50, total LP rows 50)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=49, expected 49
 % @PAP adding 43 rows, 207 nz to LP
DEBUG BB: Processing node 9, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 9 LP 2 Solution, length = 28197820.272170, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.349894 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.269979 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.269979 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.269979 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 1.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.269979 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.269979 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.730021 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.650106 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.650106 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.730021 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.730021 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.650106 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.730021 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.730021 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.730021 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28197820.272170, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28197820.272170, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 3 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 9 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 9
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.349894
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.349894)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.269979
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.269979)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.269979
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.269979)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.269979
DEBUG CAREFUL: Adding var 8 to fractional list (xi=0.269979)
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=1.000000
DEBUG CAREFUL: Skipping var 10: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.269979
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.269979)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.269979
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.269979)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 1
DEBUG CAREFUL: New best var: 1
DEBUG CAREFUL: Testing fvar[1] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
DEBUG CAREFUL: Testing fvar[2] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 5
DEBUG CAREFUL: Testing fvar[3] = var 8
DEBUG CAREFUL: Calling compare_branch_vars for var 8
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 8
DEBUG CAREFUL: New best var: 8
DEBUG CAREFUL: Testing fvar[4] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
DEBUG CAREFUL: Testing fvar[5] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 15
  % Initial guess is x8, Z0 = 28197820.2721698        , Z1 = 28242929.2011264        

DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=43, theta=1.632895, up=999999999999999983222784.000000
ITER 2: row=43, varin=31, theta=0.344905, up=999999999999999983222784.000000
ITER 3: row=31, varin=32, theta=0.009345, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 0 gives z=28217842.280677
  % 	x1 = 0,	Z0 = 28217842.2806769        
DEBUG EVAL: First branch cutoff check: z=28217842.280677, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 1
ITER 1: row=1, varin=54, theta=0.464891, up=1.000000
ITER 2: row=41, varin=43, theta=0.549017, up=999999999999999983222784.000000
  % 	x1 = 1,	Z1 = 28205120.65552          
DEBUG EVAL: Second branch cutoff check: z=28205120.655520, best_z=INF, threshold=INF
  %   New best:  x1, Z = 28205120.65552          
DEBUG EVAL: Testing var 12 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=31, varin=54, theta=0.575004, up=1.000000
ITER 2: row=41, varin=31, theta=0.336258, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 12 = 0 gives z=28217306.870745
  % 	x12 = 0,	Z0 = 28217306.8707449        
DEBUG EVAL: First branch cutoff check: z=28217306.870745, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 1
ITER 1: row=31, varin=43, theta=1.441730, up=999999999999999983222784.000000
ITER 2: row=43, varin=27, theta=0.946143, up=999999999999999983222784.000000
  % 	x12 = 1,	Z1 = 28213534.4225539        
DEBUG EVAL: Second branch cutoff check: z=28213534.422554, best_z=INF, threshold=INF
  %   New best:  x12, Z = 28213534.4225539        
DEBUG EVAL: Testing var 5 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=54, theta=0.575004, up=1.000000
ITER 2: row=41, varin=32, theta=0.602175, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 5 = 0 gives z=28208342.175895
  % 	x5 = 0,	Z0 = 28208342.1758954        
DEBUG EVAL: First branch cutoff check: z=28208342.175895, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 8 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=27, varin=43, theta=1.441730, up=999999999999999983222784.000000
ITER 2: row=43, varin=32, theta=1.323315, up=999999999999999983222784.000000
ITER 3: row=7, varin=35, theta=0.418145, up=999999999999999983222784.000000
ITER 4: row=35, varin=2, theta=0.631373, up=999999999999999983222784.000000
ITER 5: row=2, varin=40, theta=0.572067, up=999999999999999983222784.000000
ITER 6: row=20, varin=25, theta=0.578218, up=999999999999999983222784.000000
ITER 7: row=28, varin=31, theta=0.904890, up=999999999999999983222784.000000
ITER 8: row=1, varin=54, theta=0.589505, up=1.000000
DEBUG EVAL: Branch var 8 = 1 gives z=28269189.219800
  % 	x8 = 1,	Z1 = 28269189.2197996        
DEBUG EVAL: First branch cutoff check: z=28269189.219800, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 8 = 0
ITER 1: row=27, varin=54, theta=0.575004, up=1.000000
ITER 2: row=41, varin=27, theta=1.181921, up=999999999999999983222784.000000
ITER 3: row=22, varin=6, theta=0.102555, up=999999999999999983222784.000000
  % 	x8 = 0,	Z0 = 28218473.6986018        
DEBUG EVAL: Second branch cutoff check: z=28218473.698602, best_z=INF, threshold=INF
  %   New best:  x8, Z = 28218473.6986018        
DEBUG EVAL: Testing var 7 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=20, varin=54, theta=0.575004, up=1.000000
ITER 2: row=41, varin=32, theta=0.602175, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 7 = 0 gives z=28208342.175895
  % 	x7 = 0,	Z0 = 28208342.1758955        
DEBUG EVAL: First branch cutoff check: z=28208342.175895, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 15 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=22, varin=54, theta=0.575004, up=1.000000
ITER 2: row=41, varin=6, theta=0.666286, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 15 = 0 gives z=28224098.738287
  % 	x15 = 0,	Z0 = 28224098.7382866        
DEBUG EVAL: First branch cutoff check: z=28224098.738287, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 15 = 1
ITER 1: row=22, varin=43, theta=1.441730, up=999999999999999983222784.000000
ITER 2: row=43, varin=27, theta=0.946143, up=999999999999999983222784.000000
  % 	x15 = 1,	Z1 = 28213534.4225539        
DEBUG EVAL: Second branch cutoff check: z=28213534.422554, best_z=INF, threshold=INF
  % Best branch is x8, Z0 = 28218473.6986018        , Z1 = 28269189.2197996        

DEBUG CAREFUL: Final result - returning best.var = 8
DEBUG BB: Branching variable chosen: j=8
 % @NC   13    9	x8 = 0	28218473.698602
 % @NC   14    9	x8 = 1	28269189.219800
 %       9     8 28197820.2722               28218473.6986    x9 D     7     5
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e747c80
% @LO 0.01  28.19782027216982456252 99.9000000000
% @LN 0.01  28.21847369860175547274 99.9000000000
% Resuming node 13 at  28.21847369860175547274
DEBUG CONSTRNT: LP rows=43, pool->nlprows=43, pool->npend=0
DEBUG CONSTRNT: Checking 43 LP rows (pool tracks 43, total LP rows 43)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 62
DEBUG CONSTRNT: Pool row 62 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=42, expected 42
 % @PAP adding 43 rows, 207 nz to LP
DEBUG BB: Processing node 13, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=27, varin=54, theta=0.575004, up=1.000000
ITER 2: row=41, varin=27, theta=1.181921, up=999999999999999983222784.000000
ITER 3: row=22, varin=6, theta=0.102555, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28218473.698602
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.897445
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 3.000000
  % @PL 43 rows, 60 cols, 267 nonzeros, 6 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 5 rows, 16 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=64, theta=0.500000, up=1.000000
ITER 2: row=44, varin=37, theta=1.446535, up=999999999999999983222784.000000
ITER 3: row=42, varin=90, theta=0.769394, up=1.000000
LP PHASE: Switching to primal (iter=3)
ITER 4: row=1, varin=29, theta=0.330281, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28235609.086397
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 3.000000
  % @PL 48 rows, 60 cols, 283 nonzeros, 4 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=55, theta=9.500000, up=1.000000
ITER 2: row=1, varin=46, theta=8.500000, up=1.000000
ITER 3: row=1, varin=60, theta=5.000000, up=1.000000
ITER 4: row=1, varin=52, theta=6.000000, up=1.000000
ITER 5: row=1, varin=85, theta=10.000000, up=1.000000
ITER 6: row=1, varin=86, theta=9.000000, up=1.000000
ITER 7: row=1, varin=87, theta=8.000000, up=1.000000
ITER 8: row=1, varin=88, theta=7.000000, up=1.000000
ITER 9: row=1, varin=89, theta=6.000000, up=1.000000
ITER 10: row=1, varin=90, theta=5.000000, up=1.000000
LP PHASE: Switching to primal (iter=51)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28235609.086397
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 3.000000
  % @PL 44 rows, 60 cols, 275 nonzeros, 0 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 13 LP 1 Solution, length = 28235609.086397, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.160562 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.330281 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.330281 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 1.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.500000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.669719 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.839438 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.839438 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.839438 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.669719 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28235609.086397, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.01  28.21847369860175547274 99.9000000000
 % @LN 0.01  28.23560908639741029447 99.9000000000
DEBUG CG: Second cutoff check: z=28235609.086397, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 3 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 13 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 13
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.160562
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.160562)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.330281
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.330281)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.330281
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.330281)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=1.000000
DEBUG CAREFUL: Skipping var 10: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.500000
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.500000
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 12
DEBUG CAREFUL: New best var: 12
DEBUG CAREFUL: Testing fvar[1] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 15
DEBUG CAREFUL: Testing fvar[2] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 5
DEBUG CAREFUL: Testing fvar[3] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
DEBUG CAREFUL: Testing fvar[4] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
  % Initial guess is x12, Z0 = 28235609.0863974        , Z1 = 28235609.0863974        

DEBUG EVAL: Testing var 12 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=27, varin=42, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 12 = 0 gives z=28248923.457290
  % 	x12 = 0,	Z0 = 28248923.4572898        
DEBUG EVAL: First branch cutoff check: z=28248923.457290, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 1
ITER 1: row=27, varin=26, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=29, varin=22, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=30, varin=23, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=1, varin=86, theta=4.755485, up=1.000000
ITER 5: row=1, varin=39, theta=0.459466, up=999999999999999983222784.000000
  % 	x12 = 1,	Z1 = 28528846.1014117        
DEBUG EVAL: Second branch cutoff check: z=28528846.101412, best_z=INF, threshold=INF
  %   New best:  x12, Z = 28248923.4572898        
DEBUG EVAL: Testing var 15 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=22, varin=42, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 15 = 0 gives z=28248923.457290
  % 	x15 = 0,	Z0 = 28248923.4572898        
DEBUG EVAL: First branch cutoff check: z=28248923.457290, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 15 = 1
ITER 1: row=22, varin=27, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=86, theta=6.984037, up=1.000000
ITER 3: row=1, varin=39, theta=0.732119, up=999999999999999983222784.000000
  % 	x15 = 1,	Z1 = 28332581.0620523        
DEBUG EVAL: Second branch cutoff check: z=28332581.062052, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 5 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=86, theta=0.769394, up=1.000000
DEBUG EVAL: Branch var 5 = 0 gives z=28235752.918322
  % 	x5 = 0,	Z0 = 28235752.9183222        
DEBUG EVAL: First branch cutoff check: z=28235752.918322, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 7 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=20, varin=86, theta=0.769394, up=1.000000
DEBUG EVAL: Branch var 7 = 0 gives z=28235752.918322
  % 	x7 = 0,	Z0 = 28235752.9183222        
DEBUG EVAL: First branch cutoff check: z=28235752.918322, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=41, theta=0.075565, up=999999999999999983222784.000000
ITER 2: row=33, varin=37, theta=0.078510, up=999999999999999983222784.000000
ITER 3: row=10, varin=27, theta=0.139806, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 0 gives z=28247065.740014
  % 	x1 = 0,	Z0 = 28247065.7400137        
DEBUG EVAL: First branch cutoff check: z=28247065.740014, best_z=INF, threshold=INF
  % Best branch is x12, Z0 = 28248923.4572898        , Z1 = 28528846.1014117        

DEBUG CAREFUL: Final result - returning best.var = 12
DEBUG BB: Branching variable chosen: j=12
 % @NC   15   13	x12 = 0	28248923.457290
 % @NC   16   13	x12 = 1	28528846.101412
 %      13     9 28235609.0864               28245691.0133    x8 D     9     6
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e74ccf0
% @LO 0.01  28.23560908639741029447 99.9000000000
% @LN 0.01  28.24569101326601838764 99.9000000000
% Resuming node 10 at  28.24569101326601838764
DEBUG CONSTRNT: LP rows=44, pool->nlprows=44, pool->npend=0
DEBUG CONSTRNT: Checking 44 LP rows (pool tracks 44, total LP rows 44)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 18
DEBUG CONSTRNT: Pool row 18 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=43, expected 43
 % @PAP adding 40 rows, 214 nz to LP
DEBUG BB: Processing node 10, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 10 LP 3 Solution, length = 28245691.013266, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.263929 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.263929 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.500000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.736071 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.736071 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.736071 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.736071 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28245691.013266, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28245691.013266, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 10 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 10
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.263929
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.263929)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.263929
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.263929)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=1.000000
DEBUG CAREFUL: Skipping var 9: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.500000
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.500000
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 12
DEBUG CAREFUL: New best var: 12
DEBUG CAREFUL: Testing fvar[1] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 15
DEBUG CAREFUL: New best var: 15
DEBUG CAREFUL: Testing fvar[2] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[3] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
  % Initial guess is x15, Z0 = 28245691.013266         , Z1 = 28481526.4737016        

DEBUG EVAL: Testing var 12 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=4, varin=17, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=26, varin=18, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=2, varin=43, theta=0.191582, up=1.000000
ITER 4: row=7, varin=70, theta=0.350274, up=1.000000
DEBUG EVAL: Branch var 12 = 1 gives z=28504229.220748
  % 	x12 = 1,	Z1 = 28504229.2207482        
DEBUG EVAL: First branch cutoff check: z=28504229.220748, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 0
ITER 1: row=4, varin=25, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=5, varin=43, theta=0.639260, up=1.000000
ITER 3: row=7, varin=27, theta=0.953193, up=999999999999999983222784.000000
  % 	x12 = 0,	Z0 = 28317597.3537524        
DEBUG EVAL: Second branch cutoff check: z=28317597.353752, best_z=INF, threshold=INF
  %   New best:  x12, Z = 28317597.3537524        
DEBUG EVAL: Testing var 15 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=16, varin=25, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=2, varin=43, theta=0.639260, up=1.000000
ITER 3: row=7, varin=70, theta=1.168772, up=1.000000
ITER 4: row=7, varin=47, theta=0.107808, up=1.000000
ITER 5: row=17, varin=67, theta=0.576997, up=1.000000
ITER 6: row=33, varin=34, theta=0.268023, up=999999999999999983222784.000000
ITER 7: row=34, varin=37, theta=0.081636, up=999999999999999983222784.000000
ITER 8: row=7, varin=24, theta=0.182117, up=999999999999999983222784.000000
ITER 9: row=24, varin=2, theta=0.229792, up=999999999999999983222784.000000
ITER 10: row=1, varin=7, theta=0.664426, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 15 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x15 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=16, varin=27, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=59, theta=0.011977, up=1.000000
ITER 3: row=31, varin=58, theta=0.001387, up=1.000000
ITER 4: row=36, varin=3, theta=0.021729, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28320445.077510
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.978271
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
   % @PL 40 rows, 60 cols, 274 nonzeros, 5 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 5 slack rows
   % @PAP adding 7 rows, 31 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=43, theta=1.159109, up=1.000000
ITER 2: row=36, varin=16, theta=0.262287, up=999999999999999983222784.000000
ITER 3: row=40, varin=43, theta=0.447513, up=1.000000
ITER 4: row=25, varin=27, theta=2.578947, up=999999999999999983222784.000000
ITER 5: row=39, varin=45, theta=0.190089, up=1.000000
ITER 6: row=6, varin=49, theta=0.207484, up=1.000000
ITER 7: row=41, varin=46, theta=0.243783, up=1.000000
ITER 8: row=34, varin=41, theta=0.506076, up=999999999999999983222784.000000
ITER 9: row=6, varin=39, theta=0.568727, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=9)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28392898.751306
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 3.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
   % @PL 42 rows, 60 cols, 285 nonzeros, 5 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 5 slack rows
   % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=27, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=4, varin=47, theta=0.121841, up=1.000000
ITER 3: row=37, varin=21, theta=0.014844, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28402452.586522
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 3.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
   % @PL 40 rows, 60 cols, 257 nonzeros, 2 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
   % @PAP adding 3 rows, 10 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=71, theta=0.203819, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28403734.988081
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 3.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
   % @PL 41 rows, 60 cols, 257 nonzeros, 0 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 4 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=29, theta=0.450693, up=999999999999999983222784.000000
ITER 2: row=36, varin=72, theta=0.192890, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28417874.181618
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 3.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
   % @PL 45 rows, 60 cols, 270 nonzeros, 0 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 2 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=55, theta=4.142466, up=1.000000
ITER 2: row=46, varin=101, theta=0.253973, up=1.000000
ITER 3: row=22, varin=55, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28437598.127290
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.665208
DEBUG SOLUTION: lp->best_solution[8] = 0.665208
DEBUG SOLUTION: lp->best_solution[9] = 2.330416
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
   % @PL 47 rows, 60 cols, 275 nonzeros, 3 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 3 slack rows
   % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=82, theta=0.170425, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28437720.836389
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 45 rows, 60 cols, 269 nonzeros, 0 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=56, theta=19.092258, up=1.000000
ITER 2: row=46, varin=70, theta=0.077281, up=1.000000
ITER 3: row=19, varin=56, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28443369.365248
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 47 rows, 60 cols, 277 nonzeros, 0 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 10 at  28.44336936524820913519
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e743b80
% @LO 0.01  28.24569101326601838764 99.9000000000
% @LN 0.01  28.24892345728976295050 99.9000000000
% Resuming node 15 at  28.24892345728976295050
DEBUG CONSTRNT: LP rows=47, pool->nlprows=47, pool->npend=0
DEBUG CONSTRNT: Checking 47 LP rows (pool tracks 47, total LP rows 47)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=46, expected 46
 % @PAP adding 44 rows, 215 nz to LP
DEBUG BB: Processing node 15, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=27, varin=42, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28248923.457290
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 3.000000
  % @PL 44 rows, 60 cols, 275 nonzeros, 3 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 5 rows, 33 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=88, theta=1.333532, up=1.000000
ITER 2: row=42, varin=40, theta=0.122966, up=999999999999999983222784.000000
ITER 3: row=38, varin=34, theta=0.484670, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28256437.306064
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.903066
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 3.000000
  % @PL 46 rows, 60 cols, 296 nonzeros, 8 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 8 slack rows
  % @PAP adding 3 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=83, theta=0.526672, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28267908.594912
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 41 rows, 60 cols, 264 nonzeros, 1 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 15 LP 1 Solution, length = 28267908.594912, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.473328 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.473328 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.750000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.250000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.250000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.526672 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.750000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.526672 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.526672 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.750000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.526672 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.250000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.250000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.750000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.250000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28267908.594912, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.01  28.24892345728976295050 99.9000000000
 % @LN 0.01  28.26790859491162422046 99.9000000000
DEBUG CG: Second cutoff check: z=28267908.594912, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 15 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 15
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.473328
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.473328)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.473328
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.473328)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.750000
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.750000)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.250000
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.250000
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 10
DEBUG CAREFUL: New best var: 10
DEBUG CAREFUL: Testing fvar[1] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[2] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
DEBUG CAREFUL: Testing fvar[3] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[4] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
  % Initial guess is x18, Z0 = 28267908.5949116        , Z1 = 28374951.0898953        

DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=43, theta=0.500000, up=1.000000
ITER 2: row=7, varin=31, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=33, varin=23, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=2, varin=44, theta=0.319004, up=1.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28318320.194466
  % 	x10 = 1,	Z1 = 28318320.1944663        
DEBUG EVAL: First branch cutoff check: z=28318320.194466, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=3, varin=32, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=39, theta=0.426830, up=999999999999999983222784.000000
ITER 3: row=2, varin=23, theta=0.403741, up=999999999999999983222784.000000
ITER 4: row=6, varin=41, theta=0.347277, up=1.000000
  % 	x10 = 0,	Z0 = 28293147.587438         
DEBUG EVAL: Second branch cutoff check: z=28293147.587438, best_z=INF, threshold=INF
  %   New best:  x10, Z = 28293147.587438         
DEBUG EVAL: Testing var 17 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=32, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=27, varin=23, theta=0.193327, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 0 gives z=28278728.281777
  % 	x17 = 0,	Z0 = 28278728.2817773        
DEBUG EVAL: First branch cutoff check: z=28278728.281777, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 18 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=16, varin=39, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=35, theta=0.904603, up=999999999999999983222784.000000
ITER 3: row=29, varin=34, theta=1.162990, up=999999999999999983222784.000000
ITER 4: row=6, varin=28, theta=0.186893, up=999999999999999983222784.000000
ITER 5: row=35, varin=32, theta=1.623633, up=999999999999999983222784.000000
ITER 6: row=11, varin=22, theta=0.536924, up=999999999999999983222784.000000
ITER 7: row=36, varin=21, theta=0.293419, up=999999999999999983222784.000000
ITER 8: row=18, varin=18, theta=0.226964, up=999999999999999983222784.000000
ITER 9: row=19, varin=19, theta=0.174074, up=999999999999999983222784.000000
ITER 10: row=22, varin=6, theta=0.511614, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 18 = 1 gives z=28473919.362951
  % 	x18 = 1,	Z1 = 28473919.3629508        
DEBUG EVAL: First branch cutoff check: z=28473919.362951, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 18 = 0
ITER 1: row=16, varin=32, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=27, varin=23, theta=0.193327, up=999999999999999983222784.000000
  % 	x18 = 0,	Z0 = 28278728.2817773        
DEBUG EVAL: Second branch cutoff check: z=28278728.281777, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=23, theta=0.291459, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 0 gives z=28282316.020254
  % 	x1 = 0,	Z0 = 28282316.0202542        
DEBUG EVAL: First branch cutoff check: z=28282316.020254, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 0 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=39, theta=0.550250, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 0 = 0 gives z=28278218.002370
  % 	x0 = 0,	Z0 = 28278218.0023703        
DEBUG EVAL: First branch cutoff check: z=28278218.002370, best_z=INF, threshold=INF
  % Best branch is x10, Z0 = 28293147.587438         , Z1 = 28318320.1944663        

DEBUG CAREFUL: Final result - returning best.var = 10
DEBUG BB: Branching variable chosen: j=10
 % @NC   17   15	x10 = 0	28293147.587438
 % @NC   18   15	x10 = 1	28318320.194466
 %      15    10 28267908.5949               28269189.2198   x12 D    13     7
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e74a340
% @LO 0.01  28.26790859491162422046 99.9000000000
% @LN 0.01  28.26918921979961751845 99.9000000000
% Resuming node 14 at  28.26918921979961751845
DEBUG CONSTRNT: LP rows=40, pool->nlprows=40, pool->npend=0
DEBUG CONSTRNT: Checking 40 LP rows (pool tracks 40, total LP rows 40)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 73
DEBUG CONSTRNT: Pool row 73 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=39, expected 39
 % @PAP adding 43 rows, 207 nz to LP
DEBUG BB: Processing node 14, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=27, varin=43, theta=1.441730, up=999999999999999983222784.000000
ITER 2: row=43, varin=32, theta=1.323315, up=999999999999999983222784.000000
ITER 3: row=7, varin=35, theta=0.418145, up=999999999999999983222784.000000
ITER 4: row=35, varin=2, theta=0.631373, up=999999999999999983222784.000000
ITER 5: row=2, varin=40, theta=0.572067, up=999999999999999983222784.000000
ITER 6: row=20, varin=25, theta=0.578218, up=999999999999999983222784.000000
ITER 7: row=28, varin=31, theta=0.904890, up=999999999999999983222784.000000
ITER 8: row=1, varin=54, theta=0.589505, up=1.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28269189.219800
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 3.000000
  % @PL 43 rows, 60 cols, 267 nonzeros, 6 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 4 rows, 20 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=26, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=43, theta=0.132312, up=1.000000
ITER 3: row=10, varin=49, theta=0.041823, up=1.000000
ITER 4: row=35, varin=42, theta=0.046159, up=1.000000
ITER 5: row=2, varin=59, theta=0.030570, up=1.000000
ITER 6: row=30, varin=47, theta=0.023637, up=1.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28353808.378212
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 3.000000
  % @PL 41 rows, 60 cols, 273 nonzeros, 2 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 6 rows, 26 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=58, theta=1.000000, up=1.000000
ITER 2: row=1, varin=56, theta=0.714173, up=1.000000
ITER 3: row=45, varin=64, theta=0.467177, up=1.000000
ITER 4: row=34, varin=6, theta=0.583056, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28444595.674214
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.416944
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 3.000000
  % @PL 45 rows, 60 cols, 295 nonzeros, 6 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=28, theta=2.142136, up=999999999999999983222784.000000
ITER 2: row=41, varin=84, theta=1.186052, up=1.000000
ITER 3: row=41, varin=40, theta=0.064607, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28469184.444603
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 278 nonzeros, 6 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 5 rows, 17 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=37, varin=83, theta=1.000000, up=1.000000
ITER 2: row=41, varin=25, theta=1.681449, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
ITER 3: row=34, varin=27, theta=0.000000, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28490641.811504
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 41 rows, 60 cols, 273 nonzeros, 1 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 5 rows, 22 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=18, theta=0.150851, up=999999999999999983222784.000000
ITER 2: row=41, varin=45, theta=1.453839, up=999999999999999983222784.000000
ITER 3: row=31, varin=48, theta=0.259988, up=1.000000
ITER 4: row=7, varin=49, theta=0.279301, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28518961.643593
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 45 rows, 60 cols, 287 nonzeros, 2 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=40, theta=0.065289, up=999999999999999983222784.000000
ITER 2: row=42, varin=76, theta=0.096736, up=1.000000
ITER 3: row=39, varin=48, theta=0.058671, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28526146.561462
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 46 rows, 60 cols, 277 nonzeros, 1 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 3 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=75, theta=0.092516, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28528178.572098
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 48 rows, 60 cols, 279 nonzeros, 0 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 14 LP 1 Solution, length = 28528178.572098, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.226871 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.226871 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.226871 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.226871 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.092516 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.773129 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.773129 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.773129 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.773129 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.773129 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.773129 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28528178.572098, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 14 at  28.52817857209840823884
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e74a950
% @LO 0.01  28.26918921979961751845 99.9000000000
% @LN 0.01  28.27367820663385700186 99.9000000000
% Resuming node 4 at  28.27367820663385700186
DEBUG CONSTRNT: LP rows=48, pool->nlprows=48, pool->npend=0
DEBUG CONSTRNT: Checking 48 LP rows (pool tracks 48, total LP rows 48)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 62
DEBUG CONSTRNT: Pool row 62 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=47, expected 47
 % @PAP adding 50 rows, 222 nz to LP
DEBUG BB: Processing node 4, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 4 LP 3 Solution, length = 28273678.206634, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.135890 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.135890 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.092330 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.135890 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.135890 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.135890 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.864110 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.864110 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.864110 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.864110 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.864110 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.864110 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28273678.206634, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28273678.206634, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 4 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 4
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.135890
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.135890)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.135890
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.135890)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.092330
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.092330)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.135890
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.135890)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=1.000000
DEBUG CAREFUL: Skipping var 13: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.135890
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.135890)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.135890
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.135890)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 4
DEBUG CAREFUL: New best var: 4
DEBUG CAREFUL: Testing fvar[1] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[2] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[3] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 18
DEBUG CAREFUL: Testing fvar[4] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[5] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 11
  % Initial guess is x4, Z0 = 28273678.2066339        , Z1 = 28708166.9229845        

DEBUG EVAL: Testing var 4 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=14, varin=35, theta=2.905548, up=999999999999999983222784.000000
ITER 2: row=40, varin=80, theta=0.978623, up=1.000000
ITER 3: row=1, varin=40, theta=1.189657, up=999999999999999983222784.000000
ITER 4: row=14, varin=48, theta=0.625217, up=999999999999999983222784.000000
ITER 5: row=39, varin=29, theta=1.122063, up=999999999999999983222784.000000
ITER 6: row=29, varin=45, theta=0.828873, up=999999999999999983222784.000000
ITER 7: row=45, varin=42, theta=0.856851, up=999999999999999983222784.000000
ITER 8: row=40, varin=31, theta=0.250000, up=999999999999999983222784.000000
ITER 9: row=49, varin=23, theta=1.000000, up=999999999999999983222784.000000
ITER 10: row=26, varin=39, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 4 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x4 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=14, varin=75, theta=0.174343, up=1.000000
ITER 2: row=11, varin=73, theta=0.067024, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28277276.995913
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1000000.000000
   % @PL 50 rows, 60 cols, 282 nonzeros, 0 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 4 at  28.27727699591254406641
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e74a950
% @LO 0.01  28.27367820663385700186 99.9000000000
% @LN 0.01  28.27727699591254406641 99.9000000000
% Resuming node 4 at  28.27727699591254406641
DEBUG CONSTRNT: LP rows=50, pool->nlprows=50, pool->npend=0
DEBUG CONSTRNT: Checking 50 LP rows (pool tracks 50, total LP rows 50)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=49, expected 49
 % @PAP adding 50 rows, 222 nz to LP
DEBUG BB: Processing node 4, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 4 LP 4 Solution, length = 28277276.995913, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.155496 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.155496 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.155496 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.155496 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.155496 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.067024 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.844504 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.844504 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.844504 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.844504 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.844504 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.844504 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28277276.995913, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28277276.995913, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 4 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 4
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.155496
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.155496)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.155496
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.155496)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.155496
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.155496)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=1.000000
DEBUG CAREFUL: Skipping var 13: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.155496
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.155496)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.155496
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.155496)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.067024
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.067024)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 22
DEBUG CAREFUL: New best var: 22
DEBUG CAREFUL: Testing fvar[1] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 2
DEBUG CAREFUL: New best var: 2
DEBUG CAREFUL: Testing fvar[2] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[3] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 18
DEBUG CAREFUL: Testing fvar[4] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[5] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 11
DEBUG CAREFUL: New best var: 11
  % Initial guess is x11, Z0 = 28277276.9959125        , Z1 = 28668504.6608919        

DEBUG EVAL: Testing var 22 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=39, varin=11, theta=1.213427, up=999999999999999983222784.000000
ITER 2: row=11, varin=35, theta=4.114176, up=999999999999999983222784.000000
ITER 3: row=40, varin=80, theta=1.385704, up=1.000000
ITER 4: row=40, varin=48, theta=0.331161, up=999999999999999983222784.000000
ITER 5: row=14, varin=40, theta=2.756713, up=999999999999999983222784.000000
ITER 6: row=11, varin=47, theta=0.637265, up=999999999999999983222784.000000
ITER 7: row=47, varin=29, theta=0.731880, up=999999999999999983222784.000000
ITER 8: row=29, varin=45, theta=0.507260, up=999999999999999983222784.000000
ITER 9: row=45, varin=42, theta=0.446450, up=999999999999999983222784.000000
ITER 10: row=2, varin=80, theta=0.527491, up=1.000000
DEBUG EVAL: Branch var 22 = 1 gives z=28452732.239538
  % 	x22 = 1,	Z1 = 28452732.2395379        
DEBUG EVAL: First branch cutoff check: z=28452732.239538, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 22 = 0
ITER 1: row=39, varin=81, theta=0.091245, up=1.000000
  % 	x22 = 0,	Z0 = 28278514.1222872        
DEBUG EVAL: Second branch cutoff check: z=28278514.122287, best_z=INF, threshold=INF
  %   New best:  x22, Z = 28278514.1222872        
DEBUG EVAL: Testing var 2 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=11, theta=21.923453, up=999999999999999983222784.000000
ITER 2: row=11, varin=48, theta=4.167569, up=999999999999999983222784.000000
ITER 3: row=14, varin=31, theta=0.921517, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 1 gives z=28679595.378156
  % 	x2 = 1,	Z1 = 28679595.3781561        
DEBUG EVAL: First branch cutoff check: z=28679595.378156, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 0
ITER 1: row=1, varin=35, theta=0.418981, up=999999999999999983222784.000000
ITER 2: row=40, varin=47, theta=0.169045, up=999999999999999983222784.000000
  % 	x2 = 0,	Z0 = 28290529.6996482        
DEBUG EVAL: Second branch cutoff check: z=28290529.699648, best_z=INF, threshold=INF
  %   New best:  x2, Z = 28290529.6996482        
DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=8, varin=35, theta=1.342888, up=999999999999999983222784.000000
ITER 2: row=40, varin=11, theta=21.923453, up=999999999999999983222784.000000
ITER 3: row=11, varin=27, theta=3.461836, up=999999999999999983222784.000000
ITER 4: row=49, varin=48, theta=1.891031, up=999999999999999983222784.000000
ITER 5: row=8, varin=49, theta=4.167569, up=999999999999999983222784.000000
ITER 6: row=14, varin=31, theta=1.127366, up=999999999999999983222784.000000
ITER 7: row=41, varin=47, theta=8.008241, up=999999999999999983222784.000000
ITER 8: row=1, varin=30, theta=1.105924, up=999999999999999983222784.000000
ITER 9: row=29, varin=5, theta=2.355759, up=999999999999999983222784.000000
ITER 10: row=2, varin=35, theta=1.726211, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x3 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=8, varin=81, theta=3.514703, up=1.000000
ITER 2: row=8, varin=39, theta=0.124516, up=999999999999999983222784.000000
ITER 3: row=39, varin=80, theta=2.004344, up=1.000000
ITER 4: row=39, varin=81, theta=0.311209, up=1.000000
ITER 5: row=1, varin=31, theta=0.246009, up=999999999999999983222784.000000
ITER 6: row=49, varin=48, theta=0.200398, up=999999999999999983222784.000000
ITER 7: row=32, varin=80, theta=0.525850, up=1.000000
LP PHASE: Switching to primal (iter=7)
ITER 8: row=31, varin=94, theta=0.000000, up=1.000000
ITER 9: row=23, varin=73, theta=0.442429, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28307158.566811
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1000000.000000
   % @PL 50 rows, 60 cols, 282 nonzeros, 0 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 6 rows, 24 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=87, theta=0.525850, up=1.000000
ITER 2: row=55, varin=28, theta=0.093704, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 28311941.747561
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.906296
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1000000.000000
   % @PL 56 rows, 60 cols, 306 nonzeros, 3 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 3 slack rows
   % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=54, varin=88, theta=0.424982, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 28325569.985098
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 54 rows, 60 cols, 302 nonzeros, 0 slack, 54 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 4 at  28.32556998509807755227
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e747c80
% @LO 0.01  28.27727699591254406641 99.9000000000
% @LN 0.01  28.29314758743799629315 99.9000000000
% Resuming node 17 at  28.29314758743799629315
DEBUG CONSTRNT: LP rows=54, pool->nlprows=54, pool->npend=0
DEBUG CONSTRNT: Checking 54 LP rows (pool tracks 54, total LP rows 54)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=53, expected 53
 % @PAP adding 40 rows, 201 nz to LP
DEBUG BB: Processing node 17, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=3, varin=32, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=39, theta=0.426830, up=999999999999999983222784.000000
ITER 3: row=2, varin=23, theta=0.403741, up=999999999999999983222784.000000
ITER 4: row=6, varin=41, theta=0.347277, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28293147.587438
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 40 rows, 60 cols, 261 nonzeros, 8 slack, 32 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 3 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=59, theta=0.252951, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28299734.684872
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 41 rows, 60 cols, 264 nonzeros, 8 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 8 slack rows
  % @PAP adding 5 rows, 22 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=40, theta=0.244121, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 28304359.873639
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 38 rows, 60 cols, 247 nonzeros, 0 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=17, theta=0.002416, up=999999999999999983222784.000000
ITER 2: row=34, varin=28, theta=0.025132, up=999999999999999983222784.000000
ITER 3: row=29, varin=6, theta=0.010365, up=999999999999999983222784.000000
ITER 4: row=37, varin=31, theta=0.035633, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 28306002.971035
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 39 rows, 60 cols, 251 nonzeros, 2 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 17 LP 1 Solution, length = 28306002.971035, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.267817 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.732183 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.500000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.500000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.535633 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.732183 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.267817 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.267817 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.464367 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.464367 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.267817 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.464367 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.464367 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28306002.971035, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.01  28.29314758743799629315 99.9000000000
 % @LN 0.01  28.30600297103493190320 99.9000000000
DEBUG CG: Second cutoff check: z=28306002.971035, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 17 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 17
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.267817
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.267817)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.732183
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.732183)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.500000
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.500000
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.535633
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.535633)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 5
DEBUG CAREFUL: New best var: 5
DEBUG CAREFUL: Testing fvar[1] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
DEBUG CAREFUL: Testing fvar[2] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 1
DEBUG CAREFUL: New best var: 1
DEBUG CAREFUL: Testing fvar[3] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 15
DEBUG CAREFUL: Testing fvar[4] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
  % Initial guess is x1, Z0 = 28339076.7228182        , Z1 = 28306002.9710349        

DEBUG EVAL: Testing var 5 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=37, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=18, varin=36, theta=1.082850, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 5 = 0 gives z=28384265.876742
  % 	x5 = 0,	Z0 = 28384265.8767423        
DEBUG EVAL: First branch cutoff check: z=28384265.876742, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 5 = 1
ITER 1: row=3, varin=26, theta=1.000000, up=999999999999999983222784.000000
  % 	x5 = 1,	Z1 = 28320216.5212526        
DEBUG EVAL: Second branch cutoff check: z=28320216.521253, best_z=INF, threshold=INF
  %   New best:  x5, Z = 28320216.5212526        
DEBUG EVAL: Testing var 7 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=16, varin=26, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 7 = 0 gives z=28320216.521252
  % 	x7 = 0,	Z0 = 28320216.5212525        
DEBUG EVAL: First branch cutoff check: z=28320216.521252, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 7 = 1
ITER 1: row=16, varin=25, theta=1.000000, up=999999999999999983222784.000000
  % 	x7 = 1,	Z1 = 28402792.8810647        
DEBUG EVAL: Second branch cutoff check: z=28402792.881065, best_z=INF, threshold=INF
  %   New best:  x7, Z = 28320216.5212525        
DEBUG EVAL: Testing var 1 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=36, theta=0.821881, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 1 gives z=28312368.179033
  % 	x1 = 1,	Z1 = 28312368.1790327        
DEBUG EVAL: First branch cutoff check: z=28312368.179033, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 15 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=18, varin=35, theta=0.105063, up=999999999999999983222784.000000
ITER 2: row=33, varin=29, theta=0.327522, up=999999999999999983222784.000000
ITER 3: row=35, varin=32, theta=0.196348, up=999999999999999983222784.000000
ITER 4: row=33, varin=31, theta=0.608027, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 15 = 1 gives z=28337860.101154
  % 	x15 = 1,	Z1 = 28337860.1011541        
DEBUG EVAL: First branch cutoff check: z=28337860.101154, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 15 = 0
ITER 1: row=18, varin=36, theta=1.052615, up=999999999999999983222784.000000
ITER 2: row=4, varin=31, theta=0.191415, up=999999999999999983222784.000000
ITER 3: row=1, varin=29, theta=0.247754, up=999999999999999983222784.000000
ITER 4: row=28, varin=16, theta=231400.500000, up=999999999999999983222784.000000
  % 	x15 = 0,	Z0 = 28322600.4503958        
DEBUG EVAL: Second branch cutoff check: z=28322600.450396, best_z=INF, threshold=INF
  %   New best:  x15, Z = 28322600.4503958        
DEBUG EVAL: Testing var 0 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=36, theta=0.821881, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 0 = 0 gives z=28312368.179034
  % 	x0 = 0,	Z0 = 28312368.1790341        
DEBUG EVAL: First branch cutoff check: z=28312368.179034, best_z=INF, threshold=INF
  % Best branch is x15, Z0 = 28322600.4503958        , Z1 = 28337860.1011541        

DEBUG CAREFUL: Final result - returning best.var = 15
DEBUG BB: Branching variable chosen: j=15
 % @NC   19   17	x15 = 0	28322600.450396
 % @NC   20   17	x15 = 1	28337860.101154
 %      17    11 28306002.9710               28310561.2911   x10 D    15     8
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e74b550
% @LO 0.01  28.30600297103493190320 99.9000000000
% @LN 0.01  28.31056129114076469477 99.9000000000
% Resuming node 8 at  28.31056129114076469477
DEBUG CONSTRNT: LP rows=37, pool->nlprows=37, pool->npend=0
DEBUG CONSTRNT: Checking 37 LP rows (pool tracks 37, total LP rows 37)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=36, expected 36
 % @PAP adding 38 rows, 200 nz to LP
DEBUG BB: Processing node 8, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 8 LP 2 Solution, length = 28310561.291141, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.333333 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.333333 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.333333 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.148565 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 1.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.666667 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.666667 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.666667 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.851435 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.851435 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28310561.291141, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28310561.291141, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 8 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 8
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.333333
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.333333
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.333333
DEBUG CAREFUL: Adding var 9 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.148565
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.148565)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=1.000000
DEBUG CAREFUL: Skipping var 14: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 9
DEBUG CAREFUL: Calling compare_branch_vars for var 9
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 9
DEBUG CAREFUL: New best var: 9
DEBUG CAREFUL: Testing fvar[1] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 5
DEBUG CAREFUL: Testing fvar[2] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
DEBUG CAREFUL: Testing fvar[3] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x9, Z0 = 28310561.2911408        , Z1 = 28310561.2911408        

DEBUG EVAL: Testing var 9 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=22, varin=68, theta=1.000000, up=1.000000
ITER 2: row=13, varin=80, theta=0.357561, up=1.000000
DEBUG EVAL: Branch var 9 = 0 gives z=28319378.116854
  % 	x9 = 0,	Z0 = 28319378.1168541        
DEBUG EVAL: First branch cutoff check: z=28319378.116854, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 9 = 1
ITER 1: row=22, varin=37, theta=0.837607, up=999999999999999983222784.000000
ITER 2: row=34, varin=9, theta=0.896000, up=999999999999999983222784.000000
ITER 3: row=13, varin=36, theta=1.264597, up=999999999999999983222784.000000
ITER 4: row=31, varin=35, theta=1.214318, up=999999999999999983222784.000000
ITER 5: row=12, varin=68, theta=1.412995, up=1.000000
ITER 6: row=12, varin=92, theta=0.120188, up=1.000000
ITER 7: row=34, varin=65, theta=0.377308, up=1.000000
ITER 8: row=18, varin=9, theta=0.494070, up=999999999999999983222784.000000
ITER 9: row=9, varin=34, theta=0.270489, up=999999999999999983222784.000000
ITER 10: row=1, varin=31, theta=0.215041, up=999999999999999983222784.000000
  % 	x9 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: Second branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=22, varin=68, theta=1.000000, up=1.000000
ITER 2: row=13, varin=80, theta=0.357561, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 28319378.116854
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.642439
DEBUG SOLUTION: lp->best_solution[4] = 0.642439
DEBUG SOLUTION: lp->best_solution[5] = 2.284878
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 3.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 38 rows, 60 cols, 260 nonzeros, 3 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 3 slack rows
   % @PAP adding 9 rows, 30 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=55, theta=1.000000, up=1.000000
ITER 2: row=36, varin=29, theta=4.034804, up=999999999999999983222784.000000
ITER 3: row=28, varin=31, theta=1.580647, up=999999999999999983222784.000000
ITER 4: row=36, varin=25, theta=0.039720, up=999999999999999983222784.000000
ITER 5: row=43, varin=36, theta=0.998251, up=999999999999999983222784.000000
ITER 6: row=27, varin=6, theta=0.192363, up=999999999999999983222784.000000
ITER 7: row=40, varin=29, theta=0.661252, up=999999999999999983222784.000000
ITER 8: row=6, varin=40, theta=1.028710, up=999999999999999983222784.000000
ITER 9: row=29, varin=102, theta=0.123814, up=1.000000
ITER 10: row=22, varin=44, theta=0.436840, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=12)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28377602.198903
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 3.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
   % @PL 44 rows, 60 cols, 282 nonzeros, 5 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 5 slack rows
   % @PAP adding 3 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=19, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=28, varin=50, theta=0.453846, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28394169.874064
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 3.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
   % @PL 42 rows, 60 cols, 273 nonzeros, 2 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
   % @PAP adding 1 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=88, theta=0.043827, up=1.000000
ITER 2: row=40, varin=43, theta=0.036954, up=1.000000
ITER 3: row=31, varin=50, theta=0.084092, up=1.000000
ITER 4: row=17, varin=27, theta=0.149106, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
ITER 5: row=21, varin=99, theta=0.000000, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28395877.198879
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 3.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
   % @PL 41 rows, 60 cols, 266 nonzeros, 1 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 8 at  28.39587719887920869155
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e765b10
% @LO 0.01  28.31056129114076469477 99.9000000000
% @LN 0.01  28.31832019446625992032 99.9000000000
% Resuming node 18 at  28.31832019446625992032
DEBUG CONSTRNT: LP rows=40, pool->nlprows=40, pool->npend=0
DEBUG CONSTRNT: Checking 40 LP rows (pool tracks 40, total LP rows 40)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 150
DEBUG CONSTRNT: Pool row 150 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=39, expected 39
 % @PAP adding 40 rows, 201 nz to LP
DEBUG BB: Processing node 18, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=3, varin=43, theta=0.500000, up=1.000000
ITER 2: row=7, varin=31, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=33, varin=23, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=2, varin=44, theta=0.319004, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28318320.194466
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 40 rows, 60 cols, 261 nonzeros, 5 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 31 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=53, theta=0.313477, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28327193.237874
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 46 rows, 60 cols, 292 nonzeros, 5 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=73, theta=0.595341, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28337332.167956
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 43 rows, 60 cols, 269 nonzeros, 0 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=49, theta=1.233581, up=1.000000
ITER 2: row=44, varin=27, theta=0.084260, up=999999999999999983222784.000000
ITER 3: row=16, varin=74, theta=0.323443, up=1.000000
ITER 4: row=39, varin=49, theta=0.210766, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28366641.784354
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 47 rows, 60 cols, 282 nonzeros, 1 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 3 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=57, theta=0.152042, up=1.000000
ITER 2: row=49, varin=84, theta=0.395222, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28381610.237290
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 49 rows, 60 cols, 283 nonzeros, 0 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=88, theta=0.302660, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28383969.472788
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 51 rows, 60 cols, 287 nonzeros, 0 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 10 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=108, theta=0.188270, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 28384005.254301
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.811730
DEBUG SOLUTION: lp->best_solution[9] = 0.811730
DEBUG SOLUTION: lp->best_solution[10] = 2.623460
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 54 rows, 60 cols, 297 nonzeros, 8 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 8 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=33, theta=0.790265, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28384093.320260
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 266 nonzeros, 1 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 18 LP 1 Solution, length = 28384093.320260, 0.01 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.500000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.131711 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.131711 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.034956 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.034956 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 1.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.034956 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.131711 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.500000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.034956 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.034956 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.500000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.965044 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.868289 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.868289 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.965044 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.965044 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.965044 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.868289 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.868289 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.965044 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.965044 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 11 fractional variables
DEBUG CG: LP optimal, z=28384093.320260, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 18 at  28.38409332026001052895
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e743b80
% @LO 0.02  28.31832019446625992032 99.9000000000
% @LN 0.02  28.32260045039578244541 99.9000000000
% Resuming node 19 at  28.32260045039578244541
DEBUG CONSTRNT: LP rows=46, pool->nlprows=46, pool->npend=0
DEBUG CONSTRNT: Checking 46 LP rows (pool tracks 46, total LP rows 46)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 143
DEBUG CONSTRNT: Pool row 143 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 158
DEBUG CONSTRNT: Pool row 158 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=45, expected 45
 % @PAP adding 37 rows, 187 nz to LP
DEBUG BB: Processing node 19, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=18, varin=36, theta=1.052615, up=999999999999999983222784.000000
ITER 2: row=4, varin=31, theta=0.191415, up=999999999999999983222784.000000
ITER 3: row=1, varin=29, theta=0.247754, up=999999999999999983222784.000000
ITER 4: row=28, varin=16, theta=231400.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
ITER 5: row=6, varin=28, theta=0.000000, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 28322600.450397
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 37 rows, 60 cols, 247 nonzeros, 1 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 4 rows, 29 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=37, varin=20, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=28, varin=41, theta=0.500000, up=1.000000
ITER 3: row=30, varin=6, theta=0.500000, up=999999999999999983222784.000000
ITER 4: row=39, varin=36, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28367778.275357
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 40 rows, 60 cols, 236 nonzeros, 5 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 4 rows, 55 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=84, theta=0.282284, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 28399485.576117
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 3.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 39 rows, 60 cols, 267 nonzeros, 3 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % Node 19 LP 1 Solution, length = 28399485.576117, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.282284 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.717716 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.435433 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.435433 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.717716 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.564567 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.282284 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.282284 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.564567 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.282284 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.564567 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.564567 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.564567 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28399485.576117, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 19 at  28.39948557611673862766
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e74a950
% @LO 0.02  28.32260045039578244541 99.9000000000
% @LN 0.02  28.32556998509807755227 99.9000000000
% Resuming node 4 at  28.32556998509807755227
DEBUG CONSTRNT: LP rows=36, pool->nlprows=36, pool->npend=0
DEBUG CONSTRNT: Checking 36 LP rows (pool tracks 36, total LP rows 36)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 73
DEBUG CONSTRNT: Pool row 73 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=35, expected 35
 % @PAP adding 54 rows, 242 nz to LP
DEBUG BB: Processing node 4, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 4 LP 5 Solution, length = 28325569.985098, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.424982 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.424982 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.424982 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.150036 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.424982 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.575018 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.575018 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.575018 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.575018 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28325569.985098, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28325569.985098, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 4 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 4
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.424982
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.424982)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.424982
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.424982)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=1.000000
DEBUG CAREFUL: Skipping var 13: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.424982
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.424982)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.150036
DEBUG CAREFUL: Adding var 30 to fractional list (xi=0.150036)
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.424982
DEBUG CAREFUL: Adding var 33 to fractional list (xi=0.424982)
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 30
DEBUG CAREFUL: Calling compare_branch_vars for var 30
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 30
DEBUG CAREFUL: New best var: 30
DEBUG CAREFUL: Testing fvar[1] = var 33
DEBUG CAREFUL: Calling compare_branch_vars for var 33
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 33
DEBUG CAREFUL: New best var: 33
DEBUG CAREFUL: Testing fvar[2] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[3] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 29
DEBUG CAREFUL: Testing fvar[4] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
  % Initial guess is x33, Z0 = 28325569.9850981        , Z1 = 28428691.1578534        

DEBUG EVAL: Testing var 30 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=22, varin=57, theta=0.207349, up=1.000000
ITER 2: row=40, varin=49, theta=0.622578, up=999999999999999983222784.000000
ITER 3: row=49, varin=10, theta=0.601850, up=999999999999999983222784.000000
ITER 4: row=10, varin=54, theta=0.951307, up=999999999999999983222784.000000
ITER 5: row=27, varin=47, theta=0.455752, up=999999999999999983222784.000000
ITER 6: row=47, varin=43, theta=0.332679, up=999999999999999983222784.000000
ITER 7: row=43, varin=45, theta=0.419385, up=999999999999999983222784.000000
ITER 8: row=7, varin=40, theta=0.188263, up=999999999999999983222784.000000
ITER 9: row=18, varin=22, theta=0.195322, up=999999999999999983222784.000000
ITER 10: row=25, varin=7, theta=0.095748, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 30 = 1 gives z=28481682.401814
  % 	x30 = 1,	Z1 = 28481682.4018143        
DEBUG EVAL: First branch cutoff check: z=28481682.401814, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 30 = 0
ITER 1: row=22, varin=53, theta=0.189294, up=999999999999999983222784.000000
  % 	x30 = 0,	Z0 = 28331858.8450367        
DEBUG EVAL: Second branch cutoff check: z=28331858.845037, best_z=INF, threshold=INF
  %   New best:  x30, Z = 28331858.8450367        
DEBUG EVAL: Testing var 33 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=40, varin=54, theta=0.507142, up=999999999999999983222784.000000
ITER 2: row=27, varin=53, theta=0.641544, up=999999999999999983222784.000000
ITER 3: row=22, varin=49, theta=0.301590, up=999999999999999983222784.000000
ITER 4: row=49, varin=10, theta=0.349924, up=999999999999999983222784.000000
ITER 5: row=10, varin=47, theta=0.236840, up=999999999999999983222784.000000
ITER 6: row=47, varin=43, theta=0.313988, up=999999999999999983222784.000000
ITER 7: row=43, varin=40, theta=0.324586, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 33 = 1 gives z=28427437.160102
  % 	x33 = 1,	Z1 = 28428691.1578534        
DEBUG EVAL: First branch cutoff check: z=28428691.157853, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 33 = 0
ITER 1: row=40, varin=57, theta=0.060285, up=1.000000
  % 	x33 = 0,	Z0 = 28326913.5854257        
DEBUG EVAL: Second branch cutoff check: z=28326913.585426, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=57, theta=0.207349, up=1.000000
ITER 2: row=40, varin=49, theta=0.622578, up=999999999999999983222784.000000
ITER 3: row=49, varin=53, theta=0.621072, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 0 gives z=28354783.093582
  % 	x1 = 0,	Z0 = 28354783.0935818        
DEBUG EVAL: First branch cutoff check: z=28354783.093582, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 1
ITER 1: row=2, varin=29, theta=0.345472, up=999999999999999983222784.000000
ITER 2: row=40, varin=80, theta=1.006976, up=1.000000
ITER 3: row=40, varin=76, theta=0.007123, up=1.000000
ITER 4: row=22, varin=31, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=25, varin=80, theta=0.762130, up=1.000000
ITER 6: row=50, varin=54, theta=0.611309, up=999999999999999983222784.000000
ITER 7: row=27, varin=88, theta=0.961802, up=1.000000
ITER 8: row=13, varin=18, theta=0.197036, up=999999999999999983222784.000000
  % 	x1 = 1,	Z1 = 28669126.788801         
DEBUG EVAL: Second branch cutoff check: z=28669126.788801, best_z=INF, threshold=INF
  %   New best:  x1, Z = 28354783.0935818        
DEBUG EVAL: Testing var 29 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=18, varin=29, theta=0.345472, up=999999999999999983222784.000000
ITER 2: row=40, varin=80, theta=1.006976, up=1.000000
ITER 3: row=40, varin=4, theta=0.003380, up=999999999999999983222784.000000
ITER 4: row=25, varin=80, theta=1.000000, up=1.000000
ITER 5: row=41, varin=76, theta=0.406141, up=1.000000
ITER 6: row=22, varin=31, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=50, varin=54, theta=0.611309, up=999999999999999983222784.000000
ITER 8: row=27, varin=88, theta=0.961802, up=1.000000
ITER 9: row=13, varin=18, theta=0.197036, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 29 = 1 gives z=28669126.788801
  % 	x29 = 1,	Z1 = 28669126.788801         
DEBUG EVAL: First branch cutoff check: z=28669126.788801, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 29 = 0
ITER 1: row=18, varin=57, theta=0.207349, up=1.000000
ITER 2: row=40, varin=49, theta=0.622578, up=999999999999999983222784.000000
ITER 3: row=49, varin=53, theta=0.621072, up=999999999999999983222784.000000
  % 	x29 = 0,	Z0 = 28354783.0935818        
DEBUG EVAL: Second branch cutoff check: z=28354783.093582, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 0 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=57, theta=0.207349, up=1.000000
ITER 2: row=40, varin=49, theta=0.622578, up=999999999999999983222784.000000
ITER 3: row=49, varin=53, theta=0.621072, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 0 = 0 gives z=28354783.093582
  % 	x0 = 0,	Z0 = 28354783.0935818        
DEBUG EVAL: First branch cutoff check: z=28354783.093582, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 0 = 1
ITER 1: row=1, varin=29, theta=0.345472, up=999999999999999983222784.000000
ITER 2: row=40, varin=80, theta=1.006976, up=1.000000
ITER 3: row=40, varin=76, theta=0.007123, up=1.000000
  % 	x0 = 1,	Z1 = 28484732.7960293        
DEBUG EVAL: Second branch cutoff check: z=28484732.796029, best_z=INF, threshold=INF
  % Best branch is x1, Z0 = 28354783.0935818        , Z1 = 28669126.788801         

DEBUG CAREFUL: Final result - returning best.var = 1
DEBUG BB: Branching variable chosen: j=1
 % @NC   21    4	x1 = 0	28354783.093582
 % @NC   22    4	x1 = 1	28669126.788801
 %       4    12 28325569.9851               28337860.1012   x13 U     1     2
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e74a1c0
% @LO 0.02  28.32556998509807755227 99.9000000000
% @LN 0.02  28.33786010115413134258 99.9000000000
% Resuming node 20 at  28.33786010115413134258
DEBUG CONSTRNT: LP rows=54, pool->nlprows=54, pool->npend=0
DEBUG CONSTRNT: Checking 54 LP rows (pool tracks 54, total LP rows 54)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=53, expected 53
 % @PAP adding 37 rows, 187 nz to LP
DEBUG BB: Processing node 20, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=18, varin=35, theta=0.105063, up=999999999999999983222784.000000
ITER 2: row=33, varin=29, theta=0.327522, up=999999999999999983222784.000000
ITER 3: row=35, varin=32, theta=0.196348, up=999999999999999983222784.000000
ITER 4: row=33, varin=31, theta=0.608027, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 28337860.101154
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 37 rows, 60 cols, 247 nonzeros, 1 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 20 LP 1 Solution, length = 28337860.101154, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.195986 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.195986 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.500000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.500000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.804014 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.804014 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.804014 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.804014 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28337860.101154, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28337860.101154, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 20 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 20
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.195986
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.195986)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.195986
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.195986)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.500000
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.500000
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=1.000000
DEBUG CAREFUL: Skipping var 15: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 5
DEBUG CAREFUL: New best var: 5
DEBUG CAREFUL: Testing fvar[1] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 7
DEBUG CAREFUL: New best var: 7
DEBUG CAREFUL: Testing fvar[2] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
DEBUG CAREFUL: Testing fvar[3] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
  % Initial guess is x7, Z0 = 28337860.1011541        , Z1 = 28402792.8810647        

DEBUG EVAL: Testing var 5 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=26, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 5 = 1 gives z=28354179.727455
  % 	x5 = 1,	Z1 = 28354179.7274547        
DEBUG EVAL: First branch cutoff check: z=28354179.727455, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 5 = 0
ITER 1: row=3, varin=37, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=31, varin=29, theta=0.291234, up=999999999999999983222784.000000
ITER 3: row=28, varin=93, theta=0.166479, up=1.000000
ITER 4: row=32, varin=28, theta=0.388638, up=999999999999999983222784.000000
ITER 5: row=31, varin=33, theta=0.641148, up=999999999999999983222784.000000
ITER 6: row=34, varin=29, theta=0.219443, up=999999999999999983222784.000000
ITER 7: row=35, varin=36, theta=1.082850, up=999999999999999983222784.000000
  % 	x5 = 0,	Z0 = 28384265.8767423        
DEBUG EVAL: Second branch cutoff check: z=28384265.876742, best_z=INF, threshold=INF
  %   New best:  x5, Z = 28354179.7274547        
DEBUG EVAL: Testing var 7 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=16, varin=25, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=2, varin=30, theta=1.421395, up=999999999999999983222784.000000
ITER 3: row=23, varin=40, theta=0.399350, up=1.000000
ITER 4: row=7, varin=41, theta=0.490928, up=1.000000
ITER 5: row=24, varin=79, theta=1.216782, up=1.000000
ITER 6: row=24, varin=67, theta=0.535568, up=1.000000
DEBUG EVAL: Branch var 7 = 1 gives z=28530374.510716
  % 	x7 = 1,	Z1 = 28530374.5107155        
DEBUG EVAL: First branch cutoff check: z=28530374.510716, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 7 = 0
ITER 1: row=16, varin=37, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=31, varin=26, theta=0.526744, up=999999999999999983222784.000000
  % 	x7 = 0,	Z0 = 28346559.4067064        
DEBUG EVAL: Second branch cutoff check: z=28346559.406706, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 0 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=29, theta=0.094083, up=999999999999999983222784.000000
ITER 2: row=28, varin=93, theta=0.056713, up=1.000000
ITER 3: row=32, varin=40, theta=0.166113, up=1.000000
ITER 4: row=7, varin=28, theta=0.142778, up=999999999999999983222784.000000
ITER 5: row=1, varin=33, theta=0.249704, up=999999999999999983222784.000000
ITER 6: row=35, varin=41, theta=0.143966, up=1.000000
DEBUG EVAL: Branch var 0 = 0 gives z=28357929.906048
  % 	x0 = 0,	Z0 = 28357929.9060479        
DEBUG EVAL: First branch cutoff check: z=28357929.906048, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 0 = 1
ITER 1: row=1, varin=37, theta=0.690285, up=999999999999999983222784.000000
ITER 2: row=31, varin=30, theta=1.141234, up=999999999999999983222784.000000
ITER 3: row=1, varin=29, theta=1.027174, up=999999999999999983222784.000000
ITER 4: row=30, varin=25, theta=0.524972, up=999999999999999983222784.000000
ITER 5: row=1, varin=37, theta=0.518560, up=999999999999999983222784.000000
  % 	x0 = 1,	Z1 = 28388836.6997285        
DEBUG EVAL: Second branch cutoff check: z=28388836.699728, best_z=INF, threshold=INF
  %   New best:  x0, Z = 28357929.9060479        
DEBUG EVAL: Testing var 1 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=37, theta=4.880012, up=999999999999999983222784.000000
ITER 2: row=31, varin=40, theta=0.842646, up=1.000000
ITER 3: row=7, varin=41, theta=1.000614, up=1.000000
ITER 4: row=7, varin=44, theta=0.000576, up=1.000000
ITER 5: row=25, varin=67, theta=0.006095, up=1.000000
ITER 6: row=7, varin=26, theta=0.001001, up=999999999999999983222784.000000
ITER 7: row=37, varin=30, theta=0.000316, up=999999999999999983222784.000000
ITER 8: row=27, varin=31, theta=0.001324, up=999999999999999983222784.000000
ITER 9: row=1, varin=41, theta=0.002298, up=1.000000
DEBUG EVAL: Branch var 1 = 1 gives z=28477631.561958
  % 	x1 = 1,	Z1 = 28477631.5619585        
DEBUG EVAL: First branch cutoff check: z=28477631.561958, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 0
ITER 1: row=2, varin=29, theta=0.497141, up=999999999999999983222784.000000
ITER 2: row=1, varin=30, theta=0.348869, up=999999999999999983222784.000000
ITER 3: row=28, varin=16, theta=129327.500000, up=999999999999999983222784.000000
  % 	x1 = 0,	Z0 = 28339076.7228182        
DEBUG EVAL: Second branch cutoff check: z=28339076.722818, best_z=INF, threshold=INF
  % Best branch is x0, Z0 = 28357929.9060479        , Z1 = 28388836.6997285        

DEBUG CAREFUL: Final result - returning best.var = 0
DEBUG BB: Branching variable chosen: j=0
 % @NC   23   20	x0 = 0	28357929.906048
 % @NC   24   20	x0 = 1	28388836.699728
 %      20    13 28337860.1012               28354783.0936   x15 U    17     9
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e747c80
% @LO 0.02  28.33786010115413134258 99.9000000000
% @LN 0.02  28.35478309358176929322 99.9000000000
% Resuming node 21 at  28.35478309358176929322
DEBUG CONSTRNT: LP rows=37, pool->nlprows=37, pool->npend=0
DEBUG CONSTRNT: Checking 37 LP rows (pool tracks 37, total LP rows 37)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=36, expected 36
 % @PAP adding 54 rows, 242 nz to LP
DEBUG BB: Processing node 21, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=2, varin=57, theta=0.207349, up=1.000000
ITER 2: row=40, varin=49, theta=0.622578, up=999999999999999983222784.000000
ITER 3: row=49, varin=53, theta=0.621072, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 28354783.093581
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 54 rows, 60 cols, 302 nonzeros, 8 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 15 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=55, varin=81, theta=0.303878, up=1.000000
ITER 2: row=51, varin=92, theta=0.216227, up=1.000000
ITER 3: row=58, varin=84, theta=0.136769, up=1.000000
ITER 4: row=25, varin=80, theta=0.055108, up=1.000000
ITER 5: row=14, varin=18, theta=0.027793, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=58)
DEBUG SOLUTION: LP solution array indices: FST[59-98], not_covered[99-118]
DEBUG SOLUTION: lp->best_solution[0] = 28375604.049371
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 58 rows, 60 cols, 317 nonzeros, 9 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 9 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=4, theta=0.059679, up=999999999999999983222784.000000
ITER 2: row=35, varin=80, theta=0.142729, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28378419.052161
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 293 nonzeros, 0 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 21 LP 1 Solution, length = 28378419.052161, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.171454 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.171454 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.171454 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.171454 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.171454 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.142729 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.828546 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.828546 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.828546 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.828546 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.828546 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.828546 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28378419.052161, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 21 at  28.37841905216090054864
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e74a950
% @LO 0.02  28.35478309358176929322 99.9000000000
% @LN 0.02  28.35792990604786822928 99.9000000000
% Resuming node 23 at  28.35792990604786822928
DEBUG CONSTRNT: LP rows=52, pool->nlprows=52, pool->npend=0
DEBUG CONSTRNT: Checking 52 LP rows (pool tracks 52, total LP rows 52)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=51, expected 51
 % @PAP adding 37 rows, 187 nz to LP
DEBUG BB: Processing node 23, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=29, theta=0.094083, up=999999999999999983222784.000000
ITER 2: row=28, varin=93, theta=0.056713, up=1.000000
ITER 3: row=32, varin=40, theta=0.166113, up=1.000000
ITER 4: row=7, varin=28, theta=0.142778, up=999999999999999983222784.000000
ITER 5: row=1, varin=33, theta=0.249704, up=999999999999999983222784.000000
ITER 6: row=35, varin=41, theta=0.143966, up=1.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 28357929.906048
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 37 rows, 60 cols, 247 nonzeros, 1 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 6 rows, 31 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=35, theta=0.142333, up=999999999999999983222784.000000
ITER 2: row=37, varin=38, theta=0.186951, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28358330.505435
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.953262
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 42 rows, 60 cols, 275 nonzeros, 7 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 7 slack rows
  % Node 23 LP 1 Solution, length = 28358330.505435, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.140213 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.046738 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.500000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.500000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.046738 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.046738 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.953262 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.859787 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.859787 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.953262 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.859787 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.953262 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.953262 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.953262 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28358330.505435, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.02  28.35792990604786822928 99.9000000000
 % @LN 0.02  28.35833050543477540373 99.9000000000
DEBUG CG: Second cutoff check: z=28358330.505435, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 3 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 23 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 23
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.140213
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.140213)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.046738
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.046738)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.500000
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.500000
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=1.000000
DEBUG CAREFUL: Skipping var 15: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.046738
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.046738)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.046738
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.046738)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 5
DEBUG CAREFUL: New best var: 5
DEBUG CAREFUL: Testing fvar[1] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 7
DEBUG CAREFUL: New best var: 7
DEBUG CAREFUL: Testing fvar[2] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[3] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[4] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 18
DEBUG CAREFUL: Testing fvar[5] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
  % Initial guess is x7, Z0 = 28358330.5054348        , Z1 = 28530374.5107155        

DEBUG EVAL: Testing var 5 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=15, varin=24, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 5 = 1 gives z=28372550.897336
  % 	x5 = 1,	Z1 = 28372550.8973361        
DEBUG EVAL: First branch cutoff check: z=28372550.897336, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 5 = 0
ITER 1: row=15, varin=32, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=42, theta=0.024726, up=1.000000
  % 	x5 = 0,	Z0 = 28481001.4812269        
DEBUG EVAL: Second branch cutoff check: z=28481001.481227, best_z=INF, threshold=INF
  %   New best:  x5, Z = 28372550.8973361        
DEBUG EVAL: Testing var 7 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=21, varin=23, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=42, theta=0.524988, up=1.000000
ITER 3: row=3, varin=25, theta=0.032212, up=999999999999999983222784.000000
ITER 4: row=30, varin=22, theta=0.019396, up=999999999999999983222784.000000
ITER 5: row=35, varin=28, theta=0.022330, up=999999999999999983222784.000000
ITER 6: row=34, varin=31, theta=0.041202, up=999999999999999983222784.000000
ITER 7: row=23, varin=65, theta=0.384035, up=1.000000
DEBUG EVAL: Branch var 7 = 1 gives z=28534252.878085
  % 	x7 = 1,	Z1 = 28534252.8780846        
DEBUG EVAL: First branch cutoff check: z=28534252.878085, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 7 = 0
ITER 1: row=21, varin=24, theta=1.000000, up=999999999999999983222784.000000
  % 	x7 = 0,	Z0 = 28372550.8973361        
DEBUG EVAL: Second branch cutoff check: z=28372550.897336, best_z=INF, threshold=INF
  %   New best:  x7, Z = 28372550.8973361        
DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=6, theta=3.388048, up=999999999999999983222784.000000
ITER 2: row=1, varin=25, theta=1.824638, up=999999999999999983222784.000000
ITER 3: row=30, varin=22, theta=1.087947, up=999999999999999983222784.000000
ITER 4: row=35, varin=28, theta=1.202182, up=999999999999999983222784.000000
ITER 5: row=34, varin=32, theta=3.875162, up=999999999999999983222784.000000
ITER 6: row=15, varin=31, theta=1.610431, up=999999999999999983222784.000000
ITER 7: row=3, varin=65, theta=1.135644, up=1.000000
ITER 8: row=3, varin=42, theta=0.082375, up=1.000000
ITER 9: row=29, varin=24, theta=1.067019, up=999999999999999983222784.000000
ITER 10: row=32, varin=27, theta=1.028786, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 1 gives z=29039451.015663
  % 	x3 = 1,	Z1 = 29039451.015663         
DEBUG EVAL: First branch cutoff check: z=29039451.015663, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=3, varin=33, theta=0.069204, up=999999999999999983222784.000000
  % 	x3 = 0,	Z0 = 28358523.0731091        
DEBUG EVAL: Second branch cutoff check: z=28358523.073109, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 17 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=22, varin=42, theta=0.151021, up=1.000000
DEBUG EVAL: Branch var 17 = 0 gives z=28363196.307348
  % 	x17 = 0,	Z0 = 28363196.307348         
DEBUG EVAL: First branch cutoff check: z=28363196.307348, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 18 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=23, varin=33, theta=2.936338, up=999999999999999983222784.000000
ITER 2: row=1, varin=27, theta=2.656976, up=999999999999999983222784.000000
ITER 3: row=26, varin=32, theta=4.039225, up=999999999999999983222784.000000
ITER 4: row=15, varin=24, theta=3.170873, up=999999999999999983222784.000000
ITER 5: row=21, varin=65, theta=11.382462, up=1.000000
ITER 6: row=21, varin=28, theta=2.978132, up=999999999999999983222784.000000
ITER 7: row=23, varin=42, theta=3.475310, up=1.000000
ITER 8: row=23, varin=62, theta=2.594196, up=1.000000
ITER 9: row=23, varin=58, theta=1.381272, up=1.000000
ITER 10: row=23, varin=57, theta=0.371017, up=1.000000
DEBUG EVAL: Branch var 18 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x18 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=23, varin=42, theta=0.151021, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=35)
DEBUG SOLUTION: LP solution array indices: FST[36-75], not_covered[76-95]
DEBUG SOLUTION: lp->best_solution[0] = 28363196.307348
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 3.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
   % @PL 35 rows, 60 cols, 230 nonzeros, 0 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 3 rows, 16 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=25, theta=0.082258, up=999999999999999983222784.000000
ITER 2: row=30, varin=68, theta=0.355426, up=1.000000
LP PHASE: Switching to primal (iter=2)
ITER 3: row=21, varin=15, theta=129327.500000, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=38)
DEBUG SOLUTION: LP solution array indices: FST[39-78], not_covered[79-98]
DEBUG SOLUTION: lp->best_solution[0] = 28367673.391790
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 3.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
   % @PL 38 rows, 60 cols, 246 nonzeros, 1 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=39, theta=8.000000, up=1.000000
ITER 2: row=1, varin=45, theta=7.000000, up=1.000000
ITER 3: row=1, varin=78, theta=12.000000, up=1.000000
ITER 4: row=1, varin=79, theta=11.000000, up=1.000000
ITER 5: row=1, varin=80, theta=10.000000, up=1.000000
ITER 6: row=1, varin=81, theta=9.000000, up=1.000000
ITER 7: row=1, varin=82, theta=8.000000, up=1.000000
ITER 8: row=1, varin=83, theta=7.000000, up=1.000000
ITER 9: row=1, varin=84, theta=6.000000, up=1.000000
ITER 10: row=1, varin=85, theta=5.000000, up=1.000000
LP PHASE: Switching to primal (iter=39)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 28367673.391790
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 3.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
   % @PL 37 rows, 60 cols, 206 nonzeros, 0 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 23 at  28.36767339179006697236
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e74a950
% @LO 0.02  28.35833050543477540373 99.9000000000
% @LN 0.02  28.36767339179006697236 99.9000000000
% Resuming node 23 at  28.36767339179006697236
DEBUG CONSTRNT: LP rows=37, pool->nlprows=37, pool->npend=0
DEBUG CONSTRNT: Checking 37 LP rows (pool tracks 37, total LP rows 37)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=36, expected 36
 % @PAP adding 37 rows, 146 nz to LP
DEBUG BB: Processing node 23, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 23 LP 2 Solution, length = 28367673.391790, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.500000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.500000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 2 fractional variables
DEBUG CG: LP optimal, z=28367673.391790, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28367673.391790, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 23 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 23
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.500000
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.500000
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=1.000000
DEBUG CAREFUL: Skipping var 15: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 2 fractional variables

  %  Carefully choosing branching variable, nfrac = 2
DEBUG CAREFUL: Testing fvar[0] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 5
DEBUG CAREFUL: New best var: 5
DEBUG CAREFUL: Testing fvar[1] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 7
DEBUG CAREFUL: New best var: 7
  % Initial guess is x7, Z0 = 28372550.8973361        , Z1 = 28534252.8780846        

DEBUG EVAL: Testing var 5 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=23, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 5 = 1 gives z=28380935.673233
  % 	x5 = 1,	Z1 = 28380935.6732332        
DEBUG EVAL: First branch cutoff check: z=28380935.673233, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 5 = 0
ITER 1: row=6, varin=22, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=67, theta=1.000000, up=1.000000
  % 	x5 = 0,	Z0 = 28554388.8677997        
DEBUG EVAL: Second branch cutoff check: z=28554388.867800, best_z=INF, threshold=INF
  %   New best:  x5, Z = 28380935.6732332        
DEBUG EVAL: Testing var 7 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=20, varin=23, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 7 = 0 gives z=28380935.673233
  % 	x7 = 0,	Z0 = 28380935.6732332        
DEBUG EVAL: First branch cutoff check: z=28380935.673233, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 7 = 1
ITER 1: row=20, varin=22, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=67, theta=1.000000, up=1.000000
  % 	x7 = 1,	Z1 = 28554388.8677997        
DEBUG EVAL: Second branch cutoff check: z=28554388.867800, best_z=INF, threshold=INF
  % Best branch is x5, Z0 = 28554388.8677997        , Z1 = 28380935.6732332        

DEBUG CAREFUL: Final result - returning best.var = 5
DEBUG BB: Branching variable chosen: j=5
 % @NC   25   23	x5 = 1	28380935.673233
 % @NC   26   23	x5 = 0	28554388.867800
 %      23    14 28367673.3918               28378419.0522    x0 D    20    10
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e747c80
% @LO 0.02  28.36767339179006697236 99.9000000000
% @LN 0.02  28.37841905216090054864 99.9000000000
% Resuming node 21 at  28.37841905216090054864
DEBUG CONSTRNT: LP rows=37, pool->nlprows=37, pool->npend=0
DEBUG CONSTRNT: Checking 37 LP rows (pool tracks 37, total LP rows 37)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=36, expected 36
 % @PAP adding 52 rows, 233 nz to LP
DEBUG BB: Processing node 21, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 21 LP 2 Solution, length = 28378419.052161, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.171454 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.171454 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.171454 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.171454 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.171454 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.142729 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.828546 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.828546 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.828546 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.828546 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.828546 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.828546 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28378419.052161, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28378419.052161, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 21 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 21
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.171454
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.171454)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.171454
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.171454)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=1.000000
DEBUG CAREFUL: Skipping var 13: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.171454
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.171454)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.171454
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.171454)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.171454
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.171454)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.142729
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.142729)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 2
DEBUG CAREFUL: New best var: 2
DEBUG CAREFUL: Testing fvar[1] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 18
DEBUG CAREFUL: Testing fvar[2] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[3] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 11
DEBUG CAREFUL: Testing fvar[4] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 27
DEBUG CAREFUL: Testing fvar[5] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 22
  % Initial guess is x2, Z0 = 28378419.0521609        , Z1 = 28679595.3781561        

DEBUG EVAL: Testing var 2 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=35, theta=2.575713, up=999999999999999983222784.000000
ITER 2: row=49, varin=27, theta=2.956250, up=999999999999999983222784.000000
ITER 3: row=33, varin=26, theta=0.945876, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 1 gives z=28817470.363061
  % 	x2 = 1,	Z1 = 28817470.3630606        
DEBUG EVAL: First branch cutoff check: z=28817470.363061, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 0
ITER 1: row=1, varin=81, theta=206.584400, up=1.000000
ITER 2: row=1, varin=30, theta=0.331106, up=999999999999999983222784.000000
ITER 3: row=41, varin=81, theta=0.998140, up=1.000000
ITER 4: row=40, varin=80, theta=-205.584400, up=1.000000
ITER 5: row=41, varin=90, theta=1.610339, up=1.000000
ITER 6: row=41, varin=39, theta=0.070198, up=999999999999999983222784.000000
ITER 7: row=40, varin=81, theta=1.285423, up=1.000000
ITER 8: row=40, varin=90, theta=0.526712, up=1.000000
  % 	x2 = 0,	Z0 = 28416090.7857304        
DEBUG EVAL: Second branch cutoff check: z=28416090.785730, best_z=INF, threshold=INF
  %   New best:  x2, Z = 28416090.7857304        
DEBUG EVAL: Testing var 18 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=23, varin=81, theta=206.584400, up=1.000000
ITER 2: row=23, varin=30, theta=0.331106, up=999999999999999983222784.000000
ITER 3: row=41, varin=81, theta=0.998140, up=1.000000
ITER 4: row=40, varin=80, theta=-205.584400, up=1.000000
ITER 5: row=41, varin=90, theta=1.610339, up=1.000000
ITER 6: row=41, varin=76, theta=1.231999, up=1.000000
ITER 7: row=41, varin=34, theta=0.031615, up=999999999999999983222784.000000
ITER 8: row=40, varin=81, theta=2.144946, up=1.000000
ITER 9: row=40, varin=76, theta=2.495152, up=1.000000
ITER 10: row=40, varin=50, theta=0.257586, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 18 = 0 gives z=28499566.691598
  % 	x18 = 0,	Z0 = 28499566.6915978        
DEBUG EVAL: First branch cutoff check: z=28499566.691598, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 18 = 1
ITER 1: row=23, varin=35, theta=2.575713, up=999999999999999983222784.000000
ITER 2: row=49, varin=27, theta=2.956250, up=999999999999999983222784.000000
ITER 3: row=33, varin=45, theta=7.458577, up=999999999999999983222784.000000
ITER 4: row=24, varin=46, theta=17.620161, up=999999999999999983222784.000000
ITER 5: row=46, varin=41, theta=3.952850, up=999999999999999983222784.000000
ITER 6: row=7, varin=28, theta=3.870707, up=999999999999999983222784.000000
ITER 7: row=2, varin=39, theta=7.858298, up=999999999999999983222784.000000
ITER 8: row=1, varin=32, theta=2.298746, up=999999999999999983222784.000000
ITER 9: row=41, varin=20, theta=1.040404, up=999999999999999983222784.000000
ITER 10: row=43, varin=44, theta=2.514838, up=999999999999999983222784.000000
  % 	x18 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: Second branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=23, varin=81, theta=206.584400, up=1.000000
ITER 2: row=23, varin=30, theta=0.331106, up=999999999999999983222784.000000
ITER 3: row=41, varin=81, theta=0.998140, up=1.000000
ITER 4: row=40, varin=80, theta=-205.584400, up=1.000000
ITER 5: row=41, varin=90, theta=1.610339, up=1.000000
ITER 6: row=41, varin=76, theta=1.231999, up=1.000000
ITER 7: row=41, varin=34, theta=0.031615, up=999999999999999983222784.000000
ITER 8: row=40, varin=81, theta=2.144946, up=1.000000
ITER 9: row=40, varin=76, theta=2.495152, up=1.000000
ITER 10: row=40, varin=50, theta=0.257586, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=15)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28499566.691598
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 52 rows, 60 cols, 293 nonzeros, 5 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 5 slack rows
   % @PAP adding 3 rows, 10 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=73, theta=0.452569, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28505340.958726
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 50 rows, 60 cols, 293 nonzeros, 1 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=82, theta=0.328457, up=1.000000
ITER 2: row=41, varin=77, theta=0.187825, up=1.000000
ITER 3: row=22, varin=85, theta=0.445829, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28525899.668104
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.910834
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 51 rows, 60 cols, 295 nonzeros, 4 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 4 slack rows
   % @PAP adding 3 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=72, theta=0.114397, up=1.000000
ITER 2: row=41, varin=19, theta=0.078260, up=999999999999999983222784.000000
ITER 3: row=43, varin=74, theta=0.259393, up=1.000000
ITER 4: row=49, varin=78, theta=0.195505, up=1.000000
LP PHASE: Switching to primal (iter=4)
ITER 5: row=12, varin=43, theta=0.000000, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28529795.512852
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 50 rows, 60 cols, 295 nonzeros, 0 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 21 at  28.52979551285218207113
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e74a1c0
% @LO 0.02  28.37841905216090054864 99.9000000000
% @LN 0.02  28.38093567323315724593 99.9000000000
% Resuming node 25 at  28.38093567323315724593
DEBUG CONSTRNT: LP rows=50, pool->nlprows=50, pool->npend=0
DEBUG CONSTRNT: Checking 50 LP rows (pool tracks 50, total LP rows 50)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=49, expected 49
 % @PAP adding 37 rows, 146 nz to LP
DEBUG BB: Processing node 25, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=6, varin=23, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 28380935.673233
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 3.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 37 rows, 60 cols, 206 nonzeros, 1 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 11 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=20, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=69, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 28580913.430686
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 3.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 39 rows, 60 cols, 217 nonzeros, 3 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 4 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=37, varin=75, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28636827.386324
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 3.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 40 rows, 60 cols, 217 nonzeros, 0 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 40 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=68, theta=0.772134, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28655212.911206
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 3.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 41 rows, 60 cols, 257 nonzeros, 0 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 17 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=27, theta=0.207077, up=999999999999999983222784.000000
ITER 2: row=41, varin=9, theta=0.892743, up=999999999999999983222784.000000
ITER 3: row=20, varin=20, theta=0.287269, up=999999999999999983222784.000000
ITER 4: row=24, varin=68, theta=0.587063, up=1.000000
ITER 5: row=41, varin=80, theta=0.653969, up=1.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28778588.453169
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 3.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 45 rows, 60 cols, 274 nonzeros, 0 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 19 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=71, theta=0.633893, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28821269.576001
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 3.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 49 rows, 60 cols, 293 nonzeros, 0 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=75, theta=2.815031, up=1.000000
ITER 2: row=50, varin=76, theta=0.482281, up=1.000000
ITER 3: row=12, varin=75, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28876039.663716
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 3.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 50 rows, 60 cols, 297 nonzeros, 0 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=82, theta=1.698118, up=1.000000
ITER 2: row=51, varin=75, theta=0.501461, up=1.000000
ITER 3: row=38, varin=82, theta=1.000000, up=1.000000
ITER 4: row=6, varin=24, theta=0.106817, up=999999999999999983222784.000000
ITER 5: row=49, varin=80, theta=0.153725, up=1.000000
ITER 6: row=41, varin=38, theta=0.308966, up=999999999999999983222784.000000
ITER 7: row=38, varin=76, theta=0.511563, up=1.000000
ITER 8: row=34, varin=29, theta=0.098517, up=999999999999999983222784.000000
ITER 9: row=38, varin=12, theta=0.175987, up=999999999999999983222784.000000
ITER 10: row=51, varin=79, theta=0.145170, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 3.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 51 rows, 60 cols, 302 nonzeros, 3 slack, 48 tight.
  % Node 25 LP 1 Solution, length = 999999999999999983222784.000000, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.747996 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.252004 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 25 is INFEASIBLE
 %      25    13    infeasible               28384093.3203    x5 U    23    11
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e765b10
% @LO 0.02  28.38093567323315724593 99.9000000000
% @LN 0.02  28.38409332026001052895 99.9000000000
% Resuming node 18 at  28.38409332026001052895
DEBUG CONSTRNT: LP rows=51, pool->nlprows=51, pool->npend=0
DEBUG CONSTRNT: Checking 51 LP rows (pool tracks 51, total LP rows 51)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=50, expected 50
 % @PAP adding 46 rows, 196 nz to LP
DEBUG BB: Processing node 18, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 18 LP 2 Solution, length = 28384093.320260, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.500000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.131711 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.131711 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.034956 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.034956 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 1.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.034956 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.131711 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.500000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.034956 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.034956 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.500000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.965044 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.868289 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.868289 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.965044 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.965044 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.965044 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.868289 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.868289 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.965044 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.965044 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 11 fractional variables
DEBUG CG: LP optimal, z=28384093.320260, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28384093.320260, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 3 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 18 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 18
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.500000
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.500000
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.131711
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.131711)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.131711
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.131711)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.034956
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.034956)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.034956
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.034956)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=1.000000
DEBUG CAREFUL: Skipping var 10: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.034956
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.034956)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.131711
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.131711)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.500000
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.034956
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.034956)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.034956
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.034956)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 11 fractional variables

  %  Carefully choosing branching variable, nfrac = 11
DEBUG CAREFUL: Testing fvar[0] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 29
DEBUG CAREFUL: New best var: 29
DEBUG CAREFUL: Testing fvar[1] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[2] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
DEBUG CAREFUL: Testing fvar[3] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[4] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[5] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[6] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 15
DEBUG CAREFUL: Testing fvar[7] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 5
DEBUG CAREFUL: Testing fvar[8] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 36
DEBUG CAREFUL: New best var: 36
DEBUG CAREFUL: Testing fvar[9] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
DEBUG CAREFUL: Testing fvar[10] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 34
  % Initial guess is x36, Z0 = 28384093.32026          , Z1 = 28442845.3018796        

DEBUG EVAL: Testing var 29 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=22, varin=39, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 29 = 0 gives z=28399864.690695
  % 	x29 = 0,	Z0 = 28399864.6906952        
DEBUG EVAL: First branch cutoff check: z=28399864.690695, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 29 = 1
ITER 1: row=22, varin=4, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=37, varin=29, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=40, varin=5, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=37, varin=39, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=13, varin=18, theta=2.178602, up=999999999999999983222784.000000
ITER 6: row=28, varin=58, theta=1.420814, up=1.000000
ITER 7: row=28, varin=51, theta=0.466981, up=1.000000
ITER 8: row=7, varin=69, theta=0.389274, up=1.000000
ITER 9: row=28, varin=21, theta=0.127525, up=999999999999999983222784.000000
ITER 10: row=3, varin=58, theta=0.203964, up=1.000000
  % 	x29 = 1,	Z1 = 29074543.4314837        
DEBUG EVAL: Second branch cutoff check: z=29074543.431484, best_z=INF, threshold=INF
  %   New best:  x29, Z = 28399864.6906952        
DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=39, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 0 gives z=28399864.690695
  % 	x1 = 0,	Z0 = 28399864.6906952        
DEBUG EVAL: First branch cutoff check: z=28399864.690695, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 1
ITER 1: row=2, varin=29, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=40, varin=36, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=13, varin=18, theta=3.146692, up=999999999999999983222784.000000
ITER 4: row=28, varin=58, theta=2.052172, up=1.000000
ITER 5: row=28, varin=51, theta=1.167604, up=1.000000
ITER 6: row=28, varin=69, theta=0.098613, up=1.000000
ITER 7: row=3, varin=51, theta=1.486656, up=1.000000
ITER 8: row=3, varin=23, theta=0.266367, up=999999999999999983222784.000000
ITER 9: row=45, varin=58, theta=0.509975, up=1.000000
ITER 10: row=28, varin=71, theta=0.064376, up=1.000000
  % 	x1 = 1,	Z1 = 28824771.847009         
DEBUG EVAL: Second branch cutoff check: z=28824771.847009, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 0 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=39, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 0 = 0 gives z=28399864.690695
  % 	x0 = 0,	Z0 = 28399864.6906952        
DEBUG EVAL: First branch cutoff check: z=28399864.690695, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 0 = 1
ITER 1: row=1, varin=3, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=30, varin=4, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=37, varin=36, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=13, varin=18, theta=3.993336, up=999999999999999983222784.000000
ITER 5: row=28, varin=58, theta=2.604326, up=1.000000
ITER 6: row=28, varin=51, theta=1.780334, up=1.000000
ITER 7: row=28, varin=69, theta=0.459123, up=1.000000
ITER 8: row=3, varin=51, theta=1.742041, up=1.000000
ITER 9: row=3, varin=23, theta=0.406149, up=999999999999999983222784.000000
ITER 10: row=45, varin=58, theta=0.777598, up=1.000000
  % 	x0 = 1,	Z1 = 29187727.45167          
DEBUG EVAL: Second branch cutoff check: z=29187727.451670, best_z=INF, threshold=INF
  %   New best:  x0, Z = 28399864.6906952        
DEBUG EVAL: Testing var 17 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=21, varin=58, theta=0.118813, up=1.000000
DEBUG EVAL: Branch var 17 = 0 gives z=28388919.732856
  % 	x17 = 0,	Z0 = 28388919.732856         
DEBUG EVAL: First branch cutoff check: z=28388919.732856, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=46, theta=0.375796, up=999999999999999983222784.000000
ITER 2: row=13, varin=58, theta=0.058160, up=1.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28386560.591590
  % 	x2 = 0,	Z0 = 28386560.5915897        
DEBUG EVAL: First branch cutoff check: z=28386560.591590, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=46, theta=1.336827, up=999999999999999983222784.000000
ITER 2: row=13, varin=44, theta=196.698252, up=999999999999999983222784.000000
ITER 3: row=36, varin=18, theta=1.250064, up=999999999999999983222784.000000
ITER 4: row=15, varin=39, theta=1.689925, up=999999999999999983222784.000000
ITER 5: row=3, varin=42, theta=0.629080, up=999999999999999983222784.000000
ITER 6: row=31, varin=62, theta=0.913330, up=1.000000
ITER 7: row=1, varin=41, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=41, varin=21, theta=1.000000, up=999999999999999983222784.000000
ITER 9: row=32, varin=36, theta=1.000000, up=999999999999999983222784.000000
ITER 10: row=22, varin=34, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 1 gives z=28817511.468349
  % 	x3 = 1,	Z1 = 28817511.468349         
DEBUG EVAL: First branch cutoff check: z=28817511.468349, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=7, varin=58, theta=0.118813, up=1.000000
  % 	x3 = 0,	Z0 = 28388919.732856         
DEBUG EVAL: Second branch cutoff check: z=28388919.732856, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 15 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=15, varin=46, theta=0.110556, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 15 = 0 gives z=28384153.653619
  % 	x15 = 0,	Z0 = 28384153.6536189        
DEBUG EVAL: First branch cutoff check: z=28384153.653619, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 5 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=13, varin=46, theta=0.110556, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 5 = 0 gives z=28384153.653619
  % 	x5 = 0,	Z0 = 28384153.6536188        
DEBUG EVAL: First branch cutoff check: z=28384153.653619, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 36 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=36, varin=39, theta=3.339605, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 36 = 1 gives z=28436763.471331
  % 	x36 = 1,	Z1 = 28442845.3018796        
DEBUG EVAL: First branch cutoff check: z=28442845.301880, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 36 = 0
ITER 1: row=36, varin=44, theta=0.026636, up=999999999999999983222784.000000
  % 	x36 = 0,	Z0 = 28384109.4918721        
DEBUG EVAL: Second branch cutoff check: z=28384109.491872, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 7 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=20, varin=39, theta=3.339605, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 7 = 1 gives z=28436763.471332
  % 	x7 = 1,	Z1 = 28436763.4713317        
DEBUG EVAL: First branch cutoff check: z=28436763.471332, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 7 = 0
ITER 1: row=20, varin=46, theta=0.110556, up=999999999999999983222784.000000
  % 	x7 = 0,	Z0 = 28384153.6536189        
DEBUG EVAL: Second branch cutoff check: z=28384153.653619, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 34 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=31, varin=39, theta=3.339605, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 34 = 1 gives z=28436763.471332
  % 	x34 = 1,	Z1 = 28437474.6485877        
DEBUG EVAL: First branch cutoff check: z=28437474.648588, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 34 = 0
ITER 1: row=31, varin=46, theta=0.110556, up=999999999999999983222784.000000
  % 	x34 = 0,	Z0 = 28384153.6536189        
DEBUG EVAL: Second branch cutoff check: z=28384153.653619, best_z=INF, threshold=INF
  % Best branch is x0, Z0 = 28399864.6906952        , Z1 = 29187727.45167          

DEBUG CAREFUL: Final result - returning best.var = 0
DEBUG BB: Branching variable chosen: j=0
 % @NC   27   18	x0 = 0	28399864.690695
 % @NC   28   18	x0 = 1	29187727.451670
 %      18    14 28384093.3203               28388836.6997   x10 U    15     8
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e74b490
% @LO 0.02  28.38409332026001052895 99.9000000000
% @LN 0.02  28.38883669972847556551 99.9000000000
% Resuming node 24 at  28.38883669972847556551
DEBUG CONSTRNT: LP rows=46, pool->nlprows=46, pool->npend=0
DEBUG CONSTRNT: Checking 46 LP rows (pool tracks 46, total LP rows 46)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 143
DEBUG CONSTRNT: Pool row 143 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 158
DEBUG CONSTRNT: Pool row 158 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=45, expected 45
 % @PAP adding 37 rows, 187 nz to LP
DEBUG BB: Processing node 24, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=37, theta=0.690285, up=999999999999999983222784.000000
ITER 2: row=31, varin=30, theta=1.141234, up=999999999999999983222784.000000
ITER 3: row=1, varin=29, theta=1.027174, up=999999999999999983222784.000000
ITER 4: row=30, varin=25, theta=0.524972, up=999999999999999983222784.000000
ITER 5: row=1, varin=37, theta=0.518560, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 28388836.699728
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 37 rows, 60 cols, 247 nonzeros, 2 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 15 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=3, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=40, varin=4, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=25, varin=59, theta=3.726851, up=1.000000
ITER 4: row=25, varin=44, theta=0.749737, up=1.000000
ITER 5: row=16, varin=59, theta=1.016304, up=1.000000
ITER 6: row=16, varin=27, theta=0.031805, up=999999999999999983222784.000000
ITER 7: row=7, varin=71, theta=1.868674, up=1.000000
ITER 8: row=7, varin=45, theta=0.667210, up=1.000000
ITER 9: row=27, varin=48, theta=1.267705, up=1.000000
ITER 10: row=27, varin=68, theta=0.129656, up=1.000000
LP PHASE: Switching to primal (iter=13)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28822289.296088
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 41 rows, 60 cols, 262 nonzeros, 8 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 8 slack rows
  % @PAP adding 8 rows, 28 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=71, theta=1.000000, up=1.000000
ITER 2: row=38, varin=64, theta=0.842116, up=1.000000
ITER 3: row=34, varin=45, theta=0.489361, up=1.000000
ITER 4: row=38, varin=63, theta=0.020405, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 29022019.909809
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 3.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1000000.000000
  % @PL 41 rows, 60 cols, 265 nonzeros, 0 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 10 rows, 43 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=74, theta=1.521006, up=1.000000
ITER 2: row=44, varin=57, theta=0.337805, up=1.000000
ITER 3: row=51, varin=21, theta=0.466793, up=999999999999999983222784.000000
ITER 4: row=45, varin=74, theta=1.720856, up=1.000000
ITER 5: row=45, varin=77, theta=0.641349, up=1.000000
ITER 6: row=48, varin=74, theta=1.000000, up=1.000000
ITER 7: row=45, varin=79, theta=0.588504, up=1.000000
ITER 8: row=6, varin=80, theta=0.594630, up=1.000000
ITER 9: row=35, varin=76, theta=1.788678, up=1.000000
ITER 10: row=35, varin=75, theta=0.636624, up=1.000000
LP PHASE: Switching to primal (iter=16)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 29392796.570489
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 3.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1000000.000000
  % @PL 51 rows, 60 cols, 308 nonzeros, 1 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 5 rows, 24 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=55, varin=81, theta=1.000000, up=1.000000
ITER 2: row=51, varin=83, theta=1.644203, up=1.000000
ITER 3: row=51, varin=84, theta=0.652084, up=1.000000
ITER 4: row=6, varin=83, theta=1.000000, up=1.000000
ITER 5: row=35, varin=49, theta=2.208053, up=999999999999999983222784.000000
ITER 6: row=46, varin=109, theta=2.567656, up=1.000000
ITER 7: row=46, varin=104, theta=0.308169, up=1.000000
ITER 8: row=26, varin=109, theta=1.343430, up=1.000000
ITER 9: row=26, varin=22, theta=0.206920, up=999999999999999983222784.000000
ITER 10: row=51, varin=109, theta=0.893259, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 3.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1000000.000000
  % @PL 55 rows, 60 cols, 328 nonzeros, 7 slack, 48 tight.
  % Node 24 LP 1 Solution, length = 999999999999999983222784.000000, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 1.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.748588 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.748588 (FST 24)
  % DEBUG LP_VARS: x[25] = 1.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.251412 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.251412 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 24 is INFEASIBLE
 %      24    13    infeasible               28395877.1989    x0 U    20    10
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e74b550
% @LO 0.02  28.38883669972847556551 99.9000000000
% @LN 0.02  28.39587719887920869155 99.9000000000
% Resuming node 8 at  28.39587719887920869155
DEBUG CONSTRNT: LP rows=55, pool->nlprows=55, pool->npend=0
DEBUG CONSTRNT: Checking 55 LP rows (pool tracks 55, total LP rows 55)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 85
DEBUG CONSTRNT: Pool row 85 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=54, expected 54
 % @PAP adding 40 rows, 198 nz to LP
DEBUG BB: Processing node 8, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 8 LP 3 Solution, length = 28395877.198879, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.500000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.500000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.089464 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 1.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.029821 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.029821 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.970179 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.970179 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.910536 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.910536 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.970179 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.910536 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28395877.198879, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28395877.198879, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 8 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 8
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.500000
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.500000
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.089464
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.089464)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=1.000000
DEBUG CAREFUL: Skipping var 14: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.029821
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.029821)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.029821
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.029821)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 5
DEBUG CAREFUL: New best var: 5
DEBUG CAREFUL: Testing fvar[1] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
DEBUG CAREFUL: Testing fvar[2] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
DEBUG CAREFUL: Testing fvar[3] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[4] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x18, Z0 = 28395877.1988792        , Z1 = 28401552.3609627        

DEBUG EVAL: Testing var 5 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=40, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 5 = 0 gives z=28414373.160474
  % 	x5 = 0,	Z0 = 28414373.1604737        
DEBUG EVAL: First branch cutoff check: z=28414373.160474, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 5 = 1
ITER 1: row=3, varin=38, theta=1.000000, up=999999999999999983222784.000000
  % 	x5 = 1,	Z1 = 28412227.0252604        
DEBUG EVAL: Second branch cutoff check: z=28412227.025260, best_z=INF, threshold=INF
  %   New best:  x5, Z = 28412227.0252604        
DEBUG EVAL: Testing var 7 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=15, varin=38, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 7 = 0 gives z=28412227.025260
  % 	x7 = 0,	Z0 = 28412227.0252603        
DEBUG EVAL: First branch cutoff check: z=28412227.025260, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 7 = 1
ITER 1: row=15, varin=27, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=10, varin=49, theta=0.513421, up=1.000000
ITER 3: row=17, varin=43, theta=0.540602, up=1.000000
ITER 4: row=6, varin=30, theta=2.283653, up=999999999999999983222784.000000
ITER 5: row=1, varin=44, theta=0.633711, up=1.000000
ITER 6: row=25, varin=3, theta=0.226445, up=999999999999999983222784.000000
ITER 7: row=34, varin=39, theta=0.166795, up=999999999999999983222784.000000
ITER 8: row=26, varin=67, theta=0.864392, up=1.000000
  % 	x7 = 1,	Z1 = 28663590.9026728        
DEBUG EVAL: Second branch cutoff check: z=28663590.902673, best_z=INF, threshold=INF
  %   New best:  x7, Z = 28412227.0252603        
DEBUG EVAL: Testing var 18 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=26, varin=30, theta=2.404484, up=999999999999999983222784.000000
ITER 2: row=1, varin=40, theta=3.003071, up=999999999999999983222784.000000
ITER 3: row=15, varin=29, theta=1.239778, up=999999999999999983222784.000000
ITER 4: row=10, varin=49, theta=0.747934, up=1.000000
ITER 5: row=25, varin=3, theta=0.897774, up=999999999999999983222784.000000
ITER 6: row=34, varin=27, theta=1.120060, up=999999999999999983222784.000000
ITER 7: row=17, varin=43, theta=1.303013, up=1.000000
ITER 8: row=17, varin=67, theta=0.445291, up=1.000000
ITER 9: row=3, varin=4, theta=1.624455, up=999999999999999983222784.000000
ITER 10: row=31, varin=21, theta=1.492783, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 18 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x18 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=26, varin=49, theta=0.084092, up=1.000000
ITER 2: row=17, varin=31, theta=0.248613, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28396063.983958
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 3.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
   % @PL 40 rows, 60 cols, 258 nonzeros, 5 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 5 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 8 at  28.39606398395784125910
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e74b550
% @LO 0.02  28.39587719887920869155 99.9000000000
% @LN 0.02  28.39606398395784125910 99.9000000000
% Resuming node 8 at  28.39606398395784125910
DEBUG CONSTRNT: LP rows=35, pool->nlprows=35, pool->npend=0
DEBUG CONSTRNT: Checking 35 LP rows (pool tracks 35, total LP rows 35)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 150
DEBUG CONSTRNT: Pool row 150 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=34, expected 34
 % @PAP adding 35 rows, 180 nz to LP
DEBUG BB: Processing node 8, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 8 LP 4 Solution, length = 28396063.983958, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.124307 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.124307 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.500000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.500000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 1.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.875693 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.875693 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.875693 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.875693 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28396063.983958, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28396063.983958, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 8 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 8
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.124307
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.124307)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.124307
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.124307)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.500000
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.500000
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=1.000000
DEBUG CAREFUL: Skipping var 14: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 5
DEBUG CAREFUL: New best var: 5
DEBUG CAREFUL: Testing fvar[1] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 7
DEBUG CAREFUL: New best var: 7
DEBUG CAREFUL: Testing fvar[2] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[3] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
  % Initial guess is x7, Z0 = 28412227.0252603        , Z1 = 28663590.9026728        

DEBUG EVAL: Testing var 5 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=33, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 5 = 1 gives z=28412383.610258
  % 	x5 = 1,	Z1 = 28412383.6102584        
DEBUG EVAL: First branch cutoff check: z=28412383.610258, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 5 = 0
ITER 1: row=3, varin=35, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=16, varin=38, theta=0.500000, up=1.000000
ITER 3: row=6, varin=34, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=1, varin=39, theta=0.086647, up=1.000000
  % 	x5 = 0,	Z0 = 28460671.1997747        
DEBUG EVAL: Second branch cutoff check: z=28460671.199775, best_z=INF, threshold=INF
  %   New best:  x5, Z = 28412383.6102584        
DEBUG EVAL: Testing var 7 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=15, varin=33, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 7 = 0 gives z=28412383.610258
  % 	x7 = 0,	Z0 = 28412383.6102584        
DEBUG EVAL: First branch cutoff check: z=28412383.610258, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 7 = 1
ITER 1: row=15, varin=27, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=16, varin=38, theta=0.500000, up=1.000000
ITER 3: row=6, varin=34, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=1, varin=39, theta=0.595733, up=1.000000
ITER 5: row=26, varin=10, theta=0.244096, up=999999999999999983222784.000000
ITER 6: row=10, varin=65, theta=1.090124, up=1.000000
ITER 7: row=10, varin=3, theta=0.029465, up=999999999999999983222784.000000
ITER 8: row=2, varin=26, theta=0.025851, up=999999999999999983222784.000000
ITER 9: row=34, varin=62, theta=0.071462, up=1.000000
ITER 10: row=1, varin=35, theta=0.021378, up=999999999999999983222784.000000
  % 	x7 = 1,	Z1 = 28663590.9026728        
DEBUG EVAL: Second branch cutoff check: z=28663590.902673, best_z=INF, threshold=INF
  %   New best:  x7, Z = 28412383.6102584        
DEBUG EVAL: Testing var 1 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=93, theta=0.592393, up=1.000000
ITER 2: row=16, varin=35, theta=1.441383, up=999999999999999983222784.000000
ITER 3: row=2, varin=38, theta=0.761687, up=1.000000
ITER 4: row=6, varin=39, theta=0.904477, up=1.000000
ITER 5: row=27, varin=30, theta=1.226328, up=999999999999999983222784.000000
ITER 6: row=1, varin=10, theta=0.125203, up=999999999999999983222784.000000
ITER 7: row=10, varin=65, theta=0.559152, up=1.000000
DEBUG EVAL: Branch var 1 = 1 gives z=28553605.989229
  % 	x1 = 1,	Z1 = 28553605.9892289        
DEBUG EVAL: First branch cutoff check: z=28553605.989229, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 0
ITER 1: row=2, varin=38, theta=0.080529, up=1.000000
ITER 2: row=6, varin=34, theta=0.077765, up=999999999999999983222784.000000
  % 	x1 = 0,	Z0 = 28399405.8497527        
DEBUG EVAL: Second branch cutoff check: z=28399405.849753, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 0 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=38, theta=0.080529, up=1.000000
ITER 2: row=6, varin=34, theta=0.077765, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 0 = 0 gives z=28399405.849753
  % 	x0 = 0,	Z0 = 28399405.8497527        
DEBUG EVAL: First branch cutoff check: z=28399405.849753, best_z=INF, threshold=INF
  % Best branch is x7, Z0 = 28412383.6102584        , Z1 = 28663590.9026728        

DEBUG CAREFUL: Final result - returning best.var = 7
DEBUG BB: Branching variable chosen: j=7
 % @NC   29    8	x7 = 0	28412383.610258
 % @NC   30    8	x7 = 1	28663590.902673
 %       8    14 28396063.9840               28399485.5761   x14 U     5     4
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e743b80
% @LO 0.02  28.39606398395784125910 99.9000000000
% @LN 0.02  28.39948557611673862766 99.9000000000
% Resuming node 19 at  28.39948557611673862766
DEBUG CONSTRNT: LP rows=35, pool->nlprows=35, pool->npend=0
DEBUG CONSTRNT: Checking 35 LP rows (pool tracks 35, total LP rows 35)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 150
DEBUG CONSTRNT: Pool row 150 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=34, expected 34
 % @PAP adding 36 rows, 192 nz to LP
DEBUG BB: Processing node 19, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 19 LP 2 Solution, length = 28399485.576117, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.282284 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.717716 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.435433 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.435433 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.717716 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.564567 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.282284 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.282284 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.564567 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.282284 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.564567 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.564567 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.564567 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28399485.576117, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28399485.576117, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 19 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 19
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.282284
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.282284)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.717716
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.717716)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.435433
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.435433)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.435433
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.435433)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 1
DEBUG CAREFUL: New best var: 1
DEBUG CAREFUL: Testing fvar[1] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
DEBUG CAREFUL: Testing fvar[2] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[3] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 18
DEBUG CAREFUL: New best var: 18
  % Initial guess is x18, Z0 = 28399485.5761167        , Z1 = 28473919.3629508        

DEBUG EVAL: Testing var 1 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=39, theta=0.293605, up=1.000000
ITER 2: row=6, varin=40, theta=0.305990, up=1.000000
DEBUG EVAL: Branch var 1 = 1 gives z=28427986.187415
  % 	x1 = 1,	Z1 = 28427986.1874145        
DEBUG EVAL: First branch cutoff check: z=28427986.187415, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 0
ITER 1: row=2, varin=26, theta=2.365001, up=999999999999999983222784.000000
ITER 2: row=25, varin=36, theta=2208897.000000, up=999999999999999983222784.000000
ITER 3: row=21, varin=28, theta=1.000000, up=999999999999999983222784.000000
  % 	x1 = 0,	Z0 = 28500000                
DEBUG EVAL: Second branch cutoff check: z=28500000.000000, best_z=INF, threshold=INF
  %   New best:  x1, Z = 28427986.1874145        
DEBUG EVAL: Testing var 0 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=39, theta=0.293605, up=1.000000
ITER 2: row=6, varin=40, theta=0.305990, up=1.000000
DEBUG EVAL: Branch var 0 = 0 gives z=28427986.187415
  % 	x0 = 0,	Z0 = 28427986.1874145        
DEBUG EVAL: First branch cutoff check: z=28427986.187415, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 0 = 1
ITER 1: row=1, varin=26, theta=2.365001, up=999999999999999983222784.000000
ITER 2: row=25, varin=36, theta=2208897.000000, up=999999999999999983222784.000000
ITER 3: row=21, varin=22, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=33, varin=27, theta=0.500000, up=999999999999999983222784.000000
ITER 5: row=3, varin=32, theta=0.473684, up=999999999999999983222784.000000
ITER 6: row=22, varin=19, theta=1.000000, up=999999999999999983222784.000000
  % 	x0 = 1,	Z1 = 28521439.5572872        
DEBUG EVAL: Second branch cutoff check: z=28521439.557287, best_z=INF, threshold=INF
  %   New best:  x0, Z = 28427986.1874145        
DEBUG EVAL: Testing var 17 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=26, theta=0.717414, up=999999999999999983222784.000000
ITER 2: row=25, varin=36, theta=670060.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 0 gives z=28423940.406237
  % 	x17 = 0,	Z0 = 28423940.4062365        
DEBUG EVAL: First branch cutoff check: z=28423940.406237, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 18 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
DEBUG EVAL: Branch var 18 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x18 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=21, varin=31, theta=9.703842, up=999999999999999983222784.000000
ITER 2: row=36, varin=36, theta=601009.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
ITER 3: row=30, varin=96, theta=1.000000, up=1.000000
ITER 4: row=21, varin=26, theta=0.000000, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=36)
DEBUG SOLUTION: LP solution array indices: FST[37-76], not_covered[77-96]
DEBUG SOLUTION: lp->best_solution[0] = 28423940.406237
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 3.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
   % @PL 36 rows, 60 cols, 252 nonzeros, 1 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 19 at  28.42394040623653950206
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e74a1c0
% @LO 0.02  28.39948557611673862766 99.9000000000
% @LN 0.02  28.39986469069514996022 99.9000000000
% Resuming node 27 at  28.39986469069514996022
DEBUG CONSTRNT: LP rows=35, pool->nlprows=35, pool->npend=0
DEBUG CONSTRNT: Checking 35 LP rows (pool tracks 35, total LP rows 35)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 73
DEBUG CONSTRNT: Pool row 73 has lprow=34, expected 34
 % @PAP adding 46 rows, 196 nz to LP
DEBUG BB: Processing node 27, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=39, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28399864.690695
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 256 nonzeros, 2 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 27 LP 1 Solution, length = 28399864.690695, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.009408 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.009408 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.323925 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.323925 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 1.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.323925 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.009408 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.323925 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.323925 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.676075 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.990592 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.990592 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.676075 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.676075 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.676075 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.990592 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.990592 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.676075 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.676075 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 8 fractional variables
DEBUG CG: LP optimal, z=28399864.690695, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28399864.690695, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 27 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 27
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.009408
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.009408)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.009408
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.009408)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.323925
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.323925)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.323925
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.323925)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=1.000000
DEBUG CAREFUL: Skipping var 10: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.323925
DEBUG CAREFUL: Adding var 15 to fractional list (xi=0.323925)
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.009408
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.009408)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.323925
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.323925)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.323925
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.323925)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 8 fractional variables

  %  Carefully choosing branching variable, nfrac = 8
DEBUG CAREFUL: Testing fvar[0] = var 15
DEBUG CAREFUL: Calling compare_branch_vars for var 15
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 15
DEBUG CAREFUL: New best var: 15
DEBUG CAREFUL: Testing fvar[1] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 5
DEBUG CAREFUL: Testing fvar[2] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 36
DEBUG CAREFUL: New best var: 36
DEBUG CAREFUL: Testing fvar[3] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
DEBUG CAREFUL: Testing fvar[4] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 34
DEBUG CAREFUL: Testing fvar[5] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[6] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[7] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
  % Initial guess is x3, Z0 = 28399864.690695         , Z1 = 28817511.468349         

DEBUG EVAL: Testing var 15 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=15, varin=46, theta=1.024491, up=999999999999999983222784.000000
ITER 2: row=1, varin=44, theta=0.352516, up=999999999999999983222784.000000
ITER 3: row=31, varin=42, theta=0.324424, up=999999999999999983222784.000000
ITER 4: row=22, varin=18, theta=0.191481, up=999999999999999983222784.000000
ITER 5: row=28, varin=41, theta=0.211162, up=999999999999999983222784.000000
ITER 6: row=41, varin=36, theta=0.222301, up=999999999999999983222784.000000
ITER 7: row=36, varin=29, theta=0.119404, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 15 = 0 gives z=28430880.478712
  % 	x15 = 0,	Z0 = 28430880.4787121        
DEBUG EVAL: First branch cutoff check: z=28430880.478712, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 15 = 1
ITER 1: row=15, varin=58, theta=1.529964, up=1.000000
ITER 2: row=15, varin=51, theta=0.588106, up=1.000000
ITER 3: row=7, varin=69, theta=2.157438, up=1.000000
ITER 4: row=7, varin=71, theta=3.632932, up=1.000000
ITER 5: row=7, varin=77, theta=1.438075, up=1.000000
ITER 6: row=7, varin=21, theta=0.242780, up=999999999999999983222784.000000
ITER 7: row=15, varin=77, theta=2.852617, up=1.000000
ITER 8: row=15, varin=71, theta=3.533633, up=1.000000
ITER 9: row=15, varin=69, theta=0.965682, up=1.000000
ITER 10: row=21, varin=58, theta=3.226243, up=1.000000
  % 	x15 = 1,	Z1 = 28955156.3176951        
DEBUG EVAL: Second branch cutoff check: z=28955156.317695, best_z=INF, threshold=INF
  %   New best:  x15, Z = 28430880.4787121        
DEBUG EVAL: Testing var 5 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=13, varin=46, theta=1.024491, up=999999999999999983222784.000000
ITER 2: row=1, varin=44, theta=0.352516, up=999999999999999983222784.000000
ITER 3: row=31, varin=42, theta=0.324424, up=999999999999999983222784.000000
ITER 4: row=22, varin=41, theta=0.211162, up=999999999999999983222784.000000
ITER 5: row=41, varin=36, theta=0.222301, up=999999999999999983222784.000000
ITER 6: row=36, varin=29, theta=0.119404, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 5 = 0 gives z=28430880.478712
  % 	x5 = 0,	Z0 = 28430880.4787121        
DEBUG EVAL: First branch cutoff check: z=28430880.478712, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 5 = 1
ITER 1: row=13, varin=18, theta=2.345966, up=999999999999999983222784.000000
ITER 2: row=28, varin=58, theta=1.529964, up=1.000000
ITER 3: row=28, varin=51, theta=0.588106, up=1.000000
ITER 4: row=7, varin=69, theta=2.157438, up=1.000000
ITER 5: row=7, varin=71, theta=3.632932, up=1.000000
ITER 6: row=7, varin=77, theta=1.438075, up=1.000000
ITER 7: row=7, varin=21, theta=0.242780, up=999999999999999983222784.000000
ITER 8: row=28, varin=77, theta=2.852617, up=1.000000
ITER 9: row=28, varin=71, theta=3.533633, up=1.000000
ITER 10: row=28, varin=69, theta=0.965682, up=1.000000
  % 	x5 = 1,	Z1 = 28720530.1854551        
DEBUG EVAL: Second branch cutoff check: z=28720530.185455, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 36 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=31, varin=18, theta=2.345966, up=999999999999999983222784.000000
ITER 2: row=28, varin=58, theta=1.529964, up=1.000000
ITER 3: row=28, varin=51, theta=0.588106, up=1.000000
ITER 4: row=7, varin=69, theta=2.157438, up=1.000000
ITER 5: row=7, varin=71, theta=3.632932, up=1.000000
ITER 6: row=7, varin=77, theta=1.438075, up=1.000000
ITER 7: row=7, varin=21, theta=0.242780, up=999999999999999983222784.000000
ITER 8: row=28, varin=77, theta=2.852617, up=1.000000
ITER 9: row=28, varin=71, theta=3.533633, up=1.000000
ITER 10: row=28, varin=69, theta=0.965682, up=1.000000
DEBUG EVAL: Branch var 36 = 1 gives z=29169278.320131
  % 	x36 = 1,	Z1 = 29169278.3201307        
DEBUG EVAL: First branch cutoff check: z=29169278.320131, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 36 = 0
ITER 1: row=31, varin=44, theta=0.246830, up=999999999999999983222784.000000
  % 	x36 = 0,	Z0 = 28400014.5479329        
DEBUG EVAL: Second branch cutoff check: z=28400014.547933, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 7 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=20, varin=18, theta=2.345966, up=999999999999999983222784.000000
ITER 2: row=28, varin=58, theta=1.529964, up=1.000000
ITER 3: row=28, varin=51, theta=0.588106, up=1.000000
ITER 4: row=7, varin=69, theta=2.157438, up=1.000000
ITER 5: row=7, varin=71, theta=3.632932, up=1.000000
ITER 6: row=7, varin=77, theta=1.438075, up=1.000000
ITER 7: row=7, varin=21, theta=0.242780, up=999999999999999983222784.000000
ITER 8: row=28, varin=77, theta=2.852617, up=1.000000
ITER 9: row=28, varin=71, theta=3.533633, up=1.000000
ITER 10: row=28, varin=69, theta=0.965682, up=1.000000
DEBUG EVAL: Branch var 7 = 1 gives z=29241494.720881
  % 	x7 = 1,	Z1 = 29241494.7208808        
DEBUG EVAL: First branch cutoff check: z=29241494.720881, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 7 = 0
ITER 1: row=20, varin=46, theta=1.024491, up=999999999999999983222784.000000
  % 	x7 = 0,	Z0 = 28400423.7809395        
DEBUG EVAL: Second branch cutoff check: z=28400423.780940, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 34 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=22, varin=58, theta=1.529964, up=1.000000
DEBUG EVAL: Branch var 34 = 1 gives z=28440486.640638
  % 	x34 = 1,	Z1 = 28440486.6406384        
DEBUG EVAL: First branch cutoff check: z=28440486.640638, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 34 = 0
ITER 1: row=22, varin=46, theta=1.024491, up=999999999999999983222784.000000
  % 	x34 = 0,	Z0 = 28400423.7809394        
DEBUG EVAL: Second branch cutoff check: z=28400423.780939, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 17 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=21, varin=58, theta=0.008487, up=1.000000
DEBUG EVAL: Branch var 17 = 0 gives z=28400209.434452
  % 	x17 = 0,	Z0 = 28400209.4344517        
DEBUG EVAL: First branch cutoff check: z=28400209.434452, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=46, theta=0.026843, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28399879.339346
  % 	x2 = 0,	Z0 = 28399879.3393463        
DEBUG EVAL: First branch cutoff check: z=28399879.339346, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=46, theta=1.525126, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 1 gives z=28400696.989590
  % 	x3 = 1,	Z1 = 28817511.468349         
DEBUG EVAL: First branch cutoff check: z=28817511.468349, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=7, varin=58, theta=0.008487, up=1.000000
  % 	x3 = 0,	Z0 = 28400209.4344517        
DEBUG EVAL: Second branch cutoff check: z=28400209.434452, best_z=INF, threshold=INF
  % Best branch is x15, Z0 = 28430880.4787121        , Z1 = 28955156.3176951        

DEBUG CAREFUL: Final result - returning best.var = 15
DEBUG BB: Branching variable chosen: j=15
 % @NC   31   27	x15 = 0	28430880.478712
 % @NC   32   27	x15 = 1	28955156.317695
 %      27    15 28399864.6907               28412383.6103    x0 D    18     9
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e74b490
% @LO 0.03  28.39986469069514996022 99.9000000000
% @LN 0.03  28.41238361025844483265 99.9000000000
% Resuming node 29 at  28.41238361025844483265
DEBUG CONSTRNT: LP rows=46, pool->nlprows=46, pool->npend=0
DEBUG CONSTRNT: Checking 46 LP rows (pool tracks 46, total LP rows 46)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 143
DEBUG CONSTRNT: Pool row 143 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 158
DEBUG CONSTRNT: Pool row 158 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=45, expected 45
 % @PAP adding 35 rows, 180 nz to LP
DEBUG BB: Processing node 29, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=15, varin=33, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=35)
DEBUG SOLUTION: LP solution array indices: FST[36-75], not_covered[76-95]
DEBUG SOLUTION: lp->best_solution[0] = 28412383.610258
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 3.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 35 rows, 60 cols, 240 nonzeros, 1 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=35, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=3, varin=40, theta=0.500000, up=1.000000
ITER 3: row=6, varin=34, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=4, varin=41, theta=0.086647, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 28460671.199775
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 3.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 37 rows, 60 cols, 248 nonzeros, 2 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 5 rows, 26 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=85, theta=1.344322, up=1.000000
ITER 2: row=38, varin=28, theta=0.026908, up=999999999999999983222784.000000
ITER 3: row=36, varin=85, theta=1.077464, up=1.000000
ITER 4: row=36, varin=70, theta=0.095034, up=1.000000
ITER 5: row=39, varin=85, theta=0.737651, up=1.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28498029.598002
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 3.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 40 rows, 60 cols, 268 nonzeros, 0 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 5 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=56, theta=0.415505, up=1.000000
ITER 2: row=41, varin=17, theta=0.488200, up=999999999999999983222784.000000
ITER 3: row=17, varin=72, theta=0.480770, up=1.000000
ITER 4: row=37, varin=80, theta=1.082287, up=1.000000
ITER 5: row=37, varin=38, theta=0.066183, up=999999999999999983222784.000000
ITER 6: row=17, varin=80, theta=0.575589, up=1.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28550078.520092
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 3.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 45 rows, 60 cols, 280 nonzeros, 3 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 2 rows, 11 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=71, theta=0.375647, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28551243.428669
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 3.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 44 rows, 60 cols, 269 nonzeros, 0 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=84, theta=0.341402, up=1.000000
ITER 2: row=34, varin=101, theta=0.339915, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28551573.580724
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.660085
DEBUG SOLUTION: lp->best_solution[8] = 0.660085
DEBUG SOLUTION: lp->best_solution[9] = 2.320169
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 47 rows, 60 cols, 276 nonzeros, 3 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=57, theta=0.155048, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28554466.243604
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 270 nonzeros, 0 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=33, theta=0.046707, up=999999999999999983222784.000000
ITER 2: row=47, varin=22, theta=0.051393, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28556789.512697
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 276 nonzeros, 3 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=52, theta=0.099065, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28557334.996649
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 267 nonzeros, 0 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=43, theta=0.036581, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28557622.221958
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 273 nonzeros, 3 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=74, theta=0.060545, up=1.000000
ITER 2: row=9, varin=36, theta=0.052062, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28560115.864896
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 271 nonzeros, 2 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 29 LP 1 Solution, length = 28560115.864896, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.473969 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.473969 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.075147 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.075147 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.075147 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.075147 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.075147 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 1.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.075147 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.075147 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.473969 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.526031 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.924853 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.526031 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.526031 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.924853 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.526031 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.924853 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.924853 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.924853 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.924853 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.924853 (terminal 19)
 % 10 fractional variables
DEBUG CG: LP optimal, z=28560115.864896, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 29 at  28.56011586489561082658
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e743b80
% @LO 0.03  28.41238361025844483265 99.9000000000
% @LN 0.03  28.42394040623653950206 99.9000000000
% Resuming node 19 at  28.42394040623653950206
DEBUG CONSTRNT: LP rows=47, pool->nlprows=47, pool->npend=0
DEBUG CONSTRNT: Checking 47 LP rows (pool tracks 47, total LP rows 47)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 150
DEBUG CONSTRNT: Pool row 150 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=46, expected 46
 % @PAP adding 35 rows, 152 nz to LP
DEBUG BB: Processing node 19, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 19 LP 3 Solution, length = 28423940.406237, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.500000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.500000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 2 fractional variables
DEBUG CG: LP optimal, z=28423940.406237, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28423940.406237, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 19 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 19
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.500000
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.500000
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 2 fractional variables

  %  Carefully choosing branching variable, nfrac = 2
DEBUG CAREFUL: Testing fvar[0] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 1
DEBUG CAREFUL: New best var: 1
DEBUG CAREFUL: Testing fvar[1] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 0
DEBUG CAREFUL: New best var: 0
  % Initial guess is x0, Z0 = 28427986.1874145        , Z1 = 28521439.5572872        

DEBUG EVAL: Testing var 1 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=38, theta=0.500000, up=1.000000
ITER 2: row=6, varin=39, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 1 = 1 gives z=28466160.490350
  % 	x1 = 1,	Z1 = 28466160.4903503        
DEBUG EVAL: First branch cutoff check: z=28466160.490350, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 0
ITER 1: row=2, varin=28, theta=1.000000, up=999999999999999983222784.000000
  % 	x1 = 0,	Z0 = 28500000                
DEBUG EVAL: Second branch cutoff check: z=28500000.000000, best_z=INF, threshold=INF
  %   New best:  x1, Z = 28466160.4903503        
DEBUG EVAL: Testing var 0 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=38, theta=0.500000, up=1.000000
ITER 2: row=6, varin=39, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 0 = 0 gives z=28466160.490350
  % 	x0 = 0,	Z0 = 28466160.4903503        
DEBUG EVAL: First branch cutoff check: z=28466160.490350, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 0 = 1
ITER 1: row=1, varin=21, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=21, varin=22, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=33, varin=32, theta=0.473684, up=999999999999999983222784.000000
ITER 4: row=22, varin=19, theta=1.000000, up=999999999999999983222784.000000
  % 	x0 = 1,	Z1 = 28521439.5572872        
DEBUG EVAL: Second branch cutoff check: z=28521439.557287, best_z=INF, threshold=INF
  %   New best:  x0, Z = 28466160.4903503        
  % Best branch is x0, Z0 = 28466160.4903503        , Z1 = 28521439.5572872        

DEBUG CAREFUL: Final result - returning best.var = 0
DEBUG BB: Branching variable chosen: j=0
 % @NC   33   19	x0 = 0	28466160.490350
 % @NC   34   19	x0 = 1	28521439.557287
 %      19    16 28423940.4062               28430880.4787   x15 D    17     9
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e74b550
% @LO 0.03  28.42394040623653950206 99.9000000000
% @LN 0.03  28.43088047871206569539 99.9000000000
% Resuming node 31 at  28.43088047871206569539
DEBUG CONSTRNT: LP rows=35, pool->nlprows=35, pool->npend=0
DEBUG CONSTRNT: Checking 35 LP rows (pool tracks 35, total LP rows 35)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 73
DEBUG CONSTRNT: Pool row 73 has lprow=34, expected 34
 % @PAP adding 46 rows, 196 nz to LP
DEBUG BB: Processing node 31, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=15, varin=46, theta=1.024491, up=999999999999999983222784.000000
ITER 2: row=1, varin=44, theta=0.352516, up=999999999999999983222784.000000
ITER 3: row=31, varin=42, theta=0.324424, up=999999999999999983222784.000000
ITER 4: row=22, varin=18, theta=0.191481, up=999999999999999983222784.000000
ITER 5: row=28, varin=41, theta=0.211162, up=999999999999999983222784.000000
ITER 6: row=41, varin=36, theta=0.222301, up=999999999999999983222784.000000
ITER 7: row=36, varin=29, theta=0.119404, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=46)
DEBUG SOLUTION: LP solution array indices: FST[47-86], not_covered[87-106]
DEBUG SOLUTION: lp->best_solution[0] = 28430880.478712
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 46 rows, 60 cols, 256 nonzeros, 8 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=13, theta=93864.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28433136.293360
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 906135.500000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 270 nonzeros, 4 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % Node 31 LP 1 Solution, length = 28433136.293360, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.500000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 1.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.500000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.500000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.500000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 2 fractional variables
DEBUG CG: LP optimal, z=28433136.293360, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.03  28.43088047871206569539 99.9000000000
 % @LN 0.03  28.43313629335990810887 99.9000000000
DEBUG CG: Second cutoff check: z=28433136.293360, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 31 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 31
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.500000
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=1.000000
DEBUG CAREFUL: Skipping var 10: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.500000
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 2 fractional variables

  %  Carefully choosing branching variable, nfrac = 2
DEBUG CAREFUL: Testing fvar[0] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
DEBUG CAREFUL: Testing fvar[1] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
  % Initial guess is x3, Z0 = 28433136.2933599        , Z1 = 28817511.468349         

DEBUG EVAL: Testing var 17 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=20, varin=43, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=75, theta=1.000000, up=1.000000
ITER 3: row=35, varin=80, theta=1.000000, up=1.000000
ITER 4: row=39, varin=82, theta=1.000000, up=1.000000
ITER 5: row=41, varin=48, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 17 = 0 gives z=28526691.301275
  % 	x17 = 0,	Z0 = 28526691.3012749        
DEBUG EVAL: First branch cutoff check: z=28526691.301275, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 1
ITER 1: row=20, varin=30, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=75, theta=1.000000, up=1.000000
ITER 3: row=35, varin=80, theta=1.000000, up=1.000000
ITER 4: row=39, varin=82, theta=1.000000, up=1.000000
ITER 5: row=41, varin=48, theta=1.000000, up=1.000000
  % 	x17 = 1,	Z1 = 28556585.8427904        
DEBUG EVAL: Second branch cutoff check: z=28556585.842790, best_z=INF, threshold=INF
  %   New best:  x17, Z = 28526691.3012749        
DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=20, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=31, varin=24, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=1, varin=75, theta=1.000000, up=1.000000
ITER 4: row=32, varin=25, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=35, varin=80, theta=2.000000, up=1.000000
ITER 6: row=35, varin=82, theta=1.000000, up=1.000000
ITER 7: row=39, varin=80, theta=1.000000, up=1.000000
ITER 8: row=41, varin=48, theta=2.000000, up=1.000000
ITER 9: row=41, varin=57, theta=0.500000, up=1.000000
ITER 10: row=45, varin=18, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 1 gives z=29083863.137576
  % 	x3 = 1,	Z1 = 29083863.137576         
DEBUG EVAL: First branch cutoff check: z=29083863.137576, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=3, varin=43, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=75, theta=1.000000, up=1.000000
ITER 3: row=35, varin=80, theta=1.000000, up=1.000000
ITER 4: row=39, varin=82, theta=1.000000, up=1.000000
ITER 5: row=41, varin=48, theta=1.000000, up=1.000000
  % 	x3 = 0,	Z0 = 28526691.3012749        
DEBUG EVAL: Second branch cutoff check: z=28526691.301275, best_z=INF, threshold=INF
  %   New best:  x3, Z = 28526691.3012749        
  % Best branch is x3, Z0 = 28526691.3012749        , Z1 = 29083863.137576         

DEBUG CAREFUL: Final result - returning best.var = 3
DEBUG BB: Branching variable chosen: j=3
 % @NC   35   31	x3 = 0	28526691.301275
 % @NC   36   31	x3 = 1	29083863.137576
 %      31    17 28433136.2934               28434435.2431   x15 D    27    10
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e737600
% @LO 0.03  28.43313629335990810887 99.9000000000
% @LN 0.03  28.43443524313312664731 99.9000000000
% Resuming node 11 at  28.43443524313312664731
DEBUG CONSTRNT: LP rows=45, pool->nlprows=45, pool->npend=0
DEBUG CONSTRNT: Checking 45 LP rows (pool tracks 45, total LP rows 45)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 158
DEBUG CONSTRNT: Pool row 158 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=44, expected 44
 % @PAP adding 51 rows, 229 nz to LP
DEBUG BB: Processing node 11, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=26, varin=50, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28359658.391435
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 51 rows, 60 cols, 289 nonzeros, 2 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=86, theta=1.000000, up=1.000000
ITER 2: row=55, varin=82, theta=0.250000, up=1.000000
ITER 3: row=51, varin=26, theta=0.049119, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 28369895.994828
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 55 rows, 60 cols, 303 nonzeros, 6 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=56, varin=43, theta=0.282493, up=999999999999999983222784.000000
ITER 2: row=32, varin=95, theta=0.161398, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 28373582.218775
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 57 rows, 60 cols, 307 nonzeros, 3 slack, 54 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 11 LP 1 Solution, length = 28373582.218775, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.209650 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.209650 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.209650 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.209650 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.209650 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.209650 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.161398 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.790350 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.790350 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.790350 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.790350 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.790350 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.790350 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.790350 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=28373582.218775, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28373582.218775, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 11 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 11
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.209650
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.209650)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.209650
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.209650)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.209650
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.209650)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.209650
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.209650)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.209650
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.209650)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.209650
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.209650)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.161398
DEBUG CAREFUL: Adding var 37 to fractional list (xi=0.161398)
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 7 fractional variables

  %  Carefully choosing branching variable, nfrac = 7
DEBUG CAREFUL: Testing fvar[0] = var 37
DEBUG CAREFUL: Calling compare_branch_vars for var 37
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 37
DEBUG CAREFUL: New best var: 37
DEBUG CAREFUL: Testing fvar[1] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[2] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[3] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 4
DEBUG CAREFUL: Testing fvar[4] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[5] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 11
DEBUG CAREFUL: Testing fvar[6] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
  % Initial guess is x3, Z0 = 28434435.2431331        , Z1 = 29258565.3361687        

DEBUG EVAL: Testing var 37 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=51, varin=80, theta=0.083269, up=1.000000
DEBUG EVAL: Branch var 37 = 0 gives z=28374546.394577
  % 	x37 = 0,	Z0 = 28434435.2431331        
DEBUG EVAL: First branch cutoff check: z=28434435.243133, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 37 = 1
ITER 1: row=51, varin=32, theta=1.467795, up=999999999999999983222784.000000
ITER 2: row=49, varin=56, theta=0.430270, up=999999999999999983222784.000000
ITER 3: row=45, varin=51, theta=232738.000000, up=999999999999999983222784.000000
ITER 4: row=43, varin=49, theta=0.957050, up=999999999999999983222784.000000
ITER 5: row=1, varin=55, theta=0.547275, up=999999999999999983222784.000000
ITER 6: row=21, varin=52, theta=0.244599, up=999999999999999983222784.000000
ITER 7: row=52, varin=13, theta=0.224822, up=999999999999999983222784.000000
ITER 8: row=13, varin=44, theta=0.081860, up=999999999999999983222784.000000
ITER 9: row=4, varin=59, theta=0.639626, up=1.000000
  % 	x37 = 1,	Z1 = 28468039.8552638        
DEBUG EVAL: Second branch cutoff check: z=28468039.855264, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 3 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=10, varin=32, theta=0.326135, up=999999999999999983222784.000000
ITER 2: row=49, varin=55, theta=2.153685, up=999999999999999983222784.000000
ITER 3: row=50, varin=51, theta=124673.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 0 gives z=28387829.151880
  % 	x3 = 0,	Z0 = 28434435.2431331        
DEBUG EVAL: First branch cutoff check: z=28434435.243133, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 1
ITER 1: row=10, varin=80, theta=3.369365, up=1.000000
ITER 2: row=10, varin=81, theta=3.517408, up=1.000000
ITER 3: row=10, varin=79, theta=1.658788, up=1.000000
ITER 4: row=10, varin=5, theta=0.532587, up=999999999999999983222784.000000
ITER 5: row=51, varin=52, theta=3.735488, up=999999999999999983222784.000000
ITER 6: row=52, varin=79, theta=1.885773, up=1.000000
ITER 7: row=52, varin=56, theta=1.331428, up=999999999999999983222784.000000
ITER 8: row=45, varin=81, theta=5.000000, up=1.000000
ITER 9: row=45, varin=41, theta=2.000000, up=999999999999999983222784.000000
ITER 10: row=47, varin=80, theta=4.000000, up=1.000000
  % 	x3 = 1,	Z1 = 29269883.9750104        
DEBUG EVAL: Second branch cutoff check: z=29269883.975010, best_z=INF, threshold=INF
  %   New best:  x3, Z = 28434435.2431331        
DEBUG EVAL: Testing var 26 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=34, varin=55, theta=2.153685, up=999999999999999983222784.000000
ITER 2: row=50, varin=51, theta=124673.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 0 gives z=28387829.151880
  % 	x26 = 0,	Z0 = 28434435.2431331        
DEBUG EVAL: First branch cutoff check: z=28434435.243133, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 1
ITER 1: row=34, varin=32, theta=2.212833, up=999999999999999983222784.000000
ITER 2: row=49, varin=80, theta=2.814822, up=1.000000
ITER 3: row=49, varin=11, theta=0.206100, up=999999999999999983222784.000000
ITER 4: row=51, varin=80, theta=1.092144, up=1.000000
ITER 5: row=51, varin=52, theta=0.112208, up=999999999999999983222784.000000
ITER 6: row=35, varin=44, theta=1.912813, up=999999999999999983222784.000000
ITER 7: row=51, varin=80, theta=0.971081, up=1.000000
ITER 8: row=48, varin=49, theta=0.766436, up=999999999999999983222784.000000
ITER 9: row=34, varin=81, theta=1.423485, up=1.000000
ITER 10: row=34, varin=52, theta=0.518327, up=999999999999999983222784.000000
  % 	x26 = 1,	Z1 = 28610830.4062424        
DEBUG EVAL: Second branch cutoff check: z=28610830.406242, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 4 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=32, varin=32, theta=0.326135, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 4 = 0 gives z=28375529.713159
  % 	x4 = 0,	Z0 = 28434435.2431331        
DEBUG EVAL: First branch cutoff check: z=28434435.243133, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 4 = 1
ITER 1: row=32, varin=80, theta=3.369365, up=1.000000
  % 	x4 = 1,	Z1 = 28574248.5415658        
DEBUG EVAL: Second branch cutoff check: z=28574248.541566, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=11, varin=55, theta=2.153685, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28381560.197165
  % 	x10 = 0,	Z0 = 28434435.2431331        
DEBUG EVAL: First branch cutoff check: z=28434435.243133, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 1
ITER 1: row=11, varin=32, theta=2.212833, up=999999999999999983222784.000000
  % 	x10 = 1,	Z1 = 28434435.2431331        
DEBUG EVAL: Second branch cutoff check: z=28434435.243133, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 11 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=41, varin=55, theta=2.153685, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 11 = 0 gives z=28381560.197165
  % 	x11 = 0,	Z0 = 28434435.2431331        
DEBUG EVAL: First branch cutoff check: z=28434435.243133, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 11 = 1
ITER 1: row=41, varin=32, theta=2.212833, up=999999999999999983222784.000000
  % 	x11 = 1,	Z1 = 28530298.0624196        
DEBUG EVAL: Second branch cutoff check: z=28530298.062420, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=4, varin=55, theta=2.153685, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28381560.197165
  % 	x2 = 0,	Z0 = 28434435.2431331        
DEBUG EVAL: First branch cutoff check: z=28434435.243133, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 1
ITER 1: row=4, varin=32, theta=2.212833, up=999999999999999983222784.000000
  % 	x2 = 1,	Z1 = 28434435.2431331        
DEBUG EVAL: Second branch cutoff check: z=28434435.243133, best_z=INF, threshold=INF
  % Best branch is x3, Z0 = 28434435.2431331        , Z1 = 29269883.9750104        

DEBUG CAREFUL: Final result - returning best.var = 3
DEBUG BB: Branching variable chosen: j=3
 % @NC   37   11	x3 = 0	28434435.243133
 % @NC   38   11	x3 = 1	29269883.975010
 %      11    18 28373582.2188               28434435.2431    x0 D     2     2
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e74b550
% Resuming node 37 at  28.43443524313312664731
DEBUG CONSTRNT: LP rows=57, pool->nlprows=57, pool->npend=0
DEBUG CONSTRNT: Checking 57 LP rows (pool tracks 57, total LP rows 57)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=56, expected 56
 % @PAP adding 57 rows, 247 nz to LP
DEBUG BB: Processing node 37, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=10, varin=32, theta=0.326135, up=999999999999999983222784.000000
ITER 2: row=49, varin=55, theta=2.153685, up=999999999999999983222784.000000
ITER 3: row=50, varin=51, theta=124673.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 28387829.151880
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 57 rows, 60 cols, 307 nonzeros, 5 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 20 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=58, varin=42, theta=0.025000, up=999999999999999983222784.000000
ITER 2: row=51, varin=85, theta=0.018234, up=1.000000
ITER 3: row=43, varin=84, theta=1.468802, up=1.000000
ITER 4: row=43, varin=83, theta=-0.746574, up=1.000000
ITER 5: row=48, varin=84, theta=1.000000, up=1.000000
ITER 6: row=53, varin=40, theta=0.133736, up=999999999999999983222784.000000
ITER 7: row=43, varin=44, theta=0.277216, up=999999999999999983222784.000000
ITER 8: row=46, varin=41, theta=0.004901, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=61)
DEBUG SOLUTION: LP solution array indices: FST[62-101], not_covered[102-121]
DEBUG SOLUTION: lp->best_solution[0] = 28420106.958563
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 61 rows, 60 cols, 327 nonzeros, 12 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=63, varin=85, theta=0.145828, up=1.000000
ITER 2: row=24, varin=49, theta=0.624548, up=999999999999999983222784.000000
ITER 3: row=41, varin=11, theta=0.173066, up=999999999999999983222784.000000
ITER 4: row=35, varin=13, theta=0.163255, up=999999999999999983222784.000000
ITER 5: row=12, varin=91, theta=0.155867, up=1.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=63)
DEBUG SOLUTION: LP solution array indices: FST[64-103], not_covered[104-123]
DEBUG SOLUTION: lp->best_solution[0] = 28429013.625903
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 63 rows, 60 cols, 331 nonzeros, 8 slack, 55 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=64, varin=94, theta=0.156261, up=1.000000
ITER 2: row=19, varin=98, theta=0.178198, up=1.000000
ITER 3: row=65, varin=46, theta=0.044204, up=999999999999999983222784.000000
ITER 4: row=62, varin=48, theta=0.209785, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=65)
DEBUG SOLUTION: LP solution array indices: FST[66-105], not_covered[106-125]
DEBUG SOLUTION: lp->best_solution[0] = 28442967.311014
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 65 rows, 60 cols, 337 nonzeros, 13 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 13 slack rows
  % Node 37 LP 1 Solution, length = 28442967.311014, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.052446 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.052446 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.237769 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.052446 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.052446 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.237769 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.052446 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.500000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.500000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.052446 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.237769 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.947554 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.947554 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.762231 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.947554 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.762231 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.947554 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.762231 (terminal 19)
 % 12 fractional variables
DEBUG CG: LP optimal, z=28442967.311014, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.03  28.43443524313312664731 99.9000000000
 % @LN 0.03  28.44296731101427155863 99.9000000000
DEBUG CG: Second cutoff check: z=28442967.311014, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 37 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 37
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.500000
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.052446
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.052446)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.052446
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.052446)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.237769
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.237769)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.052446
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.052446)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.052446
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.052446)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.237769
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.237769)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.052446
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.052446)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.500000
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.500000
DEBUG CAREFUL: Adding var 30 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.052446
DEBUG CAREFUL: Adding var 32 to fractional list (xi=0.052446)
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.237769
DEBUG CAREFUL: Adding var 37 to fractional list (xi=0.237769)
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 12 fractional variables

  %  Carefully choosing branching variable, nfrac = 12
DEBUG CAREFUL: Testing fvar[0] = var 30
DEBUG CAREFUL: Calling compare_branch_vars for var 30
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 30
DEBUG CAREFUL: New best var: 30
DEBUG CAREFUL: Testing fvar[1] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[2] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 29
DEBUG CAREFUL: Testing fvar[3] = var 32
DEBUG CAREFUL: Calling compare_branch_vars for var 32
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 32
DEBUG CAREFUL: New best var: 32
DEBUG CAREFUL: Testing fvar[4] = var 37
DEBUG CAREFUL: Calling compare_branch_vars for var 37
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 37
DEBUG CAREFUL: Testing fvar[5] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[6] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[7] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 27
DEBUG CAREFUL: Testing fvar[8] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 11
DEBUG CAREFUL: Testing fvar[9] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 4
DEBUG CAREFUL: Testing fvar[10] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[11] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 22
  % Initial guess is x32, Z0 = 28442967.3110143        , Z1 = 28668046.4149472        

DEBUG EVAL: Testing var 30 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=41, varin=4, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=46, varin=5, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=27, varin=26, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=21, varin=84, theta=1.801349, up=1.000000
ITER 5: row=21, varin=2, theta=0.694819, up=999999999999999983222784.000000
ITER 6: row=12, varin=69, theta=0.362712, up=1.000000
ITER 7: row=18, varin=37, theta=0.213171, up=999999999999999983222784.000000
ITER 8: row=37, varin=43, theta=0.515875, up=999999999999999983222784.000000
ITER 9: row=43, varin=50, theta=0.093768, up=999999999999999983222784.000000
ITER 10: row=10, varin=10, theta=0.204142, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 30 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x30 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=41, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28508284.860643
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
   % @PL 52 rows, 60 cols, 284 nonzeros, 1 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 2 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=85, theta=0.378780, up=1.000000
LP PHASE: Switching to primal (iter=1)
ITER 2: row=48, varin=51, theta=0.160268, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28511458.907628
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
   % @PL 53 rows, 60 cols, 288 nonzeros, 1 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=66, theta=5.000000, up=1.000000
ITER 2: row=1, varin=63, theta=6.000000, up=1.000000
ITER 3: row=1, varin=69, theta=3.333333, up=1.000000
ITER 4: row=1, varin=54, theta=3.500000, up=1.000000
ITER 5: row=1, varin=68, theta=1.666667, up=1.000000
ITER 6: row=1, varin=67, theta=0.666667, up=1.000000
ITER 7: row=41, varin=93, theta=14.522968, up=1.000000
ITER 8: row=41, varin=94, theta=13.522968, up=1.000000
ITER 9: row=41, varin=95, theta=12.522968, up=1.000000
ITER 10: row=41, varin=96, theta=11.522968, up=1.000000
LP PHASE: Switching to primal (iter=73)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28511458.907628
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
   % @PL 52 rows, 60 cols, 284 nonzeros, 0 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 37 at  28.51145890762787971084
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e74ccf0
% @LO 0.03  28.44296731101427155863 99.9000000000
% @LN 0.03  28.44336936524820913519 99.9000000000
% Resuming node 10 at  28.44336936524820913519
DEBUG CONSTRNT: LP rows=52, pool->nlprows=52, pool->npend=0
DEBUG CONSTRNT: Checking 52 LP rows (pool tracks 52, total LP rows 52)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=51, expected 51
 % @PAP adding 47 rows, 217 nz to LP
DEBUG BB: Processing node 10, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 10 LP 4 Solution, length = 28443369.365248, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.183690 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.183690 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.183690 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.183690 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.081552 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.816310 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.816310 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.816310 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.816310 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.816310 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28443369.365248, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28443369.365248, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 10 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 10
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.183690
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.183690)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.183690
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.183690)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=1.000000
DEBUG CAREFUL: Skipping var 9: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.183690
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.183690)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.183690
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.183690)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.081552
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.081552)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 22
DEBUG CAREFUL: New best var: 22
DEBUG CAREFUL: Testing fvar[1] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 18
DEBUG CAREFUL: Testing fvar[2] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[3] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[4] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
  % Initial guess is x22, Z0 = 28443369.3652482        , Z1 = 28695012.7756671        

DEBUG EVAL: Testing var 22 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=24, varin=55, theta=215.017820, up=1.000000
ITER 2: row=24, varin=46, theta=1.910412, up=999999999999999983222784.000000
ITER 3: row=33, varin=45, theta=1.998569, up=999999999999999983222784.000000
ITER 4: row=1, varin=55, theta=19.783027, up=1.000000
ITER 5: row=1, varin=43, theta=0.874613, up=999999999999999983222784.000000
ITER 6: row=43, varin=33, theta=2.043561, up=999999999999999983222784.000000
ITER 7: row=26, varin=39, theta=0.924167, up=999999999999999983222784.000000
ITER 8: row=39, varin=37, theta=0.605779, up=999999999999999983222784.000000
ITER 9: row=37, varin=92, theta=0.550582, up=1.000000
DEBUG EVAL: Branch var 22 = 1 gives z=28682928.608778
  % 	x22 = 1,	Z1 = 28695012.7756671        
DEBUG EVAL: First branch cutoff check: z=28695012.775667, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 22 = 0
ITER 1: row=24, varin=72, theta=0.216889, up=1.000000
ITER 2: row=9, varin=59, theta=0.117258, up=1.000000
  % 	x22 = 0,	Z0 = 28447033.2471578        
DEBUG EVAL: Second branch cutoff check: z=28447033.247158, best_z=INF, threshold=INF
  %   New best:  x22, Z = 28447033.2471578        
DEBUG EVAL: Testing var 18 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=23, varin=59, theta=0.704060, up=1.000000
ITER 2: row=24, varin=33, theta=0.289915, up=999999999999999983222784.000000
ITER 3: row=26, varin=24, theta=0.280675, up=999999999999999983222784.000000
ITER 4: row=28, varin=92, theta=0.232876, up=1.000000
DEBUG EVAL: Branch var 18 = 0 gives z=28503604.406118
  % 	x18 = 0,	Z0 = 28503604.4061181        
DEBUG EVAL: First branch cutoff check: z=28503604.406118, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 18 = 1
ITER 1: row=23, varin=55, theta=38.202613, up=1.000000
ITER 2: row=23, varin=31, theta=2.081421, up=999999999999999983222784.000000
ITER 3: row=47, varin=55, theta=7.212348, up=1.000000
ITER 4: row=47, varin=46, theta=3.729620, up=999999999999999983222784.000000
ITER 5: row=33, varin=45, theta=7.910274, up=999999999999999983222784.000000
ITER 6: row=1, varin=34, theta=1.580441, up=999999999999999983222784.000000
ITER 7: row=24, varin=69, theta=0.727139, up=1.000000
ITER 8: row=6, varin=29, theta=1.487559, up=999999999999999983222784.000000
ITER 9: row=2, varin=3, theta=1.652383, up=999999999999999983222784.000000
ITER 10: row=40, varin=22, theta=0.902859, up=999999999999999983222784.000000
  % 	x18 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: Second branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=23, varin=59, theta=0.704060, up=1.000000
ITER 2: row=24, varin=33, theta=0.289915, up=999999999999999983222784.000000
ITER 3: row=26, varin=24, theta=0.280675, up=999999999999999983222784.000000
ITER 4: row=28, varin=92, theta=0.232876, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28503604.406118
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 47 rows, 60 cols, 277 nonzeros, 1 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 6 rows, 34 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=26, theta=0.193057, up=999999999999999983222784.000000
ITER 2: row=50, varin=57, theta=0.394344, up=1.000000
ITER 3: row=52, varin=25, theta=0.038058, up=999999999999999983222784.000000
ITER 4: row=49, varin=47, theta=0.127882, up=999999999999999983222784.000000
ITER 5: row=33, varin=50, theta=0.190585, up=999999999999999983222784.000000
ITER 6: row=48, varin=34, theta=0.012018, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28538865.012707
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 52 rows, 60 cols, 305 nonzeros, 6 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 6 slack rows
   % @PAP adding 4 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=46, theta=0.976715, up=999999999999999983222784.000000
ITER 2: row=49, varin=47, theta=0.120380, up=999999999999999983222784.000000
ITER 3: row=4, varin=75, theta=0.057681, up=1.000000
ITER 4: row=9, varin=73, theta=0.021219, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28543077.699775
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 50 rows, 60 cols, 300 nonzeros, 4 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 4 slack rows
   % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=80, theta=3.224764, up=1.000000
ITER 2: row=47, varin=43, theta=0.443893, up=999999999999999983222784.000000
ITER 3: row=43, varin=94, theta=0.751023, up=1.000000
ITER 4: row=47, varin=80, theta=0.419482, up=1.000000
LP PHASE: Switching to primal (iter=4)
ITER 5: row=43, varin=72, theta=0.488425, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28549363.778815
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 49 rows, 60 cols, 285 nonzeros, 0 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 6 rows, 24 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=86, theta=0.580518, up=1.000000
ITER 2: row=54, varin=43, theta=0.151396, up=999999999999999983222784.000000
ITER 3: row=50, varin=51, theta=0.088684, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 28558274.277824
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 55 rows, 60 cols, 309 nonzeros, 4 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 4 slack rows
   % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=87, theta=0.131500, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28561058.683412
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 53 rows, 60 cols, 286 nonzeros, 0 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 10 at  28.56105868341181519554
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e74a1c0
% @LO 0.03  28.44336936524820913519 99.9000000000
% @LN 0.03  28.46616049035032247616 99.9000000000
% Resuming node 33 at  28.46616049035032247616
DEBUG CONSTRNT: LP rows=53, pool->nlprows=53, pool->npend=0
DEBUG CONSTRNT: Checking 53 LP rows (pool tracks 53, total LP rows 53)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=52, expected 52
 % @PAP adding 35 rows, 152 nz to LP
DEBUG BB: Processing node 33, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=38, theta=0.500000, up=1.000000
ITER 2: row=6, varin=39, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=35)
DEBUG SOLUTION: LP solution array indices: FST[36-75], not_covered[76-95]
DEBUG SOLUTION: lp->best_solution[0] = 28466160.490350
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 3.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 35 rows, 60 cols, 212 nonzeros, 0 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 31 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=85, theta=0.500000, up=1.000000
ITER 2: row=39, varin=48, theta=0.500000, up=1.000000
ITER 3: row=33, varin=19, theta=0.055556, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28485700.718367
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 3.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 41 rows, 60 cols, 243 nonzeros, 3 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 4 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=26, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28500000.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 3.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 42 rows, 60 cols, 237 nonzeros, 1 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 1 rows, 40 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=22, theta=0.058824, up=999999999999999983222784.000000
ITER 2: row=24, varin=30, theta=4.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28504710.738327
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 3.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 42 rows, 60 cols, 274 nonzeros, 3 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % Node 33 LP 1 Solution, length = 28504710.738327, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.500000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.500000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.500000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 2 fractional variables
DEBUG CG: LP optimal, z=28504710.738327, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.03  28.46616049035032247616 99.9000000000
 % @LN 0.03  28.50471073832725465991 99.9000000000
DEBUG CG: Second cutoff check: z=28504710.738327, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 33 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 33
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.500000
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.500000
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 2 fractional variables

  %  Carefully choosing branching variable, nfrac = 2
DEBUG CAREFUL: Testing fvar[0] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 5
DEBUG CAREFUL: New best var: 5
DEBUG CAREFUL: Testing fvar[1] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
  % Initial guess is x5, Z0 = 28504710.7383273        , Z1 = 28504710.7383273        

DEBUG EVAL: Testing var 5 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=20, varin=69, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 5 = 0 gives z=28508933.734761
  % 	x5 = 0,	Z0 = 28508933.7347614        
DEBUG EVAL: First branch cutoff check: z=28508933.734761, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 5 = 1
ITER 1: row=20, varin=24, theta=0.205882, up=999999999999999983222784.000000
ITER 2: row=36, varin=39, theta=1.000000, up=999999999999999983222784.000000
  % 	x5 = 1,	Z1 = 28509421.4766545        
DEBUG EVAL: Second branch cutoff check: z=28509421.476655, best_z=INF, threshold=INF
  %   New best:  x5, Z = 28508933.7347614        
DEBUG EVAL: Testing var 7 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=18, varin=69, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 7 = 0 gives z=28508933.734761
  % 	x7 = 0,	Z0 = 28508933.7347614        
DEBUG EVAL: First branch cutoff check: z=28508933.734761, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 7 = 1
ITER 1: row=18, varin=24, theta=0.205882, up=999999999999999983222784.000000
ITER 2: row=36, varin=39, theta=1.000000, up=999999999999999983222784.000000
  % 	x7 = 1,	Z1 = 28509421.4766545        
DEBUG EVAL: Second branch cutoff check: z=28509421.476655, best_z=INF, threshold=INF
  % Best branch is x5, Z0 = 28508933.7347614        , Z1 = 28509421.4766545        

DEBUG CAREFUL: Final result - returning best.var = 5
DEBUG BB: Branching variable chosen: j=5
 % @NC   39   33	x5 = 0	28508933.734761
 % @NC   40   33	x5 = 1	28509421.476655
 %      33    19 28504710.7383               28508933.7348    x0 D    19    10
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e737600
% @LO 0.03  28.50471073832725465991 99.9000000000
% @LN 0.03  28.50893373476142400591 99.9000000000
% Resuming node 39 at  28.50893373476142400591
DEBUG CONSTRNT: LP rows=39, pool->nlprows=39, pool->npend=0
DEBUG CONSTRNT: Checking 39 LP rows (pool tracks 39, total LP rows 39)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 162
DEBUG CONSTRNT: Pool row 162 has lprow=38, expected 38
 % @PAP adding 39 rows, 199 nz to LP
DEBUG BB: Processing node 39, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=20, varin=69, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 28508933.734761
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 3.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 39 rows, 60 cols, 259 nonzeros, 0 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 39 LP 1 Solution, length = 28508933.734761, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.500000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 2 fractional variables
DEBUG CG: LP optimal, z=28508933.734761, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28508933.734761, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 39 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 39
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.500000
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.500000
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 2 fractional variables

  %  Carefully choosing branching variable, nfrac = 2
DEBUG CAREFUL: Testing fvar[0] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 29
DEBUG CAREFUL: New best var: 29
DEBUG CAREFUL: Testing fvar[1] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
  % Initial guess is x29, Z0 = 28508933.7347614        , Z1 = 28517867.4695228        

DEBUG EVAL: Testing var 29 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=31, varin=24, theta=0.205882, up=999999999999999983222784.000000
ITER 2: row=36, varin=39, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 29 = 1 gives z=28517867.469523
  % 	x29 = 1,	Z1 = 28517867.4695228        
DEBUG EVAL: First branch cutoff check: z=28517867.469523, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 29 = 0
ITER 1: row=31, varin=74, theta=0.500000, up=1.000000
  % 	x29 = 0,	Z0 = 28536890.7125805        
DEBUG EVAL: Second branch cutoff check: z=28536890.712581, best_z=INF, threshold=INF
  %   New best:  x29, Z = 28517867.4695228        
DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=37, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=31, varin=20, theta=0.333333, up=999999999999999983222784.000000
ITER 3: row=37, varin=69, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 1 = 0 gives z=28595713.107168
  % 	x1 = 0,	Z0 = 28595713.1071685        
DEBUG EVAL: First branch cutoff check: z=28595713.107168, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 1
ITER 1: row=1, varin=39, theta=1.000000, up=999999999999999983222784.000000
  % 	x1 = 1,	Z1 = 28517867.4695228        
DEBUG EVAL: Second branch cutoff check: z=28517867.469523, best_z=INF, threshold=INF
  %   New best:  x1, Z = 28517867.4695228        
  % Best branch is x1, Z0 = 28595713.1071685        , Z1 = 28517867.4695228        

DEBUG CAREFUL: Final result - returning best.var = 1
DEBUG BB: Branching variable chosen: j=1
 % @NC   41   39	x1 = 1	28517867.469523
 % @NC   42   39	x1 = 0	28595713.107168
 %      39    20 28508933.7348               28509421.4767    x5 D    33    11
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e76d9f0
% @LO 0.03  28.50893373476142400591 99.9000000000
% @LN 0.03  28.50942147665450576710 99.9000000000
% Resuming node 40 at  28.50942147665450576710
DEBUG CONSTRNT: LP rows=39, pool->nlprows=39, pool->npend=0
DEBUG CONSTRNT: Checking 39 LP rows (pool tracks 39, total LP rows 39)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 162
DEBUG CONSTRNT: Pool row 162 has lprow=38, expected 38
 % @PAP adding 39 rows, 199 nz to LP
DEBUG BB: Processing node 40, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=20, varin=24, theta=0.205882, up=999999999999999983222784.000000
ITER 2: row=36, varin=39, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 28509421.476655
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 3.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 39 rows, 60 cols, 259 nonzeros, 1 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 44 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=21, theta=0.031188, up=999999999999999983222784.000000
ITER 2: row=40, varin=41, theta=479027.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28517973.019770
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 3.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 41 rows, 60 cols, 303 nonzeros, 2 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 2 rows, 11 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=18, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=35, theta=2.812500, up=999999999999999983222784.000000
ITER 3: row=23, varin=71, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28717950.777223
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 3.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 41 rows, 60 cols, 272 nonzeros, 3 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 4 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=77, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28773864.732861
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 3.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 42 rows, 60 cols, 234 nonzeros, 0 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 16 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=56, theta=0.466667, up=1.000000
ITER 2: row=34, varin=98, theta=0.153846, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28781570.797957
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.846154
DEBUG SOLUTION: lp->best_solution[8] = 0.846154
DEBUG SOLUTION: lp->best_solution[9] = 2.692308
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 44 rows, 60 cols, 250 nonzeros, 7 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 7 slack rows
  % @PAP adding 4 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=27, theta=0.444444, up=999999999999999983222784.000000
ITER 2: row=38, varin=46, theta=0.357143, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28790186.537396
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 41 rows, 60 cols, 237 nonzeros, 1 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 4 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=25, theta=0.666667, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28791748.252785
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 242 nonzeros, 2 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 40 LP 1 Solution, length = 28791748.252785, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.166667 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.166667 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.166667 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.166667 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.166667 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.833333 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.833333 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.833333 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.833333 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.833333 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28791748.252785, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 40 at  28.79174825278480653878
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e754ad0
% @LO 0.03  28.50942147665450576710 99.9000000000
% @LN 0.03  28.50993065642243706748 99.9000000000
% Resuming node 6 at  28.50993065642243706748
DEBUG CONSTRNT: LP rows=42, pool->nlprows=42, pool->npend=0
DEBUG CONSTRNT: Checking 42 LP rows (pool tracks 42, total LP rows 42)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 73
DEBUG CONSTRNT: Pool row 73 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=41, expected 41
 % @PAP adding 57 rows, 237 nz to LP
DEBUG BB: Processing node 6, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 6 LP 2 Solution, length = 28509930.656422, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.078131 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.078131 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.078131 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.078131 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.109344 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 1.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.078131 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.078131 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.109344 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.078131 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.109344 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.078131 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.078131 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.921869 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.921869 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.921869 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.921869 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.921869 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.921869 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.890656 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.890656 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.921869 (terminal 19)
 % 12 fractional variables
DEBUG CG: LP optimal, z=28509930.656422, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28509930.656422, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 6 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 6
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.078131
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.078131)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.078131
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.078131)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.078131
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.078131)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.078131
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.078131)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.109344
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.109344)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=1.000000
DEBUG CAREFUL: Skipping var 16: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.078131
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.078131)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.078131
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.078131)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.109344
DEBUG CAREFUL: Adding var 21 to fractional list (xi=0.109344)
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.078131
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.078131)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.109344
DEBUG CAREFUL: Adding var 25 to fractional list (xi=0.109344)
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.078131
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.078131)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.078131
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.078131)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 12 fractional variables

  %  Carefully choosing branching variable, nfrac = 12
DEBUG CAREFUL: Testing fvar[0] = var 25
DEBUG CAREFUL: Calling compare_branch_vars for var 25
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 25
DEBUG CAREFUL: New best var: 25
DEBUG CAREFUL: Testing fvar[1] = var 21
DEBUG CAREFUL: Calling compare_branch_vars for var 21
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 21
DEBUG CAREFUL: Testing fvar[2] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
DEBUG CAREFUL: Testing fvar[3] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 11
DEBUG CAREFUL: New best var: 11
DEBUG CAREFUL: Testing fvar[4] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[5] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[6] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 27
DEBUG CAREFUL: Testing fvar[7] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[8] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 18
DEBUG CAREFUL: Testing fvar[9] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 22
DEBUG CAREFUL: Testing fvar[10] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[11] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
  % Initial guess is x11, Z0 = 28509930.6564224        , Z1 = 28830653.858205         

DEBUG EVAL: Testing var 25 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=49, varin=55, theta=1.133004, up=999999999999999983222784.000000
ITER 2: row=43, varin=31, theta=3.505348, up=999999999999999983222784.000000
ITER 3: row=15, varin=10, theta=1.804813, up=999999999999999983222784.000000
ITER 4: row=10, varin=56, theta=1.596088, up=999999999999999983222784.000000
ITER 5: row=56, varin=53, theta=1.585263, up=999999999999999983222784.000000
ITER 6: row=51, varin=54, theta=3.329902, up=999999999999999983222784.000000
ITER 7: row=14, varin=49, theta=1.292363, up=999999999999999983222784.000000
ITER 8: row=40, varin=3, theta=0.834856, up=999999999999999983222784.000000
ITER 9: row=3, varin=42, theta=0.297338, up=999999999999999983222784.000000
ITER 10: row=42, varin=59, theta=0.766924, up=1.000000
DEBUG EVAL: Branch var 25 = 1 gives z=28846527.060172
  % 	x25 = 1,	Z1 = 28846527.0601723        
DEBUG EVAL: First branch cutoff check: z=28846527.060172, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 25 = 0
ITER 1: row=49, varin=9, theta=0.265560, up=999999999999999983222784.000000
ITER 2: row=38, varin=54, theta=0.175024, up=999999999999999983222784.000000
  % 	x25 = 0,	Z0 = 28515895.6941932        
DEBUG EVAL: Second branch cutoff check: z=28515895.694193, best_z=INF, threshold=INF
  %   New best:  x25, Z = 28515895.6941932        
DEBUG EVAL: Testing var 21 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=40, varin=55, theta=1.133004, up=999999999999999983222784.000000
ITER 2: row=43, varin=31, theta=3.505348, up=999999999999999983222784.000000
ITER 3: row=15, varin=10, theta=1.804813, up=999999999999999983222784.000000
ITER 4: row=10, varin=56, theta=1.596088, up=999999999999999983222784.000000
ITER 5: row=56, varin=53, theta=1.585263, up=999999999999999983222784.000000
ITER 6: row=51, varin=51, theta=1.434784, up=999999999999999983222784.000000
ITER 7: row=49, varin=54, theta=1.009064, up=999999999999999983222784.000000
ITER 8: row=14, varin=3, theta=1.072304, up=999999999999999983222784.000000
ITER 9: row=3, varin=42, theta=0.381907, up=999999999999999983222784.000000
ITER 10: row=42, varin=59, theta=0.985050, up=1.000000
DEBUG EVAL: Branch var 21 = 1 gives z=28803728.696455
  % 	x21 = 1,	Z1 = 28803728.6964551        
DEBUG EVAL: First branch cutoff check: z=28803728.696455, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 21 = 0
ITER 1: row=40, varin=9, theta=0.265560, up=999999999999999983222784.000000
ITER 2: row=38, varin=54, theta=0.175024, up=999999999999999983222784.000000
  % 	x21 = 0,	Z0 = 28515895.6941932        
DEBUG EVAL: Second branch cutoff check: z=28515895.694193, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 12 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=21, varin=9, theta=0.265560, up=999999999999999983222784.000000
ITER 2: row=38, varin=54, theta=0.175024, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 12 = 0 gives z=28515895.694193
  % 	x12 = 0,	Z0 = 28515895.6941932        
DEBUG EVAL: First branch cutoff check: z=28515895.694193, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 1
ITER 1: row=21, varin=55, theta=1.133004, up=999999999999999983222784.000000
ITER 2: row=43, varin=31, theta=3.505348, up=999999999999999983222784.000000
ITER 3: row=15, varin=10, theta=1.804813, up=999999999999999983222784.000000
ITER 4: row=10, varin=56, theta=1.596088, up=999999999999999983222784.000000
ITER 5: row=56, varin=53, theta=1.585263, up=999999999999999983222784.000000
ITER 6: row=51, varin=51, theta=1.434784, up=999999999999999983222784.000000
ITER 7: row=49, varin=54, theta=1.009064, up=999999999999999983222784.000000
ITER 8: row=14, varin=49, theta=0.375516, up=999999999999999983222784.000000
  % 	x12 = 1,	Z1 = 28721801.9559227        
DEBUG EVAL: Second branch cutoff check: z=28721801.955923, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 11 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=14, varin=41, theta=3.518916, up=999999999999999983222784.000000
ITER 2: row=33, varin=46, theta=6.540872, up=999999999999999983222784.000000
ITER 3: row=2, varin=32, theta=2.285952, up=999999999999999983222784.000000
ITER 4: row=7, varin=40, theta=1.615009, up=999999999999999983222784.000000
ITER 5: row=52, varin=31, theta=2.054171, up=999999999999999983222784.000000
ITER 6: row=31, varin=39, theta=10.898157, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 11 = 1 gives z=31538089.800158
  % 	x11 = 1,	Z1 = 31538089.8001582        
DEBUG EVAL: First branch cutoff check: z=31538089.800158, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 11 = 0
ITER 1: row=14, varin=55, theta=0.170883, up=999999999999999983222784.000000
  % 	x11 = 0,	Z0 = 28514085.0585053        
DEBUG EVAL: Second branch cutoff check: z=28514085.058505, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 17 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=24, varin=55, theta=0.170883, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 0 gives z=28514085.058505
  % 	x17 = 0,	Z0 = 28514085.0585052        
DEBUG EVAL: First branch cutoff check: z=28514085.058505, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 3 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=8, varin=55, theta=0.170883, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 0 gives z=28514085.058505
  % 	x3 = 0,	Z0 = 28514085.0585052        
DEBUG EVAL: First branch cutoff check: z=28514085.058505, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 27 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=51, varin=54, theta=1.475116, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 27 = 1 gives z=28560204.303477
  % 	x27 = 1,	Z1 = 28722651.6252773        
DEBUG EVAL: First branch cutoff check: z=28722651.625277, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 27 = 0
ITER 1: row=51, varin=55, theta=0.170883, up=999999999999999983222784.000000
  % 	x27 = 0,	Z0 = 28514085.0585052        
DEBUG EVAL: Second branch cutoff check: z=28514085.058505, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=54, theta=0.208320, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28517030.458829
  % 	x10 = 0,	Z0 = 28517030.4588287        
DEBUG EVAL: First branch cutoff check: z=28517030.458829, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 1
ITER 1: row=7, varin=31, theta=1.085595, up=999999999999999983222784.000000
  % 	x10 = 1,	Z1 = 28540537.2560457        
DEBUG EVAL: Second branch cutoff check: z=28540537.256046, best_z=INF, threshold=INF
  %   New best:  x10, Z = 28517030.4588287        
DEBUG EVAL: Testing var 18 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=31, varin=54, theta=0.208320, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 18 = 0 gives z=28517030.458829
  % 	x18 = 0,	Z0 = 28517030.4588287        
DEBUG EVAL: First branch cutoff check: z=28517030.458829, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 18 = 1
ITER 1: row=31, varin=55, theta=1.698421, up=999999999999999983222784.000000
  % 	x18 = 1,	Z1 = 28551221.5894293        
DEBUG EVAL: Second branch cutoff check: z=28551221.589429, best_z=INF, threshold=INF
  %   New best:  x18, Z = 28517030.4588287        
DEBUG EVAL: Testing var 22 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=42, varin=54, theta=1.475116, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 22 = 1 gives z=28560204.303477
  % 	x22 = 1,	Z1 = 28587421.495686         
DEBUG EVAL: First branch cutoff check: z=28587421.495686, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 22 = 0
ITER 1: row=42, varin=55, theta=0.170883, up=999999999999999983222784.000000
  % 	x22 = 0,	Z0 = 28514085.0585052        
DEBUG EVAL: Second branch cutoff check: z=28514085.058505, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 26 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=37, varin=54, theta=0.208320, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 0 gives z=28517030.458829
  % 	x26 = 0,	Z0 = 28517030.4588287        
DEBUG EVAL: First branch cutoff check: z=28517030.458829, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 1
ITER 1: row=37, varin=9, theta=0.465038, up=999999999999999983222784.000000
  % 	x26 = 1,	Z1 = 28513665.6211974        
DEBUG EVAL: Second branch cutoff check: z=28513665.621197, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=55, theta=0.170883, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28514085.058505
  % 	x2 = 0,	Z0 = 28514085.0585052        
DEBUG EVAL: First branch cutoff check: z=28514085.058505, best_z=INF, threshold=INF
  % Best branch is x18, Z0 = 28517030.4588287        , Z1 = 28551221.5894293        

DEBUG CAREFUL: Final result - returning best.var = 18
DEBUG BB: Branching variable chosen: j=18
 % @NC   43    6	x18 = 0	28517030.458829
 % @NC   44    6	x18 = 1	28551221.589429
 %       6    21 28509930.6564               28511458.9076   x16 U     3     3
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e74b550
% @LO 0.03  28.50993065642243706748 99.9000000000
% @LN 0.03  28.51145890762787971084 99.9000000000
% Resuming node 37 at  28.51145890762787971084
DEBUG CONSTRNT: LP rows=57, pool->nlprows=57, pool->npend=0
DEBUG CONSTRNT: Checking 57 LP rows (pool tracks 57, total LP rows 57)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 137
DEBUG CONSTRNT: Pool row 137 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=56, expected 56
 % @PAP adding 52 rows, 224 nz to LP
DEBUG BB: Processing node 37, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 37 LP 2 Solution, length = 28511458.907628, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.160268 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.160268 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.358928 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.160268 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.160268 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.358928 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.160268 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.358928 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.839732 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.839732 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.641072 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.839732 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.641072 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.839732 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.641072 (terminal 19)
 % 8 fractional variables
DEBUG CG: LP optimal, z=28511458.907628, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28511458.907628, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 37 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 37
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.160268
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.160268)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.160268
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.160268)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.358928
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.358928)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.160268
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.160268)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.160268
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.160268)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.358928
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.358928)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.160268
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.160268)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.358928
DEBUG CAREFUL: Adding var 37 to fractional list (xi=0.358928)
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 8 fractional variables

  %  Carefully choosing branching variable, nfrac = 8
DEBUG CAREFUL: Testing fvar[0] = var 37
DEBUG CAREFUL: Calling compare_branch_vars for var 37
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 37
DEBUG CAREFUL: New best var: 37
DEBUG CAREFUL: Testing fvar[1] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 26
DEBUG CAREFUL: New best var: 26
DEBUG CAREFUL: Testing fvar[2] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[3] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 27
DEBUG CAREFUL: New best var: 27
DEBUG CAREFUL: Testing fvar[4] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 11
DEBUG CAREFUL: Testing fvar[5] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 4
DEBUG CAREFUL: Testing fvar[6] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[7] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 22
  % Initial guess is x27, Z0 = 28511458.9076279        , Z1 = 28622711.3537852        

DEBUG EVAL: Testing var 37 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=46, varin=48, theta=0.560993, up=999999999999999983222784.000000
ITER 2: row=40, varin=42, theta=1.942659, up=999999999999999983222784.000000
ITER 3: row=42, varin=41, theta=128148.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 37 = 0 gives z=28549852.925989
  % 	x37 = 0,	Z0 = 28549852.9259887        
DEBUG EVAL: First branch cutoff check: z=28549852.925989, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 37 = 1
ITER 1: row=46, varin=84, theta=0.925780, up=1.000000
ITER 2: row=4, varin=42, theta=1.262684, up=999999999999999983222784.000000
ITER 3: row=42, varin=37, theta=0.282976, up=999999999999999983222784.000000
ITER 4: row=37, varin=49, theta=0.639506, up=999999999999999983222784.000000
ITER 5: row=39, varin=4, theta=0.727225, up=999999999999999983222784.000000
ITER 6: row=1, varin=29, theta=0.785997, up=999999999999999983222784.000000
ITER 7: row=47, varin=39, theta=0.749836, up=999999999999999983222784.000000
ITER 8: row=10, varin=35, theta=2.585460, up=999999999999999983222784.000000
ITER 9: row=35, varin=33, theta=3.495945, up=999999999999999983222784.000000
ITER 10: row=33, varin=21, theta=1.826855, up=999999999999999983222784.000000
  % 	x37 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: Second branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=48, theta=0.560993, up=999999999999999983222784.000000
ITER 2: row=40, varin=42, theta=1.942659, up=999999999999999983222784.000000
ITER 3: row=42, varin=41, theta=128148.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28549852.925989
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
   % @PL 52 rows, 60 cols, 284 nonzeros, 1 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 3 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=54, varin=45, theta=0.071429, up=999999999999999983222784.000000
ITER 2: row=52, varin=54, theta=1.250000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 28562258.240345
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
   % @PL 54 rows, 60 cols, 258 nonzeros, 3 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 3 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 37 at  28.56225824034515881067
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e737600
% @LO 0.03  28.51145890762787971084 99.9000000000
% @LN 0.03  28.51703045882866405236 99.9000000000
% Resuming node 43 at  28.51703045882866405236
DEBUG CONSTRNT: LP rows=51, pool->nlprows=51, pool->npend=0
DEBUG CONSTRNT: Checking 51 LP rows (pool tracks 51, total LP rows 51)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=50, expected 50
 % @PAP adding 57 rows, 237 nz to LP
DEBUG BB: Processing node 43, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=31, varin=54, theta=0.208320, up=999999999999999983222784.000000
ITER 2: row=21, varin=62, theta=0.108833, up=1.000000
LP PHASE: Switching to primal (iter=2)
ITER 3: row=8, varin=70, theta=0.062767, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 28514295.487622
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1000000.000000
  % @PL 57 rows, 60 cols, 297 nonzeros, 0 slack, 57 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 33 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=58, varin=67, theta=0.141095, up=1.000000
ITER 2: row=63, varin=58, theta=0.795802, up=999999999999999983222784.000000
ITER 3: row=1, varin=32, theta=0.024249, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=63)
DEBUG SOLUTION: LP solution array indices: FST[64-103], not_covered[104-123]
DEBUG SOLUTION: lp->best_solution[0] = 28535404.969572
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1000000.000000
  % @PL 63 rows, 60 cols, 330 nonzeros, 12 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 12 slack rows
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=54, theta=0.289404, up=1.000000
ITER 2: row=43, varin=57, theta=0.296018, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28547223.003206
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1000000.000000
  % @PL 52 rows, 60 cols, 295 nonzeros, 0 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 5 rows, 23 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=53, varin=88, theta=0.473049, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 28551862.342586
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1000000.000000
  % @PL 57 rows, 60 cols, 318 nonzeros, 0 slack, 57 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=58, varin=41, theta=0.073732, up=999999999999999983222784.000000
ITER 2: row=59, varin=58, theta=0.107126, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=59)
DEBUG SOLUTION: LP solution array indices: FST[60-99], not_covered[100-119]
DEBUG SOLUTION: lp->best_solution[0] = 28557783.530629
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1000000.000000
  % @PL 59 rows, 60 cols, 322 nonzeros, 3 slack, 56 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=57, varin=30, theta=0.190895, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=58)
DEBUG SOLUTION: LP solution array indices: FST[59-98], not_covered[99-118]
DEBUG SOLUTION: lp->best_solution[0] = 28567615.421558
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1000000.000000
  % @PL 58 rows, 60 cols, 317 nonzeros, 3 slack, 55 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=56, varin=91, theta=0.216433, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 28573658.269549
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1000000.000000
  % @PL 57 rows, 60 cols, 302 nonzeros, 0 slack, 57 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 43 LP 1 Solution, length = 28573658.269549, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.216433 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.216433 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.067134 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 1.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.067134 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.216433 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.216433 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.067134 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.216433 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.216433 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.216433 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.783567 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.783567 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.783567 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.783567 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.783567 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.932866 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.932866 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 10 fractional variables
DEBUG CG: LP optimal, z=28573658.269549, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 43 at  28.57365826954885434930
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e74a1c0
% @LO 0.04  28.51703045882866405236 99.9000000000
% @LN 0.04  28.51786746952284801182 99.9000000000
% Resuming node 41 at  28.51786746952284801182
DEBUG CONSTRNT: LP rows=57, pool->nlprows=57, pool->npend=0
DEBUG CONSTRNT: Checking 57 LP rows (pool tracks 57, total LP rows 57)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 137
DEBUG CONSTRNT: Pool row 137 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=56, expected 56
 % @PAP adding 39 rows, 199 nz to LP
DEBUG BB: Processing node 41, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=39, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 28517867.469523
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 3.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 39 rows, 60 cols, 259 nonzeros, 1 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=75, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28573781.425161
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 3.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 40 rows, 60 cols, 261 nonzeros, 1 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 4 rows, 27 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=80, theta=1.000000, up=1.000000
ITER 2: row=43, varin=55, theta=0.466667, up=1.000000
ITER 3: row=36, varin=97, theta=0.153846, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28581487.490257
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.846154
DEBUG SOLUTION: lp->best_solution[8] = 0.846154
DEBUG SOLUTION: lp->best_solution[9] = 2.692308
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 43 rows, 60 cols, 248 nonzeros, 7 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 7 slack rows
  % @PAP adding 4 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=29, theta=0.444444, up=999999999999999983222784.000000
ITER 2: row=37, varin=45, theta=0.357143, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28590103.229696
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 235 nonzeros, 1 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 4 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=27, theta=0.666667, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28591664.945085
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 240 nonzeros, 2 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 41 LP 1 Solution, length = 28591664.945085, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 1.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.166667 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.166667 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.166667 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.166667 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.166667 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.833333 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.833333 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.833333 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.833333 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.833333 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28591664.945085, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 41 at  28.59166494508454192669
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e76a3a0
% @LO 0.04  28.51786746952284801182 99.9000000000
% @LN 0.04  28.52143955728715596365 99.9000000000
% Resuming node 34 at  28.52143955728715596365
DEBUG CONSTRNT: LP rows=41, pool->nlprows=41, pool->npend=0
DEBUG CONSTRNT: Checking 41 LP rows (pool tracks 41, total LP rows 41)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 143
DEBUG CONSTRNT: Pool row 143 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 73
DEBUG CONSTRNT: Pool row 73 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 85
DEBUG CONSTRNT: Pool row 85 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=40, expected 40
 % @PAP adding 35 rows, 152 nz to LP
DEBUG BB: Processing node 34, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=21, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=21, varin=22, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=33, varin=32, theta=0.473684, up=999999999999999983222784.000000
ITER 4: row=22, varin=19, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=35)
DEBUG SOLUTION: LP solution array indices: FST[36-75], not_covered[76-95]
DEBUG SOLUTION: lp->best_solution[0] = 28521439.557287
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 3.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 35 rows, 60 cols, 212 nonzeros, 3 slack, 32 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 15 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=3, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=38, varin=4, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=35, varin=45, theta=0.526316, up=1.000000
ITER 4: row=22, varin=35, theta=13.333333, up=999999999999999983222784.000000
ITER 5: row=32, varin=57, theta=1.000000, up=1.000000
ITER 6: row=21, varin=42, theta=0.500000, up=1.000000
ITER 7: row=6, varin=43, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=7)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 28678261.878683
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 3.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 39 rows, 60 cols, 227 nonzeros, 4 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 6 rows, 31 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=85, theta=0.500000, up=1.000000
ITER 2: row=39, varin=48, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28697802.106700
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 3.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 41 rows, 60 cols, 243 nonzeros, 3 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 4 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=20, theta=0.125000, up=999999999999999983222784.000000
ITER 2: row=22, varin=72, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28729968.857856
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 3.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 237 nonzeros, 0 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=79, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28785882.813494
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 3.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 242 nonzeros, 0 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 27 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=85, theta=1.000000, up=1.000000
ITER 2: row=48, varin=29, theta=1.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28787499.440140
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 3.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 269 nonzeros, 4 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 4 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=44, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=48, varin=60, theta=0.155556, up=1.000000
ITER 3: row=37, varin=102, theta=0.051282, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28791610.546292
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 0.948718
DEBUG SOLUTION: lp->best_solution[6] = 0.948718
DEBUG SOLUTION: lp->best_solution[7] = 2.897436
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 254 nonzeros, 9 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 9 slack rows
  % @PAP adding 5 rows, 48 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=39, theta=0.084026, up=999999999999999983222784.000000
ITER 2: row=41, varin=30, theta=0.172022, up=999999999999999983222784.000000
ITER 3: row=40, varin=71, theta=0.228521, up=1.000000
ITER 4: row=44, varin=49, theta=0.087721, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28795139.390723
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 266 nonzeros, 1 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 8 rows, 30 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=38, theta=0.097937, up=999999999999999983222784.000000
ITER 2: row=44, varin=14, theta=0.069398, up=999999999999999983222784.000000
ITER 3: row=27, varin=28, theta=0.315154, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
ITER 4: row=14, varin=27, theta=0.000000, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28796835.411447
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 288 nonzeros, 5 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % Node 34 LP 1 Solution, length = 28796835.411447, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 1.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.078789 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.078789 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.078789 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.263634 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.263634 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.078789 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.078789 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.263634 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.263634 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.736366 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.921211 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.921211 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.736366 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.736366 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.736366 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.921211 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.921211 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.921211 (terminal 19)
 % 9 fractional variables
DEBUG CG: LP optimal, z=28796835.411447, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 34 at  28.79683541144738967432
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e743b80
% @LO 0.04  28.52143955728715596365 99.9000000000
% @LN 0.04  28.52669130127494057092 99.9000000000
% Resuming node 35 at  28.52669130127494057092
DEBUG CONSTRNT: LP rows=46, pool->nlprows=46, pool->npend=0
DEBUG CONSTRNT: Checking 46 LP rows (pool tracks 46, total LP rows 46)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=45, expected 45
 % @PAP adding 45 rows, 163 nz to LP
DEBUG BB: Processing node 35, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=3, varin=43, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=75, theta=1.000000, up=1.000000
ITER 3: row=35, varin=80, theta=1.000000, up=1.000000
ITER 4: row=39, varin=82, theta=1.000000, up=1.000000
ITER 5: row=41, varin=48, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28526691.301275
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 223 nonzeros, 3 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=59, theta=0.500000, up=1.000000
ITER 2: row=47, varin=30, theta=0.066667, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28530463.048635
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 235 nonzeros, 6 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 3 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=18, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28530548.524063
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 227 nonzeros, 2 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 2 rows, 44 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=49, theta=0.138391, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28533940.891326
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 267 nonzeros, 2 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 3 rows, 11 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=39, theta=0.431202, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28534253.273611
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 266 nonzeros, 2 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 35 LP 1 Solution, length = 28534253.273611, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.086240 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.086240 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.284399 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.284399 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 1.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.086240 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.086240 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.284399 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.284399 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.715601 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.913760 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.913760 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.715601 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.715601 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.715601 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.913760 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.913760 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 8 fractional variables
DEBUG CG: LP optimal, z=28534253.273611, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 35 at  28.53425327361081542676
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e74a340
% @LO 0.05  28.52669130127494057092 99.9000000000
% @LN 0.05  28.52817857209840823884 99.9000000000
% Resuming node 14 at  28.52817857209840823884
DEBUG CONSTRNT: LP rows=43, pool->nlprows=43, pool->npend=0
DEBUG CONSTRNT: Checking 43 LP rows (pool tracks 43, total LP rows 43)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 158
DEBUG CONSTRNT: Pool row 158 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=42, expected 42
 % @PAP adding 48 rows, 219 nz to LP
DEBUG BB: Processing node 14, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 14 LP 2 Solution, length = 28528178.572098, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.226871 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.226871 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.226871 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.226871 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.092516 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.773129 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.773129 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.773129 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.773129 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.773129 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.773129 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28528178.572098, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28528178.572098, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 14 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 14
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.226871
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.226871)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=1.000000
DEBUG CAREFUL: Skipping var 8: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.226871
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.226871)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.226871
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.226871)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.226871
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.226871)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.092516
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.092516)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 26
DEBUG CAREFUL: New best var: 26
DEBUG CAREFUL: Testing fvar[1] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[2] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 18
DEBUG CAREFUL: Testing fvar[3] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[4] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x26, Z0 = 28528178.5720984        , Z1 = 28647729.6537993        

DEBUG EVAL: Testing var 26 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=27, varin=46, theta=1.151000, up=999999999999999983222784.000000
ITER 2: row=38, varin=41, theta=0.640420, up=999999999999999983222784.000000
ITER 3: row=39, varin=43, theta=0.574834, up=999999999999999983222784.000000
ITER 4: row=3, varin=33, theta=0.978797, up=999999999999999983222784.000000
ITER 5: row=26, varin=7, theta=0.267542, up=999999999999999983222784.000000
ITER 6: row=7, varin=31, theta=0.530362, up=999999999999999983222784.000000
ITER 7: row=30, varin=40, theta=0.336934, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 1 gives z=28647729.653799
  % 	x26 = 1,	Z1 = 28647729.6537993        
DEBUG EVAL: First branch cutoff check: z=28647729.653799, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 0
ITER 1: row=27, varin=4, theta=0.196789, up=999999999999999983222784.000000
ITER 2: row=1, varin=102, theta=0.141204, up=1.000000
  % 	x26 = 0,	Z0 = 28537142.7861763        
DEBUG EVAL: Second branch cutoff check: z=28537142.786176, best_z=INF, threshold=INF
  %   New best:  x26, Z = 28537142.7861763        
DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=4, theta=1.251966, up=999999999999999983222784.000000
ITER 2: row=1, varin=24, theta=0.904074, up=999999999999999983222784.000000
ITER 3: row=44, varin=46, theta=32.886309, up=999999999999999983222784.000000
ITER 4: row=38, varin=33, theta=3.586760, up=999999999999999983222784.000000
ITER 5: row=25, varin=27, theta=0.947868, up=999999999999999983222784.000000
ITER 6: row=45, varin=17, theta=1.471979, up=999999999999999983222784.000000
ITER 7: row=11, varin=35, theta=0.988004, up=999999999999999983222784.000000
ITER 8: row=27, varin=78, theta=1.501351, up=1.000000
ITER 9: row=27, varin=71, theta=0.293774, up=1.000000
ITER 10: row=47, varin=78, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 3 = 1 gives z=29469766.051392
  % 	x3 = 1,	Z1 = 29469766.0513923        
DEBUG EVAL: First branch cutoff check: z=29469766.051392, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=3, varin=43, theta=0.253580, up=999999999999999983222784.000000
  % 	x3 = 0,	Z0 = 28568060.9995177        
DEBUG EVAL: Second branch cutoff check: z=28568060.999518, best_z=INF, threshold=INF
  %   New best:  x3, Z = 28568060.9995177        
DEBUG EVAL: Testing var 18 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=24, varin=40, theta=0.364891, up=999999999999999983222784.000000
ITER 2: row=44, varin=38, theta=1.358614, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 18 = 0 gives z=28598114.974649
  % 	x18 = 0,	Z0 = 28598114.9746493        
DEBUG EVAL: First branch cutoff check: z=28598114.974649, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 18 = 1
ITER 1: row=24, varin=4, theta=1.251966, up=999999999999999983222784.000000
ITER 2: row=1, varin=33, theta=3.586760, up=999999999999999983222784.000000
ITER 3: row=25, varin=46, theta=32.886309, up=999999999999999983222784.000000
ITER 4: row=38, varin=6, theta=1.327855, up=999999999999999983222784.000000
ITER 5: row=39, varin=35, theta=1.424524, up=999999999999999983222784.000000
ITER 6: row=27, varin=78, theta=2.567476, up=1.000000
ITER 7: row=27, varin=71, theta=0.941451, up=1.000000
ITER 8: row=42, varin=41, theta=2.086427, up=999999999999999983222784.000000
ITER 9: row=27, varin=70, theta=2.477237, up=1.000000
ITER 10: row=27, varin=17, theta=2.693902, up=999999999999999983222784.000000
  % 	x18 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: Second branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=24, varin=40, theta=0.364891, up=999999999999999983222784.000000
ITER 2: row=44, varin=38, theta=1.358614, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28598114.974649
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
   % @PL 48 rows, 60 cols, 279 nonzeros, 1 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 6 rows, 22 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=53, varin=42, theta=0.115959, up=999999999999999983222784.000000
ITER 2: row=48, varin=90, theta=0.462133, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28621127.554663
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 3.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
   % @PL 53 rows, 60 cols, 295 nonzeros, 6 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 6 slack rows
   % @PAP adding 4 rows, 20 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=105, theta=0.460990, up=1.000000
ITER 2: row=51, varin=27, theta=0.055556, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28624858.013069
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.586994
DEBUG SOLUTION: lp->best_solution[9] = 0.586994
DEBUG SOLUTION: lp->best_solution[10] = 2.173988
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
   % @PL 51 rows, 60 cols, 295 nonzeros, 5 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 5 slack rows
   % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=61, theta=0.214012, up=1.000000
ITER 2: row=47, varin=43, theta=0.103765, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 28634843.288746
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 49 rows, 60 cols, 289 nonzeros, 2 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
   % @PAP adding 4 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=56, theta=0.187867, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28641847.380827
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 51 rows, 60 cols, 298 nonzeros, 1 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 4 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=53, varin=79, theta=0.714793, up=1.000000
ITER 2: row=10, varin=44, theta=0.379840, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 28652649.689367
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 54 rows, 60 cols, 303 nonzeros, 2 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 14 at  28.65264968936688561030
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e75e250
% @LO 0.05  28.52817857209840823884 99.9000000000
% @LN 0.05  28.52884610141171251030 99.9000000000
% Resuming node 16 at  28.52884610141171251030
DEBUG CONSTRNT: LP rows=52, pool->nlprows=52, pool->npend=0
DEBUG CONSTRNT: Checking 52 LP rows (pool tracks 52, total LP rows 52)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 62
DEBUG CONSTRNT: Pool row 62 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=51, expected 51
 % @PAP adding 44 rows, 215 nz to LP
DEBUG BB: Processing node 16, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=27, varin=26, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=29, varin=22, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=30, varin=23, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=1, varin=86, theta=4.755485, up=1.000000
ITER 5: row=1, varin=39, theta=0.459466, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28528846.101412
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 3.000000
  % @PL 44 rows, 60 cols, 275 nonzeros, 7 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 28 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=92, theta=1.000000, up=1.000000
ITER 2: row=49, varin=40, theta=0.561116, up=999999999999999983222784.000000
ITER 3: row=38, varin=34, theta=2.290816, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28557369.584754
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 0.541837
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 3.000000
  % @PL 50 rows, 60 cols, 303 nonzeros, 8 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 8 slack rows
  % @PAP adding 3 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=48, theta=0.066441, up=1.000000
ITER 2: row=10, varin=49, theta=0.071377, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28564606.830455
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 3.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 272 nonzeros, 0 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 16 LP 1 Solution, length = 28564606.830455, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.071377 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.428623 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.428623 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.428623 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.571377 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.571377 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.571377 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.571377 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.571377 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.571377 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28564606.830455, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 16 at  28.56460683045548876180
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e747c80
% @LO 0.05  28.52884610141171251030 99.9000000000
% @LN 0.05  28.52979551285218207113 99.9000000000
% Resuming node 21 at  28.52979551285218207113
DEBUG CONSTRNT: LP rows=45, pool->nlprows=45, pool->npend=0
DEBUG CONSTRNT: Checking 45 LP rows (pool tracks 45, total LP rows 45)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=44, expected 44
 % @PAP adding 50 rows, 235 nz to LP
DEBUG BB: Processing node 21, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 21 LP 3 Solution, length = 28529795.512852, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.268165 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.268165 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.268165 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.268165 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.195505 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.731835 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.731835 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.731835 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.731835 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.731835 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28529795.512852, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28529795.512852, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 21 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 21
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.268165
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.268165)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.268165
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.268165)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=1.000000
DEBUG CAREFUL: Skipping var 13: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.268165
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.268165)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.268165
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.268165)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.195505
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.195505)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 2
DEBUG CAREFUL: New best var: 2
DEBUG CAREFUL: Testing fvar[1] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[2] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 11
DEBUG CAREFUL: Testing fvar[3] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 27
DEBUG CAREFUL: Testing fvar[4] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 22
  % Initial guess is x2, Z0 = 28529795.5128522        , Z1 = 28817470.3630606        

DEBUG EVAL: Testing var 2 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=49, theta=8.914053, up=999999999999999983222784.000000
ITER 2: row=9, varin=48, theta=6.073664, up=999999999999999983222784.000000
ITER 3: row=48, varin=44, theta=4.416069, up=999999999999999983222784.000000
ITER 4: row=44, varin=34, theta=0.907999, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 1 gives z=28851822.382917
  % 	x2 = 1,	Z1 = 28851822.3829172        
DEBUG EVAL: First branch cutoff check: z=28851822.382917, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 0
ITER 1: row=1, varin=63, theta=215.883212, up=1.000000
ITER 2: row=1, varin=48, theta=-6.952172, up=999999999999999983222784.000000
ITER 3: row=1, varin=33, theta=0.304425, up=999999999999999983222784.000000
ITER 4: row=34, varin=63, theta=0.922292, up=1.000000
ITER 5: row=43, varin=78, theta=0.388317, up=1.000000
  % 	x2 = 0,	Z0 = 28613843.9314093        
DEBUG EVAL: Second branch cutoff check: z=28613843.931409, best_z=INF, threshold=INF
  %   New best:  x2, Z = 28613843.9314093        
DEBUG EVAL: Testing var 17 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=12, varin=63, theta=215.883212, up=1.000000
ITER 2: row=12, varin=48, theta=-6.952172, up=999999999999999983222784.000000
ITER 3: row=9, varin=3, theta=0.427158, up=999999999999999983222784.000000
ITER 4: row=34, varin=63, theta=0.988814, up=1.000000
ITER 5: row=50, varin=107, theta=0.709189, up=1.000000
ITER 6: row=21, varin=12, theta=54592.750000, up=999999999999999983222784.000000
ITER 7: row=18, varin=21, theta=0.171482, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 0 gives z=28591628.373514
  % 	x17 = 0,	Z0 = 28591628.3735141        
DEBUG EVAL: First branch cutoff check: z=28591628.373514, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 11 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=49, theta=8.914053, up=999999999999999983222784.000000
ITER 2: row=9, varin=48, theta=6.073664, up=999999999999999983222784.000000
ITER 3: row=48, varin=44, theta=4.416069, up=999999999999999983222784.000000
ITER 4: row=44, varin=38, theta=10.721432, up=999999999999999983222784.000000
ITER 5: row=38, varin=37, theta=4.212103, up=999999999999999983222784.000000
ITER 6: row=23, varin=25, theta=1.796686, up=999999999999999983222784.000000
ITER 7: row=36, varin=26, theta=2.989385, up=999999999999999983222784.000000
ITER 8: row=6, varin=33, theta=5.940738, up=999999999999999983222784.000000
ITER 9: row=1, varin=9, theta=5.151814, up=999999999999999983222784.000000
ITER 10: row=8, varin=28, theta=1.808748, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 11 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x11 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=6, varin=63, theta=215.883212, up=1.000000
ITER 2: row=6, varin=48, theta=-6.952172, up=999999999999999983222784.000000
ITER 3: row=6, varin=35, theta=0.558242, up=999999999999999983222784.000000
ITER 4: row=34, varin=63, theta=0.912122, up=1.000000
ITER 5: row=43, varin=78, theta=0.439160, up=1.000000
LP PHASE: Switching to primal (iter=5)
ITER 6: row=1, varin=43, theta=0.000000, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28613952.860710
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 50 rows, 60 cols, 295 nonzeros, 2 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
   % @PAP adding 5 rows, 22 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=3, theta=0.457240, up=999999999999999983222784.000000
ITER 2: row=48, varin=66, theta=215.883212, up=1.000000
ITER 3: row=48, varin=46, theta=0.235262, up=999999999999999983222784.000000
ITER 4: row=22, varin=66, theta=1.036396, up=1.000000
ITER 5: row=22, varin=12, theta=54592.750000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28655359.088797
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.600000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 945407.250000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 53 rows, 60 cols, 313 nonzeros, 5 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 5 slack rows
   % @PAP adding 4 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=80, theta=1.000000, up=1.000000
ITER 2: row=47, varin=65, theta=0.200000, up=1.000000
ITER 3: row=38, varin=81, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28666807.055054
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 52 rows, 60 cols, 268 nonzeros, 0 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 1 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=53, varin=19, theta=1.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28692969.884100
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 0.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 53 rows, 60 cols, 273 nonzeros, 2 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 21 at  28.69296988409958615307
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e743b80
% @LO 0.05  28.52979551285218207113 99.9000000000
% @LN 0.05  28.53425327361081542676 99.9000000000
% Resuming node 35 at  28.53425327361081542676
DEBUG CONSTRNT: LP rows=51, pool->nlprows=51, pool->npend=0
DEBUG CONSTRNT: Checking 51 LP rows (pool tracks 51, total LP rows 51)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=50, expected 50
 % @PAP adding 43 rows, 189 nz to LP
DEBUG BB: Processing node 35, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 35 LP 2 Solution, length = 28534253.273611, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.086240 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.086240 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.284399 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.284399 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 1.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.086240 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.086240 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.284399 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.284399 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.715601 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.913760 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.913760 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.715601 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.715601 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.715601 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.913760 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.913760 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 8 fractional variables
DEBUG CG: LP optimal, z=28534253.273611, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28534253.273611, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 35 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 35
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.086240
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.086240)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.086240
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.086240)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.284399
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.284399)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.284399
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.284399)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=1.000000
DEBUG CAREFUL: Skipping var 10: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.086240
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.086240)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.086240
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.086240)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.284399
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.284399)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.284399
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.284399)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 8 fractional variables

  %  Carefully choosing branching variable, nfrac = 8
DEBUG CAREFUL: Testing fvar[0] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 5
DEBUG CAREFUL: New best var: 5
DEBUG CAREFUL: Testing fvar[1] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 36
DEBUG CAREFUL: New best var: 36
DEBUG CAREFUL: Testing fvar[2] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 7
DEBUG CAREFUL: New best var: 7
DEBUG CAREFUL: Testing fvar[3] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 34
DEBUG CAREFUL: Testing fvar[4] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 4
DEBUG CAREFUL: Testing fvar[5] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[6] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 11
DEBUG CAREFUL: Testing fvar[7] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
  % Initial guess is x7, Z0 = 28534253.2736108        , Z1 = 29241494.7208808        

DEBUG EVAL: Testing var 5 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=19, varin=70, theta=1.258100, up=1.000000
ITER 2: row=19, varin=20, theta=0.318649, up=999999999999999983222784.000000
ITER 3: row=33, varin=70, theta=1.000000, up=1.000000
ITER 4: row=37, varin=36, theta=4.103452, up=999999999999999983222784.000000
ITER 5: row=25, varin=68, theta=2.364525, up=1.000000
ITER 6: row=25, varin=74, theta=0.718500, up=1.000000
ITER 7: row=10, varin=68, theta=1.000000, up=1.000000
ITER 8: row=25, varin=66, theta=0.173708, up=1.000000
ITER 9: row=22, varin=74, theta=0.596618, up=1.000000
DEBUG EVAL: Branch var 5 = 1 gives z=28735408.948615
  % 	x5 = 1,	Z1 = 28735408.9486153        
DEBUG EVAL: First branch cutoff check: z=28735408.948615, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 5 = 0
ITER 1: row=19, varin=42, theta=0.769690, up=999999999999999983222784.000000
ITER 2: row=7, varin=41, theta=101740.666667, up=999999999999999983222784.000000
  % 	x5 = 0,	Z0 = 28537926.704108         
DEBUG EVAL: Second branch cutoff check: z=28537926.704108, best_z=INF, threshold=INF
  %   New best:  x5, Z = 28537926.704108         
DEBUG EVAL: Testing var 36 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=36, varin=70, theta=1.258100, up=1.000000
ITER 2: row=36, varin=20, theta=0.318649, up=999999999999999983222784.000000
ITER 3: row=33, varin=70, theta=1.000000, up=1.000000
ITER 4: row=37, varin=68, theta=3.126426, up=1.000000
ITER 5: row=37, varin=74, theta=1.119685, up=1.000000
ITER 6: row=37, varin=66, theta=0.084838, up=1.000000
ITER 7: row=22, varin=74, theta=8.877895, up=1.000000
ITER 8: row=22, varin=68, theta=18.095804, up=1.000000
ITER 9: row=22, varin=42, theta=1.550623, up=999999999999999983222784.000000
ITER 10: row=7, varin=18, theta=0.625116, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 36 = 1 gives z=29198904.538360
  % 	x36 = 1,	Z1 = 29198904.5383602        
DEBUG EVAL: First branch cutoff check: z=29198904.538360, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 36 = 0
ITER 1: row=36, varin=42, theta=0.769690, up=999999999999999983222784.000000
ITER 2: row=7, varin=36, theta=0.138617, up=999999999999999983222784.000000
  % 	x36 = 0,	Z0 = 28537553.0943941        
DEBUG EVAL: Second branch cutoff check: z=28537553.094394, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 7 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=17, varin=70, theta=1.258100, up=1.000000
ITER 2: row=17, varin=68, theta=0.641388, up=1.000000
ITER 3: row=33, varin=70, theta=1.000000, up=1.000000
ITER 4: row=17, varin=74, theta=1.119685, up=1.000000
ITER 5: row=17, varin=66, theta=0.084838, up=1.000000
ITER 6: row=22, varin=74, theta=8.877895, up=1.000000
ITER 7: row=22, varin=68, theta=18.095804, up=1.000000
ITER 8: row=22, varin=42, theta=1.550623, up=999999999999999983222784.000000
ITER 9: row=7, varin=18, theta=0.625116, up=999999999999999983222784.000000
ITER 10: row=43, varin=39, theta=1.624925, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 7 = 1 gives z=29242232.945863
  % 	x7 = 1,	Z1 = 29242232.9458627        
DEBUG EVAL: First branch cutoff check: z=29242232.945863, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 7 = 0
ITER 1: row=17, varin=42, theta=0.769690, up=999999999999999983222784.000000
ITER 2: row=7, varin=41, theta=101740.666667, up=999999999999999983222784.000000
  % 	x7 = 0,	Z0 = 28537926.704108         
DEBUG EVAL: Second branch cutoff check: z=28537926.704108, best_z=INF, threshold=INF
  %   New best:  x7, Z = 28537926.704108         
DEBUG EVAL: Testing var 34 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=34, varin=42, theta=0.769690, up=999999999999999983222784.000000
ITER 2: row=7, varin=34, theta=0.134395, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 34 = 0 gives z=28537571.953029
  % 	x34 = 0,	Z0 = 28537571.9530293        
DEBUG EVAL: First branch cutoff check: z=28537571.953029, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 4 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=39, theta=1.621655, up=999999999999999983222784.000000
ITER 2: row=39, varin=41, theta=552590.000000, up=999999999999999983222784.000000
ITER 3: row=17, varin=38, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=39, varin=70, theta=2.522423, up=1.000000
ITER 5: row=39, varin=36, theta=123.299448, up=999999999999999983222784.000000
ITER 6: row=36, varin=18, theta=0.642626, up=999999999999999983222784.000000
ITER 7: row=1, varin=34, theta=1.292660, up=999999999999999983222784.000000
ITER 8: row=34, varin=70, theta=0.954480, up=1.000000
ITER 9: row=43, varin=19, theta=1.408665, up=999999999999999983222784.000000
ITER 10: row=19, varin=22, theta=1.210161, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 4 = 1 gives z=29525260.009855
  % 	x4 = 1,	Z1 = 29525260.009855         
DEBUG EVAL: First branch cutoff check: z=29525260.009855, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 4 = 0
ITER 1: row=7, varin=70, theta=0.201723, up=1.000000
  % 	x4 = 0,	Z0 = 28534395.9376683        
DEBUG EVAL: Second branch cutoff check: z=28534395.937668, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=18, varin=42, theta=1.668056, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 1 gives z=28538771.538145
  % 	x17 = 1,	Z1 = 28556585.8427904        
DEBUG EVAL: First branch cutoff check: z=28556585.842790, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 0
ITER 1: row=18, varin=70, theta=0.201723, up=1.000000
  % 	x17 = 0,	Z0 = 28534395.9376683        
DEBUG EVAL: Second branch cutoff check: z=28534395.937668, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 11 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=39, varin=42, theta=1.668056, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 11 = 1 gives z=28538771.538145
  % 	x11 = 1,	Z1 = 28741938.6705998        
DEBUG EVAL: First branch cutoff check: z=28741938.670600, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 11 = 0
ITER 1: row=39, varin=70, theta=0.201723, up=1.000000
  % 	x11 = 0,	Z0 = 28534395.9376683        
DEBUG EVAL: Second branch cutoff check: z=28534395.937668, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=70, theta=0.201723, up=1.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28534395.937668
  % 	x2 = 0,	Z0 = 28534395.9376683        
DEBUG EVAL: First branch cutoff check: z=28534395.937668, best_z=INF, threshold=INF
  % Best branch is x7, Z0 = 28537926.704108         , Z1 = 29242232.9458627        

DEBUG CAREFUL: Final result - returning best.var = 7
DEBUG BB: Branching variable chosen: j=7
 % @NC   45   35	x7 = 0	28537926.704108
 % @NC   46   35	x7 = 1	29242232.945863
 %      35    22 28534253.2736               28537926.7041    x3 D    31    11
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e754ad0
% @LO 0.05  28.53425327361081542676 99.9000000000
% @LN 0.05  28.53792670410803111736 99.9000000000
% Resuming node 45 at  28.53792670410803111736
DEBUG CONSTRNT: LP rows=43, pool->nlprows=43, pool->npend=0
DEBUG CONSTRNT: Checking 43 LP rows (pool tracks 43, total LP rows 43)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 158
DEBUG CONSTRNT: Pool row 158 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=42, expected 42
 % @PAP adding 43 rows, 189 nz to LP
DEBUG BB: Processing node 45, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=17, varin=42, theta=0.769690, up=999999999999999983222784.000000
ITER 2: row=7, varin=41, theta=101740.666667, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28537926.704108
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 249 nonzeros, 3 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % Node 45 LP 1 Solution, length = 28537926.704108, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.333333 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 1.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.333333 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.333333 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.666667 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.666667 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.666667 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.666667 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28537926.704108, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.05  28.53792670410803111736 99.9000000000
 % @LN 0.05  28.53792670410803467007 99.9000000000
DEBUG CG: Second cutoff check: z=28537926.704108, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 45 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 45
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.333333
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=1.000000
DEBUG CAREFUL: Skipping var 10: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.333333
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.333333
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 3 fractional variables

  %  Carefully choosing branching variable, nfrac = 3
DEBUG CAREFUL: Testing fvar[0] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
DEBUG CAREFUL: Testing fvar[1] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 11
DEBUG CAREFUL: New best var: 11
DEBUG CAREFUL: Testing fvar[2] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
  % Initial guess is x11, Z0 = 28537926.704108         , Z1 = 28741938.6705998        

DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=18, varin=39, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 1 gives z=28556585.842790
  % 	x17 = 1,	Z1 = 28556585.8427904        
DEBUG EVAL: First branch cutoff check: z=28556585.842790, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 0
ITER 1: row=18, varin=45, theta=0.500000, up=1.000000
  % 	x17 = 0,	Z0 = 28540960.475406         
DEBUG EVAL: Second branch cutoff check: z=28540960.475406, best_z=INF, threshold=INF
  %   New best:  x17, Z = 28540960.475406         
DEBUG EVAL: Testing var 11 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=38, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=36, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=36, varin=34, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=34, varin=30, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=30, varin=42, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 11 = 1 gives z=28635060.278797
  % 	x11 = 1,	Z1 = 28741938.6705998        
DEBUG EVAL: First branch cutoff check: z=28741938.670600, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 11 = 0
ITER 1: row=7, varin=45, theta=0.500000, up=1.000000
  % 	x11 = 0,	Z0 = 28540960.475406         
DEBUG EVAL: Second branch cutoff check: z=28540960.475406, best_z=INF, threshold=INF
  %   New best:  x11, Z = 28540960.475406         
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=45, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28540960.475406
  % 	x2 = 0,	Z0 = 28540960.475406         
DEBUG EVAL: First branch cutoff check: z=28540960.475406, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 1
ITER 1: row=1, varin=39, theta=1.000000, up=999999999999999983222784.000000
  % 	x2 = 1,	Z1 = 28556585.8427904        
DEBUG EVAL: Second branch cutoff check: z=28556585.842790, best_z=INF, threshold=INF
  % Best branch is x11, Z0 = 28540960.475406         , Z1 = 28741938.6705998        

DEBUG CAREFUL: Final result - returning best.var = 11
DEBUG BB: Branching variable chosen: j=11
 % @NC   47   45	x11 = 0	28540960.475406
 % @NC   48   45	x11 = 1	28741938.670600
 %      45    23 28537926.7041               28540960.4754    x7 D    35    12
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e743b80
% @LO 0.05  28.53792670410803467007 99.9000000000
% @LN 0.05  28.54096047540600977754 99.9000000000
% Resuming node 47 at  28.54096047540600977754
DEBUG CONSTRNT: LP rows=40, pool->nlprows=40, pool->npend=0
DEBUG CONSTRNT: Checking 40 LP rows (pool tracks 40, total LP rows 40)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 158
DEBUG CONSTRNT: Pool row 158 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=39, expected 39
 % @PAP adding 40 rows, 145 nz to LP
DEBUG BB: Processing node 47, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=7, varin=45, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28540960.475406
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 205 nonzeros, 0 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 21 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=20, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=37, varin=39, theta=0.333333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28546168.931201
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 226 nonzeros, 4 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % Node 47 LP 1 Solution, length = 28546168.931201, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.333333 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.333333 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 1.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.333333 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.666667 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.666667 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.666667 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.666667 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28546168.931201, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.05  28.54096047540600977754 99.9000000000
 % @LN 0.05  28.54616893120079623714 99.9000000000
DEBUG CG: Second cutoff check: z=28546168.931201, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 47 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 47
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.333333
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.333333
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=1.000000
DEBUG CAREFUL: Skipping var 10: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.333333
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 3 fractional variables

  %  Carefully choosing branching variable, nfrac = 3
DEBUG CAREFUL: Testing fvar[0] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 4
DEBUG CAREFUL: New best var: 4
DEBUG CAREFUL: Testing fvar[1] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[2] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
  % Initial guess is x4, Z0 = 28546168.9312008        , Z1 = 29525260.009855         

DEBUG EVAL: Testing var 4 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=37, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=19, varin=38, theta=2.000000, up=999999999999999983222784.000000
ITER 3: row=1, varin=36, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=37, varin=34, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=34, varin=30, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=30, varin=42, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 4 = 1 gives z=28659786.960076
  % 	x4 = 1,	Z1 = 29525260.009855         
DEBUG EVAL: First branch cutoff check: z=29525260.009855, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 4 = 0
ITER 1: row=7, varin=67, theta=1.000000, up=1.000000
ITER 2: row=33, varin=39, theta=1.000000, up=999999999999999983222784.000000
  % 	x4 = 0,	Z0 = 28556585.8427904        
DEBUG EVAL: Second branch cutoff check: z=28556585.842790, best_z=INF, threshold=INF
  %   New best:  x4, Z = 28556585.8427904        
DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=18, varin=37, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=19, varin=39, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 1 gives z=28556585.842790
  % 	x17 = 1,	Z1 = 28556585.8427904        
DEBUG EVAL: First branch cutoff check: z=28556585.842790, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 0
ITER 1: row=18, varin=67, theta=1.000000, up=1.000000
ITER 2: row=33, varin=89, theta=1.000000, up=1.000000
  % 	x17 = 0,	Z0 = 28604493.4261764        
DEBUG EVAL: Second branch cutoff check: z=28604493.426176, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 2 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=37, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=19, varin=39, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 1 gives z=28556585.842790
  % 	x2 = 1,	Z1 = 28556585.8427904        
DEBUG EVAL: First branch cutoff check: z=28556585.842790, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 0
ITER 1: row=1, varin=67, theta=1.000000, up=1.000000
ITER 2: row=33, varin=38, theta=0.500000, up=999999999999999983222784.000000
  % 	x2 = 0,	Z0 = 28555907.7461637        
DEBUG EVAL: Second branch cutoff check: z=28555907.746164, best_z=INF, threshold=INF
  % Best branch is x4, Z0 = 28556585.8427904        , Z1 = 29525260.009855         

DEBUG CAREFUL: Final result - returning best.var = 4
DEBUG BB: Branching variable chosen: j=4
 % @NC   49   47	x4 = 0	28556585.842790
 % @NC   50   47	x4 = 1	29525260.009855
 %      47    24 28546168.9312               28551221.5894   x11 D    45    13
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e7725c0
% @LO 0.05  28.54616893120079623714 99.9000000000
% @LN 0.05  28.55122158942934262882 99.9000000000
% Resuming node 44 at  28.55122158942934262882
DEBUG CONSTRNT: LP rows=40, pool->nlprows=40, pool->npend=0
DEBUG CONSTRNT: Checking 40 LP rows (pool tracks 40, total LP rows 40)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 158
DEBUG CONSTRNT: Pool row 158 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=39, expected 39
 % @PAP adding 57 rows, 237 nz to LP
DEBUG BB: Processing node 44, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=31, varin=55, theta=1.698421, up=999999999999999983222784.000000
ITER 2: row=43, varin=54, theta=5.496259, up=999999999999999983222784.000000
ITER 3: row=14, varin=46, theta=5.350813, up=999999999999999983222784.000000
ITER 4: row=2, varin=35, theta=2.757142, up=999999999999999983222784.000000
ITER 5: row=44, varin=39, theta=15.848184, up=999999999999999983222784.000000
ITER 6: row=1, varin=41, theta=4.403728, up=999999999999999983222784.000000
ITER 7: row=33, varin=65, theta=4.336548, up=1.000000
ITER 8: row=33, varin=23, theta=3.596244, up=999999999999999983222784.000000
ITER 9: row=23, varin=25, theta=5.639576, up=999999999999999983222784.000000
ITER 10: row=25, varin=40, theta=3.725275, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 57 rows, 60 cols, 297 nonzeros, 10 slack, 47 tight.
  % Node 44 LP 1 Solution, length = 999999999999999983222784.000000, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.078131 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.078131 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.078131 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.078131 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.109344 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 1.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.078131 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.078131 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.109344 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.078131 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.109344 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.078131 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.078131 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.829117 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.829117 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.756325 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.756325 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.829117 (terminal 19)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 44 is INFEASIBLE
 %      44    23    infeasible               28554388.8678   x18 U     6     4
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e767ee0
% @LO 0.05  28.55122158942934262882 99.9000000000
% @LN 0.05  28.55438886779973728380 99.9000000000
% Resuming node 26 at  28.55438886779973728380
DEBUG CONSTRNT: LP rows=57, pool->nlprows=57, pool->npend=0
DEBUG CONSTRNT: Checking 57 LP rows (pool tracks 57, total LP rows 57)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 137
DEBUG CONSTRNT: Pool row 137 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=56, expected 56
 % @PAP adding 37 rows, 146 nz to LP
DEBUG BB: Processing node 26, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=6, varin=22, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=67, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 28554388.867800
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 3.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 37 rows, 60 cols, 206 nonzeros, 1 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=76, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28610302.823438
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 3.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 41 rows, 60 cols, 219 nonzeros, 1 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 2 rows, 46 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=30, theta=0.188697, up=999999999999999983222784.000000
ITER 2: row=41, varin=79, theta=0.775157, up=1.000000
ITER 3: row=42, varin=9, theta=1.109955, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28612707.148456
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.445023
DEBUG SOLUTION: lp->best_solution[8] = 0.445023
DEBUG SOLUTION: lp->best_solution[9] = 1.890045
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 42 rows, 60 cols, 263 nonzeros, 3 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 2 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=53, theta=0.229312, up=1.000000
ITER 2: row=41, varin=39, theta=142395.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28614606.423318
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 41 rows, 60 cols, 267 nonzeros, 1 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 26 LP 1 Solution, length = 28614606.423318, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.500000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.500000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.500000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28614606.423318, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 26 at  28.61460642331820025674
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e754ad0
% @LO 0.05  28.55438886779973728380 99.9000000000
% @LN 0.05  28.55658584279036560361 99.9000000000
% Resuming node 49 at  28.55658584279036560361
DEBUG CONSTRNT: LP rows=40, pool->nlprows=40, pool->npend=0
DEBUG CONSTRNT: Checking 40 LP rows (pool tracks 40, total LP rows 40)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=39, expected 39
 % @PAP adding 40 rows, 145 nz to LP
DEBUG BB: Processing node 49, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=7, varin=67, theta=1.000000, up=1.000000
ITER 2: row=33, varin=39, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28556585.842790
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 205 nonzeros, 2 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 40 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=90, theta=0.522713, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28581627.756403
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 41 rows, 60 cols, 245 nonzeros, 4 slack, 37 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 4 rows, 29 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=38, varin=66, theta=0.799029, up=1.000000
ITER 2: row=10, varin=72, theta=0.407120, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28606930.399217
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 41 rows, 60 cols, 262 nonzeros, 0 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 15 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=79, theta=0.447545, up=1.000000
ITER 2: row=45, varin=47, theta=0.173692, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28622434.207959
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 277 nonzeros, 3 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 3 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=68, theta=0.354878, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28622591.301887
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 276 nonzeros, 0 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 49 LP 1 Solution, length = 28622591.301887, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.645122 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 1.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.645122 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.354878 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.354878 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.354878 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.354878 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.354878 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28622591.301887, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 49 at  28.62259130188724398636
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e74b490
% @LO 0.05  28.55658584279036560361 99.9000000000
% @LN 0.05  28.56011586489561082658 99.9000000000
% Resuming node 29 at  28.56011586489561082658
DEBUG CONSTRNT: LP rows=45, pool->nlprows=45, pool->npend=0
DEBUG CONSTRNT: Checking 45 LP rows (pool tracks 45, total LP rows 45)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 158
DEBUG CONSTRNT: Pool row 158 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 60
DEBUG CONSTRNT: Pool row 60 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 73
DEBUG CONSTRNT: Pool row 73 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=44, expected 44
 % @PAP adding 47 rows, 206 nz to LP
DEBUG BB: Processing node 29, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 29 LP 2 Solution, length = 28560115.864896, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.473969 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.473969 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.075147 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.075147 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.075147 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.075147 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.075147 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 1.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.075147 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.075147 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.473969 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.526031 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.924853 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.526031 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.526031 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.924853 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.526031 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.924853 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.924853 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.924853 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.924853 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.924853 (terminal 19)
 % 10 fractional variables
DEBUG CG: LP optimal, z=28560115.864896, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28560115.864896, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 3 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 29 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 29
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.473969
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.473969)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.473969
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.473969)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.075147
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.075147)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.075147
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.075147)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.075147
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.075147)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.075147
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.075147)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.075147
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.075147)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=1.000000
DEBUG CAREFUL: Skipping var 14: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.075147
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.075147)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.075147
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.075147)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.473969
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.473969)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 10 fractional variables

  %  Carefully choosing branching variable, nfrac = 10
DEBUG CAREFUL: Testing fvar[0] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 1
DEBUG CAREFUL: New best var: 1
DEBUG CAREFUL: Testing fvar[1] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
DEBUG CAREFUL: Testing fvar[2] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 29
DEBUG CAREFUL: Testing fvar[3] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 10
DEBUG CAREFUL: New best var: 10
DEBUG CAREFUL: Testing fvar[4] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 4
DEBUG CAREFUL: New best var: 4
DEBUG CAREFUL: Testing fvar[5] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[6] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 11
DEBUG CAREFUL: Testing fvar[7] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[8] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[9] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
  % Initial guess is x4, Z0 = 28560115.8648956        , Z1 = 28870364.0019233        

DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=9, theta=0.551194, up=999999999999999983222784.000000
ITER 2: row=9, varin=46, theta=0.666057, up=999999999999999983222784.000000
ITER 3: row=3, varin=44, theta=0.346390, up=999999999999999983222784.000000
ITER 4: row=12, varin=42, theta=0.010870, up=999999999999999983222784.000000
ITER 5: row=29, varin=40, theta=0.007481, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 0 gives z=28608326.934872
  % 	x1 = 0,	Z0 = 28608326.9348722        
DEBUG EVAL: First branch cutoff check: z=28608326.934872, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 1
ITER 1: row=2, varin=70, theta=0.454272, up=1.000000
ITER 2: row=3, varin=42, theta=0.339595, up=999999999999999983222784.000000
ITER 3: row=29, varin=9, theta=1.764792, up=999999999999999983222784.000000
ITER 4: row=9, varin=44, theta=0.320140, up=999999999999999983222784.000000
ITER 5: row=12, varin=30, theta=0.092572, up=999999999999999983222784.000000
ITER 6: row=9, varin=40, theta=0.335480, up=999999999999999983222784.000000
ITER 7: row=30, varin=22, theta=0.168046, up=999999999999999983222784.000000
ITER 8: row=9, varin=28, theta=0.209184, up=999999999999999983222784.000000
ITER 9: row=23, varin=13, theta=0.423316, up=999999999999999983222784.000000
ITER 10: row=7, varin=35, theta=0.944823, up=999999999999999983222784.000000
  % 	x1 = 1,	Z1 = 28679398.6334293        
DEBUG EVAL: Second branch cutoff check: z=28679398.633429, best_z=INF, threshold=INF
  %   New best:  x1, Z = 28608326.9348722        
DEBUG EVAL: Testing var 0 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=9, theta=0.551194, up=999999999999999983222784.000000
ITER 2: row=9, varin=46, theta=0.666057, up=999999999999999983222784.000000
ITER 3: row=3, varin=44, theta=0.346390, up=999999999999999983222784.000000
ITER 4: row=12, varin=42, theta=0.010870, up=999999999999999983222784.000000
ITER 5: row=29, varin=40, theta=0.007481, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 0 = 0 gives z=28608326.934872
  % 	x0 = 0,	Z0 = 28608326.9348722        
DEBUG EVAL: First branch cutoff check: z=28608326.934872, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 0 = 1
ITER 1: row=1, varin=70, theta=0.454272, up=1.000000
ITER 2: row=3, varin=42, theta=0.339595, up=999999999999999983222784.000000
ITER 3: row=29, varin=9, theta=1.764792, up=999999999999999983222784.000000
ITER 4: row=9, varin=44, theta=0.320140, up=999999999999999983222784.000000
ITER 5: row=12, varin=30, theta=0.092572, up=999999999999999983222784.000000
ITER 6: row=9, varin=40, theta=0.335480, up=999999999999999983222784.000000
ITER 7: row=30, varin=22, theta=0.168046, up=999999999999999983222784.000000
ITER 8: row=9, varin=28, theta=0.209184, up=999999999999999983222784.000000
ITER 9: row=23, varin=13, theta=0.423316, up=999999999999999983222784.000000
ITER 10: row=7, varin=35, theta=0.944823, up=999999999999999983222784.000000
  % 	x0 = 1,	Z1 = 29096472.1865304        
DEBUG EVAL: Second branch cutoff check: z=29096472.186530, best_z=INF, threshold=INF
  %   New best:  x0, Z = 28608326.9348722        
DEBUG EVAL: Testing var 29 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=32, varin=9, theta=0.551194, up=999999999999999983222784.000000
ITER 2: row=9, varin=46, theta=0.666057, up=999999999999999983222784.000000
ITER 3: row=3, varin=44, theta=0.346390, up=999999999999999983222784.000000
ITER 4: row=12, varin=42, theta=0.010870, up=999999999999999983222784.000000
ITER 5: row=29, varin=32, theta=0.006234, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 29 = 0 gives z=28608272.156549
  % 	x29 = 0,	Z0 = 28608272.1565491        
DEBUG EVAL: First branch cutoff check: z=28608272.156549, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=9, theta=3.480826, up=999999999999999983222784.000000
ITER 2: row=9, varin=42, theta=3.161716, up=999999999999999983222784.000000
ITER 3: row=29, varin=46, theta=2.387506, up=999999999999999983222784.000000
ITER 4: row=3, varin=44, theta=1.407649, up=999999999999999983222784.000000
ITER 5: row=1, varin=70, theta=1.927103, up=1.000000
ITER 6: row=1, varin=72, theta=2.909963, up=1.000000
ITER 7: row=1, varin=31, theta=0.504494, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28866662.565709
  % 	x10 = 1,	Z1 = 28866662.5657095        
DEBUG EVAL: First branch cutoff check: z=28866662.565709, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=7, varin=70, theta=0.243763, up=1.000000
  % 	x10 = 0,	Z0 = 28561672.4943031        
DEBUG EVAL: Second branch cutoff check: z=28561672.494303, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 4 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=12, varin=9, theta=3.480826, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 4 = 1 gives z=28580033.905336
  % 	x4 = 1,	Z1 = 28870364.0019233        
DEBUG EVAL: First branch cutoff check: z=28870364.001923, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 4 = 0
ITER 1: row=12, varin=70, theta=0.243763, up=1.000000
  % 	x4 = 0,	Z0 = 28561672.4943031        
DEBUG EVAL: Second branch cutoff check: z=28561672.494303, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 3 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=70, theta=0.243763, up=1.000000
DEBUG EVAL: Branch var 3 = 0 gives z=28561672.494303
  % 	x3 = 0,	Z0 = 28561672.4943031        
DEBUG EVAL: First branch cutoff check: z=28561672.494303, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 11 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=30, varin=9, theta=3.480826, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 11 = 1 gives z=28580033.905336
  % 	x11 = 1,	Z1 = 28834463.0413748        
DEBUG EVAL: First branch cutoff check: z=28834463.041375, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 11 = 0
ITER 1: row=30, varin=70, theta=0.243763, up=1.000000
  % 	x11 = 0,	Z0 = 28561672.4943031        
DEBUG EVAL: Second branch cutoff check: z=28561672.494303, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 26 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=36, varin=9, theta=3.480826, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 1 gives z=28580033.905336
  % 	x26 = 1,	Z1 = 28580033.9053359        
DEBUG EVAL: First branch cutoff check: z=28580033.905336, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 17 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=22, varin=70, theta=0.243763, up=1.000000
DEBUG EVAL: Branch var 17 = 0 gives z=28561672.494303
  % 	x17 = 0,	Z0 = 28561672.4943031        
DEBUG EVAL: First branch cutoff check: z=28561672.494303, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=70, theta=0.243763, up=1.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28561672.494303
  % 	x2 = 0,	Z0 = 28561672.4943031        
DEBUG EVAL: First branch cutoff check: z=28561672.494303, best_z=INF, threshold=INF
  % Best branch is x0, Z0 = 28608326.9348722        , Z1 = 29096472.1865304        

DEBUG CAREFUL: Final result - returning best.var = 0
DEBUG BB: Branching variable chosen: j=0
 % @NC   51   29	x0 = 0	28608326.934872
 % @NC   52   29	x0 = 1	29096472.186530
 %      29    24 28560115.8649               28561058.6834    x7 D     8     5
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e74ccf0
% @LO 0.05  28.56011586489561082658 99.9000000000
% @LN 0.05  28.56105868341181519554 99.9000000000
% Resuming node 10 at  28.56105868341181519554
DEBUG CONSTRNT: LP rows=47, pool->nlprows=47, pool->npend=0
DEBUG CONSTRNT: Checking 47 LP rows (pool tracks 47, total LP rows 47)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 150
DEBUG CONSTRNT: Pool row 150 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=46, expected 46
 % @PAP adding 53 rows, 226 nz to LP
DEBUG BB: Processing node 10, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 10 LP 5 Solution, length = 28561058.683412, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.333333 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.333333 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.028833 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.028833 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.028833 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.028833 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.028833 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.028833 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.333333 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.333333 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.131500 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.666667 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.971167 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.666667 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.666667 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.971167 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.666667 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.971167 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.971167 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.971167 (terminal 19)
 % 11 fractional variables
DEBUG CG: LP optimal, z=28561058.683412, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28561058.683412, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 3 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 10 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 10
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.333333
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.333333
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.028833
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.028833)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.028833
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.028833)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.028833
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.028833)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=1.000000
DEBUG CAREFUL: Skipping var 9: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.028833
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.028833)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.028833
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.028833)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.028833
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.028833)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.333333
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.333333
DEBUG CAREFUL: Adding var 30 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.131500
DEBUG CAREFUL: Adding var 33 to fractional list (xi=0.131500)
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 11 fractional variables

  %  Carefully choosing branching variable, nfrac = 11
DEBUG CAREFUL: Testing fvar[0] = var 30
DEBUG CAREFUL: Calling compare_branch_vars for var 30
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 30
DEBUG CAREFUL: New best var: 30
DEBUG CAREFUL: Testing fvar[1] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[2] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 29
DEBUG CAREFUL: Testing fvar[3] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
DEBUG CAREFUL: Testing fvar[4] = var 33
DEBUG CAREFUL: Calling compare_branch_vars for var 33
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 33
DEBUG CAREFUL: New best var: 33
DEBUG CAREFUL: Testing fvar[5] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[6] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[7] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 4
DEBUG CAREFUL: New best var: 4
DEBUG CAREFUL: Testing fvar[8] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[9] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 11
DEBUG CAREFUL: Testing fvar[10] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 22
  % Initial guess is x4, Z0 = 28561058.6834118        , Z1 = 28878309.3137798        

DEBUG EVAL: Testing var 30 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=45, varin=26, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=1, varin=3, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=53, varin=4, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=36, varin=35, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=49, varin=75, theta=1.093354, up=1.000000
ITER 6: row=49, varin=77, theta=0.129016, up=1.000000
ITER 7: row=42, varin=79, theta=0.102338, up=1.000000
ITER 8: row=3, varin=22, theta=0.028707, up=999999999999999983222784.000000
ITER 9: row=22, varin=87, theta=0.193143, up=1.000000
DEBUG EVAL: Branch var 30 = 1 gives z=29689546.354121
  % 	x30 = 1,	Z1 = 29689546.3541206        
DEBUG EVAL: First branch cutoff check: z=29689546.354121, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 30 = 0
ITER 1: row=45, varin=51, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=49, varin=52, theta=0.104896, up=999999999999999983222784.000000
  % 	x30 = 0,	Z0 = 28569530.155181         
DEBUG EVAL: Second branch cutoff check: z=28569530.155181, best_z=INF, threshold=INF
  %   New best:  x30, Z = 28569530.155181         
DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=51, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=49, varin=49, theta=0.125980, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 0 gives z=28574731.706747
  % 	x1 = 0,	Z0 = 28574731.7067474        
DEBUG EVAL: First branch cutoff check: z=28574731.706747, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 1
ITER 1: row=2, varin=52, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=49, varin=75, theta=1.266498, up=1.000000
ITER 3: row=49, varin=77, theta=0.368303, up=1.000000
ITER 4: row=45, varin=26, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=9, varin=75, theta=0.444871, up=1.000000
ITER 6: row=3, varin=87, theta=0.971988, up=1.000000
  % 	x1 = 1,	Z1 = 28854786.3172909        
DEBUG EVAL: Second branch cutoff check: z=28854786.317291, best_z=INF, threshold=INF
  %   New best:  x1, Z = 28574731.7067474        
DEBUG EVAL: Testing var 29 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=35, varin=51, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=49, varin=49, theta=0.125980, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 29 = 0 gives z=28574731.706747
  % 	x29 = 0,	Z0 = 28574731.7067474        
DEBUG EVAL: First branch cutoff check: z=28574731.706747, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 29 = 1
ITER 1: row=35, varin=52, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=49, varin=75, theta=1.266498, up=1.000000
ITER 3: row=49, varin=77, theta=0.368303, up=1.000000
ITER 4: row=45, varin=4, theta=0.500000, up=999999999999999983222784.000000
ITER 5: row=9, varin=75, theta=0.805980, up=1.000000
ITER 6: row=36, varin=26, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=24, varin=87, theta=0.971988, up=1.000000
  % 	x29 = 1,	Z1 = 28854786.3172908        
DEBUG EVAL: Second branch cutoff check: z=28854786.317291, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 0 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=51, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=49, varin=49, theta=0.125980, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 0 = 0 gives z=28574731.706747
  % 	x0 = 0,	Z0 = 28574731.7067474        
DEBUG EVAL: First branch cutoff check: z=28574731.706747, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 0 = 1
ITER 1: row=1, varin=52, theta=2.000000, up=999999999999999983222784.000000
ITER 2: row=49, varin=75, theta=1.266498, up=1.000000
ITER 3: row=49, varin=77, theta=0.368303, up=1.000000
ITER 4: row=45, varin=3, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=27, varin=4, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=36, varin=35, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=42, varin=79, theta=0.882166, up=1.000000
ITER 8: row=24, varin=22, theta=0.247460, up=999999999999999983222784.000000
ITER 9: row=31, varin=87, theta=1.664922, up=1.000000
ITER 10: row=31, varin=30, theta=0.051626, up=999999999999999983222784.000000
  % 	x0 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: Second branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=51, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=49, varin=49, theta=0.125980, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28574731.706748
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 53 rows, 60 cols, 286 nonzeros, 3 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 3 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 10 at  28.57473170674750662101
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e74b550
% @LO 0.05  28.56105868341181519554 99.9000000000
% @LN 0.05  28.56225824034515881067 99.9000000000
% Resuming node 37 at  28.56225824034515881067
DEBUG CONSTRNT: LP rows=50, pool->nlprows=50, pool->npend=0
DEBUG CONSTRNT: Checking 50 LP rows (pool tracks 50, total LP rows 50)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=49, expected 49
 % @PAP adding 51 rows, 184 nz to LP
DEBUG BB: Processing node 37, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 37 LP 3 Solution, length = 28562258.240345, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.250000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.250000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.250000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.250000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.250000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.250000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.250000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.750000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.750000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.750000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.750000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.750000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.750000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.750000 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=28562258.240345, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28562258.240345, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 37 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 37
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.250000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.250000
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.250000
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.250000
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.250000
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.250000
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.250000
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 7 fractional variables

  %  Carefully choosing branching variable, nfrac = 7
DEBUG CAREFUL: Testing fvar[0] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 27
DEBUG CAREFUL: New best var: 27
DEBUG CAREFUL: Testing fvar[1] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 11
DEBUG CAREFUL: Testing fvar[2] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 4
DEBUG CAREFUL: Testing fvar[3] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[4] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 22
DEBUG CAREFUL: Testing fvar[5] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[6] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
  % Initial guess is x27, Z0 = 28562258.2403452        , Z1 = 28622711.3537852        

DEBUG EVAL: Testing var 27 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=46, varin=19, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=19, varin=40, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=45, varin=32, theta=6.000000, up=999999999999999983222784.000000
ITER 4: row=31, varin=12, theta=2.500000, up=999999999999999983222784.000000
ITER 5: row=12, varin=24, theta=2.500000, up=999999999999999983222784.000000
ITER 6: row=24, varin=46, theta=1.666667, up=999999999999999983222784.000000
ITER 7: row=51, varin=37, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 27 = 1 gives z=28804707.559040
  % 	x27 = 1,	Z1 = 28804707.5590403        
DEBUG EVAL: First branch cutoff check: z=28804707.559040, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 27 = 0
ITER 1: row=46, varin=85, theta=1.500000, up=1.000000
ITER 2: row=46, varin=47, theta=0.111111, up=999999999999999983222784.000000
ITER 3: row=41, varin=85, theta=1.000000, up=1.000000
  % 	x27 = 0,	Z0 = 28567032.8197644        
DEBUG EVAL: Second branch cutoff check: z=28567032.819764, best_z=INF, threshold=INF
  %   New best:  x27, Z = 28567032.8197644        
DEBUG EVAL: Testing var 11 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=37, varin=85, theta=1.500000, up=1.000000
ITER 2: row=37, varin=84, theta=0.333333, up=1.000000
ITER 3: row=41, varin=85, theta=1.000000, up=1.000000
ITER 4: row=48, varin=49, theta=2.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 11 = 0 gives z=28611137.032772
  % 	x11 = 0,	Z0 = 28611137.0327721        
DEBUG EVAL: First branch cutoff check: z=28611137.032772, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 11 = 1
ITER 1: row=37, varin=19, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=19, varin=47, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=46, varin=40, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=45, varin=32, theta=4.000000, up=999999999999999983222784.000000
ITER 5: row=31, varin=12, theta=1.500000, up=999999999999999983222784.000000
ITER 6: row=12, varin=24, theta=1.500000, up=999999999999999983222784.000000
ITER 7: row=24, varin=46, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=51, varin=50, theta=0.750000, up=999999999999999983222784.000000
ITER 9: row=11, varin=78, theta=1.000000, up=1.000000
  % 	x11 = 1,	Z1 = 28777952.0010265        
DEBUG EVAL: Second branch cutoff check: z=28777952.001026, best_z=INF, threshold=INF
  %   New best:  x11, Z = 28611137.0327721        
DEBUG EVAL: Testing var 4 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=10, varin=19, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=19, varin=47, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=46, varin=32, theta=4.000000, up=999999999999999983222784.000000
ITER 4: row=31, varin=12, theta=1.500000, up=999999999999999983222784.000000
ITER 5: row=12, varin=24, theta=1.500000, up=999999999999999983222784.000000
ITER 6: row=24, varin=37, theta=0.750000, up=999999999999999983222784.000000
ITER 7: row=11, varin=78, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 4 = 1 gives z=28802678.682305
  % 	x4 = 1,	Z1 = 28802678.6823048        
DEBUG EVAL: First branch cutoff check: z=28802678.682305, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 4 = 0
ITER 1: row=10, varin=85, theta=1.500000, up=1.000000
ITER 2: row=10, varin=40, theta=0.111111, up=999999999999999983222784.000000
ITER 3: row=41, varin=85, theta=1.000000, up=1.000000
ITER 4: row=45, varin=84, theta=1.000000, up=1.000000
ITER 5: row=48, varin=49, theta=2.000000, up=999999999999999983222784.000000
  % 	x4 = 0,	Z0 = 28611137.0327721        
DEBUG EVAL: Second branch cutoff check: z=28611137.032772, best_z=INF, threshold=INF
  %   New best:  x4, Z = 28611137.0327721        
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=4, varin=85, theta=1.500000, up=1.000000
ITER 2: row=4, varin=84, theta=0.333333, up=1.000000
ITER 3: row=41, varin=85, theta=1.000000, up=1.000000
ITER 4: row=48, varin=49, theta=2.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28611137.032772
  % 	x2 = 0,	Z0 = 28611137.0327721        
DEBUG EVAL: First branch cutoff check: z=28611137.032772, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 1
ITER 1: row=4, varin=19, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=19, varin=47, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=46, varin=40, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=45, varin=32, theta=4.000000, up=999999999999999983222784.000000
ITER 5: row=31, varin=12, theta=1.500000, up=999999999999999983222784.000000
ITER 6: row=12, varin=24, theta=1.500000, up=999999999999999983222784.000000
ITER 7: row=24, varin=46, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=51, varin=37, theta=0.600000, up=999999999999999983222784.000000
ITER 9: row=11, varin=78, theta=0.333333, up=1.000000
  % 	x2 = 1,	Z1 = 28738214.8577331        
DEBUG EVAL: Second branch cutoff check: z=28738214.857733, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 22 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=39, varin=85, theta=1.500000, up=1.000000
ITER 2: row=39, varin=84, theta=0.333333, up=1.000000
ITER 3: row=41, varin=85, theta=1.000000, up=1.000000
ITER 4: row=48, varin=46, theta=0.333333, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 22 = 0 gives z=28607390.290347
  % 	x22 = 0,	Z0 = 28607390.2903467        
DEBUG EVAL: First branch cutoff check: z=28607390.290347, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 26 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=31, varin=50, theta=0.750000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 1 gives z=28599474.183414
  % 	x26 = 1,	Z1 = 28610830.4062424        
DEBUG EVAL: First branch cutoff check: z=28610830.406242, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=21, varin=85, theta=1.500000, up=1.000000
ITER 2: row=21, varin=40, theta=0.111111, up=999999999999999983222784.000000
ITER 3: row=41, varin=85, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28567709.112010
  % 	x10 = 0,	Z0 = 28567709.1120096        
DEBUG EVAL: First branch cutoff check: z=28567709.112010, best_z=INF, threshold=INF
  % Best branch is x4, Z0 = 28611137.0327721        , Z1 = 28802678.6823048        

DEBUG CAREFUL: Final result - returning best.var = 4
DEBUG BB: Branching variable chosen: j=4
 % @NC   53   37	x4 = 0	28611137.032772
 % @NC   54   37	x4 = 1	28802678.682305
 %      37    25 28562258.2403               28564606.8305    x3 D    11     3
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e75e250
% @LO 0.05  28.56225824034515881067 99.9000000000
% @LN 0.05  28.56460683045548876180 99.9000000000
% Resuming node 16 at  28.56460683045548876180
DEBUG CONSTRNT: LP rows=51, pool->nlprows=51, pool->npend=0
DEBUG CONSTRNT: Checking 51 LP rows (pool tracks 51, total LP rows 51)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=50, expected 50
 % @PAP adding 45 rows, 212 nz to LP
DEBUG BB: Processing node 16, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 16 LP 2 Solution, length = 28564606.830455, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.071377 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.428623 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.428623 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.428623 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.571377 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.571377 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.571377 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.571377 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.571377 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.571377 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28564606.830455, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28564606.830455, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 16 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 16
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.071377
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.071377)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.428623
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.428623)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=1.000000
DEBUG CAREFUL: Skipping var 12: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.428623
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.428623)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.428623
DEBUG CAREFUL: Adding var 18 to fractional list (xi=0.428623)
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[1] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[2] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[3] = var 18
DEBUG CAREFUL: Calling compare_branch_vars for var 18
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 18
  % Initial guess is x3, Z0 = 28564606.8304555        , Z1 = 28665385.9536897        

DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=10, theta=0.864410, up=999999999999999983222784.000000
ITER 2: row=10, varin=43, theta=1.088609, up=999999999999999983222784.000000
ITER 3: row=9, varin=47, theta=0.184679, up=1.000000
DEBUG EVAL: Branch var 3 = 1 gives z=28659042.295892
  % 	x3 = 1,	Z1 = 28665385.9536897        
DEBUG EVAL: First branch cutoff check: z=28665385.953690, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=1, varin=52, theta=0.069566, up=1.000000
ITER 2: row=42, varin=22, theta=0.007740, up=999999999999999983222784.000000
  % 	x3 = 0,	Z0 = 28567210.3696525        
DEBUG EVAL: Second branch cutoff check: z=28567210.369653, best_z=INF, threshold=INF
  %   New best:  x3, Z = 28567210.3696525        
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=9, varin=31, theta=1.423025, up=999999999999999983222784.000000
ITER 2: row=32, varin=47, theta=1.047243, up=1.000000
ITER 3: row=32, varin=9, theta=0.025317, up=999999999999999983222784.000000
ITER 4: row=44, varin=32, theta=0.041804, up=999999999999999983222784.000000
ITER 5: row=9, varin=22, theta=0.037689, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28611594.214655
  % 	x10 = 0,	Z0 = 28611594.2146549        
DEBUG EVAL: First branch cutoff check: z=28611594.214655, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 1
ITER 1: row=9, varin=43, theta=0.883167, up=999999999999999983222784.000000
  % 	x10 = 1,	Z1 = 28640995.2991674        
DEBUG EVAL: Second branch cutoff check: z=28640995.299167, best_z=INF, threshold=INF
  %   New best:  x10, Z = 28611594.2146549        
DEBUG EVAL: Testing var 17 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=19, varin=33, theta=0.525552, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 0 gives z=28658534.489943
  % 	x17 = 0,	Z0 = 28658534.4899428        
DEBUG EVAL: First branch cutoff check: z=28658534.489943, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 1
ITER 1: row=19, varin=31, theta=0.817661, up=999999999999999983222784.000000
ITER 2: row=32, varin=30, theta=0.981712, up=999999999999999983222784.000000
ITER 3: row=44, varin=41, theta=1.441915, up=999999999999999983222784.000000
ITER 4: row=24, varin=37, theta=4.371718, up=999999999999999983222784.000000
ITER 5: row=5, varin=75, theta=10.800477, up=1.000000
ITER 6: row=5, varin=20, theta=1.114407, up=999999999999999983222784.000000
ITER 7: row=40, varin=75, theta=1.000000, up=1.000000
ITER 8: row=1, varin=52, theta=0.315682, up=1.000000
ITER 9: row=42, varin=22, theta=0.034345, up=999999999999999983222784.000000
ITER 10: row=14, varin=24, theta=0.338997, up=999999999999999983222784.000000
  % 	x17 = 1,	Z1 = 29197828.1319113        
DEBUG EVAL: Second branch cutoff check: z=29197828.131911, best_z=INF, threshold=INF
  %   New best:  x17, Z = 28658534.4899428        
DEBUG EVAL: Testing var 18 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=27, varin=31, theta=1.423025, up=999999999999999983222784.000000
ITER 2: row=32, varin=47, theta=1.047243, up=1.000000
ITER 3: row=32, varin=22, theta=0.037689, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 18 = 0 gives z=28611594.214655
  % 	x18 = 0,	Z0 = 28611594.2146549        
DEBUG EVAL: First branch cutoff check: z=28611594.214655, best_z=INF, threshold=INF
  % Best branch is x17, Z0 = 28658534.4899428        , Z1 = 29197828.1319113        

DEBUG CAREFUL: Final result - returning best.var = 17
DEBUG BB: Branching variable chosen: j=17
 % @NC   55   16	x17 = 0	28658534.489943
 % @NC   56   16	x17 = 1	29197828.131911
 %      16    26 28564606.8305               28573658.2695   x12 U    13     7
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e737600
% @LO 0.05  28.56460683045548876180 99.9000000000
% @LN 0.05  28.57365826954885434930 99.9000000000
% Resuming node 43 at  28.57365826954885434930
DEBUG CONSTRNT: LP rows=45, pool->nlprows=45, pool->npend=0
DEBUG CONSTRNT: Checking 45 LP rows (pool tracks 45, total LP rows 45)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=44, expected 44
 % @PAP adding 57 rows, 242 nz to LP
DEBUG BB: Processing node 43, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 43 LP 2 Solution, length = 28573658.269549, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.216433 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.216433 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.067134 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 1.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.067134 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.216433 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.216433 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.067134 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.216433 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.216433 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.216433 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.783567 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.783567 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.783567 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.783567 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.783567 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.932866 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.932866 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 10 fractional variables
DEBUG CG: LP optimal, z=28573658.269549, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28573658.269549, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 43 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 43
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.216433
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.216433)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.216433
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.216433)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.067134
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.067134)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=1.000000
DEBUG CAREFUL: Skipping var 16: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.067134
DEBUG CAREFUL: Adding var 21 to fractional list (xi=0.067134)
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.216433
DEBUG CAREFUL: Adding var 23 to fractional list (xi=0.216433)
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.216433
DEBUG CAREFUL: Adding var 24 to fractional list (xi=0.216433)
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.067134
DEBUG CAREFUL: Adding var 25 to fractional list (xi=0.067134)
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.216433
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.216433)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.216433
DEBUG CAREFUL: Adding var 30 to fractional list (xi=0.216433)
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.216433
DEBUG CAREFUL: Adding var 33 to fractional list (xi=0.216433)
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 10 fractional variables

  %  Carefully choosing branching variable, nfrac = 10
DEBUG CAREFUL: Testing fvar[0] = var 33
DEBUG CAREFUL: Calling compare_branch_vars for var 33
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 33
DEBUG CAREFUL: New best var: 33
DEBUG CAREFUL: Testing fvar[1] = var 25
DEBUG CAREFUL: Calling compare_branch_vars for var 25
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 25
DEBUG CAREFUL: New best var: 25
DEBUG CAREFUL: Testing fvar[2] = var 21
DEBUG CAREFUL: Calling compare_branch_vars for var 21
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 21
DEBUG CAREFUL: Testing fvar[3] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
DEBUG CAREFUL: Testing fvar[4] = var 24
DEBUG CAREFUL: Calling compare_branch_vars for var 24
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 24
DEBUG CAREFUL: Testing fvar[5] = var 23
DEBUG CAREFUL: Calling compare_branch_vars for var 23
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 23
DEBUG CAREFUL: Testing fvar[6] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
DEBUG CAREFUL: Testing fvar[7] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[8] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 29
DEBUG CAREFUL: Testing fvar[9] = var 30
DEBUG CAREFUL: Calling compare_branch_vars for var 30
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 30
  % Initial guess is x25, Z0 = 28573658.2695489        , Z1 = 28846527.0601723        

DEBUG EVAL: Testing var 33 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=45, varin=56, theta=0.460739, up=999999999999999983222784.000000
ITER 2: row=9, varin=54, theta=0.387837, up=999999999999999983222784.000000
ITER 3: row=2, varin=50, theta=0.129091, up=999999999999999983222784.000000
ITER 4: row=14, varin=49, theta=0.086359, up=999999999999999983222784.000000
ITER 5: row=32, varin=53, theta=0.455769, up=999999999999999983222784.000000
ITER 6: row=29, varin=45, theta=0.091829, up=999999999999999983222784.000000
ITER 7: row=36, varin=40, theta=0.101869, up=999999999999999983222784.000000
ITER 8: row=21, varin=10, theta=0.021147, up=999999999999999983222784.000000
ITER 9: row=11, varin=46, theta=0.018111, up=999999999999999983222784.000000
ITER 10: row=46, varin=44, theta=0.017959, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 33 = 1 gives z=28656936.163055
  % 	x33 = 1,	Z1 = 28665862.9395485        
DEBUG EVAL: First branch cutoff check: z=28665862.939549, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 33 = 0
ITER 1: row=45, varin=6, theta=0.118508, up=999999999999999983222784.000000
ITER 2: row=55, varin=9, theta=0.162513, up=999999999999999983222784.000000
ITER 3: row=57, varin=48, theta=0.337414, up=999999999999999983222784.000000
  % 	x33 = 0,	Z0 = 28581644.3667876        
DEBUG EVAL: Second branch cutoff check: z=28581644.366788, best_z=INF, threshold=INF
  %   New best:  x33, Z = 28581644.3667876        
DEBUG EVAL: Testing var 25 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=43, varin=6, theta=6.111557, up=999999999999999983222784.000000
ITER 2: row=27, varin=46, theta=1.549449, up=999999999999999983222784.000000
ITER 3: row=46, varin=44, theta=1.537589, up=999999999999999983222784.000000
ITER 4: row=44, varin=10, theta=1.782303, up=999999999999999983222784.000000
ITER 5: row=10, varin=48, theta=4.083077, up=999999999999999983222784.000000
ITER 6: row=45, varin=87, theta=18.010143, up=1.000000
ITER 7: row=45, varin=41, theta=1.298847, up=999999999999999983222784.000000
ITER 8: row=41, varin=27, theta=1.579799, up=999999999999999983222784.000000
ITER 9: row=10, varin=53, theta=0.355783, up=999999999999999983222784.000000
ITER 10: row=29, varin=38, theta=0.148530, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 25 = 1 gives z=28872243.906621
  % 	x25 = 1,	Z1 = 28872243.9066206        
DEBUG EVAL: First branch cutoff check: z=28872243.906621, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 25 = 0
ITER 1: row=43, varin=56, theta=0.103069, up=999999999999999983222784.000000
ITER 2: row=9, varin=9, theta=0.221168, up=999999999999999983222784.000000
ITER 3: row=57, varin=90, theta=0.187103, up=1.000000
  % 	x25 = 0,	Z0 = 28592010.7309384        
DEBUG EVAL: Second branch cutoff check: z=28592010.730938, best_z=INF, threshold=INF
  %   New best:  x25, Z = 28592010.7309384        
DEBUG EVAL: Testing var 21 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=41, varin=6, theta=6.111557, up=999999999999999983222784.000000
ITER 2: row=27, varin=46, theta=1.549449, up=999999999999999983222784.000000
ITER 3: row=46, varin=44, theta=1.537589, up=999999999999999983222784.000000
ITER 4: row=44, varin=10, theta=1.782303, up=999999999999999983222784.000000
ITER 5: row=10, varin=48, theta=4.083077, up=999999999999999983222784.000000
ITER 6: row=45, varin=43, theta=1.502951, up=999999999999999983222784.000000
ITER 7: row=43, varin=87, theta=6.026955, up=1.000000
ITER 8: row=43, varin=27, theta=2.029123, up=999999999999999983222784.000000
ITER 9: row=10, varin=53, theta=0.456974, up=999999999999999983222784.000000
ITER 10: row=29, varin=38, theta=0.190774, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 21 = 1 gives z=28816286.111083
  % 	x21 = 1,	Z1 = 28816286.1110828        
DEBUG EVAL: First branch cutoff check: z=28816286.111083, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 21 = 0
ITER 1: row=41, varin=56, theta=0.103069, up=999999999999999983222784.000000
  % 	x21 = 0,	Z0 = 28578552.2854476        
DEBUG EVAL: Second branch cutoff check: z=28578552.285448, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 12 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=20, varin=6, theta=6.111557, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 12 = 1 gives z=28648727.803882
  % 	x12 = 1,	Z1 = 28721801.9559227        
DEBUG EVAL: First branch cutoff check: z=28721801.955923, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 0
ITER 1: row=20, varin=56, theta=0.103069, up=999999999999999983222784.000000
  % 	x12 = 0,	Z0 = 28578552.2854476        
DEBUG EVAL: Second branch cutoff check: z=28578552.285448, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 24 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=9, theta=0.162513, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 24 = 0 gives z=28580316.784482
  % 	x24 = 0,	Z0 = 28580316.7844816        
DEBUG EVAL: First branch cutoff check: z=28580316.784482, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 23 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=10, varin=10, theta=0.108412, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 23 = 0 gives z=28580048.616700
  % 	x23 = 0,	Z0 = 28580048.6167003        
DEBUG EVAL: First branch cutoff check: z=28580048.616700, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 0 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=9, theta=0.162513, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 0 = 0 gives z=28580316.784482
  % 	x0 = 0,	Z0 = 28580316.7844816        
DEBUG EVAL: First branch cutoff check: z=28580316.784482, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 1 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=56, theta=0.460739, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 1 gives z=28595535.584173
  % 	x1 = 1,	Z1 = 28620946.6380255        
DEBUG EVAL: First branch cutoff check: z=28620946.638025, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 0
ITER 1: row=2, varin=9, theta=0.162513, up=999999999999999983222784.000000
  % 	x1 = 0,	Z0 = 28580316.7844816        
DEBUG EVAL: Second branch cutoff check: z=28580316.784482, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 29 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=27, varin=9, theta=0.162513, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 29 = 0 gives z=28580316.784482
  % 	x29 = 0,	Z0 = 28580316.7844816        
DEBUG EVAL: First branch cutoff check: z=28580316.784482, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 30 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=29, varin=56, theta=0.460739, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 30 = 1 gives z=28595535.584173
  % 	x30 = 1,	Z1 = 28595535.5841734        
DEBUG EVAL: First branch cutoff check: z=28595535.584173, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 30 = 0
ITER 1: row=29, varin=9, theta=0.162513, up=999999999999999983222784.000000
  % 	x30 = 0,	Z0 = 28580316.7844817        
DEBUG EVAL: Second branch cutoff check: z=28580316.784482, best_z=INF, threshold=INF
  % Best branch is x25, Z0 = 28592010.7309384        , Z1 = 28872243.9066206        

DEBUG CAREFUL: Final result - returning best.var = 25
DEBUG BB: Branching variable chosen: j=25
 % @NC   57   43	x25 = 0	28592010.730938
 % @NC   58   43	x25 = 1	28872243.906621
 %      43    27 28573658.2695               28574731.7067   x18 D     6     4
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e74ccf0
% @LO 0.05  28.57365826954885434930 99.9000000000
% @LN 0.05  28.57473170674750662101 99.9000000000
% Resuming node 10 at  28.57473170674750662101
DEBUG CONSTRNT: LP rows=57, pool->nlprows=57, pool->npend=0
DEBUG CONSTRNT: Checking 57 LP rows (pool tracks 57, total LP rows 57)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 137
DEBUG CONSTRNT: Pool row 137 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=56, expected 56
 % @PAP adding 50 rows, 219 nz to LP
DEBUG BB: Processing node 10, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 10 LP 6 Solution, length = 28574731.706748, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.160854 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.160854 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.160854 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.160854 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.160854 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.034874 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.839146 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.839146 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.839146 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.839146 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.839146 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28574731.706748, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28574731.706748, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 10 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 10
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.160854
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.160854)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.160854
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.160854)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.160854
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.160854)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=1.000000
DEBUG CAREFUL: Skipping var 9: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.160854
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.160854)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.160854
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.160854)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.034874
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.034874)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 2
DEBUG CAREFUL: New best var: 2
DEBUG CAREFUL: Testing fvar[1] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[2] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 4
DEBUG CAREFUL: New best var: 4
DEBUG CAREFUL: Testing fvar[3] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[4] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 11
DEBUG CAREFUL: Testing fvar[5] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 22
  % Initial guess is x4, Z0 = 28574731.7067475        , Z1 = 28878309.3137798        

DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=40, theta=0.176834, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28593838.953831
  % 	x2 = 0,	Z0 = 28593838.9538308        
DEBUG EVAL: First branch cutoff check: z=28593838.953831, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 1
ITER 1: row=1, varin=49, theta=16.822962, up=999999999999999983222784.000000
ITER 2: row=49, varin=9, theta=19.321471, up=999999999999999983222784.000000
ITER 3: row=9, varin=46, theta=1.297175, up=999999999999999983222784.000000
ITER 4: row=6, varin=45, theta=0.802972, up=999999999999999983222784.000000
  % 	x2 = 1,	Z1 = 28944006.0848365        
DEBUG EVAL: Second branch cutoff check: z=28944006.084836, best_z=INF, threshold=INF
  %   New best:  x2, Z = 28593838.9538308        
DEBUG EVAL: Testing var 17 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=22, varin=15, theta=1.001650, up=999999999999999983222784.000000
ITER 2: row=32, varin=84, theta=1.998493, up=1.000000
ITER 3: row=32, varin=29, theta=1.438979, up=999999999999999983222784.000000
ITER 4: row=43, varin=84, theta=0.562354, up=1.000000
DEBUG EVAL: Branch var 17 = 0 gives z=28642562.732321
  % 	x17 = 0,	Z0 = 28642562.7323208        
DEBUG EVAL: First branch cutoff check: z=28642562.732321, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 1
ITER 1: row=22, varin=49, theta=16.822962, up=999999999999999983222784.000000
ITER 2: row=49, varin=9, theta=19.321471, up=999999999999999983222784.000000
ITER 3: row=9, varin=30, theta=1.773435, up=999999999999999983222784.000000
ITER 4: row=47, varin=45, theta=3.504991, up=999999999999999983222784.000000
ITER 5: row=12, varin=43, theta=1.297480, up=999999999999999983222784.000000
ITER 6: row=48, varin=47, theta=2.625024, up=999999999999999983222784.000000
ITER 7: row=30, varin=58, theta=19.841402, up=1.000000
ITER 8: row=30, varin=28, theta=1.054143, up=999999999999999983222784.000000
ITER 9: row=42, varin=58, theta=4.226525, up=1.000000
ITER 10: row=42, varin=41, theta=1.937064, up=999999999999999983222784.000000
  % 	x17 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: Second branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=22, varin=15, theta=1.001650, up=999999999999999983222784.000000
ITER 2: row=32, varin=84, theta=1.998493, up=1.000000
ITER 3: row=32, varin=29, theta=1.438979, up=999999999999999983222784.000000
ITER 4: row=43, varin=84, theta=0.562354, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28642562.732321
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 50 rows, 60 cols, 279 nonzeros, 4 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 4 slack rows
   % @PAP adding 4 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=73, theta=0.279967, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28645418.829369
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 50 rows, 60 cols, 268 nonzeros, 0 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 4 rows, 19 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=21, theta=0.157501, up=999999999999999983222784.000000
ITER 2: row=54, varin=78, theta=0.336677, up=1.000000
ITER 3: row=48, varin=76, theta=0.276784, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 28665419.317695
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 54 rows, 60 cols, 287 nonzeros, 0 slack, 54 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 4 rows, 16 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=55, varin=23, theta=0.053782, up=999999999999999983222784.000000
ITER 2: row=29, varin=96, theta=0.578528, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=58)
DEBUG SOLUTION: LP solution array indices: FST[59-98], not_covered[99-118]
DEBUG SOLUTION: lp->best_solution[0] = 28676262.678837
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 58 rows, 60 cols, 303 nonzeros, 0 slack, 58 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 2 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=60, varin=86, theta=0.293358, up=1.000000
ITER 2: row=58, varin=9, theta=0.326481, up=999999999999999983222784.000000
ITER 3: row=8, varin=88, theta=0.304775, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=60)
DEBUG SOLUTION: LP solution array indices: FST[61-100], not_covered[101-120]
DEBUG SOLUTION: lp->best_solution[0] = 28686496.735605
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 60 rows, 60 cols, 315 nonzeros, 0 slack, 60 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=62, varin=14, theta=0.060998, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=62)
DEBUG SOLUTION: LP solution array indices: FST[63-102], not_covered[103-122]
DEBUG SOLUTION: lp->best_solution[0] = 28686659.730990
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.939002
DEBUG SOLUTION: lp->best_solution[14] = 0.939002
   % @PL 62 rows, 60 cols, 321 nonzeros, 3 slack, 59 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 3 slack rows
   % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=60, varin=89, theta=0.305909, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=60)
DEBUG SOLUTION: LP solution array indices: FST[61-100], not_covered[101-120]
DEBUG SOLUTION: lp->best_solution[0] = 28687350.514987
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 60 rows, 60 cols, 314 nonzeros, 0 slack, 60 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 10 at  28.68735051498651955626
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e74a1c0
% @LO 0.05  28.57473170674750662101 99.9000000000
% @LN 0.05  28.59166494508454192669 99.9000000000
% Resuming node 41 at  28.59166494508454192669
DEBUG CONSTRNT: LP rows=60, pool->nlprows=60, pool->npend=0
DEBUG CONSTRNT: Checking 60 LP rows (pool tracks 60, total LP rows 60)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=56, expected 56
DEBUG CONSTRNT: Checking LP row 57 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=57, expected 57
DEBUG CONSTRNT: Checking LP row 58 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=58, expected 58
DEBUG CONSTRNT: Checking LP row 59 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=59, expected 59
 % @PAP adding 41 rows, 163 nz to LP
DEBUG BB: Processing node 41, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 41 LP 2 Solution, length = 28591664.945085, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 1.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.166667 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.166667 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.166667 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.166667 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.166667 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.833333 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.833333 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.833333 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.833333 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.833333 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28591664.945085, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28591664.945085, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 41 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 41
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=1.000000
DEBUG CAREFUL: Skipping var 1: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.166667
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.166667
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.166667
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.166667
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.166667
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.166667)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[1] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[2] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[3] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 4
DEBUG CAREFUL: New best var: 4
DEBUG CAREFUL: Testing fvar[4] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 11
  % Initial guess is x4, Z0 = 28591664.9450845        , Z1 = 28810085.6109512        

DEBUG EVAL: Testing var 3 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=68, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 3 = 0 gives z=28597592.725174
  % 	x3 = 0,	Z0 = 28597592.7251737        
DEBUG EVAL: First branch cutoff check: z=28597592.725174, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 1
ITER 1: row=6, varin=39, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=25, varin=16, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=26, varin=36, theta=1.500000, up=999999999999999983222784.000000
ITER 4: row=36, varin=35, theta=1.000000, up=999999999999999983222784.000000
  % 	x3 = 1,	Z1 = 28644325.810146         
DEBUG EVAL: Second branch cutoff check: z=28644325.810146, best_z=INF, threshold=INF
  %   New best:  x3, Z = 28597592.7251737        
DEBUG EVAL: Testing var 17 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=16, varin=16, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=26, varin=68, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 17 = 0 gives z=28597592.725174
  % 	x17 = 0,	Z0 = 28597592.7251737        
DEBUG EVAL: First branch cutoff check: z=28597592.725174, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 1
ITER 1: row=16, varin=39, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=25, varin=36, theta=1.500000, up=999999999999999983222784.000000
ITER 3: row=36, varin=35, theta=1.000000, up=999999999999999983222784.000000
  % 	x17 = 1,	Z1 = 28644325.810146         
DEBUG EVAL: Second branch cutoff check: z=28644325.810146, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=35, theta=0.200000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28595065.380297
  % 	x2 = 0,	Z0 = 28595065.3802968        
DEBUG EVAL: First branch cutoff check: z=28595065.380297, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 4 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=25, varin=16, theta=1.666667, up=999999999999999983222784.000000
ITER 2: row=26, varin=36, theta=2.500000, up=999999999999999983222784.000000
ITER 3: row=36, varin=35, theta=3.000000, up=999999999999999983222784.000000
ITER 4: row=1, varin=34, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=34, varin=31, theta=2.000000, up=999999999999999983222784.000000
ITER 6: row=31, varin=30, theta=2.000000, up=999999999999999983222784.000000
ITER 7: row=30, varin=28, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=28, varin=25, theta=1.000000, up=999999999999999983222784.000000
ITER 9: row=40, varin=26, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 4 = 1 gives z=28889868.715754
  % 	x4 = 1,	Z1 = 28889868.7157536        
DEBUG EVAL: First branch cutoff check: z=28889868.715754, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 4 = 0
ITER 1: row=25, varin=39, theta=0.250000, up=999999999999999983222784.000000
  % 	x4 = 0,	Z0 = 28593031.4460497        
DEBUG EVAL: Second branch cutoff check: z=28593031.446050, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 11 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=36, varin=39, theta=2.500000, up=999999999999999983222784.000000
ITER 2: row=25, varin=35, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=1, varin=34, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=34, varin=31, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=31, varin=30, theta=2.000000, up=999999999999999983222784.000000
ITER 6: row=30, varin=28, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=28, varin=19, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=37, varin=25, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 11 = 1 gives z=28865142.034475
  % 	x11 = 1,	Z1 = 28865142.0344753        
DEBUG EVAL: First branch cutoff check: z=28865142.034475, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 11 = 0
ITER 1: row=36, varin=16, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=26, varin=68, theta=1.000000, up=1.000000
  % 	x11 = 0,	Z0 = 28597592.7251737        
DEBUG EVAL: Second branch cutoff check: z=28597592.725174, best_z=INF, threshold=INF
  %   New best:  x11, Z = 28597592.7251737        
  % Best branch is x11, Z0 = 28597592.7251737        , Z1 = 28865142.0344753        

DEBUG CAREFUL: Final result - returning best.var = 11
DEBUG BB: Branching variable chosen: j=11
 % @NC   59   41	x11 = 0	28597592.725174
 % @NC   60   41	x11 = 1	28865142.034475
 %      41    28 28591664.9451               28592010.7309    x1 U    39    12
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e75e250
% @LO 0.05  28.59166494508454192669 99.9000000000
% @LN 0.05  28.59201073093842637718 99.9000000000
% Resuming node 57 at  28.59201073093842637718
DEBUG CONSTRNT: LP rows=41, pool->nlprows=41, pool->npend=0
DEBUG CONSTRNT: Checking 41 LP rows (pool tracks 41, total LP rows 41)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 143
DEBUG CONSTRNT: Pool row 143 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 73
DEBUG CONSTRNT: Pool row 73 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 85
DEBUG CONSTRNT: Pool row 85 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=40, expected 40
 % @PAP adding 57 rows, 242 nz to LP
DEBUG BB: Processing node 57, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=56, theta=0.103069, up=999999999999999983222784.000000
ITER 2: row=9, varin=9, theta=0.221168, up=999999999999999983222784.000000
ITER 3: row=57, varin=90, theta=0.187103, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 28592010.730938
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1000000.000000
  % @PL 57 rows, 60 cols, 302 nonzeros, 0 slack, 57 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=58, varin=54, theta=0.124159, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=59)
DEBUG SOLUTION: LP solution array indices: FST[60-99], not_covered[100-119]
DEBUG SOLUTION: lp->best_solution[0] = 28592057.052125
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1000000.000000
  % @PL 59 rows, 60 cols, 308 nonzeros, 2 slack, 57 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 6 rows, 17 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=58, varin=43, theta=0.173404, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=63)
DEBUG SOLUTION: LP solution array indices: FST[64-103], not_covered[104-123]
DEBUG SOLUTION: lp->best_solution[0] = 28592795.812865
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1000000.000000
  % @PL 63 rows, 60 cols, 321 nonzeros, 2 slack, 61 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 57 LP 1 Solution, length = 28592795.812865, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.206649 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.206649 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.173404 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 1.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.173404 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.206649 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.206649 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.206649 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.206649 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.206649 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.793351 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.793351 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.793351 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.793351 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 0.793351 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.826596 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.826596 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 9 fractional variables
DEBUG CG: LP optimal, z=28592795.812865, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.05  28.59201073093842637718 99.9000000000
 % @LN 0.05  28.59279581286534721585 99.9000000000
DEBUG CG: Second cutoff check: z=28592795.812865, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 57 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 57
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.206649
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.206649)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.206649
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.206649)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.173404
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.173404)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=1.000000
DEBUG CAREFUL: Skipping var 16: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.173404
DEBUG CAREFUL: Adding var 21 to fractional list (xi=0.173404)
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.206649
DEBUG CAREFUL: Adding var 23 to fractional list (xi=0.206649)
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.206649
DEBUG CAREFUL: Adding var 24 to fractional list (xi=0.206649)
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.206649
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.206649)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.206649
DEBUG CAREFUL: Adding var 30 to fractional list (xi=0.206649)
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.206649
DEBUG CAREFUL: Adding var 33 to fractional list (xi=0.206649)
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 9 fractional variables

  %  Carefully choosing branching variable, nfrac = 9
DEBUG CAREFUL: Testing fvar[0] = var 21
DEBUG CAREFUL: Calling compare_branch_vars for var 21
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 21
DEBUG CAREFUL: New best var: 21
DEBUG CAREFUL: Testing fvar[1] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
DEBUG CAREFUL: Testing fvar[2] = var 24
DEBUG CAREFUL: Calling compare_branch_vars for var 24
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 24
DEBUG CAREFUL: Testing fvar[3] = var 23
DEBUG CAREFUL: Calling compare_branch_vars for var 23
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 23
DEBUG CAREFUL: Testing fvar[4] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
DEBUG CAREFUL: Testing fvar[5] = var 30
DEBUG CAREFUL: Calling compare_branch_vars for var 30
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 30
DEBUG CAREFUL: Testing fvar[6] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[7] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 29
DEBUG CAREFUL: Testing fvar[8] = var 33
DEBUG CAREFUL: Calling compare_branch_vars for var 33
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 33
  % Initial guess is x21, Z0 = 28592795.8128653        , Z1 = 28816286.1110828        

DEBUG EVAL: Testing var 21 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=41, varin=57, theta=1.183707, up=999999999999999983222784.000000
ITER 2: row=47, varin=55, theta=0.733906, up=999999999999999983222784.000000
ITER 3: row=44, varin=54, theta=0.908987, up=999999999999999983222784.000000
ITER 4: row=34, varin=114, theta=0.720130, up=1.000000
ITER 5: row=53, varin=52, theta=0.668288, up=999999999999999983222784.000000
ITER 6: row=29, varin=45, theta=0.399445, up=999999999999999983222784.000000
ITER 7: row=45, varin=10, theta=0.438592, up=999999999999999983222784.000000
ITER 8: row=10, varin=43, theta=0.336398, up=999999999999999983222784.000000
ITER 9: row=43, varin=49, theta=0.299214, up=999999999999999983222784.000000
ITER 10: row=14, varin=48, theta=0.213278, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 21 = 1 gives z=28803728.696455
  % 	x21 = 1,	Z1 = 28816286.1110828        
DEBUG EVAL: First branch cutoff check: z=28816286.111083, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 21 = 0
ITER 1: row=41, varin=93, theta=0.176639, up=1.000000
  % 	x21 = 0,	Z0 = 28594377.9945265        
DEBUG EVAL: Second branch cutoff check: z=28594377.994526, best_z=INF, threshold=INF
  %   New best:  x21, Z = 28594377.9945265        
DEBUG EVAL: Testing var 12 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=20, varin=57, theta=1.183707, up=999999999999999983222784.000000
ITER 2: row=47, varin=55, theta=0.733906, up=999999999999999983222784.000000
ITER 3: row=44, varin=54, theta=0.908987, up=999999999999999983222784.000000
ITER 4: row=34, varin=114, theta=0.720130, up=1.000000
ITER 5: row=53, varin=52, theta=0.668288, up=999999999999999983222784.000000
ITER 6: row=29, varin=45, theta=0.399445, up=999999999999999983222784.000000
ITER 7: row=45, varin=10, theta=0.438592, up=999999999999999983222784.000000
ITER 8: row=10, varin=43, theta=0.336398, up=999999999999999983222784.000000
ITER 9: row=43, varin=49, theta=0.299214, up=999999999999999983222784.000000
ITER 10: row=14, varin=48, theta=0.213278, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 12 = 1 gives z=28737189.259443
  % 	x12 = 1,	Z1 = 28737189.2594427        
DEBUG EVAL: First branch cutoff check: z=28737189.259443, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 0
ITER 1: row=20, varin=93, theta=0.176639, up=1.000000
  % 	x12 = 0,	Z0 = 28594377.9945265        
DEBUG EVAL: Second branch cutoff check: z=28594377.994526, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 24 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=57, theta=4.168171, up=999999999999999983222784.000000
ITER 2: row=47, varin=47, theta=0.468679, up=999999999999999983222784.000000
ITER 3: row=33, varin=114, theta=0.077219, up=1.000000
DEBUG EVAL: Branch var 24 = 0 gives z=28613685.045332
  % 	x24 = 0,	Z0 = 28613685.0453323        
DEBUG EVAL: First branch cutoff check: z=28613685.045332, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 24 = 1
ITER 1: row=3, varin=54, theta=1.819380, up=999999999999999983222784.000000
ITER 2: row=34, varin=49, theta=0.920582, up=999999999999999983222784.000000
ITER 3: row=14, varin=6, theta=3.165928, up=999999999999999983222784.000000
ITER 4: row=27, varin=44, theta=1.134265, up=999999999999999983222784.000000
ITER 5: row=36, varin=55, theta=43.340962, up=999999999999999983222784.000000
ITER 6: row=44, varin=48, theta=0.700323, up=999999999999999983222784.000000
ITER 7: row=5, varin=27, theta=2.822563, up=999999999999999983222784.000000
ITER 8: row=59, varin=2, theta=1.230247, up=999999999999999983222784.000000
ITER 9: row=5, varin=57, theta=1.850868, up=999999999999999983222784.000000
ITER 10: row=47, varin=91, theta=1.033418, up=1.000000
  % 	x24 = 1,	Z1 = 29407273.695247         
DEBUG EVAL: Second branch cutoff check: z=29407273.695247, best_z=INF, threshold=INF
  %   New best:  x24, Z = 28613685.0453323        
DEBUG EVAL: Testing var 23 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=10, varin=57, theta=4.168171, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 23 = 0 gives z=28605196.350101
  % 	x23 = 0,	Z0 = 28605196.3501008        
DEBUG EVAL: First branch cutoff check: z=28605196.350101, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 0 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=57, theta=4.168171, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 0 = 0 gives z=28605196.350101
  % 	x0 = 0,	Z0 = 28605196.3501008        
DEBUG EVAL: First branch cutoff check: z=28605196.350101, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 30 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=29, varin=54, theta=1.819380, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 30 = 1 gives z=28626776.319707
  % 	x30 = 1,	Z1 = 28626776.3197073        
DEBUG EVAL: First branch cutoff check: z=28626776.319707, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 30 = 0
ITER 1: row=29, varin=57, theta=4.168171, up=999999999999999983222784.000000
  % 	x30 = 0,	Z0 = 28605196.3501007        
DEBUG EVAL: Second branch cutoff check: z=28605196.350101, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 1 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=57, theta=1.761350, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 1 gives z=28598035.924970
  % 	x1 = 1,	Z1 = 28620946.6380255        
DEBUG EVAL: First branch cutoff check: z=28620946.638025, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 0
ITER 1: row=2, varin=6, theta=0.275749, up=999999999999999983222784.000000
  % 	x1 = 0,	Z0 = 28606540.6623631        
DEBUG EVAL: Second branch cutoff check: z=28606540.662363, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 29 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=27, varin=47, theta=0.468679, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 29 = 0 gives z=28612402.580575
  % 	x29 = 0,	Z0 = 28612402.5805745        
DEBUG EVAL: First branch cutoff check: z=28612402.580575, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 33 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=47, varin=54, theta=1.819380, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 33 = 1 gives z=28626776.319707
  % 	x33 = 1,	Z1 = 28665862.9395485        
DEBUG EVAL: First branch cutoff check: z=28665862.939549, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 33 = 0
ITER 1: row=47, varin=57, theta=0.196888, up=999999999999999983222784.000000
  % 	x33 = 0,	Z0 = 28593381.5649258        
DEBUG EVAL: Second branch cutoff check: z=28593381.564926, best_z=INF, threshold=INF
  % Best branch is x24, Z0 = 28613685.0453323        , Z1 = 29407273.695247         

DEBUG CAREFUL: Final result - returning best.var = 24
DEBUG BB: Branching variable chosen: j=24
 % @NC   61   57	x24 = 0	28613685.045332
 % @NC   62   57	x24 = 1	29407273.695247
 %      57    29 28592795.8129               28595713.1072   x25 D    43     5
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e770fa0
% @LO 0.05  28.59279581286534721585 99.9000000000
% @LN 0.05  28.59571310716846070932 99.9000000000
% Resuming node 42 at  28.59571310716846070932
DEBUG CONSTRNT: LP rows=61, pool->nlprows=61, pool->npend=0
DEBUG CONSTRNT: Checking 61 LP rows (pool tracks 61, total LP rows 61)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 137
DEBUG CONSTRNT: Pool row 137 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=56, expected 56
DEBUG CONSTRNT: Checking LP row 57 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=57, expected 57
DEBUG CONSTRNT: Checking LP row 58 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=58, expected 58
DEBUG CONSTRNT: Checking LP row 59 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=59, expected 59
DEBUG CONSTRNT: Checking LP row 60 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=60, expected 60
 % @PAP adding 39 rows, 199 nz to LP
DEBUG BB: Processing node 42, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=37, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=31, varin=20, theta=0.333333, up=999999999999999983222784.000000
ITER 3: row=37, varin=69, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 28595713.107168
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 3.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 39 rows, 60 cols, 259 nonzeros, 1 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=50, theta=0.333333, up=1.000000
ITER 2: row=37, varin=34, theta=2.333333, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28605961.518320
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 3.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 43 rows, 60 cols, 272 nonzeros, 7 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 7 slack rows
  % Node 42 LP 1 Solution, length = 28605961.518320, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.333333 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.333333 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.333333 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.666667 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.666667 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.666667 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.666667 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.666667 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.666667 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.666667 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28605961.518320, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 42 at  28.60596151832001510229
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e737600
% @LO 0.06  28.59571310716846070932 99.9000000000
% @LN 0.06  28.59759272517368700051 99.9000000000
% Resuming node 59 at  28.59759272517368700051
DEBUG CONSTRNT: LP rows=36, pool->nlprows=36, pool->npend=0
DEBUG CONSTRNT: Checking 36 LP rows (pool tracks 36, total LP rows 36)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 162
DEBUG CONSTRNT: Pool row 162 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=35, expected 35
 % @PAP adding 41 rows, 163 nz to LP
DEBUG BB: Processing node 59, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=16, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=26, varin=68, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28597592.725174
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 41 rows, 60 cols, 223 nonzeros, 0 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 17 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=36, theta=0.250000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28599213.116369
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 240 nonzeros, 5 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % Node 59 LP 1 Solution, length = 28599213.116369, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 1.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.250000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.250000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.250000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.250000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.750000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.750000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.750000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.750000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.750000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28599213.116369, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.06  28.59759272517368700051 99.9000000000
 % @LN 0.06  28.59921311636932017564 99.9000000000
DEBUG CG: Second cutoff check: z=28599213.116369, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 59 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 59
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=1.000000
DEBUG CAREFUL: Skipping var 1: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.250000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.250000
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.250000
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.250000
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[1] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[2] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[3] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 4
DEBUG CAREFUL: New best var: 4
  % Initial guess is x4, Z0 = 28599213.1163693        , Z1 = 28889868.7157536        

DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=39, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=39, varin=36, theta=1.500000, up=999999999999999983222784.000000
ITER 3: row=25, varin=35, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 1 gives z=28644325.810146
  % 	x3 = 1,	Z1 = 28644325.810146         
DEBUG EVAL: First branch cutoff check: z=28644325.810146, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=6, varin=26, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=16, varin=15, theta=0.142857, up=999999999999999983222784.000000
ITER 3: row=34, varin=17, theta=0.166667, up=999999999999999983222784.000000
  % 	x3 = 0,	Z0 = 28615060.4434682        
DEBUG EVAL: Second branch cutoff check: z=28615060.443468, best_z=INF, threshold=INF
  %   New best:  x3, Z = 28615060.4434682        
DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=19, varin=39, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=39, varin=26, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=16, varin=36, theta=1.500000, up=999999999999999983222784.000000
ITER 4: row=25, varin=35, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 1 gives z=28644325.810146
  % 	x17 = 1,	Z1 = 28644325.810146         
DEBUG EVAL: First branch cutoff check: z=28644325.810146, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 0
ITER 1: row=19, varin=15, theta=0.142857, up=999999999999999983222784.000000
ITER 2: row=34, varin=17, theta=0.166667, up=999999999999999983222784.000000
  % 	x17 = 0,	Z0 = 28615060.4434682        
DEBUG EVAL: Second branch cutoff check: z=28615060.443468, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=35, theta=0.333333, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28607396.565485
  % 	x2 = 0,	Z0 = 28607396.5654847        
DEBUG EVAL: First branch cutoff check: z=28607396.565485, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 4 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=25, varin=39, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=39, varin=35, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=1, varin=34, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=34, varin=31, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=31, varin=30, theta=2.000000, up=999999999999999983222784.000000
ITER 6: row=30, varin=28, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=28, varin=25, theta=1.000000, up=999999999999999983222784.000000
ITER 8: row=37, varin=26, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 4 = 1 gives z=28889868.715754
  % 	x4 = 1,	Z1 = 28889868.7157536        
DEBUG EVAL: First branch cutoff check: z=28889868.715754, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 4 = 0
ITER 1: row=25, varin=26, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=16, varin=36, theta=0.500000, up=999999999999999983222784.000000
  % 	x4 = 0,	Z0 = 28609494.2895845        
DEBUG EVAL: Second branch cutoff check: z=28609494.289585, best_z=INF, threshold=INF
  % Best branch is x3, Z0 = 28615060.4434682        , Z1 = 28644325.810146         

DEBUG CAREFUL: Final result - returning best.var = 3
DEBUG BB: Branching variable chosen: j=3
 % @NC   63   59	x3 = 0	28615060.443468
 % @NC   64   59	x3 = 1	28644325.810146
 %      59    30 28599213.1164               28605961.5183   x11 D    41    13
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e770fa0
% @LO 0.06  28.59921311636932017564 99.9000000000
% @LN 0.06  28.60596151832001510229 99.9000000000
% Resuming node 42 at  28.60596151832001510229
DEBUG CONSTRNT: LP rows=40, pool->nlprows=40, pool->npend=0
DEBUG CONSTRNT: Checking 40 LP rows (pool tracks 40, total LP rows 40)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 143
DEBUG CONSTRNT: Pool row 143 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 73
DEBUG CONSTRNT: Pool row 73 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 85
DEBUG CONSTRNT: Pool row 85 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=39, expected 39
 % @PAP adding 36 rows, 179 nz to LP
DEBUG BB: Processing node 42, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 42 LP 2 Solution, length = 28605961.518320, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.333333 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.333333 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.333333 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.666667 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.666667 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.666667 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.666667 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.666667 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.666667 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.666667 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28605961.518320, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28605961.518320, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 42 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 42
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.333333
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.333333
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.333333
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.333333)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 3 fractional variables

  %  Carefully choosing branching variable, nfrac = 3
DEBUG CAREFUL: Testing fvar[0] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[1] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[2] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
  % Initial guess is x3, Z0 = 28605961.51832          , Z1 = 28605961.51832          

DEBUG EVAL: Testing var 3 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=71, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 3 = 0 gives z=28623670.084988
  % 	x3 = 0,	Z0 = 28623670.0849876        
DEBUG EVAL: First branch cutoff check: z=28623670.084988, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 1
ITER 1: row=1, varin=30, theta=0.666667, up=999999999999999983222784.000000
ITER 2: row=30, varin=33, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=33, varin=6, theta=0.666667, up=999999999999999983222784.000000
ITER 4: row=6, varin=19, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=28, varin=21, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=29, varin=22, theta=0.666667, up=999999999999999983222784.000000
ITER 7: row=18, varin=32, theta=0.500000, up=999999999999999983222784.000000
  % 	x3 = 1,	Z1 = 28811488.8273182        
DEBUG EVAL: Second branch cutoff check: z=28811488.827318, best_z=INF, threshold=INF
  %   New best:  x3, Z = 28623670.0849876        
DEBUG EVAL: Testing var 17 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=19, varin=71, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 17 = 0 gives z=28623670.084988
  % 	x17 = 0,	Z0 = 28623670.0849876        
DEBUG EVAL: First branch cutoff check: z=28623670.084988, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 1
ITER 1: row=19, varin=30, theta=0.666667, up=999999999999999983222784.000000
ITER 2: row=30, varin=33, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=33, varin=27, theta=0.666667, up=999999999999999983222784.000000
ITER 4: row=18, varin=32, theta=0.500000, up=999999999999999983222784.000000
  % 	x17 = 1,	Z1 = 28678165.3197957        
DEBUG EVAL: Second branch cutoff check: z=28678165.319796, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 7 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=18, varin=30, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=30, varin=27, theta=0.333333, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 7 = 0 gives z=28618776.879864
  % 	x7 = 0,	Z0 = 28618776.8798638        
DEBUG EVAL: First branch cutoff check: z=28618776.879864, best_z=INF, threshold=INF
  % Best branch is x3, Z0 = 28623670.0849876        , Z1 = 28811488.8273182        

DEBUG CAREFUL: Final result - returning best.var = 3
DEBUG BB: Branching variable chosen: j=3
 % @NC   65   42	x3 = 0	28623670.084988
 % @NC   66   42	x3 = 1	28811488.827318
 %      42    31 28605961.5183               28608326.9349    x1 D    39    12
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e7725c0
% @LO 0.06  28.60596151832001510229 99.9000000000
% @LN 0.06  28.60832693487217781581 99.9000000000
% Resuming node 51 at  28.60832693487217781581
DEBUG CONSTRNT: LP rows=36, pool->nlprows=36, pool->npend=0
DEBUG CONSTRNT: Checking 36 LP rows (pool tracks 36, total LP rows 36)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 162
DEBUG CONSTRNT: Pool row 162 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=35, expected 35
 % @PAP adding 47 rows, 206 nz to LP
DEBUG BB: Processing node 51, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=9, theta=0.551194, up=999999999999999983222784.000000
ITER 2: row=9, varin=46, theta=0.666057, up=999999999999999983222784.000000
ITER 3: row=3, varin=44, theta=0.346390, up=999999999999999983222784.000000
ITER 4: row=12, varin=42, theta=0.010870, up=999999999999999983222784.000000
ITER 5: row=29, varin=40, theta=0.007481, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28608326.934872
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 266 nonzeros, 6 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 3 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=47, theta=0.083569, up=1.000000
ITER 2: row=43, varin=44, theta=2.001150, up=999999999999999983222784.000000
ITER 3: row=12, varin=39, theta=0.000386, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28621188.478739
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 268 nonzeros, 3 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % Node 51 LP 1 Solution, length = 28621188.478739, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.333076 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.333462 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.333462 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 1.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.333462 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.333462 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.666538 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.666538 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.666538 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.666924 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.666538 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.666538 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.666538 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28621188.478739, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 51 at  28.62118847873899696310
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e74b490
% @LO 0.06  28.60832693487217781581 99.9000000000
% @LN 0.06  28.61113703277212394482 99.9000000000
% Resuming node 53 at  28.61113703277212394482
DEBUG CONSTRNT: LP rows=41, pool->nlprows=41, pool->npend=0
DEBUG CONSTRNT: Checking 41 LP rows (pool tracks 41, total LP rows 41)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 150
DEBUG CONSTRNT: Pool row 150 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=40, expected 40
 % @PAP adding 51 rows, 184 nz to LP
DEBUG BB: Processing node 53, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=10, varin=85, theta=1.500000, up=1.000000
ITER 2: row=10, varin=40, theta=0.111111, up=999999999999999983222784.000000
ITER 3: row=41, varin=85, theta=1.000000, up=1.000000
ITER 4: row=45, varin=84, theta=1.000000, up=1.000000
ITER 5: row=48, varin=49, theta=2.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28611137.032772
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 51 rows, 60 cols, 244 nonzeros, 3 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=86, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 28624619.933044
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 54 rows, 60 cols, 252 nonzeros, 1 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 2 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=54, varin=46, theta=0.250000, up=999999999999999983222784.000000
ITER 2: row=51, varin=80, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 28637584.480553
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 0.500000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 2.000000
  % @PL 55 rows, 60 cols, 262 nonzeros, 1 slack, 54 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 5 rows, 18 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=56, varin=49, theta=0.250000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=59)
DEBUG SOLUTION: LP solution array indices: FST[60-99], not_covered[100-119]
DEBUG SOLUTION: lp->best_solution[0] = 28640410.867232
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 59 rows, 60 cols, 278 nonzeros, 9 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 9 slack rows
  % Node 53 LP 1 Solution, length = 28640410.867232, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.250000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.250000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.250000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.250000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.250000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.250000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.250000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.250000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.250000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.750000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.750000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.750000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.750000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.750000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.750000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.750000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.750000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.750000 (terminal 19)
 % 9 fractional variables
DEBUG CG: LP optimal, z=28640410.867232, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 53 at  28.64041086723239715184
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e74a1c0
% @LO 0.06  28.61113703277212394482 99.9000000000
% @LN 0.06  28.61368504533227508091 99.9000000000
% Resuming node 61 at  28.61368504533227508091
DEBUG CONSTRNT: LP rows=50, pool->nlprows=50, pool->npend=0
DEBUG CONSTRNT: Checking 50 LP rows (pool tracks 50, total LP rows 50)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=49, expected 49
 % @PAP adding 61 rows, 254 nz to LP
DEBUG BB: Processing node 61, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=3, varin=57, theta=4.168171, up=999999999999999983222784.000000
ITER 2: row=47, varin=47, theta=0.468679, up=999999999999999983222784.000000
ITER 3: row=33, varin=114, theta=0.077219, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=61)
DEBUG SOLUTION: LP solution array indices: FST[62-101], not_covered[102-121]
DEBUG SOLUTION: lp->best_solution[0] = 28613685.045333
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1000000.000000
  % @PL 61 rows, 60 cols, 314 nonzeros, 1 slack, 60 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 2 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=61, varin=54, theta=0.077751, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=62)
DEBUG SOLUTION: LP solution array indices: FST[63-102], not_covered[103-122]
DEBUG SOLUTION: lp->best_solution[0] = 28614155.154300
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1000000.000000
  % @PL 62 rows, 60 cols, 311 nonzeros, 2 slack, 60 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 61 LP 1 Solution, length = 28614155.154300, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.077751 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.077751 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.077751 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.077751 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.077751 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.300241 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 1.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.077751 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.300241 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.077751 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.077751 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.077751 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.922249 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.922249 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.922249 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.922249 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.922249 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.922249 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.699759 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.699759 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.922249 (terminal 19)
 % 11 fractional variables
DEBUG CG: LP optimal, z=28614155.154300, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.06  28.61368504533227508091 99.9000000000
 % @LN 0.06  28.61415515429993305929 99.9000000000
DEBUG CG: Second cutoff check: z=28614155.154300, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 61 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 61
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.077751
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.077751)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.077751
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.077751)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.077751
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.077751)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.077751
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.077751)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.077751
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.077751)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.300241
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.300241)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=1.000000
DEBUG CAREFUL: Skipping var 16: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.077751
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.077751)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.300241
DEBUG CAREFUL: Adding var 21 to fractional list (xi=0.300241)
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.077751
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.077751)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.077751
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.077751)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.077751
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.077751)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 11 fractional variables

  %  Carefully choosing branching variable, nfrac = 11
DEBUG CAREFUL: Testing fvar[0] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 11
DEBUG CAREFUL: New best var: 11
DEBUG CAREFUL: Testing fvar[1] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[2] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[3] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 27
DEBUG CAREFUL: Testing fvar[4] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 22
DEBUG CAREFUL: Testing fvar[5] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[6] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[7] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[8] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 4
DEBUG CAREFUL: Testing fvar[9] = var 21
DEBUG CAREFUL: Calling compare_branch_vars for var 21
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 21
DEBUG CAREFUL: Testing fvar[10] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
  % Initial guess is x11, Z0 = 28614155.1542999        , Z1 = 31538089.8001582        

DEBUG EVAL: Testing var 11 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=36, varin=94, theta=41.736257, up=1.000000
ITER 2: row=36, varin=53, theta=5.126471, up=999999999999999983222784.000000
ITER 3: row=7, varin=6, theta=7.161776, up=999999999999999983222784.000000
ITER 4: row=60, varin=59, theta=13.487276, up=999999999999999983222784.000000
ITER 5: row=44, varin=48, theta=4.174271, up=999999999999999983222784.000000
ITER 6: row=14, varin=94, theta=20.690971, up=1.000000
ITER 7: row=14, varin=47, theta=1.525383, up=999999999999999983222784.000000
ITER 8: row=21, varin=92, theta=1.665942, up=1.000000
ITER 9: row=21, varin=94, theta=5.772108, up=1.000000
ITER 10: row=21, varin=93, theta=1.122335, up=1.000000
DEBUG EVAL: Branch var 11 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x11 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=33, theta=0.219118, up=999999999999999983222784.000000
ITER 2: row=52, varin=37, theta=0.623051, up=999999999999999983222784.000000
ITER 3: row=30, varin=3, theta=0.183778, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=60)
DEBUG SOLUTION: LP solution array indices: FST[61-100], not_covered[101-120]
DEBUG SOLUTION: lp->best_solution[0] = 28638083.668123
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.816222
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 2.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.000000
DEBUG SOLUTION: lp->best_solution[14] = 1000000.000000
   % @PL 60 rows, 60 cols, 305 nonzeros, 7 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 7 slack rows
   % @PAP adding 4 rows, 10 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=56, varin=43, theta=0.069976, up=999999999999999983222784.000000
ITER 2: row=54, varin=56, theta=0.093781, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 28638756.401084
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 57 rows, 60 cols, 296 nonzeros, 3 slack, 54 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 3 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 61 at  28.63875640108373588077
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e767ee0
% @LO 0.06  28.61415515429993305929 99.9000000000
% @LN 0.06  28.61460642331820025674 99.9000000000
% Resuming node 26 at  28.61460642331820025674
DEBUG CONSTRNT: LP rows=54, pool->nlprows=54, pool->npend=0
DEBUG CONSTRNT: Checking 54 LP rows (pool tracks 54, total LP rows 54)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 137
DEBUG CONSTRNT: Pool row 137 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=53, expected 53
 % @PAP adding 40 rows, 167 nz to LP
DEBUG BB: Processing node 26, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 26 LP 2 Solution, length = 28614606.423318, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.500000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.500000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.500000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28614606.423318, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28614606.423318, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 26 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 26
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.500000
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=1.000000
DEBUG CAREFUL: Skipping var 15: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.500000
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.500000
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 3 fractional variables

  %  Carefully choosing branching variable, nfrac = 3
DEBUG CAREFUL: Testing fvar[0] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 36
DEBUG CAREFUL: New best var: 36
DEBUG CAREFUL: Testing fvar[1] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
DEBUG CAREFUL: Testing fvar[2] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 34
  % Initial guess is x36, Z0 = 28614606.4233182        , Z1 = 28618910.0231984        

DEBUG EVAL: Testing var 36 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=27, varin=40, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=40, varin=39, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=6, varin=38, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 36 = 1 gives z=28618910.023198
  % 	x36 = 1,	Z1 = 28618910.0231984        
DEBUG EVAL: First branch cutoff check: z=28618910.023198, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 36 = 0
ITER 1: row=27, varin=39, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=6, varin=100, theta=0.066667, up=1.000000
  % 	x36 = 0,	Z0 = 28617607.1479673        
DEBUG EVAL: Second branch cutoff check: z=28617607.147967, best_z=INF, threshold=INF
  %   New best:  x36, Z = 28617607.1479673        
DEBUG EVAL: Testing var 7 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=40, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=40, varin=39, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=6, varin=27, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 7 = 0 gives z=28618854.366554
  % 	x7 = 0,	Z0 = 28618854.3665538        
DEBUG EVAL: First branch cutoff check: z=28618854.366554, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 7 = 1
ITER 1: row=1, varin=39, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=6, varin=100, theta=0.066667, up=1.000000
  % 	x7 = 1,	Z1 = 28617607.1479673        
DEBUG EVAL: Second branch cutoff check: z=28617607.147967, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 34 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=17, varin=39, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=6, varin=100, theta=0.066667, up=1.000000
DEBUG EVAL: Branch var 34 = 0 gives z=28617607.147967
  % 	x34 = 0,	Z0 = 28617607.1479673        
DEBUG EVAL: First branch cutoff check: z=28617607.147967, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 34 = 1
ITER 1: row=17, varin=40, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=40, varin=39, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=6, varin=27, theta=1.000000, up=999999999999999983222784.000000
  % 	x34 = 1,	Z1 = 28618854.3665538        
DEBUG EVAL: Second branch cutoff check: z=28618854.366554, best_z=INF, threshold=INF
  % Best branch is x36, Z0 = 28617607.1479673        , Z1 = 28618910.0231984        

DEBUG CAREFUL: Final result - returning best.var = 36
DEBUG BB: Branching variable chosen: j=36
 % @NC   67   26	x36 = 0	28617607.147967
 % @NC   68   26	x36 = 1	28618910.023198
 %      26    32 28614606.4233               28615060.4435    x5 D    23    11
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e75e250
% @LO 0.06  28.61460642331820025674 99.9000000000
% @LN 0.06  28.61506044346823429692 99.9000000000
% Resuming node 63 at  28.61506044346823429692
DEBUG CONSTRNT: LP rows=40, pool->nlprows=40, pool->npend=0
DEBUG CONSTRNT: Checking 40 LP rows (pool tracks 40, total LP rows 40)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=39, expected 39
 % @PAP adding 40 rows, 162 nz to LP
DEBUG BB: Processing node 63, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=6, varin=26, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=16, varin=15, theta=0.142857, up=999999999999999983222784.000000
ITER 3: row=34, varin=17, theta=0.166667, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28615060.443468
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 222 nonzeros, 2 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=81, theta=0.384615, up=1.000000
ITER 2: row=15, varin=93, theta=1.000000, up=1.000000
ITER 3: row=32, varin=34, theta=0.416667, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28666524.257079
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.083333
  % @PL 44 rows, 60 cols, 236 nonzeros, 6 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 3 rows, 15 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=39, varin=66, theta=2.000000, up=1.000000
ITER 2: row=39, varin=75, theta=0.500000, up=1.000000
ITER 3: row=9, varin=66, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28723348.197747
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 41 rows, 60 cols, 222 nonzeros, 0 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=74, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28728217.636983
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 43 rows, 60 cols, 228 nonzeros, 0 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 3 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=23, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28732265.742388
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 231 nonzeros, 3 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 1 rows, 40 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=80, theta=0.103647, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28734824.471722
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 42 rows, 60 cols, 265 nonzeros, 0 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=67, theta=0.066962, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28736168.672329
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 273 nonzeros, 0 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 63 LP 1 Solution, length = 28736168.672329, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 1.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.466519 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.466519 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.466519 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.066962 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.533481 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.533481 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.533481 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.533481 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.533481 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28736168.672329, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 63 at  28.73616867232879101834
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e770fa0
% @LO 0.06  28.61506044346823429692 99.9000000000
% @LN 0.06  28.61760714796727000930 99.9000000000
% Resuming node 67 at  28.61760714796727000930
DEBUG CONSTRNT: LP rows=44, pool->nlprows=44, pool->npend=0
DEBUG CONSTRNT: Checking 44 LP rows (pool tracks 44, total LP rows 44)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 143
DEBUG CONSTRNT: Pool row 143 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 73
DEBUG CONSTRNT: Pool row 73 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 60
DEBUG CONSTRNT: Pool row 60 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=43, expected 43
 % @PAP adding 40 rows, 167 nz to LP
DEBUG BB: Processing node 67, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=27, varin=39, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=6, varin=100, theta=0.066667, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28617607.147967
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 227 nonzeros, 4 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 5 rows, 54 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=27, theta=0.351475, up=999999999999999983222784.000000
ITER 2: row=41, varin=99, theta=0.434499, up=1.000000
ITER 3: row=39, varin=50, theta=0.228475, up=1.000000
LP PHASE: Switching to primal (iter=3)
ITER 4: row=17, varin=45, theta=401147.000000, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 29752593.963873
DEBUG SOLUTION: lp->best_solution[1] = 19.639731
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 281 nonzeros, 6 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 6 rows, 24 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=47, theta=8.000000, up=1.000000
ITER 2: row=1, varin=53, theta=7.000000, up=1.000000
ITER 3: row=1, varin=86, theta=12.000000, up=1.000000
ITER 4: row=1, varin=87, theta=11.000000, up=1.000000
ITER 5: row=1, varin=88, theta=10.000000, up=1.000000
ITER 6: row=1, varin=89, theta=9.000000, up=1.000000
ITER 7: row=1, varin=90, theta=8.000000, up=1.000000
ITER 8: row=1, varin=91, theta=7.000000, up=1.000000
ITER 9: row=1, varin=92, theta=6.000000, up=1.000000
ITER 10: row=1, varin=93, theta=5.000000, up=1.000000
LP PHASE: Switching to primal (iter=49)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28623520.354958
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 247 nonzeros, 3 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 67 LP 1 Solution, length = 28623520.354958, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.083333 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.083333 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.083333 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.500000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.083333 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.083333 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.500000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.916667 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.916667 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.916667 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.916667 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.916667 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=28623520.354958, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 67 at  28.62352035495761626294
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e779300
% @LO 0.06  28.61760714796727000930 99.9000000000
% @LN 0.06  28.61891002319844190538 99.9000000000
% Resuming node 68 at  28.61891002319844190538
DEBUG CONSTRNT: LP rows=45, pool->nlprows=45, pool->npend=0
DEBUG CONSTRNT: Checking 45 LP rows (pool tracks 45, total LP rows 45)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 85
DEBUG CONSTRNT: Pool row 85 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=44, expected 44
 % @PAP adding 40 rows, 167 nz to LP
DEBUG BB: Processing node 68, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=27, varin=40, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=40, varin=39, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=6, varin=38, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28618910.023198
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 227 nonzeros, 1 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 19 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=19, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=44, varin=98, theta=2.000000, up=1.000000
ITER 3: row=44, varin=56, theta=0.500000, up=1.000000
ITER 4: row=40, varin=98, theta=3.000000, up=1.000000
ITER 5: row=40, varin=104, theta=0.133333, up=1.000000
ITER 6: row=1, varin=17, theta=0.125000, up=999999999999999983222784.000000
ITER 7: row=43, varin=79, theta=7.000000, up=1.000000
ITER 8: row=43, varin=44, theta=6.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 29137997.773910
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 246 nonzeros, 8 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 8 slack rows
  % @PAP adding 5 rows, 54 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=68, theta=0.779812, up=1.000000
ITER 2: row=37, varin=95, theta=0.148418, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 29151217.420792
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 41 rows, 60 cols, 273 nonzeros, 1 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 5 rows, 19 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=18, theta=0.399965, up=999999999999999983222784.000000
ITER 2: row=45, varin=37, theta=1.280279, up=999999999999999983222784.000000
ITER 3: row=41, varin=70, theta=2.084905, up=1.000000
ITER 4: row=41, varin=68, theta=0.364892, up=1.000000
ITER 5: row=9, varin=70, theta=1.000000, up=1.000000
ITER 6: row=38, varin=50, theta=0.112577, up=1.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 29290394.203388
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 284 nonzeros, 4 slack, 41 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 7 rows, 25 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=41, theta=1.396289, up=999999999999999983222784.000000
ITER 2: row=43, varin=79, theta=1.124907, up=1.000000
ITER 3: row=43, varin=17, theta=0.069916, up=999999999999999983222784.000000
ITER 4: row=28, varin=79, theta=1.000000, up=1.000000
ITER 5: row=44, varin=70, theta=0.668805, up=1.000000
ITER 6: row=48, varin=41, theta=0.287877, up=999999999999999983222784.000000
ITER 7: row=45, varin=48, theta=0.041375, up=999999999999999983222784.000000
ITER 8: row=43, varin=44, theta=0.133463, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 29341513.011620
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 301 nonzeros, 5 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 4 rows, 10 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=71, theta=0.979599, up=1.000000
ITER 2: row=44, varin=32, theta=0.010930, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 29352043.540699
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 282 nonzeros, 1 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=97, theta=5.720263, up=1.000000
ITER 2: row=47, varin=4, theta=0.261012, up=999999999999999983222784.000000
ITER 3: row=26, varin=97, theta=1.000000, up=1.000000
ITER 4: row=29, varin=74, theta=0.778047, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 29389791.544370
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 278 nonzeros, 0 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=9, theta=0.929620, up=999999999999999983222784.000000
ITER 2: row=8, varin=77, theta=0.827888, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=49)
DEBUG SOLUTION: LP solution array indices: FST[50-89], not_covered[90-109]
DEBUG SOLUTION: lp->best_solution[0] = 29418357.683397
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 49 rows, 60 cols, 283 nonzeros, 0 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=50, varin=80, theta=0.808941, up=1.000000
ITER 2: row=25, varin=27, theta=0.370735, up=999999999999999983222784.000000
ITER 3: row=28, varin=17, theta=0.331636, up=999999999999999983222784.000000
ITER 4: row=23, varin=24, theta=0.103200, up=999999999999999983222784.000000
ITER 5: row=51, varin=50, theta=0.026991, up=999999999999999983222784.000000
ITER 6: row=40, varin=6, theta=0.018292, up=999999999999999983222784.000000
ITER 7: row=1, varin=43, theta=0.041662, up=999999999999999983222784.000000
ITER 8: row=18, varin=41, theta=0.115326, up=999999999999999983222784.000000
ITER 9: row=22, varin=34, theta=0.122777, up=999999999999999983222784.000000
ITER 10: row=34, varin=82, theta=0.672487, up=1.000000
LP PHASE: Switching to primal (iter=10)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 29558486.651261
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.934497
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.815503
  % @PL 51 rows, 60 cols, 289 nonzeros, 4 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 4 rows, 11 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=20, theta=0.149744, up=999999999999999983222784.000000
ITER 2: row=48, varin=83, theta=1.157018, up=1.000000
ITER 3: row=48, varin=79, theta=0.202010, up=1.000000
ITER 4: row=46, varin=63, theta=0.357518, up=1.000000
ITER 5: row=30, varin=84, theta=0.260278, up=1.000000
ITER 6: row=49, varin=85, theta=0.854408, up=1.000000
ITER 7: row=44, varin=56, theta=1.246863, up=1.000000
ITER 8: row=44, varin=53, theta=0.035872, up=1.000000
ITER 9: row=37, varin=54, theta=1.000000, up=1.000000
ITER 10: row=5, varin=56, theta=0.784954, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.934497
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.815503
  % @PL 51 rows, 60 cols, 292 nonzeros, 2 slack, 49 tight.
  % Node 68 LP 1 Solution, length = 999999999999999983222784.000000, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.922487 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.327513 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 1.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 1.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.934497 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.815503 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 68 is INFEASIBLE
 %      68    31    infeasible               28621188.4787   x36 U    26    12
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e7725c0
% @LO 0.06  28.61891002319844190538 99.9000000000
% @LN 0.06  28.62118847873899696310 99.9000000000
% Resuming node 51 at  28.62118847873899696310
DEBUG CONSTRNT: LP rows=51, pool->nlprows=51, pool->npend=0
DEBUG CONSTRNT: Checking 51 LP rows (pool tracks 51, total LP rows 51)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=50, expected 50
 % @PAP adding 41 rows, 194 nz to LP
DEBUG BB: Processing node 51, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 51 LP 2 Solution, length = 28621188.478739, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.333076 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.333462 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.333462 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 1.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.333462 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.333462 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.666538 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.666538 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.666538 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.666924 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.666538 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.666538 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.666538 (terminal 19)
 % 5 fractional variables
DEBUG CG: LP optimal, z=28621188.478739, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28621188.478739, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 51 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 51
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.333076
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.333076)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.333462
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.333462)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.333462
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.333462)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=1.000000
DEBUG CAREFUL: Skipping var 14: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.333462
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.333462)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.333462
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.333462)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 5 fractional variables

  %  Carefully choosing branching variable, nfrac = 5
DEBUG CAREFUL: Testing fvar[0] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 10
DEBUG CAREFUL: New best var: 10
DEBUG CAREFUL: Testing fvar[1] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[2] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[3] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[4] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
  % Initial guess is x10, Z0 = 28621188.478739         , Z1 = 28866662.5657095        

DEBUG EVAL: Testing var 10 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=31, theta=1.239632, up=999999999999999983222784.000000
ITER 2: row=1, varin=53, theta=0.299843, up=1.000000
ITER 3: row=35, varin=41, theta=0.354214, up=999999999999999983222784.000000
ITER 4: row=22, varin=64, theta=0.498635, up=1.000000
ITER 5: row=1, varin=28, theta=0.155459, up=999999999999999983222784.000000
ITER 6: row=29, varin=44, theta=0.630324, up=1.000000
DEBUG EVAL: Branch var 10 = 1 gives z=28852737.025964
  % 	x10 = 1,	Z1 = 28866662.5657095        
DEBUG EVAL: First branch cutoff check: z=28866662.565709, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 0
ITER 1: row=7, varin=36, theta=1.891094, up=999999999999999983222784.000000
ITER 2: row=23, varin=12, theta=332965.000000, up=999999999999999983222784.000000
  % 	x10 = 0,	Z0 = 28667035.7355939        
DEBUG EVAL: Second branch cutoff check: z=28667035.735594, best_z=INF, threshold=INF
  %   New best:  x10, Z = 28667035.7355939        
DEBUG EVAL: Testing var 26 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=23, varin=36, theta=0.283476, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 0 gives z=28621560.912856
  % 	x26 = 0,	Z0 = 28621560.9128557        
DEBUG EVAL: First branch cutoff check: z=28621560.912856, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 17 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=22, varin=36, theta=1.891094, up=999999999999999983222784.000000
ITER 2: row=23, varin=12, theta=332965.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 0 gives z=28667035.735594
  % 	x17 = 0,	Z0 = 28667035.7355939        
DEBUG EVAL: First branch cutoff check: z=28667035.735594, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 1
ITER 1: row=22, varin=28, theta=1.806873, up=999999999999999983222784.000000
ITER 2: row=12, varin=13, theta=3.248970, up=999999999999999983222784.000000
ITER 3: row=23, varin=64, theta=2.257091, up=1.000000
ITER 4: row=23, varin=66, theta=4.840560, up=1.000000
ITER 5: row=23, varin=63, theta=0.969819, up=1.000000
ITER 6: row=36, varin=66, theta=9.979875, up=1.000000
ITER 7: row=36, varin=35, theta=2.467836, up=999999999999999983222784.000000
ITER 8: row=30, varin=3, theta=1.471576, up=999999999999999983222784.000000
ITER 9: row=3, varin=57, theta=2.797450, up=1.000000
ITER 10: row=3, varin=7, theta=0.897270, up=999999999999999983222784.000000
  % 	x17 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: Second branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=22, varin=36, theta=1.891094, up=999999999999999983222784.000000
ITER 2: row=23, varin=12, theta=332965.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=41)
DEBUG SOLUTION: LP solution array indices: FST[42-81], not_covered[82-101]
DEBUG SOLUTION: lp->best_solution[0] = 28667035.735594
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 667035.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 41 rows, 60 cols, 254 nonzeros, 1 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 2 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=41, varin=54, theta=0.500000, up=1.000000
ITER 2: row=42, varin=79, theta=0.800000, up=1.000000
ITER 3: row=38, varin=41, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=1, varin=40, theta=0.058824, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=42)
DEBUG SOLUTION: LP solution array indices: FST[43-82], not_covered[83-102]
DEBUG SOLUTION: lp->best_solution[0] = 28671168.784740
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 42 rows, 60 cols, 226 nonzeros, 2 slack, 40 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
   % @PAP adding 8 rows, 35 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=51, theta=1.125000, up=1.000000
ITER 2: row=46, varin=28, theta=0.166667, up=999999999999999983222784.000000
ITER 3: row=41, varin=51, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28675168.729939
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 48 rows, 60 cols, 257 nonzeros, 1 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 51 at  28.67516872993937937508
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e754ad0
% @LO 0.06  28.62118847873899696310 99.9000000000
% @LN 0.06  28.62259130188724398636 99.9000000000
% Resuming node 49 at  28.62259130188724398636
DEBUG CONSTRNT: LP rows=47, pool->nlprows=47, pool->npend=0
DEBUG CONSTRNT: Checking 47 LP rows (pool tracks 47, total LP rows 47)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 150
DEBUG CONSTRNT: Pool row 150 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=46, expected 46
 % @PAP adding 45 rows, 216 nz to LP
DEBUG BB: Processing node 49, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 49 LP 2 Solution, length = 28622591.301887, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.645122 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 1.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.645122 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.354878 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.354878 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.354878 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.354878 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.354878 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28622591.301887, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28622591.301887, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 49 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 49
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.645122
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.645122)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=1.000000
DEBUG CAREFUL: Skipping var 10: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.645122
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.645122)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.354878
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.354878)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 3 fractional variables

  %  Carefully choosing branching variable, nfrac = 3
DEBUG CAREFUL: Testing fvar[0] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
DEBUG CAREFUL: Testing fvar[1] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[2] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 22
DEBUG CAREFUL: New best var: 22
  % Initial guess is x22, Z0 = 28622591.3018872        , Z1 = 28742580.4289045        

DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=43, theta=0.741760, up=999999999999999983222784.000000
ITER 2: row=43, varin=40, theta=0.887882, up=999999999999999983222784.000000
ITER 3: row=35, varin=33, theta=0.308753, up=999999999999999983222784.000000
ITER 4: row=37, varin=36, theta=0.763578, up=999999999999999983222784.000000
ITER 5: row=25, varin=4, theta=0.815288, up=999999999999999983222784.000000
ITER 6: row=1, varin=10, theta=3.176327, up=999999999999999983222784.000000
ITER 7: row=10, varin=23, theta=0.412475, up=999999999999999983222784.000000
ITER 8: row=32, varin=32, theta=1.510459, up=999999999999999983222784.000000
ITER 9: row=33, varin=34, theta=1.526547, up=999999999999999983222784.000000
ITER 10: row=17, varin=70, theta=2.027524, up=1.000000
DEBUG EVAL: Branch var 17 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x17 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=7, varin=32, theta=0.705480, up=999999999999999983222784.000000
ITER 2: row=38, varin=42, theta=2.377264, up=999999999999999983222784.000000
ITER 3: row=17, varin=35, theta=89889.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28698113.638758
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 45 rows, 60 cols, 276 nonzeros, 3 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 3 slack rows
   % @PAP adding 2 rows, 5 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=43, varin=67, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 28720347.033831
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 44 rows, 60 cols, 233 nonzeros, 0 slack, 44 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 4 rows, 19 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=72, theta=0.500000, up=1.000000
ITER 2: row=42, varin=70, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28757445.566211
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 48 rows, 60 cols, 252 nonzeros, 0 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 4 rows, 16 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=49, varin=10, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=9, varin=78, theta=0.500000, up=1.000000
ITER 3: row=38, varin=24, theta=0.041667, up=999999999999999983222784.000000
ITER 4: row=52, varin=80, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28780883.239704
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 52 rows, 60 cols, 268 nonzeros, 0 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=53, varin=83, theta=0.500000, up=1.000000
ITER 2: row=36, varin=38, theta=0.611111, up=999999999999999983222784.000000
ITER 3: row=31, varin=35, theta=0.055556, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 28782740.731715
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 54 rows, 60 cols, 274 nonzeros, 3 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 3 slack rows
   % @PAP adding 5 rows, 21 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=53, varin=89, theta=0.500000, up=1.000000
ITER 2: row=51, varin=88, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=56)
DEBUG SOLUTION: LP solution array indices: FST[57-96], not_covered[97-116]
DEBUG SOLUTION: lp->best_solution[0] = 28819225.955183
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 56 rows, 60 cols, 289 nonzeros, 0 slack, 56 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 2 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=57, varin=2, theta=0.250000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=58)
DEBUG SOLUTION: LP solution array indices: FST[59-98], not_covered[99-118]
DEBUG SOLUTION: lp->best_solution[0] = 28825708.228937
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 0.750000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 58 rows, 60 cols, 301 nonzeros, 1 slack, 57 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 1 slack rows
   % @PAP adding 3 rows, 10 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=59, varin=14, theta=0.100000, up=999999999999999983222784.000000
ITER 2: row=34, varin=15, theta=0.043902, up=999999999999999983222784.000000
ITER 3: row=51, varin=32, theta=0.287671, up=999999999999999983222784.000000
ITER 4: row=58, varin=59, theta=0.044776, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=60)
DEBUG SOLUTION: LP solution array indices: FST[61-100], not_covered[101-120]
DEBUG SOLUTION: lp->best_solution[0] = 28832933.590712
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.917910
   % @PL 60 rows, 60 cols, 309 nonzeros, 9 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 9 slack rows
   % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=92, theta=0.500000, up=1.000000
ITER 2: row=40, varin=30, theta=1.764706, up=999999999999999983222784.000000
ITER 3: row=53, varin=17, theta=0.166667, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28844015.497883
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 53 rows, 60 cols, 271 nonzeros, 2 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 49 at  28.84401549788297458576
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e770fa0
% @LO 0.06  28.62259130188724398636 99.9000000000
% @LN 0.06  28.62352035495761626294 99.9000000000
% Resuming node 67 at  28.62352035495761626294
DEBUG CONSTRNT: LP rows=51, pool->nlprows=51, pool->npend=0
DEBUG CONSTRNT: Checking 51 LP rows (pool tracks 51, total LP rows 51)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 157
DEBUG CONSTRNT: Pool row 157 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 158
DEBUG CONSTRNT: Pool row 158 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 60
DEBUG CONSTRNT: Pool row 60 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 73
DEBUG CONSTRNT: Pool row 73 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 143
DEBUG CONSTRNT: Pool row 143 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 70
DEBUG CONSTRNT: Pool row 70 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=50, expected 50
 % @PAP adding 45 rows, 187 nz to LP
DEBUG BB: Processing node 67, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 67 LP 2 Solution, length = 28623520.354958, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.083333 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.083333 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.083333 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.500000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.083333 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 1.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.083333 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.500000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.916667 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.916667 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.916667 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.916667 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.916667 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=28623520.354958, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28623520.354958, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 67 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 67
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.083333
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.083333)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.083333
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.083333)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.083333
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.083333)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.500000
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.083333
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.083333)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=1.000000
DEBUG CAREFUL: Skipping var 15: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.083333
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.083333)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.500000
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 7 fractional variables

  %  Carefully choosing branching variable, nfrac = 7
DEBUG CAREFUL: Testing fvar[0] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[1] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[2] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 7
DEBUG CAREFUL: New best var: 7
DEBUG CAREFUL: Testing fvar[3] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 34
DEBUG CAREFUL: Testing fvar[4] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 4
DEBUG CAREFUL: Testing fvar[5] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[6] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 11
  % Initial guess is x7, Z0 = 29752593.9638727        , Z1 = 29760364.2252915        

DEBUG EVAL: Testing var 3 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=69, theta=0.500000, up=1.000000
ITER 2: row=8, varin=72, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 3 = 0 gives z=28626484.245002
  % 	x3 = 0,	Z0 = 29752593.9638727        
DEBUG EVAL: First branch cutoff check: z=29752593.963873, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 1
ITER 1: row=6, varin=45, theta=2.750000, up=999999999999999983222784.000000
ITER 2: row=24, varin=18, theta=1.166667, up=999999999999999983222784.000000
ITER 3: row=36, varin=43, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=25, varin=36, theta=5.000000, up=999999999999999983222784.000000
ITER 5: row=19, varin=37, theta=1.500000, up=999999999999999983222784.000000
ITER 6: row=37, varin=35, theta=1.000000, up=999999999999999983222784.000000
  % 	x3 = 1,	Z1 = 29752593.9638727        
DEBUG EVAL: Second branch cutoff check: z=29752593.963873, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 17 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=18, varin=69, theta=0.500000, up=1.000000
ITER 2: row=8, varin=72, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 17 = 0 gives z=28626484.245002
  % 	x17 = 0,	Z0 = 29752593.9638727        
DEBUG EVAL: First branch cutoff check: z=29752593.963873, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 1
ITER 1: row=18, varin=45, theta=2.750000, up=999999999999999983222784.000000
ITER 2: row=24, varin=43, theta=7.000000, up=999999999999999983222784.000000
ITER 3: row=17, varin=37, theta=1.500000, up=999999999999999983222784.000000
ITER 4: row=37, varin=35, theta=1.000000, up=999999999999999983222784.000000
  % 	x17 = 1,	Z1 = 29752593.9638727        
DEBUG EVAL: Second branch cutoff check: z=29752593.963873, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 7 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=17, varin=34, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 7 = 0 gives z=28636737.886477
  % 	x7 = 0,	Z0 = 29752593.9638727        
DEBUG EVAL: First branch cutoff check: z=29752593.963873, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 7 = 1
ITER 1: row=17, varin=43, theta=1.000000, up=999999999999999983222784.000000
  % 	x7 = 1,	Z1 = 29760364.2252915        
DEBUG EVAL: Second branch cutoff check: z=29760364.225291, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 34 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=34, varin=43, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 34 = 0 gives z=28628186.343361
  % 	x34 = 0,	Z0 = 29752593.9638727        
DEBUG EVAL: First branch cutoff check: z=29752593.963873, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 34 = 1
ITER 1: row=34, varin=17, theta=1.000000, up=999999999999999983222784.000000
  % 	x34 = 1,	Z1 = 29752593.9638727        
DEBUG EVAL: Second branch cutoff check: z=29752593.963873, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 4 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=24, varin=45, theta=0.125000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 4 = 0 gives z=28624203.605440
  % 	x4 = 0,	Z0 = 29752593.9638727        
DEBUG EVAL: First branch cutoff check: z=29752593.963873, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 4 = 1
ITER 1: row=24, varin=43, theta=11.000000, up=999999999999999983222784.000000
ITER 2: row=17, varin=37, theta=2.500000, up=999999999999999983222784.000000
ITER 3: row=37, varin=35, theta=3.000000, up=999999999999999983222784.000000
ITER 4: row=1, varin=34, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=34, varin=9, theta=2.000000, up=999999999999999983222784.000000
ITER 6: row=9, varin=30, theta=2.000000, up=999999999999999983222784.000000
ITER 7: row=30, varin=47, theta=2.000000, up=1.000000
ITER 8: row=30, varin=27, theta=0.500000, up=999999999999999983222784.000000
ITER 9: row=27, varin=23, theta=0.500000, up=999999999999999983222784.000000
ITER 10: row=40, varin=24, theta=0.500000, up=999999999999999983222784.000000
  % 	x4 = 1,	Z1 = 29752593.9638727        
DEBUG EVAL: Second branch cutoff check: z=29752593.963873, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=35, theta=0.100000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28625220.572564
  % 	x2 = 0,	Z0 = 29752593.9638727        
DEBUG EVAL: First branch cutoff check: z=29752593.963873, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 1
ITER 1: row=1, varin=45, theta=2.750000, up=999999999999999983222784.000000
ITER 2: row=24, varin=43, theta=7.000000, up=999999999999999983222784.000000
ITER 3: row=17, varin=37, theta=1.500000, up=999999999999999983222784.000000
ITER 4: row=37, varin=34, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=34, varin=9, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=9, varin=30, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=30, varin=47, theta=1.000000, up=1.000000
  % 	x2 = 1,	Z1 = 29752593.9638727        
DEBUG EVAL: Second branch cutoff check: z=29752593.963873, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 11 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=37, varin=69, theta=0.500000, up=1.000000
ITER 2: row=8, varin=72, theta=0.500000, up=1.000000
DEBUG EVAL: Branch var 11 = 0 gives z=28626484.245002
  % 	x11 = 0,	Z0 = 29752593.9638727        
DEBUG EVAL: First branch cutoff check: z=29752593.963873, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 11 = 1
ITER 1: row=37, varin=45, theta=2.750000, up=999999999999999983222784.000000
ITER 2: row=24, varin=43, theta=7.000000, up=999999999999999983222784.000000
ITER 3: row=17, varin=35, theta=3.000000, up=999999999999999983222784.000000
ITER 4: row=1, varin=34, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=34, varin=9, theta=2.000000, up=999999999999999983222784.000000
ITER 6: row=9, varin=30, theta=2.000000, up=999999999999999983222784.000000
ITER 7: row=30, varin=47, theta=2.000000, up=1.000000
ITER 8: row=30, varin=27, theta=0.500000, up=999999999999999983222784.000000
ITER 9: row=27, varin=20, theta=0.500000, up=999999999999999983222784.000000
ITER 10: row=38, varin=24, theta=0.500000, up=999999999999999983222784.000000
  % 	x11 = 1,	Z1 = 29752593.9638727        
DEBUG EVAL: Second branch cutoff check: z=29752593.963873, best_z=INF, threshold=INF
  % 7 consecutive failures: giving up.
  % Best branch is x7, Z0 = 29752593.9638727        , Z1 = 29760364.2252915        

DEBUG CAREFUL: Final result - returning best.var = 7
DEBUG BB: Branching variable chosen: j=7
 % @NC   69   67	x7 = 0	29752593.963873
 % @NC   70   67	x7 = 1	29760364.225291
 %      67    32 28623520.3550               28623670.0850   x36 D    26    12
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e737600
% @LO 0.06  28.62352035495761626294 99.9000000000
% @LN 0.06  28.62367008498757314783 99.9000000000
% Resuming node 65 at  28.62367008498757314783
DEBUG CONSTRNT: LP rows=45, pool->nlprows=45, pool->npend=0
DEBUG CONSTRNT: Checking 45 LP rows (pool tracks 45, total LP rows 45)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 67
DEBUG CONSTRNT: Pool row 67 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 85
DEBUG CONSTRNT: Pool row 85 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=44, expected 44
 % @PAP adding 36 rows, 179 nz to LP
DEBUG BB: Processing node 65, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=71, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=36)
DEBUG SOLUTION: LP solution array indices: FST[37-76], not_covered[77-96]
DEBUG SOLUTION: lp->best_solution[0] = 28623670.084988
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 3.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 36 rows, 60 cols, 239 nonzeros, 0 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 65 LP 1 Solution, length = 28623670.084988, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.500000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.500000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.500000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 2 fractional variables
DEBUG CG: LP optimal, z=28623670.084988, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28623670.084988, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 65 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 65
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.500000
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.500000
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 2 fractional variables

  %  Carefully choosing branching variable, nfrac = 2
DEBUG CAREFUL: Testing fvar[0] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 34
DEBUG CAREFUL: New best var: 34
DEBUG CAREFUL: Testing fvar[1] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
  % Initial guess is x34, Z0 = 28623670.0849876        , Z1 = 28651627.0628067        

DEBUG EVAL: Testing var 34 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=18, varin=30, theta=0.333333, up=999999999999999983222784.000000
ITER 2: row=30, varin=33, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=33, varin=6, theta=0.333333, up=999999999999999983222784.000000
ITER 4: row=6, varin=19, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=19, varin=32, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 34 = 1 gives z=28747340.169975
  % 	x34 = 1,	Z1 = 28747340.1699751        
DEBUG EVAL: First branch cutoff check: z=28747340.169975, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 34 = 0
ITER 1: row=18, varin=73, theta=0.500000, up=1.000000
  % 	x34 = 0,	Z0 = 28623697.9133099        
DEBUG EVAL: Second branch cutoff check: z=28623697.913310, best_z=INF, threshold=INF
  %   New best:  x34, Z = 28623697.9133099        
DEBUG EVAL: Testing var 7 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=27, theta=0.500000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 7 = 0 gives z=28642893.127303
  % 	x7 = 0,	Z0 = 28642893.1273032        
DEBUG EVAL: First branch cutoff check: z=28642893.127303, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 7 = 1
ITER 1: row=1, varin=19, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=19, varin=32, theta=1.000000, up=999999999999999983222784.000000
  % 	x7 = 1,	Z1 = 28747340.1699751        
DEBUG EVAL: Second branch cutoff check: z=28747340.169975, best_z=INF, threshold=INF
  %   New best:  x7, Z = 28642893.1273032        
  % Best branch is x7, Z0 = 28642893.1273032        , Z1 = 28747340.1699751        

DEBUG CAREFUL: Final result - returning best.var = 7
DEBUG BB: Branching variable chosen: j=7
 % @NC   71   65	x7 = 0	28642893.127303
 % @NC   72   65	x7 = 1	28747340.169975
 %      65    33 28623670.0850               28638756.4011    x3 D    42    13
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e74a1c0
% @LO 0.06  28.62367008498757314783 99.9000000000
% @LN 0.06  28.63875640108373588077 99.9000000000
% Resuming node 61 at  28.63875640108373588077
DEBUG CONSTRNT: LP rows=36, pool->nlprows=36, pool->npend=0
DEBUG CONSTRNT: Checking 36 LP rows (pool tracks 36, total LP rows 36)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 162
DEBUG CONSTRNT: Pool row 162 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=35, expected 35
 % @PAP adding 54 rows, 228 nz to LP
DEBUG BB: Processing node 61, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 61 LP 2 Solution, length = 28638756.401084, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.093781 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.093781 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.093781 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.093781 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.343531 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 1.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.093781 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.343531 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.093781 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.093781 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.093781 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.906219 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.906219 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.906219 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.906219 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.906219 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.906219 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.656469 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.656469 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.906219 (terminal 19)
 % 10 fractional variables
DEBUG CG: LP optimal, z=28638756.401084, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28638756.401084, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 61 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 61
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.093781
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.093781)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.093781
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.093781)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.093781
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.093781)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.093781
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.093781)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.343531
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.343531)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=1.000000
DEBUG CAREFUL: Skipping var 16: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.093781
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.093781)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.343531
DEBUG CAREFUL: Adding var 21 to fractional list (xi=0.343531)
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.093781
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.093781)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.093781
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.093781)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.093781
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.093781)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 10 fractional variables

  %  Carefully choosing branching variable, nfrac = 10
DEBUG CAREFUL: Testing fvar[0] = var 21
DEBUG CAREFUL: Calling compare_branch_vars for var 21
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 21
DEBUG CAREFUL: New best var: 21
DEBUG CAREFUL: Testing fvar[1] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 12
DEBUG CAREFUL: Testing fvar[2] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[3] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 3
DEBUG CAREFUL: Testing fvar[4] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 27
DEBUG CAREFUL: Testing fvar[5] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 22
DEBUG CAREFUL: Testing fvar[6] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[7] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[8] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[9] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 4
DEBUG CAREFUL: New best var: 4
  % Initial guess is x4, Z0 = 28638756.4010837        , Z1 = 28869820.3839701        

DEBUG EVAL: Testing var 21 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=29, varin=53, theta=0.767053, up=999999999999999983222784.000000
ITER 2: row=42, varin=52, theta=0.999842, up=999999999999999983222784.000000
ITER 3: row=29, varin=88, theta=2.005324, up=1.000000
ITER 4: row=29, varin=5, theta=0.280410, up=999999999999999983222784.000000
ITER 5: row=26, varin=51, theta=0.638488, up=999999999999999983222784.000000
ITER 6: row=33, varin=43, theta=0.393023, up=999999999999999983222784.000000
ITER 7: row=31, varin=84, theta=1.882738, up=1.000000
ITER 8: row=31, varin=88, theta=0.728716, up=1.000000
ITER 9: row=43, varin=42, theta=0.471792, up=999999999999999983222784.000000
ITER 10: row=40, varin=9, theta=0.531086, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 21 = 1 gives z=28836759.876087
  % 	x21 = 1,	Z1 = 28836759.8760873        
DEBUG EVAL: First branch cutoff check: z=28836759.876087, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 21 = 0
ITER 1: row=29, varin=86, theta=0.348603, up=1.000000
  % 	x21 = 0,	Z0 = 28641523.7963691        
DEBUG EVAL: Second branch cutoff check: z=28641523.796369, best_z=INF, threshold=INF
  %   New best:  x21, Z = 28641523.7963691        
DEBUG EVAL: Testing var 12 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=19, varin=53, theta=0.767053, up=999999999999999983222784.000000
ITER 2: row=42, varin=52, theta=0.999842, up=999999999999999983222784.000000
ITER 3: row=19, varin=88, theta=2.005324, up=1.000000
ITER 4: row=19, varin=5, theta=0.280410, up=999999999999999983222784.000000
ITER 5: row=26, varin=51, theta=0.638488, up=999999999999999983222784.000000
ITER 6: row=33, varin=43, theta=0.393023, up=999999999999999983222784.000000
ITER 7: row=31, varin=84, theta=1.882738, up=1.000000
ITER 8: row=31, varin=88, theta=0.728716, up=1.000000
ITER 9: row=43, varin=42, theta=0.471792, up=999999999999999983222784.000000
ITER 10: row=40, varin=9, theta=0.531086, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 12 = 1 gives z=28767601.875538
  % 	x12 = 1,	Z1 = 28767601.8755379        
DEBUG EVAL: First branch cutoff check: z=28767601.875538, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 0
ITER 1: row=19, varin=86, theta=0.348603, up=1.000000
  % 	x12 = 0,	Z0 = 28641523.7963691        
DEBUG EVAL: Second branch cutoff check: z=28641523.796369, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 17 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=22, varin=88, theta=0.193905, up=1.000000
DEBUG EVAL: Branch var 17 = 0 gives z=28640409.347308
  % 	x17 = 0,	Z0 = 28640409.3473085        
DEBUG EVAL: First branch cutoff check: z=28640409.347308, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 3 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=29, theta=0.110398, up=999999999999999983222784.000000
ITER 2: row=36, varin=88, theta=0.193905, up=1.000000
DEBUG EVAL: Branch var 3 = 0 gives z=28640409.347308
  % 	x3 = 0,	Z0 = 28640409.3473085        
DEBUG EVAL: First branch cutoff check: z=28640409.347308, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 27 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=40, varin=53, theta=0.887932, up=999999999999999983222784.000000
ITER 2: row=42, varin=29, theta=6.020607, up=999999999999999983222784.000000
ITER 3: row=36, varin=50, theta=4.234712, up=999999999999999983222784.000000
ITER 4: row=19, varin=39, theta=5.382662, up=999999999999999983222784.000000
ITER 5: row=1, varin=31, theta=0.977650, up=999999999999999983222784.000000
ITER 6: row=6, varin=67, theta=0.319370, up=1.000000
ITER 7: row=7, varin=36, theta=0.075419, up=999999999999999983222784.000000
ITER 8: row=42, varin=46, theta=0.169609, up=999999999999999983222784.000000
ITER 9: row=13, varin=49, theta=1.348277, up=999999999999999983222784.000000
ITER 10: row=28, varin=22, theta=0.157108, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 27 = 1 gives z=29292561.832446
  % 	x27 = 1,	Z1 = 29292561.8324462        
DEBUG EVAL: First branch cutoff check: z=29292561.832446, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 27 = 0
ITER 1: row=40, varin=88, theta=0.193905, up=1.000000
  % 	x27 = 0,	Z0 = 28640409.3473085        
DEBUG EVAL: Second branch cutoff check: z=28640409.347308, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 22 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=37, varin=88, theta=0.193905, up=1.000000
DEBUG EVAL: Branch var 22 = 0 gives z=28640409.347308
  % 	x22 = 0,	Z0 = 28640409.3473085        
DEBUG EVAL: First branch cutoff check: z=28640409.347308, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=4, varin=88, theta=0.193905, up=1.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28640409.347308
  % 	x2 = 0,	Z0 = 28640409.3473085        
DEBUG EVAL: First branch cutoff check: z=28640409.347308, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=88, theta=0.193905, up=1.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28640409.347308
  % 	x10 = 0,	Z0 = 28640409.3473085        
DEBUG EVAL: First branch cutoff check: z=28640409.347308, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 26 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=33, varin=88, theta=0.193905, up=1.000000
DEBUG EVAL: Branch var 26 = 0 gives z=28640409.347308
  % 	x26 = 0,	Z0 = 28640409.3473085        
DEBUG EVAL: First branch cutoff check: z=28640409.347308, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 4 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=13, varin=53, theta=0.887932, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 4 = 1 gives z=28645257.091050
  % 	x4 = 1,	Z1 = 28869820.3839701        
DEBUG EVAL: First branch cutoff check: z=28869820.383970, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 4 = 0
ITER 1: row=13, varin=88, theta=0.193905, up=1.000000
  % 	x4 = 0,	Z0 = 28640409.3473085        
DEBUG EVAL: Second branch cutoff check: z=28640409.347308, best_z=INF, threshold=INF
  % Best branch is x21, Z0 = 28641523.7963691        , Z1 = 28836759.8760873        

DEBUG CAREFUL: Final result - returning best.var = 21
DEBUG BB: Branching variable chosen: j=21
 % @NC   73   61	x21 = 0	28641523.796369
 % @NC   74   61	x21 = 1	28836759.876087
 %      61    34 28638756.4011               28640410.8672   x24 D    57     6
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e74b490
% @LO 0.06  28.63875640108373588077 99.9000000000
% @LN 0.06  28.64041086723239715184 99.9000000000
% Resuming node 53 at  28.64041086723239715184
DEBUG CONSTRNT: LP rows=54, pool->nlprows=54, pool->npend=0
DEBUG CONSTRNT: Checking 54 LP rows (pool tracks 54, total LP rows 54)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 137
DEBUG CONSTRNT: Pool row 137 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=53, expected 53
 % @PAP adding 50 rows, 185 nz to LP
DEBUG BB: Processing node 53, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 53 LP 2 Solution, length = 28640410.867232, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.250000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.250000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.250000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.250000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.250000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.250000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.250000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.250000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.250000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.750000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.750000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.750000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.750000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.750000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.750000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.750000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.750000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.750000 (terminal 19)
 % 9 fractional variables
DEBUG CG: LP optimal, z=28640410.867232, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28640410.867232, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 53 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 53
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.250000
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.250000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.250000
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.250000
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=1.000000
DEBUG CAREFUL: Skipping var 19: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.250000
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.250000
DEBUG CAREFUL: Adding var 27 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.250000
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.250000
DEBUG CAREFUL: Adding var 31 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.250000
DEBUG CAREFUL: Adding var 32 to fractional list (xi=0.250000)
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 9 fractional variables

  %  Carefully choosing branching variable, nfrac = 9
DEBUG CAREFUL: Testing fvar[0] = var 27
DEBUG CAREFUL: Calling compare_branch_vars for var 27
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 27
DEBUG CAREFUL: New best var: 27
DEBUG CAREFUL: Testing fvar[1] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 11
DEBUG CAREFUL: Testing fvar[2] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[3] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[4] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[5] = var 32
DEBUG CAREFUL: Calling compare_branch_vars for var 32
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 32
DEBUG CAREFUL: Testing fvar[6] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[7] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 29
DEBUG CAREFUL: Testing fvar[8] = var 31
DEBUG CAREFUL: Calling compare_branch_vars for var 31
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 31
  % Initial guess is x27, Z0 = 28640410.8672324        , Z1 = 28804707.5590403        

DEBUG EVAL: Testing var 27 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=36, varin=49, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=11, varin=47, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=42, varin=45, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=1, varin=43, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=43, varin=39, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=39, varin=18, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=18, varin=36, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 27 = 1 gives z=28804707.559040
  % 	x27 = 1,	Z1 = 28804707.5590403        
DEBUG EVAL: First branch cutoff check: z=28804707.559040, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 27 = 0
ITER 1: row=36, varin=89, theta=1.000000, up=1.000000
  % 	x27 = 0,	Z0 = 28664419.4228127        
DEBUG EVAL: Second branch cutoff check: z=28664419.422813, best_z=INF, threshold=INF
  %   New best:  x27, Z = 28664419.4228127        
DEBUG EVAL: Testing var 11 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=20, varin=49, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=11, varin=47, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=42, varin=45, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=1, varin=43, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=43, varin=39, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=39, varin=18, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=18, varin=42, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 11 = 1 gives z=28777952.001026
  % 	x11 = 1,	Z1 = 28777952.0010265        
DEBUG EVAL: First branch cutoff check: z=28777952.001026, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 11 = 0
ITER 1: row=20, varin=89, theta=1.000000, up=1.000000
  % 	x11 = 0,	Z0 = 28664419.4228127        
DEBUG EVAL: Second branch cutoff check: z=28664419.422813, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 2 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=49, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=11, varin=47, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=42, varin=45, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=1, varin=43, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=43, varin=39, theta=1.000000, up=999999999999999983222784.000000
ITER 6: row=39, varin=18, theta=1.000000, up=999999999999999983222784.000000
ITER 7: row=18, varin=42, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 1 gives z=28777952.001026
  % 	x2 = 1,	Z1 = 28777952.0010265        
DEBUG EVAL: First branch cutoff check: z=28777952.001026, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 0
ITER 1: row=3, varin=89, theta=1.000000, up=1.000000
  % 	x2 = 0,	Z0 = 28664419.4228127        
DEBUG EVAL: Second branch cutoff check: z=28664419.422813, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 26 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=30, varin=31, theta=0.285714, up=999999999999999983222784.000000
ITER 2: row=10, varin=89, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 26 = 0 gives z=28664419.422813
  % 	x26 = 0,	Z0 = 28664419.4228127        
DEBUG EVAL: First branch cutoff check: z=28664419.422813, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 1
ITER 1: row=30, varin=49, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=11, varin=44, theta=0.750000, up=999999999999999983222784.000000
  % 	x26 = 1,	Z1 = 28677626.8103016        
DEBUG EVAL: Second branch cutoff check: z=28677626.810302, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=9, varin=89, theta=1.000000, up=1.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28664419.422813
  % 	x10 = 0,	Z0 = 28664419.4228127        
DEBUG EVAL: First branch cutoff check: z=28664419.422813, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 10 = 1
ITER 1: row=9, varin=49, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=11, varin=44, theta=0.750000, up=999999999999999983222784.000000
  % 	x10 = 1,	Z1 = 28677626.8103016        
DEBUG EVAL: Second branch cutoff check: z=28677626.810302, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 32 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=43, varin=49, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=11, varin=47, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=42, varin=39, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=39, varin=18, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=18, varin=42, theta=2.000000, up=999999999999999983222784.000000
ITER 6: row=36, varin=36, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 32 = 1 gives z=28867910.089725
  % 	x32 = 1,	Z1 = 28867910.0897251        
DEBUG EVAL: First branch cutoff check: z=28867910.089725, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 32 = 0
ITER 1: row=43, varin=45, theta=0.333333, up=999999999999999983222784.000000
  % 	x32 = 0,	Z0 = 28650168.8120525        
DEBUG EVAL: Second branch cutoff check: z=28650168.812052, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=45, theta=0.333333, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 0 gives z=28650168.812052
  % 	x1 = 0,	Z0 = 28650168.8120525        
DEBUG EVAL: First branch cutoff check: z=28650168.812052, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 29 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=25, varin=45, theta=0.333333, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 29 = 0 gives z=28650168.812052
  % 	x29 = 0,	Z0 = 28650168.8120525        
DEBUG EVAL: First branch cutoff check: z=28650168.812052, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 31 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=42, varin=49, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=11, varin=45, theta=3.000000, up=999999999999999983222784.000000
ITER 3: row=1, varin=43, theta=2.000000, up=999999999999999983222784.000000
ITER 4: row=43, varin=39, theta=2.000000, up=999999999999999983222784.000000
ITER 5: row=39, varin=18, theta=2.000000, up=999999999999999983222784.000000
ITER 6: row=18, varin=42, theta=2.000000, up=999999999999999983222784.000000
ITER 7: row=36, varin=36, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 31 = 1 gives z=28881392.989997
  % 	x31 = 1,	Z1 = 28881392.9899966        
DEBUG EVAL: First branch cutoff check: z=28881392.989997, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 31 = 0
ITER 1: row=42, varin=47, theta=0.333333, up=999999999999999983222784.000000
  % 	x31 = 0,	Z0 = 28645674.511962         
DEBUG EVAL: Second branch cutoff check: z=28645674.511962, best_z=INF, threshold=INF
  % Best branch is x27, Z0 = 28664419.4228127        , Z1 = 28804707.5590403        

DEBUG CAREFUL: Final result - returning best.var = 27
DEBUG BB: Branching variable chosen: j=27
 % @NC   75   53	x27 = 0	28664419.422813
 % @NC   76   53	x27 = 1	28804707.559040
 %      53    35 28640410.8672               28641523.7964    x4 D    37     4
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e737600
% @LO 0.06  28.64041086723239715184 99.9000000000
% @LN 0.06  28.64152379636913892114 99.9000000000
% Resuming node 73 at  28.64152379636913892114
DEBUG CONSTRNT: LP rows=50, pool->nlprows=50, pool->npend=0
DEBUG CONSTRNT: Checking 50 LP rows (pool tracks 50, total LP rows 50)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=49, expected 49
 % @PAP adding 54 rows, 228 nz to LP
DEBUG BB: Processing node 73, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=29, varin=86, theta=0.348603, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 28641523.796369
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 54 rows, 60 cols, 288 nonzeros, 0 slack, 54 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 2 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=55, varin=29, theta=1.246195, up=999999999999999983222784.000000
ITER 2: row=36, varin=89, theta=1.809681, up=1.000000
ITER 3: row=36, varin=50, theta=0.093045, up=999999999999999983222784.000000
ITER 4: row=6, varin=89, theta=1.178355, up=1.000000
ITER 5: row=6, varin=53, theta=0.062765, up=999999999999999983222784.000000
ITER 6: row=46, varin=39, theta=0.092717, up=999999999999999983222784.000000
ITER 7: row=1, varin=89, theta=0.416594, up=1.000000
ITER 8: row=32, varin=56, theta=0.133507, up=1.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 28657157.476375
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 55 rows, 60 cols, 290 nonzeros, 3 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 6 rows, 17 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=53, varin=91, theta=0.666198, up=1.000000
ITER 2: row=1, varin=31, theta=0.143719, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=58)
DEBUG SOLUTION: LP solution array indices: FST[59-98], not_covered[99-118]
DEBUG SOLUTION: lp->best_solution[0] = 28724980.637003
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 58 rows, 60 cols, 301 nonzeros, 7 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 7 slack rows
  % @PAP adding 4 rows, 10 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=54, varin=93, theta=0.420883, up=1.000000
ITER 2: row=52, varin=5, theta=0.117591, up=999999999999999983222784.000000
ITER 3: row=53, varin=54, theta=0.145505, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=55)
DEBUG SOLUTION: LP solution array indices: FST[56-95], not_covered[96-115]
DEBUG SOLUTION: lp->best_solution[0] = 28731838.450131
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 55 rows, 60 cols, 294 nonzeros, 2 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 4 rows, 20 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=54, varin=47, theta=0.083454, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=57)
DEBUG SOLUTION: LP solution array indices: FST[58-97], not_covered[98-117]
DEBUG SOLUTION: lp->best_solution[0] = 28754316.817771
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 57 rows, 60 cols, 308 nonzeros, 4 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % Node 73 LP 1 Solution, length = 28754316.817771, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.291365 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.083454 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.083454 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 1.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.083454 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.083454 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.291365 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.291365 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.916546 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.708635 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.708635 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.916546 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.916546 (terminal 19)
 % 7 fractional variables
DEBUG CG: LP optimal, z=28754316.817771, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 73 at  28.75431681777091341701
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e770fa0
% @LO 0.06  28.64152379636913892114 99.9000000000
% @LN 0.06  28.64289312730320702372 99.9000000000
% Resuming node 71 at  28.64289312730320702372
DEBUG CONSTRNT: LP rows=53, pool->nlprows=53, pool->npend=0
DEBUG CONSTRNT: Checking 53 LP rows (pool tracks 53, total LP rows 53)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 11
DEBUG CONSTRNT: Pool row 11 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 82
DEBUG CONSTRNT: Pool row 82 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 49
DEBUG CONSTRNT: Pool row 49 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 68
DEBUG CONSTRNT: Pool row 68 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 137
DEBUG CONSTRNT: Pool row 137 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=52, expected 52
 % @PAP adding 36 rows, 179 nz to LP
DEBUG BB: Processing node 71, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=27, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=36)
DEBUG SOLUTION: LP solution array indices: FST[37-76], not_covered[77-96]
DEBUG SOLUTION: lp->best_solution[0] = 28642893.127303
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 3.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 36 rows, 60 cols, 239 nonzeros, 3 slack, 33 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 27 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=37, varin=77, theta=0.500000, up=1.000000
ITER 2: row=40, varin=94, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28643333.799234
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 0.500000
DEBUG SOLUTION: lp->best_solution[8] = 0.500000
DEBUG SOLUTION: lp->best_solution[9] = 2.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 40 rows, 60 cols, 266 nonzeros, 6 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % Node 71 LP 1 Solution, length = 28643333.799234, 0.01 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.500000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.500000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.500000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.500000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.500000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.500000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.500000 (terminal 19)
 % 2 fractional variables
DEBUG CG: LP optimal, z=28643333.799234, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
 % @LO 0.07  28.64289312730320702372 99.9000000000
 % @LN 0.07  28.64333379923419542479 99.9000000000
DEBUG CG: Second cutoff check: z=28643333.799234, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 71 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 71
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.500000
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.500000
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 2 fractional variables

  %  Carefully choosing branching variable, nfrac = 2
DEBUG CAREFUL: Testing fvar[0] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 2
DEBUG CAREFUL: New best var: 2
DEBUG CAREFUL: Testing fvar[1] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 17
DEBUG CAREFUL: New best var: 17
  % Initial guess is x17, Z0 = 28643333.7992342        , Z1 = 28678165.3197957        

DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=59, theta=0.666667, up=1.000000
ITER 2: row=9, varin=15, theta=0.066667, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28650456.049900
  % 	x2 = 0,	Z0 = 28650456.0498995        
DEBUG EVAL: First branch cutoff check: z=28650456.049900, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 2 = 1
ITER 1: row=1, varin=34, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=34, varin=31, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=31, varin=24, theta=0.333333, up=999999999999999983222784.000000
ITER 4: row=24, varin=27, theta=0.500000, up=999999999999999983222784.000000
ITER 5: row=27, varin=19, theta=1.000000, up=999999999999999983222784.000000
  % 	x2 = 1,	Z1 = 28756773.056953         
DEBUG EVAL: Second branch cutoff check: z=28756773.056953, best_z=INF, threshold=INF
  %   New best:  x2, Z = 28650456.0498995        
DEBUG EVAL: Testing var 17 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=26, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 1 gives z=28786667.598468
  % 	x17 = 1,	Z1 = 28786667.5984684        
DEBUG EVAL: First branch cutoff check: z=28786667.598468, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 17 = 0
ITER 1: row=6, varin=59, theta=2.000000, up=1.000000
ITER 2: row=6, varin=24, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=9, varin=59, theta=1.000000, up=1.000000
ITER 4: row=1, varin=15, theta=0.111111, up=999999999999999983222784.000000
ITER 5: row=24, varin=4, theta=1.142857, up=999999999999999983222784.000000
ITER 6: row=34, varin=31, theta=1.142857, up=999999999999999983222784.000000
ITER 7: row=31, varin=37, theta=1.000000, up=1.000000
ITER 8: row=29, varin=10, theta=1.000000, up=999999999999999983222784.000000
  % 	x17 = 0,	Z0 = 28701379.9928164        
DEBUG EVAL: Second branch cutoff check: z=28701379.992816, best_z=INF, threshold=INF
  %   New best:  x17, Z = 28701379.9928164        
  % Best branch is x17, Z0 = 28701379.9928164        , Z1 = 28786667.5984684        

DEBUG CAREFUL: Final result - returning best.var = 17
DEBUG BB: Branching variable chosen: j=17
 % @NC   77   71	x17 = 0	28701379.992816
 % @NC   78   71	x17 = 1	28786667.598468
 %      71    36 28643333.7992               28644325.8101    x7 D    65    14
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e777d40
% @LO 0.07  28.64333379923419542479 99.9000000000
% @LN 0.07  28.64432581014597545277 99.9000000000
% Resuming node 64 at  28.64432581014597545277
DEBUG CONSTRNT: LP rows=34, pool->nlprows=34, pool->npend=0
DEBUG CONSTRNT: Checking 34 LP rows (pool tracks 34, total LP rows 34)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 61
DEBUG CONSTRNT: Pool row 61 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 162
DEBUG CONSTRNT: Pool row 162 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 71
DEBUG CONSTRNT: Pool row 71 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 73
DEBUG CONSTRNT: Pool row 73 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 85
DEBUG CONSTRNT: Pool row 85 has lprow=33, expected 33
 % @PAP adding 40 rows, 162 nz to LP
DEBUG BB: Processing node 64, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=6, varin=39, theta=3.000000, up=999999999999999983222784.000000
ITER 2: row=39, varin=36, theta=1.500000, up=999999999999999983222784.000000
ITER 3: row=25, varin=35, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=40)
DEBUG SOLUTION: LP solution array indices: FST[41-80], not_covered[81-100]
DEBUG SOLUTION: lp->best_solution[0] = 28644325.810146
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 40 rows, 60 cols, 222 nonzeros, 4 slack, 36 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 54 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=18, theta=0.639781, up=999999999999999983222784.000000
ITER 2: row=32, varin=31, theta=14.698078, up=999999999999999983222784.000000
ITER 3: row=31, varin=71, theta=1.768183, up=1.000000
ITER 4: row=31, varin=34, theta=62.214351, up=999999999999999983222784.000000
ITER 5: row=34, varin=19, theta=0.324256, up=999999999999999983222784.000000
ITER 6: row=39, varin=71, theta=1.000000, up=1.000000
ITER 7: row=27, varin=24, theta=1.116341, up=999999999999999983222784.000000
ITER 8: row=31, varin=67, theta=1.525268, up=1.000000
ITER 9: row=31, varin=69, theta=2.022601, up=1.000000
ITER 10: row=31, varin=66, theta=0.258227, up=1.000000
LP PHASE: Switching to primal (iter=15)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 29350139.045102
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 276 nonzeros, 5 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 5 rows, 19 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=40, varin=17, theta=0.059698, up=999999999999999983222784.000000
ITER 2: row=44, varin=68, theta=1.207496, up=1.000000
ITER 3: row=44, varin=72, theta=0.161342, up=1.000000
ITER 4: row=31, varin=67, theta=0.060393, up=1.000000
ITER 5: row=33, varin=47, theta=0.195395, up=1.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=44)
DEBUG SOLUTION: LP solution array indices: FST[45-84], not_covered[85-104]
DEBUG SOLUTION: lp->best_solution[0] = 29417700.246356
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 44 rows, 60 cols, 285 nonzeros, 1 slack, 43 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 4 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=44, varin=71, theta=1.000000, up=1.000000
ITER 2: row=1, varin=32, theta=0.022868, up=999999999999999983222784.000000
ITER 3: row=35, varin=84, theta=0.053976, up=1.000000
ITER 4: row=47, varin=82, theta=0.067126, up=1.000000
ITER 5: row=28, varin=44, theta=0.078574, up=999999999999999983222784.000000
ITER 6: row=9, varin=52, theta=0.026303, up=1.000000
ITER 7: row=1, varin=81, theta=0.085721, up=1.000000
ITER 8: row=45, varin=16, theta=0.011160, up=999999999999999983222784.000000
ITER 9: row=21, varin=73, theta=0.085022, up=1.000000
ITER 10: row=42, varin=96, theta=0.030100, up=1.000000
LP PHASE: Switching to primal (iter=10)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 29452918.934390
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.969900
  % @PL 47 rows, 60 cols, 297 nonzeros, 5 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 5 slack rows
  % @PAP adding 6 rows, 21 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=77, theta=0.960792, up=1.000000
ITER 2: row=45, varin=25, theta=3.227501, up=999999999999999983222784.000000
ITER 3: row=1, varin=17, theta=0.111207, up=999999999999999983222784.000000
ITER 4: row=48, varin=13, theta=0.019204, up=999999999999999983222784.000000
ITER 5: row=45, varin=18, theta=0.010186, up=999999999999999983222784.000000
ITER 6: row=26, varin=24, theta=0.009860, up=999999999999999983222784.000000
ITER 7: row=47, varin=27, theta=0.002269, up=999999999999999983222784.000000
ITER 8: row=43, varin=47, theta=0.000415, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 29542160.364105
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.978191
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 304 nonzeros, 9 slack, 39 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 9 slack rows
  % @PAP adding 6 rows, 16 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=42, varin=74, theta=1.000000, up=1.000000
ITER 2: row=44, varin=78, theta=1.317931, up=1.000000
ITER 3: row=44, varin=77, theta=0.306432, up=1.000000
ITER 4: row=1, varin=48, theta=0.449414, up=1.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 29661709.197429
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 295 nonzeros, 0 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=80, theta=0.426774, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 29667459.984477
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 301 nonzeros, 1 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 64 LP 1 Solution, length = 29667459.984477, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 1.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.573226 (FST 2)
  % DEBUG LP_VARS: x[3] = 1.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.426774 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.426774 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.573226 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.426774 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=29667459.984477, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 64 at  29.66745998447689913746
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e74a340
% @LO 0.07  28.64432581014597545277 99.9000000000
% @LN 0.07  28.65264968936688561030 99.9000000000
% Resuming node 14 at  28.65264968936688561030
DEBUG CONSTRNT: LP rows=46, pool->nlprows=46, pool->npend=0
DEBUG CONSTRNT: Checking 46 LP rows (pool tracks 46, total LP rows 46)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 143
DEBUG CONSTRNT: Pool row 143 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 73
DEBUG CONSTRNT: Pool row 73 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 122
DEBUG CONSTRNT: Pool row 122 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 139
DEBUG CONSTRNT: Pool row 139 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 140
DEBUG CONSTRNT: Pool row 140 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 144
DEBUG CONSTRNT: Pool row 144 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 133
DEBUG CONSTRNT: Pool row 133 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 70
DEBUG CONSTRNT: Pool row 70 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=45, expected 45
 % @PAP adding 52 rows, 226 nz to LP
DEBUG BB: Processing node 14, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 14 LP 3 Solution, length = 28652649.689367, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.335280 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.335280 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.094960 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.094960 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.094960 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.094960 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.094960 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.094960 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.094960 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.335280 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.664720 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.905040 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.664720 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.664720 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.905040 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.664720 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.905040 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.905040 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.905040 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.905040 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.905040 (terminal 19)
 % 10 fractional variables
DEBUG CG: LP optimal, z=28652649.689367, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28652649.689367, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 3 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 14 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 14
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.335280
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.335280)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.335280
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.335280)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.094960
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.094960)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.094960
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.094960)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.094960
DEBUG CAREFUL: Adding var 4 to fractional list (xi=0.094960)
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=1.000000
DEBUG CAREFUL: Skipping var 8: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.094960
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.094960)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.094960
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.094960)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.094960
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.094960)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.094960
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.094960)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.335280
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.335280)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 10 fractional variables

  %  Carefully choosing branching variable, nfrac = 10
DEBUG CAREFUL: Testing fvar[0] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[1] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[2] = var 4
DEBUG CAREFUL: Calling compare_branch_vars for var 4
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 4
DEBUG CAREFUL: Testing fvar[3] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[4] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[5] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 11
DEBUG CAREFUL: Testing fvar[6] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[7] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[8] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 29
DEBUG CAREFUL: Testing fvar[9] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
  % Initial guess is x3, Z0 = 28652649.6893669        , Z1 = 29469766.0513923        

DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=10, theta=3.406258, up=999999999999999983222784.000000
ITER 2: row=10, varin=51, theta=2.370277, up=999999999999999983222784.000000
ITER 3: row=13, varin=48, theta=1.332811, up=999999999999999983222784.000000
ITER 4: row=1, varin=75, theta=2.338521, up=1.000000
ITER 5: row=1, varin=21, theta=0.671701, up=999999999999999983222784.000000
ITER 6: row=35, varin=75, theta=0.826791, up=1.000000
ITER 7: row=46, varin=14, theta=2.737218, up=999999999999999983222784.000000
ITER 8: row=6, varin=29, theta=1.053150, up=999999999999999983222784.000000
ITER 9: row=43, varin=42, theta=1.647803, up=999999999999999983222784.000000
ITER 10: row=42, varin=45, theta=3.480709, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 1 gives z=29755438.424932
  % 	x3 = 1,	Z1 = 29755438.4249317        
DEBUG EVAL: First branch cutoff check: z=29755438.424932, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=7, varin=75, theta=0.308031, up=1.000000
  % 	x3 = 0,	Z0 = 28654616.7256971        
DEBUG EVAL: Second branch cutoff check: z=28654616.725697, best_z=INF, threshold=INF
  %   New best:  x3, Z = 28654616.7256971        
DEBUG EVAL: Testing var 26 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=39, varin=75, theta=0.308031, up=1.000000
DEBUG EVAL: Branch var 26 = 0 gives z=28654616.725697
  % 	x26 = 0,	Z0 = 28654616.7256971        
DEBUG EVAL: First branch cutoff check: z=28654616.725697, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 1
ITER 1: row=39, varin=10, theta=3.406258, up=999999999999999983222784.000000
ITER 2: row=10, varin=44, theta=1.176598, up=999999999999999983222784.000000
ITER 3: row=1, varin=8, theta=0.799695, up=999999999999999983222784.000000
ITER 4: row=41, varin=75, theta=2.144853, up=1.000000
ITER 5: row=41, varin=77, theta=3.618047, up=1.000000
ITER 6: row=41, varin=34, theta=0.659348, up=999999999999999983222784.000000
ITER 7: row=47, varin=51, theta=1.545141, up=999999999999999983222784.000000
ITER 8: row=13, varin=77, theta=1.253768, up=1.000000
ITER 9: row=13, varin=75, theta=0.089512, up=1.000000
  % 	x26 = 1,	Z1 = 28975582.8594271        
DEBUG EVAL: Second branch cutoff check: z=28975582.859427, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 4 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=13, varin=10, theta=3.406258, up=999999999999999983222784.000000
ITER 2: row=10, varin=48, theta=2.305469, up=999999999999999983222784.000000
ITER 3: row=4, varin=35, theta=1.082900, up=999999999999999983222784.000000
ITER 4: row=50, varin=75, theta=2.434356, up=1.000000
ITER 5: row=50, varin=21, theta=0.719793, up=999999999999999983222784.000000
ITER 6: row=35, varin=75, theta=1.776967, up=1.000000
ITER 7: row=35, varin=42, theta=1.295979, up=999999999999999983222784.000000
ITER 8: row=46, varin=29, theta=3.186821, up=999999999999999983222784.000000
ITER 9: row=43, varin=75, theta=2.417599, up=1.000000
ITER 10: row=43, varin=14, theta=2.440420, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 4 = 1 gives z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
  % 	x4 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: First branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=13, varin=75, theta=0.308031, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28654616.725697
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 52 rows, 60 cols, 286 nonzeros, 0 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @PAP adding 6 rows, 24 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=57, varin=51, theta=0.064101, up=999999999999999983222784.000000
ITER 2: row=53, varin=89, theta=0.097467, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=58)
DEBUG SOLUTION: LP solution array indices: FST[59-98], not_covered[99-118]
DEBUG SOLUTION: lp->best_solution[0] = 28659552.243036
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 58 rows, 60 cols, 310 nonzeros, 6 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 6 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 14 at  28.65955224303615622716
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e74b550
% @LO 0.07  28.65264968936688561030 99.9000000000
% @LN 0.07  28.65853448994280228135 99.9000000000
% Resuming node 55 at  28.65853448994280228135
DEBUG CONSTRNT: LP rows=52, pool->nlprows=52, pool->npend=0
DEBUG CONSTRNT: Checking 52 LP rows (pool tracks 52, total LP rows 52)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 62
DEBUG CONSTRNT: Pool row 62 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=51, expected 51
 % @PAP adding 45 rows, 212 nz to LP
DEBUG BB: Processing node 55, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=19, varin=33, theta=0.525552, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
ITER 2: row=2, varin=47, theta=1.000000, up=1.000000
ITER 3: row=19, varin=22, theta=0.037689, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=45)
DEBUG SOLUTION: LP solution array indices: FST[46-85], not_covered[86-105]
DEBUG SOLUTION: lp->best_solution[0] = 28611594.214655
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 45 rows, 60 cols, 272 nonzeros, 7 slack, 38 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 7 rows, 34 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=94, theta=0.500000, up=1.000000
ITER 2: row=46, varin=59, theta=0.274742, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28640782.545660
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.500000
DEBUG SOLUTION: lp->best_solution[4] = 0.500000
DEBUG SOLUTION: lp->best_solution[5] = 2.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 306 nonzeros, 7 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 8 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=53, varin=84, theta=0.510756, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 28651365.314318
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.500000
DEBUG SOLUTION: lp->best_solution[4] = 0.500000
DEBUG SOLUTION: lp->best_solution[5] = 2.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 54 rows, 60 cols, 314 nonzeros, 7 slack, 47 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 9 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=58, varin=52, theta=0.012483, up=999999999999999983222784.000000
ITER 2: row=55, varin=85, theta=0.010499, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=58)
DEBUG SOLUTION: LP solution array indices: FST[59-98], not_covered[99-118]
DEBUG SOLUTION: lp->best_solution[0] = 28652153.542961
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.500000
DEBUG SOLUTION: lp->best_solution[4] = 0.500000
DEBUG SOLUTION: lp->best_solution[5] = 2.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 58 rows, 60 cols, 323 nonzeros, 7 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 17 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=59, varin=97, theta=0.012590, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=62)
DEBUG SOLUTION: LP solution array indices: FST[63-102], not_covered[103-122]
DEBUG SOLUTION: lp->best_solution[0] = 28652418.713578
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 0.500000
DEBUG SOLUTION: lp->best_solution[4] = 0.500000
DEBUG SOLUTION: lp->best_solution[5] = 2.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 3.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 62 rows, 60 cols, 340 nonzeros, 7 slack, 55 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % Node 55 LP 1 Solution, length = 28652418.713578, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.500000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.487410 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.487410 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 1.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.500000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.012590 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.500000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.512590 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.512590 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.512590 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 6 fractional variables
DEBUG CG: LP optimal, z=28652418.713578, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28652418.713578, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 2 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 55 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 55
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.500000
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.500000
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.487410
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.487410)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.487410
DEBUG CAREFUL: Adding var 7 to fractional list (xi=0.487410)
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=1.000000
DEBUG CAREFUL: Skipping var 12: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.500000
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.012590
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.012590)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 6 fractional variables

  %  Carefully choosing branching variable, nfrac = 6
DEBUG CAREFUL: Testing fvar[0] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 29
DEBUG CAREFUL: New best var: 29
DEBUG CAREFUL: Testing fvar[1] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[2] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
DEBUG CAREFUL: Testing fvar[3] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 34
DEBUG CAREFUL: New best var: 34
DEBUG CAREFUL: Testing fvar[4] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 5
DEBUG CAREFUL: Testing fvar[5] = var 7
DEBUG CAREFUL: Calling compare_branch_vars for var 7
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 7
  % Initial guess is x34, Z0 = 28652418.7135779        , Z1 = 28742156.0820377        

DEBUG EVAL: Testing var 29 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=24, varin=7, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=56, varin=8, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=28, varin=99, theta=0.627866, up=1.000000
DEBUG EVAL: Branch var 29 = 1 gives z=29240751.793750
  % 	x29 = 1,	Z1 = 29240751.7937503        
DEBUG EVAL: First branch cutoff check: z=29240751.793750, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 29 = 0
ITER 1: row=24, varin=58, theta=1.000000, up=999999999999999983222784.000000
  % 	x29 = 0,	Z0 = 28673127.7571539        
DEBUG EVAL: Second branch cutoff check: z=28673127.757154, best_z=INF, threshold=INF
  %   New best:  x29, Z = 28673127.7571539        
DEBUG EVAL: Testing var 1 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=55, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=52, varin=37, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=28, varin=99, theta=0.836613, up=1.000000
DEBUG EVAL: Branch var 1 = 1 gives z=28910125.393881
  % 	x1 = 1,	Z1 = 28910125.3938812        
DEBUG EVAL: First branch cutoff check: z=28910125.393881, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 0
ITER 1: row=2, varin=58, theta=1.000000, up=999999999999999983222784.000000
  % 	x1 = 0,	Z0 = 28673127.7571539        
DEBUG EVAL: Second branch cutoff check: z=28673127.757154, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 0 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=55, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=52, varin=6, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=40, varin=7, theta=0.400000, up=999999999999999983222784.000000
ITER 4: row=56, varin=58, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=39, varin=40, theta=4.000000, up=999999999999999983222784.000000
ITER 6: row=28, varin=99, theta=1.019173, up=1.000000
ITER 7: row=28, varin=116, theta=0.019118, up=1.000000
ITER 8: row=42, varin=99, theta=6.671573, up=1.000000
ITER 9: row=42, varin=41, theta=0.021035, up=999999999999999983222784.000000
ITER 10: row=49, varin=99, theta=1.052649, up=1.000000
DEBUG EVAL: Branch var 0 = 1 gives z=29189376.078842
  % 	x0 = 1,	Z1 = 29189376.0788425        
DEBUG EVAL: First branch cutoff check: z=29189376.078842, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 0 = 0
ITER 1: row=1, varin=58, theta=1.000000, up=999999999999999983222784.000000
  % 	x0 = 0,	Z0 = 28673127.7571539        
DEBUG EVAL: Second branch cutoff check: z=28673127.757154, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 34 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=28, varin=59, theta=0.823474, up=999999999999999983222784.000000
ITER 2: row=59, varin=55, theta=0.979081, up=999999999999999983222784.000000
ITER 3: row=52, varin=58, theta=0.843576, up=999999999999999983222784.000000
ITER 4: row=24, varin=53, theta=0.184814, up=999999999999999983222784.000000
ITER 5: row=53, varin=46, theta=0.189502, up=999999999999999983222784.000000
ITER 6: row=46, varin=43, theta=0.224511, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 34 = 1 gives z=28750967.094310
  % 	x34 = 1,	Z1 = 28750967.0943096        
DEBUG EVAL: First branch cutoff check: z=28750967.094310, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 34 = 0
ITER 1: row=28, varin=99, theta=0.012973, up=1.000000
  % 	x34 = 0,	Z0 = 28652514.0087384        
DEBUG EVAL: Second branch cutoff check: z=28652514.008738, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 5 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=81, theta=0.327622, up=1.000000
DEBUG EVAL: Branch var 5 = 0 gives z=28711522.618550
  % 	x5 = 0,	Z0 = 28711522.6185501        
DEBUG EVAL: First branch cutoff check: z=28711522.618550, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 5 = 1
ITER 1: row=6, varin=58, theta=1.516527, up=999999999999999983222784.000000
ITER 2: row=5, varin=9, theta=0.602915, up=999999999999999983222784.000000
ITER 3: row=62, varin=29, theta=0.526367, up=999999999999999983222784.000000
  % 	x5 = 1,	Z1 = 28769291.5299743        
DEBUG EVAL: Second branch cutoff check: z=28769291.529974, best_z=INF, threshold=INF
  %   New best:  x5, Z = 28711522.6185501        
DEBUG EVAL: Testing var 7 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=19, varin=81, theta=0.327622, up=1.000000
DEBUG EVAL: Branch var 7 = 0 gives z=28711522.618550
  % 	x7 = 0,	Z0 = 28711522.6185501        
DEBUG EVAL: First branch cutoff check: z=28711522.618550, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 7 = 1
ITER 1: row=19, varin=58, theta=1.516527, up=999999999999999983222784.000000
ITER 2: row=5, varin=28, theta=0.477392, up=999999999999999983222784.000000
  % 	x7 = 1,	Z1 = 28743677.7886019        
DEBUG EVAL: Second branch cutoff check: z=28743677.788602, best_z=INF, threshold=INF
  % Best branch is x5, Z0 = 28711522.6185501        , Z1 = 28769291.5299743        

DEBUG CAREFUL: Final result - returning best.var = 5
DEBUG BB: Branching variable chosen: j=5
 % @NC   79   55	x5 = 0	28711522.618550
 % @NC   80   55	x5 = 1	28769291.529974
 %      55    37 28652418.7136               28659552.2430   x17 D    16     8
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e74a340
% @LO 0.07  28.65853448994280228135 99.9000000000
% @LN 0.07  28.65955224303615622716 99.9000000000
% Resuming node 14 at  28.65955224303615622716
DEBUG CONSTRNT: LP rows=62, pool->nlprows=62, pool->npend=0
DEBUG CONSTRNT: Checking 62 LP rows (pool tracks 62, total LP rows 62)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 48
DEBUG CONSTRNT: Pool row 48 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 64
DEBUG CONSTRNT: Pool row 64 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 26
DEBUG CONSTRNT: Pool row 26 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=56, expected 56
DEBUG CONSTRNT: Checking LP row 57 -> pool row 143
DEBUG CONSTRNT: Pool row 143 has lprow=57, expected 57
DEBUG CONSTRNT: Checking LP row 58 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=58, expected 58
DEBUG CONSTRNT: Checking LP row 59 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=59, expected 59
DEBUG CONSTRNT: Checking LP row 60 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=60, expected 60
DEBUG CONSTRNT: Checking LP row 61 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=61, expected 61
 % @PAP adding 52 rows, 227 nz to LP
DEBUG BB: Processing node 14, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 14 LP 4 Solution, length = 28659552.243036, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.451267 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.451267 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.075211 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.075211 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.075211 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.075211 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.075211 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.075211 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.075211 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.451267 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.097467 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.548733 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.924789 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.548733 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.548733 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.924789 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.548733 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.924789 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.924789 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.924789 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.924789 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.924789 (terminal 19)
 % 11 fractional variables
DEBUG CG: LP optimal, z=28659552.243036, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28659552.243036, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 3 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 14 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 14
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.451267
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.451267)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.451267
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.451267)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.075211
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.075211)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.075211
DEBUG CAREFUL: Adding var 3 to fractional list (xi=0.075211)
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=1.000000
DEBUG CAREFUL: Skipping var 8: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.075211
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.075211)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.075211
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.075211)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.075211
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.075211)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.075211
DEBUG CAREFUL: Adding var 22 to fractional list (xi=0.075211)
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.075211
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.075211)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.451267
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.451267)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.097467
DEBUG CAREFUL: Adding var 30 to fractional list (xi=0.097467)
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 11 fractional variables

  %  Carefully choosing branching variable, nfrac = 11
DEBUG CAREFUL: Testing fvar[0] = var 30
DEBUG CAREFUL: Calling compare_branch_vars for var 30
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 30
DEBUG CAREFUL: New best var: 30
DEBUG CAREFUL: Testing fvar[1] = var 3
DEBUG CAREFUL: Calling compare_branch_vars for var 3
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 3
DEBUG CAREFUL: New best var: 3
DEBUG CAREFUL: Testing fvar[2] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 26
DEBUG CAREFUL: Testing fvar[3] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[4] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[5] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 11
DEBUG CAREFUL: Testing fvar[6] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
DEBUG CAREFUL: Testing fvar[7] = var 22
DEBUG CAREFUL: Calling compare_branch_vars for var 22
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 22
DEBUG CAREFUL: Testing fvar[8] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 1
DEBUG CAREFUL: Testing fvar[9] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 29
DEBUG CAREFUL: Testing fvar[10] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
  % Initial guess is x3, Z0 = 28659552.2430362        , Z1 = 29755438.4249317        

DEBUG EVAL: Testing var 30 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=48, varin=50, theta=1.068519, up=999999999999999983222784.000000
ITER 2: row=35, varin=10, theta=1.157324, up=999999999999999983222784.000000
ITER 3: row=10, varin=44, theta=1.173527, up=999999999999999983222784.000000
ITER 4: row=47, varin=48, theta=0.576092, up=999999999999999983222784.000000
ITER 5: row=3, varin=47, theta=0.229602, up=999999999999999983222784.000000
ITER 6: row=13, varin=42, theta=0.432103, up=999999999999999983222784.000000
ITER 7: row=42, varin=39, theta=0.359086, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 30 = 1 gives z=28814349.060060
  % 	x30 = 1,	Z1 = 28814349.0600597        
DEBUG EVAL: First branch cutoff check: z=28814349.060060, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 30 = 0
ITER 1: row=48, varin=52, theta=0.229982, up=999999999999999983222784.000000
  % 	x30 = 0,	Z0 = 28660671.2702224        
DEBUG EVAL: Second branch cutoff check: z=28660671.270222, best_z=INF, threshold=INF
  %   New best:  x30, Z = 28660671.2702224        
DEBUG EVAL: Testing var 3 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=52, theta=7.794250, up=999999999999999983222784.000000
ITER 2: row=48, varin=50, theta=2.697192, up=999999999999999983222784.000000
ITER 3: row=1, varin=10, theta=16.671862, up=999999999999999983222784.000000
ITER 4: row=10, varin=48, theta=3.169260, up=999999999999999983222784.000000
ITER 5: row=13, varin=21, theta=1.086604, up=999999999999999983222784.000000
ITER 6: row=46, varin=14, theta=2.737218, up=999999999999999983222784.000000
ITER 7: row=6, varin=29, theta=1.053150, up=999999999999999983222784.000000
ITER 8: row=43, varin=42, theta=1.647803, up=999999999999999983222784.000000
ITER 9: row=42, varin=45, theta=3.480709, up=999999999999999983222784.000000
ITER 10: row=3, varin=3, theta=1.627036, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 3 = 1 gives z=29755438.424932
  % 	x3 = 1,	Z1 = 29755438.4249317        
DEBUG EVAL: First branch cutoff check: z=29755438.424932, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 3 = 0
ITER 1: row=7, varin=44, theta=0.107047, up=999999999999999983222784.000000
ITER 2: row=47, varin=86, theta=0.568157, up=1.000000
ITER 3: row=48, varin=50, theta=0.249937, up=999999999999999983222784.000000
ITER 4: row=35, varin=48, theta=0.050427, up=999999999999999983222784.000000
  % 	x3 = 0,	Z0 = 28686127.7716265        
DEBUG EVAL: Second branch cutoff check: z=28686127.771626, best_z=INF, threshold=INF
  %   New best:  x3, Z = 28686127.7716265        
DEBUG EVAL: Testing var 26 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=39, varin=52, theta=7.794250, up=999999999999999983222784.000000
ITER 2: row=48, varin=50, theta=2.697192, up=999999999999999983222784.000000
ITER 3: row=1, varin=10, theta=16.671862, up=999999999999999983222784.000000
ITER 4: row=10, varin=8, theta=0.799269, up=999999999999999983222784.000000
ITER 5: row=41, varin=44, theta=3.097489, up=999999999999999983222784.000000
ITER 6: row=47, varin=34, theta=0.982098, up=999999999999999983222784.000000
ITER 7: row=48, varin=77, theta=2.761051, up=1.000000
ITER 8: row=48, varin=83, theta=0.958331, up=1.000000
ITER 9: row=1, varin=77, theta=1.000000, up=1.000000
ITER 10: row=48, varin=74, theta=0.292410, up=1.000000
DEBUG EVAL: Branch var 26 = 1 gives z=29108203.956890
  % 	x26 = 1,	Z1 = 29108203.9568901        
DEBUG EVAL: First branch cutoff check: z=29108203.956890, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 0
ITER 1: row=39, varin=39, theta=0.083740, up=999999999999999983222784.000000
  % 	x26 = 0,	Z0 = 28675139.1736804        
DEBUG EVAL: Second branch cutoff check: z=28675139.173680, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 17 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=21, varin=86, theta=0.568157, up=1.000000
DEBUG EVAL: Branch var 17 = 0 gives z=28677527.399328
  % 	x17 = 0,	Z0 = 28677527.3993275        
DEBUG EVAL: First branch cutoff check: z=28677527.399328, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=14, theta=0.091440, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28676765.828809
  % 	x10 = 0,	Z0 = 28676765.8288093        
DEBUG EVAL: First branch cutoff check: z=28676765.828809, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 11 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=13, varin=52, theta=7.794250, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 11 = 1 gives z=28697476.789740
  % 	x11 = 1,	Z1 = 28917212.9270826        
DEBUG EVAL: First branch cutoff check: z=28917212.927083, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 11 = 0
ITER 1: row=13, varin=48, theta=0.106686, up=999999999999999983222784.000000
  % 	x11 = 0,	Z0 = 28674387.2154792        
DEBUG EVAL: Second branch cutoff check: z=28674387.215479, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=45, theta=0.087131, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28668587.150480
  % 	x2 = 0,	Z0 = 28668587.1504801        
DEBUG EVAL: First branch cutoff check: z=28668587.150480, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 22 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=35, varin=52, theta=7.794250, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 22 = 1 gives z=28697476.789740
  % 	x22 = 1,	Z1 = 28834160.8066085        
DEBUG EVAL: First branch cutoff check: z=28834160.806608, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 22 = 0
ITER 1: row=35, varin=50, theta=0.083224, up=999999999999999983222784.000000
  % 	x22 = 0,	Z0 = 28660380.9889661        
DEBUG EVAL: Second branch cutoff check: z=28660380.988966, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=52, theta=1.566359, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 0 gives z=28667173.688158
  % 	x1 = 0,	Z0 = 28667173.6881578        
DEBUG EVAL: First branch cutoff check: z=28667173.688158, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 29 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=36, varin=52, theta=1.566359, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 29 = 0 gives z=28667173.688158
  % 	x29 = 0,	Z0 = 28667173.6881578        
DEBUG EVAL: First branch cutoff check: z=28667173.688158, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 0 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=52, theta=1.566359, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 0 = 0 gives z=28667173.688158
  % 	x0 = 0,	Z0 = 28667173.6881578        
DEBUG EVAL: First branch cutoff check: z=28667173.688158, best_z=INF, threshold=INF
  % Best branch is x3, Z0 = 28686127.7716265        , Z1 = 29755438.4249317        

DEBUG CAREFUL: Final result - returning best.var = 3
DEBUG BB: Branching variable chosen: j=3
 % @NC   81   14	x3 = 0	28686127.771626
 % @NC   82   14	x3 = 1	29755438.424932
 %      14    38 28659552.2430               28663590.9027    x8 U     9     6
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e765b10
% @LO 0.07  28.65955224303615622716 99.9000000000
% @LN 0.07  28.66359090267276243935 99.9000000000
% Resuming node 30 at  28.66359090267276243935
DEBUG CONSTRNT: LP rows=52, pool->nlprows=52, pool->npend=0
DEBUG CONSTRNT: Checking 52 LP rows (pool tracks 52, total LP rows 52)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 62
DEBUG CONSTRNT: Pool row 62 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=51, expected 51
 % @PAP adding 35 rows, 180 nz to LP
DEBUG BB: Processing node 30, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=15, varin=27, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=16, varin=38, theta=0.500000, up=1.000000
ITER 3: row=6, varin=34, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=1, varin=39, theta=0.595733, up=1.000000
ITER 5: row=26, varin=10, theta=0.244096, up=999999999999999983222784.000000
ITER 6: row=32, varin=65, theta=1.090124, up=1.000000
ITER 7: row=32, varin=3, theta=0.029465, up=999999999999999983222784.000000
ITER 8: row=2, varin=26, theta=0.025851, up=999999999999999983222784.000000
ITER 9: row=34, varin=62, theta=0.071462, up=1.000000
ITER 10: row=1, varin=35, theta=0.021378, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=16)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=35)
DEBUG SOLUTION: LP solution array indices: FST[36-75], not_covered[76-95]
DEBUG SOLUTION: lp->best_solution[0] = 28629202.947040
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 3.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 35 rows, 60 cols, 240 nonzeros, 1 slack, 34 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 8 rows, 30 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=59, theta=0.090275, up=1.000000
ITER 2: row=40, varin=46, theta=0.645287, up=1.000000
ITER 3: row=6, varin=66, theta=0.775198, up=1.000000
ITER 4: row=17, varin=52, theta=0.121592, up=1.000000
ITER 5: row=21, varin=61, theta=0.082627, up=1.000000
ITER 6: row=26, varin=47, theta=0.157173, up=1.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=43)
DEBUG SOLUTION: LP solution array indices: FST[44-83], not_covered[84-103]
DEBUG SOLUTION: lp->best_solution[0] = 28772402.154083
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 3.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 43 rows, 60 cols, 270 nonzeros, 1 slack, 42 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % @PAP adding 8 rows, 35 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=45, varin=72, theta=0.825171, up=1.000000
ITER 2: row=15, varin=94, theta=0.024285, up=1.000000
ITER 3: row=50, varin=56, theta=0.113354, up=1.000000
ITER 4: row=34, varin=61, theta=0.144977, up=1.000000
ITER 5: row=10, varin=106, theta=0.020405, up=1.000000
ITER 6: row=47, varin=27, theta=0.015630, up=999999999999999983222784.000000
ITER 7: row=46, varin=17, theta=0.290425, up=999999999999999983222784.000000
ITER 8: row=17, varin=52, theta=0.152776, up=1.000000
ITER 9: row=3, varin=45, theta=0.375409, up=999999999999999983222784.000000
ITER 10: row=42, varin=105, theta=0.010054, up=1.000000
LP PHASE: Switching to primal (iter=11)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28874022.960367
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 3.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 50 rows, 60 cols, 303 nonzeros, 0 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 3 rows, 13 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=28, theta=0.407120, up=999999999999999983222784.000000
ITER 2: row=45, varin=78, theta=3.303090, up=1.000000
ITER 3: row=45, varin=76, theta=1.088382, up=1.000000
ITER 4: row=45, varin=3, theta=0.062207, up=999999999999999983222784.000000
ITER 5: row=49, varin=76, theta=1.000000, up=1.000000
ITER 6: row=36, varin=81, theta=0.689621, up=1.000000
ITER 7: row=7, varin=82, theta=0.698058, up=1.000000
ITER 8: row=12, varin=77, theta=1.000000, up=1.000000
ITER 9: row=46, varin=78, theta=1.003839, up=1.000000
ITER 10: row=46, varin=60, theta=0.001335, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 3.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.000000
  % @PL 53 rows, 60 cols, 316 nonzeros, 1 slack, 52 tight.
  % Node 30 LP 1 Solution, length = 999999999999999983222784.000000, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 1.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 1.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.743795 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.256205 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 30 is INFEASIBLE
 %      30    37    infeasible               28664419.4228    x7 U     8     5
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e74a1c0
% @LO 0.07  28.66359090267276243935 99.9000000000
% @LN 0.07  28.66441942281268140391 99.9000000000
% Resuming node 75 at  28.66441942281268140391
DEBUG CONSTRNT: LP rows=53, pool->nlprows=53, pool->npend=0
DEBUG CONSTRNT: Checking 53 LP rows (pool tracks 53, total LP rows 53)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 150
DEBUG CONSTRNT: Pool row 150 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 136
DEBUG CONSTRNT: Pool row 136 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=52, expected 52
 % @PAP adding 50 rows, 185 nz to LP
DEBUG BB: Processing node 75, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=89, theta=1.000000, up=1.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=50)
DEBUG SOLUTION: LP solution array indices: FST[51-90], not_covered[91-110]
DEBUG SOLUTION: lp->best_solution[0] = 28664419.422813
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 50 rows, 60 cols, 245 nonzeros, 0 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 22 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=42, theta=0.250000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 28669532.097414
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 54 rows, 60 cols, 267 nonzeros, 4 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 1 rows, 40 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=68, theta=0.133232, up=1.000000
ITER 2: row=17, varin=91, theta=0.173924, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=51)
DEBUG SOLUTION: LP solution array indices: FST[52-91], not_covered[92-111]
DEBUG SOLUTION: lp->best_solution[0] = 28682027.159585
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 51 rows, 60 cols, 283 nonzeros, 0 slack, 51 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 9 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=11, theta=0.222782, up=999999999999999983222784.000000
ITER 2: row=12, varin=36, theta=0.215564, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=53)
DEBUG SOLUTION: LP solution array indices: FST[54-93], not_covered[94-113]
DEBUG SOLUTION: lp->best_solution[0] = 28702613.732590
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 2.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 53 rows, 60 cols, 292 nonzeros, 1 slack, 52 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 1 slack rows
  % Node 75 LP 1 Solution, length = 28702613.732590, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.357782 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.357782 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.142218 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.142218 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 1.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.142218 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.357782 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.357782 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.357782 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.142218 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.642218 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.642218 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.642218 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.642218 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.857782 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.642218 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.857782 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.857782 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.857782 (terminal 19)
 % 9 fractional variables
DEBUG CG: LP optimal, z=28702613.732590, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 75 at  28.70261373259022263937
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e74a280
% @LO 0.07  28.66441942281268140391 99.9000000000
% @LN 0.07  28.66912678880101594814 99.9000000000
% Resuming node 22 at  28.66912678880101594814
DEBUG CONSTRNT: LP rows=52, pool->nlprows=52, pool->npend=0
DEBUG CONSTRNT: Checking 52 LP rows (pool tracks 52, total LP rows 52)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 50
DEBUG CONSTRNT: Pool row 50 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 57
DEBUG CONSTRNT: Pool row 57 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 69
DEBUG CONSTRNT: Pool row 69 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 112
DEBUG CONSTRNT: Pool row 112 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 118
DEBUG CONSTRNT: Pool row 118 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 152
DEBUG CONSTRNT: Pool row 152 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 156
DEBUG CONSTRNT: Pool row 156 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 160
DEBUG CONSTRNT: Pool row 160 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 78
DEBUG CONSTRNT: Pool row 78 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 25
DEBUG CONSTRNT: Pool row 25 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 94
DEBUG CONSTRNT: Pool row 94 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 40
DEBUG CONSTRNT: Pool row 40 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 105
DEBUG CONSTRNT: Pool row 105 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 130
DEBUG CONSTRNT: Pool row 130 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 20
DEBUG CONSTRNT: Pool row 20 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=51, expected 51
 % @PAP adding 54 rows, 242 nz to LP
DEBUG BB: Processing node 22, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=2, varin=29, theta=0.345472, up=999999999999999983222784.000000
ITER 2: row=40, varin=80, theta=1.006976, up=1.000000
ITER 3: row=40, varin=76, theta=0.007123, up=1.000000
ITER 4: row=22, varin=31, theta=1.000000, up=999999999999999983222784.000000
ITER 5: row=25, varin=80, theta=0.762130, up=1.000000
ITER 6: row=50, varin=54, theta=0.611309, up=999999999999999983222784.000000
ITER 7: row=27, varin=88, theta=0.961802, up=1.000000
ITER 8: row=13, varin=18, theta=0.197036, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=54)
DEBUG SOLUTION: LP solution array indices: FST[55-94], not_covered[95-114]
DEBUG SOLUTION: lp->best_solution[0] = 28669126.788800
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 54 rows, 60 cols, 302 nonzeros, 5 slack, 49 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 6 rows, 14 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=60, varin=40, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=57, varin=26, theta=0.210707, up=999999999999999983222784.000000
ITER 3: row=55, varin=88, theta=1.999184, up=1.000000
ITER 4: row=55, varin=23, theta=0.400045, up=999999999999999983222784.000000
ITER 5: row=59, varin=89, theta=1.004054, up=1.000000
ITER 6: row=59, varin=25, theta=0.006568, up=999999999999999983222784.000000
ITER 7: row=52, varin=33, theta=0.001276, up=999999999999999983222784.000000
ITER 8: row=34, varin=47, theta=0.002489, up=999999999999999983222784.000000
ITER 9: row=1, varin=91, theta=0.004124, up=1.000000
ITER 10: row=2, varin=55, theta=0.012664, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=60)
DEBUG SOLUTION: LP solution array indices: FST[61-100], not_covered[101-120]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 60 rows, 60 cols, 316 nonzeros, 13 slack, 47 tight.
  % Node 22 LP 1 Solution, length = 999999999999999983222784.000000, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 1.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.197036 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.591108 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.394072 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 1.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.014820 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.802964 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.802964 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 22 is INFEASIBLE
 %      22    36    infeasible               28675168.7299    x1 U     4     3
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e7725c0
% @LO 0.07  28.66912678880101594814 99.9000000000
% @LN 0.07  28.67516872993937937508 99.9000000000
% Resuming node 51 at  28.67516872993937937508
DEBUG CONSTRNT: LP rows=60, pool->nlprows=60, pool->npend=0
DEBUG CONSTRNT: Checking 60 LP rows (pool tracks 60, total LP rows 60)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 38
DEBUG CONSTRNT: Pool row 38 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 102
DEBUG CONSTRNT: Pool row 102 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 126
DEBUG CONSTRNT: Pool row 126 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=52, expected 52
DEBUG CONSTRNT: Checking LP row 53 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=53, expected 53
DEBUG CONSTRNT: Checking LP row 54 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=54, expected 54
DEBUG CONSTRNT: Checking LP row 55 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=55, expected 55
DEBUG CONSTRNT: Checking LP row 56 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=56, expected 56
DEBUG CONSTRNT: Checking LP row 57 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=57, expected 57
DEBUG CONSTRNT: Checking LP row 58 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=58, expected 58
DEBUG CONSTRNT: Checking LP row 59 -> pool row 143
DEBUG CONSTRNT: Pool row 143 has lprow=59, expected 59
 % @PAP adding 47 rows, 191 nz to LP
DEBUG BB: Processing node 51, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 51 LP 3 Solution, length = 28675168.729939, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.500000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 1.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.500000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.500000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.500000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.500000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28675168.729939, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28675168.729939, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 51 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 51
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.500000
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=1.000000
DEBUG CAREFUL: Skipping var 14: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.500000
DEBUG CAREFUL: Adding var 34 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.500000
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 3 fractional variables

  %  Carefully choosing branching variable, nfrac = 3
DEBUG CAREFUL: Testing fvar[0] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 5
DEBUG CAREFUL: New best var: 5
DEBUG CAREFUL: Testing fvar[1] = var 34
DEBUG CAREFUL: Calling compare_branch_vars for var 34
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 34
DEBUG CAREFUL: Testing fvar[2] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 36
  % Initial guess is x5, Z0 = 28675168.7299394        , Z1 = 28675168.7299394        

DEBUG EVAL: Testing var 5 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=74, theta=1.000000, up=1.000000
ITER 2: row=34, varin=52, theta=1.000000, up=1.000000
ITER 3: row=6, varin=28, theta=0.058824, up=999999999999999983222784.000000
ITER 4: row=41, varin=101, theta=1.125000, up=1.000000
ITER 5: row=41, varin=21, theta=0.013158, up=999999999999999983222784.000000
ITER 6: row=47, varin=29, theta=0.007519, up=999999999999999983222784.000000
ITER 7: row=43, varin=23, theta=0.005376, up=999999999999999983222784.000000
ITER 8: row=44, varin=45, theta=0.049505, up=999999999999999983222784.000000
ITER 9: row=46, varin=40, theta=0.001431, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 5 = 0 gives z=28702366.442614
  % 	x5 = 0,	Z0 = 28702366.4426143        
DEBUG EVAL: First branch cutoff check: z=28702366.442614, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 5 = 1
ITER 1: row=1, varin=40, theta=0.125000, up=999999999999999983222784.000000
ITER 2: row=6, varin=45, theta=0.529412, up=999999999999999983222784.000000
ITER 3: row=45, varin=37, theta=1.000000, up=999999999999999983222784.000000
  % 	x5 = 1,	Z1 = 28684127.4115022        
DEBUG EVAL: Second branch cutoff check: z=28684127.411502, best_z=INF, threshold=INF
  %   New best:  x5, Z = 28684127.4115022        
DEBUG EVAL: Testing var 34 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=22, varin=33, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 34 = 0 gives z=28684183.068147
  % 	x34 = 0,	Z0 = 28684183.0681469        
DEBUG EVAL: First branch cutoff check: z=28684183.068147, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 34 = 1
ITER 1: row=22, varin=40, theta=0.125000, up=999999999999999983222784.000000
ITER 2: row=6, varin=45, theta=0.529412, up=999999999999999983222784.000000
ITER 3: row=45, varin=37, theta=1.000000, up=999999999999999983222784.000000
  % 	x34 = 1,	Z1 = 28684127.4115022        
DEBUG EVAL: Second branch cutoff check: z=28684127.411502, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 36 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=33, varin=37, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 36 = 0 gives z=28684127.411502
  % 	x36 = 0,	Z0 = 28684127.4115022        
DEBUG EVAL: First branch cutoff check: z=28684127.411502, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 36 = 1
ITER 1: row=33, varin=40, theta=0.125000, up=999999999999999983222784.000000
ITER 2: row=6, varin=45, theta=0.529412, up=999999999999999983222784.000000
ITER 3: row=45, varin=33, theta=1.000000, up=999999999999999983222784.000000
  % 	x36 = 1,	Z1 = 28684183.0681469        
DEBUG EVAL: Second branch cutoff check: z=28684183.068147, best_z=INF, threshold=INF
  % Best branch is x5, Z0 = 28702366.4426143        , Z1 = 28684127.4115022        

DEBUG CAREFUL: Final result - returning best.var = 5
DEBUG BB: Branching variable chosen: j=5
 % @NC   83   51	x5 = 1	28684127.411502
 % @NC   84   51	x5 = 0	28702366.442614
 %      51    37 28675168.7299               28684127.4115    x0 D    29     6
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e74a280
% @LO 0.07  28.67516872993937937508 99.9000000000
% @LN 0.07  28.68412741150223155273 99.9000000000
% Resuming node 83 at  28.68412741150223155273
DEBUG CONSTRNT: LP rows=47, pool->nlprows=47, pool->npend=0
DEBUG CONSTRNT: Checking 47 LP rows (pool tracks 47, total LP rows 47)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 150
DEBUG CONSTRNT: Pool row 150 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 83
DEBUG CONSTRNT: Pool row 83 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 84
DEBUG CONSTRNT: Pool row 84 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=46, expected 46
 % @PAP adding 47 rows, 191 nz to LP
DEBUG BB: Processing node 83, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=1, varin=40, theta=0.125000, up=999999999999999983222784.000000
ITER 2: row=6, varin=45, theta=0.529412, up=999999999999999983222784.000000
ITER 3: row=45, varin=37, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 28684127.411502
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 251 nonzeros, 2 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 1 rows, 40 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=48, varin=75, theta=0.937625, up=1.000000
ITER 2: row=1, varin=33, theta=1.076926, up=999999999999999983222784.000000
ITER 3: row=34, varin=12, theta=0.740380, up=999999999999999983222784.000000
ITER 4: row=7, varin=71, theta=0.912115, up=1.000000
ITER 5: row=41, varin=70, theta=0.884115, up=1.000000
LP PHASE: Switching to primal (iter=5)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28941376.133749
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 291 nonzeros, 3 slack, 45 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 3 slack rows
  % @PAP adding 2 rows, 7 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=46, varin=72, theta=3.926233, up=1.000000
ITER 2: row=46, varin=21, theta=0.144252, up=999999999999999983222784.000000
ITER 3: row=42, varin=3, theta=0.973311, up=999999999999999983222784.000000
ITER 4: row=4, varin=78, theta=1.765199, up=1.000000
ITER 5: row=4, varin=75, theta=0.379830, up=1.000000
ITER 6: row=45, varin=78, theta=1.747014, up=1.000000
ITER 7: row=45, varin=7, theta=0.186226, up=999999999999999983222784.000000
ITER 8: row=9, varin=72, theta=1.000000, up=1.000000
ITER 9: row=7, varin=28, theta=0.092263, up=999999999999999983222784.000000
ITER 10: row=1, varin=54, theta=0.205794, up=1.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=47)
DEBUG SOLUTION: LP solution array indices: FST[48-87], not_covered[88-107]
DEBUG SOLUTION: lp->best_solution[0] = 999999999999999983222784.000000
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 47 rows, 60 cols, 292 nonzeros, 8 slack, 39 tight.
  % Node 83 LP 1 Solution, length = 999999999999999983222784.000000, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 1.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 1.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.884115 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.115885 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
DEBUG BB: compute_good_lower_bound returned status=1
DEBUG BB: Node 83 is INFEASIBLE
 %      83    36    infeasible               28686127.7716    x5 U    51     7
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e74b550
% @LO 0.07  28.68412741150223155273 99.9000000000
% @LN 0.07  28.68612777162648086460 99.9000000000
% Resuming node 81 at  28.68612777162648086460
DEBUG CONSTRNT: LP rows=47, pool->nlprows=47, pool->npend=0
DEBUG CONSTRNT: Checking 47 LP rows (pool tracks 47, total LP rows 47)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 47
DEBUG CONSTRNT: Pool row 47 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 66
DEBUG CONSTRNT: Pool row 66 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 150
DEBUG CONSTRNT: Pool row 150 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 155
DEBUG CONSTRNT: Pool row 155 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 116
DEBUG CONSTRNT: Pool row 116 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 77
DEBUG CONSTRNT: Pool row 77 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 34
DEBUG CONSTRNT: Pool row 34 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 21
DEBUG CONSTRNT: Pool row 21 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 106
DEBUG CONSTRNT: Pool row 106 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 131
DEBUG CONSTRNT: Pool row 131 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=46, expected 46
 % @PAP adding 52 rows, 227 nz to LP
DEBUG BB: Processing node 81, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=7, varin=44, theta=0.107047, up=999999999999999983222784.000000
ITER 2: row=47, varin=86, theta=0.568157, up=1.000000
ITER 3: row=48, varin=50, theta=0.249937, up=999999999999999983222784.000000
ITER 4: row=35, varin=48, theta=0.050427, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28686127.771626
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 52 rows, 60 cols, 287 nonzeros, 6 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 6 slack rows
  % @PAP adding 2 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=47, varin=35, theta=0.034678, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=48)
DEBUG SOLUTION: LP solution array indices: FST[49-88], not_covered[89-108]
DEBUG SOLUTION: lp->best_solution[0] = 28689985.358325
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 2.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 48 rows, 60 cols, 287 nonzeros, 2 slack, 46 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 81 LP 1 Solution, length = 28689985.358325, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.500000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.034678 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.034678 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.034678 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.034678 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.034678 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.500000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.395966 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.500000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.965322 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.965322 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.965322 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.965322 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.965322 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.965322 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.965322 (terminal 19)
 % 9 fractional variables
DEBUG CG: LP optimal, z=28689985.358325, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG BB: compute_good_lower_bound returned status=5
 % suspending node 81 at  28.68998535832482943420
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e74ccf0
% @LO 0.07  28.68612777162648086460 99.9000000000
% @LN 0.07  28.68735051498651955626 99.9000000000
% Resuming node 10 at  28.68735051498651955626
DEBUG CONSTRNT: LP rows=46, pool->nlprows=46, pool->npend=0
DEBUG CONSTRNT: Checking 46 LP rows (pool tracks 46, total LP rows 46)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 62
DEBUG CONSTRNT: Pool row 62 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=45, expected 45
 % @PAP adding 60 rows, 254 nz to LP
DEBUG BB: Processing node 10, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 10 LP 7 Solution, length = 28687350.514987, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.347045 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.347045 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 1.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.305909 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.347045 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 0.652955 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.652955 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.652955 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 4 fractional variables
DEBUG CG: LP optimal, z=28687350.514987, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28687350.514987, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 10 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 10
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.347045
DEBUG CAREFUL: Adding var 5 to fractional list (xi=0.347045)
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.347045
DEBUG CAREFUL: Adding var 6 to fractional list (xi=0.347045)
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=1.000000
DEBUG CAREFUL: Skipping var 9: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.305909
DEBUG CAREFUL: Adding var 28 to fractional list (xi=0.305909)
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.347045
DEBUG CAREFUL: Adding var 36 to fractional list (xi=0.347045)
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 4 fractional variables

  %  Carefully choosing branching variable, nfrac = 4
DEBUG CAREFUL: Testing fvar[0] = var 5
DEBUG CAREFUL: Calling compare_branch_vars for var 5
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 5
DEBUG CAREFUL: New best var: 5
DEBUG CAREFUL: Testing fvar[1] = var 6
DEBUG CAREFUL: Calling compare_branch_vars for var 6
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 6
DEBUG CAREFUL: Testing fvar[2] = var 36
DEBUG CAREFUL: Calling compare_branch_vars for var 36
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 36
DEBUG CAREFUL: Testing fvar[3] = var 28
DEBUG CAREFUL: Calling compare_branch_vars for var 28
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 28
DEBUG CAREFUL: New best var: 28
  % Initial guess is x28, Z0 = 28687350.5149865        , Z1 = 28819933.269787         

DEBUG EVAL: Testing var 5 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=20, varin=52, theta=1.235772, up=999999999999999983222784.000000
ITER 2: row=57, varin=22, theta=0.047678, up=999999999999999983222784.000000
ITER 3: row=55, varin=60, theta=0.270810, up=999999999999999983222784.000000
ITER 4: row=49, varin=59, theta=0.450681, up=999999999999999983222784.000000
ITER 5: row=38, varin=86, theta=784.053528, up=1.000000
ITER 6: row=38, varin=89, theta=187.331199, up=1.000000
ITER 7: row=38, varin=40, theta=0.340229, up=999999999999999983222784.000000
ITER 8: row=53, varin=89, theta=2.134899, up=1.000000
ITER 9: row=53, varin=86, theta=0.904469, up=1.000000
ITER 10: row=50, varin=88, theta=-979.066910, up=1.000000
DEBUG EVAL: Branch var 5 = 0 gives z=28753391.163648
  % 	x5 = 0,	Z0 = 28753391.1636479        
DEBUG EVAL: First branch cutoff check: z=28753391.163648, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 5 = 1
ITER 1: row=20, varin=57, theta=2.771289, up=999999999999999983222784.000000
ITER 2: row=57, varin=27, theta=0.358289, up=999999999999999983222784.000000
ITER 3: row=50, varin=45, theta=6.229732, up=999999999999999983222784.000000
ITER 4: row=45, varin=49, theta=1.439635, up=999999999999999983222784.000000
ITER 5: row=55, varin=28, theta=3.121215, up=999999999999999983222784.000000
ITER 6: row=26, varin=39, theta=0.777239, up=999999999999999983222784.000000
ITER 7: row=12, varin=26, theta=1.351942, up=999999999999999983222784.000000
ITER 8: row=45, varin=55, theta=3.284116, up=999999999999999983222784.000000
ITER 9: row=53, varin=37, theta=0.732042, up=999999999999999983222784.000000
ITER 10: row=28, varin=3, theta=1.394326, up=999999999999999983222784.000000
  % 	x5 = 1,	Z1 = 1.79769313486232e+308   
DEBUG EVAL: Second branch cutoff check: z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, best_z=INF, threshold=INF
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=20, varin=52, theta=1.235772, up=999999999999999983222784.000000
ITER 2: row=57, varin=22, theta=0.047678, up=999999999999999983222784.000000
ITER 3: row=55, varin=60, theta=0.270810, up=999999999999999983222784.000000
ITER 4: row=49, varin=59, theta=0.450681, up=999999999999999983222784.000000
ITER 5: row=38, varin=86, theta=784.053528, up=1.000000
ITER 6: row=38, varin=89, theta=187.331199, up=1.000000
ITER 7: row=38, varin=40, theta=0.340229, up=999999999999999983222784.000000
ITER 8: row=53, varin=89, theta=2.134899, up=1.000000
ITER 9: row=53, varin=86, theta=0.904469, up=1.000000
ITER 10: row=50, varin=88, theta=-979.066910, up=1.000000
LP PHASE: Switching to primal (iter=14)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=60)
DEBUG SOLUTION: LP solution array indices: FST[61-100], not_covered[101-120]
DEBUG SOLUTION: lp->best_solution[0] = 28753391.163604
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 60 rows, 60 cols, 314 nonzeros, 10 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 10 slack rows
   % @PAP adding 2 rows, 4 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=52, varin=65, theta=196.013382, up=1.000000
ITER 2: row=52, varin=81, theta=186.613504, up=1.000000
ITER 3: row=52, varin=49, theta=1.237417, up=999999999999999983222784.000000
ITER 4: row=35, varin=20, theta=29.840795, up=999999999999999983222784.000000
ITER 5: row=52, varin=81, theta=5.754999, up=1.000000
ITER 6: row=52, varin=65, theta=0.947964, up=1.000000
ITER 7: row=50, varin=80, theta=0.259985, up=1.000000
LP PHASE: Switching to primal (iter=7)
ITER 8: row=17, varin=50, theta=0.000000, up=999999999999999983222784.000000
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28765253.675924
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 52 rows, 60 cols, 290 nonzeros, 4 slack, 48 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 4 slack rows
   % @PAP adding 4 rows, 11 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=51, varin=45, theta=0.405572, up=999999999999999983222784.000000
ITER 2: row=49, varin=65, theta=0.029057, up=1.000000
ITER 3: row=46, varin=81, theta=0.145976, up=1.000000
ITER 4: row=47, varin=48, theta=0.139415, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=4)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=52)
DEBUG SOLUTION: LP solution array indices: FST[53-92], not_covered[93-112]
DEBUG SOLUTION: lp->best_solution[0] = 28773153.791479
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 52 rows, 60 cols, 289 nonzeros, 2 slack, 50 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 2 slack rows
   % @PAP adding 8 rows, 43 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=53, varin=43, theta=0.356869, up=999999999999999983222784.000000
ITER 2: row=52, varin=39, theta=0.053422, up=999999999999999983222784.000000
ITER 3: row=51, varin=52, theta=0.277751, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=3)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=58)
DEBUG SOLUTION: LP solution array indices: FST[59-98], not_covered[99-118]
DEBUG SOLUTION: lp->best_solution[0] = 28784958.246193
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1000000.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
   % @PL 58 rows, 60 cols, 320 nonzeros, 5 slack, 53 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
   % @D deleting 5 slack rows
DEBUG BB: Branching variable chosen: j=-1
 % suspending node 10 at  28.78495824619290388569
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e74b550
% @LO 0.07  28.68735051498651955626 99.9000000000
% @LN 0.07  28.68998535832482943420 99.9000000000
% Resuming node 81 at  28.68998535832482943420
DEBUG CONSTRNT: LP rows=53, pool->nlprows=53, pool->npend=0
DEBUG CONSTRNT: Checking 53 LP rows (pool tracks 53, total LP rows 53)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 63
DEBUG CONSTRNT: Pool row 63 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 80
DEBUG CONSTRNT: Pool row 80 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 86
DEBUG CONSTRNT: Pool row 86 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 43
DEBUG CONSTRNT: Pool row 43 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 15
DEBUG CONSTRNT: Pool row 15 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 99
DEBUG CONSTRNT: Pool row 99 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 44
DEBUG CONSTRNT: Pool row 44 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 54
DEBUG CONSTRNT: Pool row 54 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 124
DEBUG CONSTRNT: Pool row 124 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 35
DEBUG CONSTRNT: Pool row 35 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 7
DEBUG CONSTRNT: Pool row 7 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 129
DEBUG CONSTRNT: Pool row 129 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 16
DEBUG CONSTRNT: Pool row 16 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 143
DEBUG CONSTRNT: Pool row 143 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 51
DEBUG CONSTRNT: Pool row 51 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 53
DEBUG CONSTRNT: Pool row 53 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 58
DEBUG CONSTRNT: Pool row 58 has lprow=50, expected 50
DEBUG CONSTRNT: Checking LP row 51 -> pool row 59
DEBUG CONSTRNT: Pool row 59 has lprow=51, expected 51
DEBUG CONSTRNT: Checking LP row 52 -> pool row 100
DEBUG CONSTRNT: Pool row 100 has lprow=52, expected 52
 % @PAP adding 46 rows, 215 nz to LP
DEBUG BB: Processing node 81, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 81 LP 2 Solution, length = 28689985.358325, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.500000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.500000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.034678 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 1.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.034678 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.034678 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.034678 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.034678 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.500000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.395966 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 0.500000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 0.965322 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 0.500000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 0.500000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.965322 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 0.500000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 0.965322 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.965322 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 0.965322 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 0.965322 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 0.965322 (terminal 19)
 % 9 fractional variables
DEBUG CG: LP optimal, z=28689985.358325, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28689985.358325, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 % @cutset: 3 connected components.
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 81 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 81
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.500000
DEBUG CAREFUL: Adding var 0 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.500000
DEBUG CAREFUL: Adding var 1 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.034678
DEBUG CAREFUL: Adding var 2 to fractional list (xi=0.034678)
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=1.000000
DEBUG CAREFUL: Skipping var 8: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.034678
DEBUG CAREFUL: Adding var 10 to fractional list (xi=0.034678)
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.034678
DEBUG CAREFUL: Adding var 11 to fractional list (xi=0.034678)
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.000000
DEBUG CAREFUL: Skipping var 12: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=0.000000
DEBUG CAREFUL: Skipping var 13: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.034678
DEBUG CAREFUL: Adding var 17 to fractional list (xi=0.034678)
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.000000
DEBUG CAREFUL: Skipping var 21: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.000000
DEBUG CAREFUL: Skipping var 25: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.034678
DEBUG CAREFUL: Adding var 26 to fractional list (xi=0.034678)
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.500000
DEBUG CAREFUL: Adding var 29 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.395966
DEBUG CAREFUL: Adding var 33 to fractional list (xi=0.395966)
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 9 fractional variables

  %  Carefully choosing branching variable, nfrac = 9
DEBUG CAREFUL: Testing fvar[0] = var 1
DEBUG CAREFUL: Calling compare_branch_vars for var 1
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 1
DEBUG CAREFUL: New best var: 1
DEBUG CAREFUL: Testing fvar[1] = var 29
DEBUG CAREFUL: Calling compare_branch_vars for var 29
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 29
DEBUG CAREFUL: Testing fvar[2] = var 0
DEBUG CAREFUL: Calling compare_branch_vars for var 0
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 0
DEBUG CAREFUL: Testing fvar[3] = var 26
DEBUG CAREFUL: Calling compare_branch_vars for var 26
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 26
DEBUG CAREFUL: New best var: 26
DEBUG CAREFUL: Testing fvar[4] = var 17
DEBUG CAREFUL: Calling compare_branch_vars for var 17
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 17
DEBUG CAREFUL: Testing fvar[5] = var 10
DEBUG CAREFUL: Calling compare_branch_vars for var 10
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 10
DEBUG CAREFUL: Testing fvar[6] = var 33
DEBUG CAREFUL: Calling compare_branch_vars for var 33
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 33
DEBUG CAREFUL: Testing fvar[7] = var 11
DEBUG CAREFUL: Calling compare_branch_vars for var 11
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 11
DEBUG CAREFUL: Testing fvar[8] = var 2
DEBUG CAREFUL: Calling compare_branch_vars for var 2
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 2
  % Initial guess is x26, Z0 = 28689985.3583248        , Z1 = 29108203.9568901        

DEBUG EVAL: Testing var 1 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=77, theta=1.000000, up=1.000000
ITER 2: row=38, varin=45, theta=0.748719, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 1 = 0 gives z=28792060.271840
  % 	x1 = 0,	Z0 = 28792060.2718396        
DEBUG EVAL: First branch cutoff check: z=28792060.271840, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 1 = 1
ITER 1: row=2, varin=32, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=38, varin=69, theta=0.087671, up=1.000000
ITER 3: row=13, varin=80, theta=0.298296, up=1.000000
  % 	x1 = 1,	Z1 = 28919278.0615486        
DEBUG EVAL: Second branch cutoff check: z=28919278.061549, best_z=INF, threshold=INF
  %   New best:  x1, Z = 28792060.2718396        
DEBUG EVAL: Testing var 29 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=35, varin=77, theta=1.000000, up=1.000000
ITER 2: row=38, varin=45, theta=0.748719, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 29 = 0 gives z=28792060.271840
  % 	x29 = 0,	Z0 = 28792060.2718396        
DEBUG EVAL: First branch cutoff check: z=28792060.271840, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 29 = 1
ITER 1: row=35, varin=4, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=36, varin=32, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=38, varin=69, theta=0.087671, up=1.000000
ITER 4: row=13, varin=80, theta=0.298296, up=1.000000
  % 	x29 = 1,	Z1 = 28919278.0615486        
DEBUG EVAL: Second branch cutoff check: z=28919278.061549, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 0 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=1, varin=77, theta=1.000000, up=1.000000
ITER 2: row=38, varin=45, theta=0.748719, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 0 = 0 gives z=28792060.271840
  % 	x0 = 0,	Z0 = 28792060.2718396        
DEBUG EVAL: First branch cutoff check: z=28792060.271840, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 0 = 1
ITER 1: row=1, varin=3, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=33, varin=4, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=36, varin=35, theta=1.000000, up=999999999999999983222784.000000
ITER 4: row=38, varin=69, theta=1.229594, up=1.000000
ITER 5: row=38, varin=70, theta=0.266166, up=1.000000
ITER 6: row=42, varin=68, theta=0.227460, up=1.000000
ITER 7: row=26, varin=84, theta=0.396524, up=1.000000
ITER 8: row=13, varin=16, theta=0.209483, up=999999999999999983222784.000000
ITER 9: row=26, varin=72, theta=12.469576, up=1.000000
ITER 10: row=26, varin=80, theta=0.886364, up=1.000000
  % 	x0 = 1,	Z1 = 29549533.7569975        
DEBUG EVAL: Second branch cutoff check: z=29549533.756997, best_z=INF, threshold=INF
  %   New best:  x0, Z = 28792060.2718396        
DEBUG EVAL: Testing var 26 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=21, varin=34, theta=1.490407, up=999999999999999983222784.000000
ITER 2: row=38, varin=69, theta=0.591250, up=1.000000
ITER 3: row=7, varin=80, theta=2.789289, up=1.000000
ITER 4: row=7, varin=45, theta=0.916046, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 26 = 1 gives z=28980356.893283
  % 	x26 = 1,	Z1 = 29108203.9568901        
DEBUG EVAL: First branch cutoff check: z=29108203.956890, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 26 = 0
ITER 1: row=21, varin=38, theta=0.031036, up=999999999999999983222784.000000
  % 	x26 = 0,	Z0 = 28695209.3437845        
DEBUG EVAL: Second branch cutoff check: z=28695209.343785, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 17 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=13, varin=46, theta=0.111036, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 17 = 0 gives z=28698479.460427
  % 	x17 = 0,	Z0 = 28698479.4604271        
DEBUG EVAL: First branch cutoff check: z=28698479.460427, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 10 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=6, varin=46, theta=0.111036, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 10 = 0 gives z=28698479.460427
  % 	x10 = 0,	Z0 = 28698479.4604271        
DEBUG EVAL: First branch cutoff check: z=28698479.460427, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 33 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=38, varin=10, theta=0.506893, up=999999999999999983222784.000000
ITER 2: row=10, varin=13, theta=263816.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 33 = 1 gives z=29667594.150459
  % 	x33 = 1,	Z1 = 29667594.1504594        
DEBUG EVAL: First branch cutoff check: z=29667594.150459, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 33 = 0
ITER 1: row=38, varin=69, theta=0.279590, up=1.000000
  % 	x33 = 0,	Z0 = 28694703.7716445        
DEBUG EVAL: Second branch cutoff check: z=28694703.771644, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 11 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=7, varin=46, theta=1.403722, up=999999999999999983222784.000000
ITER 2: row=38, varin=10, theta=1.003099, up=999999999999999983222784.000000
ITER 3: row=10, varin=43, theta=1.124117, up=999999999999999983222784.000000
ITER 4: row=13, varin=41, theta=151.933763, up=999999999999999983222784.000000
ITER 5: row=41, varin=45, theta=1.305333, up=999999999999999983222784.000000
ITER 6: row=1, varin=29, theta=0.292438, up=999999999999999983222784.000000
ITER 7: row=42, varin=14, theta=0.377167, up=999999999999999983222784.000000
ITER 8: row=6, varin=69, theta=0.378529, up=1.000000
ITER 9: row=3, varin=3, theta=0.248268, up=999999999999999983222784.000000
ITER 10: row=5, varin=22, theta=0.145031, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 11 = 1 gives z=30293699.745988
  % 	x11 = 1,	Z1 = 30293699.745988         
DEBUG EVAL: First branch cutoff check: z=30293699.745988, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 11 = 0
ITER 1: row=7, varin=44, theta=0.039244, up=999999999999999983222784.000000
  % 	x11 = 0,	Z0 = 28699849.5766141        
DEBUG EVAL: Second branch cutoff check: z=28699849.576614, best_z=INF, threshold=INF
DEBUG EVAL: Testing var 2 = 0, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=3, varin=43, theta=0.035279, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 2 = 0 gives z=28695012.859834
  % 	x2 = 0,	Z0 = 28695012.8598339        
DEBUG EVAL: First branch cutoff check: z=28695012.859834, best_z=INF, threshold=INF
  % Best branch is x0, Z0 = 28792060.2718396        , Z1 = 29549533.7569975        

DEBUG CAREFUL: Final result - returning best.var = 0
DEBUG BB: Branching variable chosen: j=0
 % @NC   85   81	x0 = 0	28792060.271840
 % @NC   86   81	x0 = 1	29549533.756997
 %      81    37 28689985.3583               28692969.8841    x3 D    14     7
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e747c80
% @LO 0.07  28.68998535832482943420 99.9000000000
% @LN 0.07  28.69296988409958615307 99.9000000000
% Resuming node 21 at  28.69296988409958615307
DEBUG CONSTRNT: LP rows=46, pool->nlprows=46, pool->npend=0
DEBUG CONSTRNT: Checking 46 LP rows (pool tracks 46, total LP rows 46)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 23
DEBUG CONSTRNT: Pool row 23 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 28
DEBUG CONSTRNT: Pool row 28 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 87
DEBUG CONSTRNT: Pool row 87 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 161
DEBUG CONSTRNT: Pool row 161 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 123
DEBUG CONSTRNT: Pool row 123 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 111
DEBUG CONSTRNT: Pool row 111 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 117
DEBUG CONSTRNT: Pool row 117 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 56
DEBUG CONSTRNT: Pool row 56 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 45
DEBUG CONSTRNT: Pool row 45 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 62
DEBUG CONSTRNT: Pool row 62 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 79
DEBUG CONSTRNT: Pool row 79 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 9
DEBUG CONSTRNT: Pool row 9 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 10
DEBUG CONSTRNT: Pool row 10 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 114
DEBUG CONSTRNT: Pool row 114 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 121
DEBUG CONSTRNT: Pool row 121 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 29
DEBUG CONSTRNT: Pool row 29 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 128
DEBUG CONSTRNT: Pool row 128 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 142
DEBUG CONSTRNT: Pool row 142 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=45, expected 45
 % @PAP adding 51 rows, 201 nz to LP
DEBUG BB: Processing node 21, calling compute_good_lower_bound
  % 	Constraint pool unchanged, skip LP solve.
  % Node 21 LP 4 Solution, length = 28692969.884100, 0.00 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 0.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.500000 (FST 12)
  % DEBUG LP_VARS: x[13] = 1.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.500000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.500000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 1.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 0.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 0.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 0.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 0.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 1.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 0.500000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 0.500000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 3 fractional variables
DEBUG CG: LP optimal, z=28692969.884100, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG CG: integer_feasible_solution returned: FALSE
DEBUG CG: Second cutoff check: z=28692969.884100, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
 %   Final iteration: 0.00/0.00/0.00/0.00/0.00/0.00/0.00
DEBUG BB: compute_good_lower_bound returned status=4
DEBUG BB: Node 21 is FRACTIONAL - need to branch
DEBUG BB: Choosing branching variable for node 21
DEBUG CAREFUL: Checking var 0: edge_mask=ON, x[0]=0.000000
DEBUG CAREFUL: Skipping var 0: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 1: edge_mask=ON, x[1]=0.000000
DEBUG CAREFUL: Skipping var 1: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 2: edge_mask=ON, x[2]=0.000000
DEBUG CAREFUL: Skipping var 2: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 3: edge_mask=ON, x[3]=0.000000
DEBUG CAREFUL: Skipping var 3: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 4: edge_mask=ON, x[4]=0.000000
DEBUG CAREFUL: Skipping var 4: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 5: edge_mask=ON, x[5]=0.000000
DEBUG CAREFUL: Skipping var 5: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 6: edge_mask=ON, x[6]=0.000000
DEBUG CAREFUL: Skipping var 6: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 7: edge_mask=ON, x[7]=0.000000
DEBUG CAREFUL: Skipping var 7: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 8: edge_mask=ON, x[8]=0.000000
DEBUG CAREFUL: Skipping var 8: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 9: edge_mask=ON, x[9]=0.000000
DEBUG CAREFUL: Skipping var 9: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 10: edge_mask=ON, x[10]=0.000000
DEBUG CAREFUL: Skipping var 10: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 11: edge_mask=ON, x[11]=0.000000
DEBUG CAREFUL: Skipping var 11: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 12: edge_mask=ON, x[12]=0.500000
DEBUG CAREFUL: Adding var 12 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 13: edge_mask=ON, x[13]=1.000000
DEBUG CAREFUL: Skipping var 13: xi+FUZZ=1.000001 >= 1.0
DEBUG CAREFUL: Checking var 14: edge_mask=ON, x[14]=0.000000
DEBUG CAREFUL: Skipping var 14: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 15: edge_mask=ON, x[15]=0.000000
DEBUG CAREFUL: Skipping var 15: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 16: edge_mask=ON, x[16]=0.000000
DEBUG CAREFUL: Skipping var 16: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 17: edge_mask=ON, x[17]=0.000000
DEBUG CAREFUL: Skipping var 17: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 18: edge_mask=ON, x[18]=0.000000
DEBUG CAREFUL: Skipping var 18: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 19: edge_mask=ON, x[19]=0.000000
DEBUG CAREFUL: Skipping var 19: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 20: edge_mask=ON, x[20]=0.000000
DEBUG CAREFUL: Skipping var 20: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 21: edge_mask=ON, x[21]=0.500000
DEBUG CAREFUL: Adding var 21 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 22: edge_mask=ON, x[22]=0.000000
DEBUG CAREFUL: Skipping var 22: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 23: edge_mask=ON, x[23]=0.000000
DEBUG CAREFUL: Skipping var 23: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 24: edge_mask=ON, x[24]=0.000000
DEBUG CAREFUL: Skipping var 24: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 25: edge_mask=ON, x[25]=0.500000
DEBUG CAREFUL: Adding var 25 to fractional list (xi=0.500000)
DEBUG CAREFUL: Checking var 26: edge_mask=ON, x[26]=0.000000
DEBUG CAREFUL: Skipping var 26: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 27: edge_mask=ON, x[27]=0.000000
DEBUG CAREFUL: Skipping var 27: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 28: edge_mask=ON, x[28]=0.000000
DEBUG CAREFUL: Skipping var 28: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 29: edge_mask=ON, x[29]=0.000000
DEBUG CAREFUL: Skipping var 29: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 30: edge_mask=ON, x[30]=0.000000
DEBUG CAREFUL: Skipping var 30: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 31: edge_mask=ON, x[31]=0.000000
DEBUG CAREFUL: Skipping var 31: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 32: edge_mask=ON, x[32]=0.000000
DEBUG CAREFUL: Skipping var 32: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 33: edge_mask=ON, x[33]=0.000000
DEBUG CAREFUL: Skipping var 33: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 34: edge_mask=ON, x[34]=0.000000
DEBUG CAREFUL: Skipping var 34: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 35: edge_mask=ON, x[35]=0.000000
DEBUG CAREFUL: Skipping var 35: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 36: edge_mask=ON, x[36]=0.000000
DEBUG CAREFUL: Skipping var 36: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 37: edge_mask=ON, x[37]=0.000000
DEBUG CAREFUL: Skipping var 37: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 38: edge_mask=ON, x[38]=0.000000
DEBUG CAREFUL: Skipping var 38: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Checking var 39: edge_mask=ON, x[39]=0.000000
DEBUG CAREFUL: Skipping var 39: xi=0.000000 <= FUZZ=0.000001
DEBUG CAREFUL: Found 3 fractional variables

  %  Carefully choosing branching variable, nfrac = 3
DEBUG CAREFUL: Testing fvar[0] = var 12
DEBUG CAREFUL: Calling compare_branch_vars for var 12
DEBUG CAREFUL: compare_branch_vars returned TRUE for var 12
DEBUG CAREFUL: New best var: 12
DEBUG CAREFUL: Testing fvar[1] = var 25
DEBUG CAREFUL: Calling compare_branch_vars for var 25
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 25
DEBUG CAREFUL: Testing fvar[2] = var 21
DEBUG CAREFUL: Calling compare_branch_vars for var 21
DEBUG CAREFUL: compare_branch_vars returned FALSE for var 21
  % Initial guess is x12, Z0 = 28692969.8840996        , Z1 = 28705654.3806904        

DEBUG EVAL: Testing var 12 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=2, varin=51, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=51, varin=45, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=45, varin=48, theta=0.450000, up=999999999999999983222784.000000
ITER 4: row=8, varin=36, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 12 = 1 gives z=28738889.445639
  % 	x12 = 1,	Z1 = 28738889.445639         
DEBUG EVAL: First branch cutoff check: z=28738889.445639, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 12 = 0
ITER 1: row=2, varin=84, theta=1.000000, up=1.000000
ITER 2: row=46, varin=41, theta=1.500000, up=999999999999999983222784.000000
ITER 3: row=49, varin=30, theta=0.333333, up=999999999999999983222784.000000
  % 	x12 = 0,	Z0 = 28735399.1558585        
DEBUG EVAL: Second branch cutoff check: z=28735399.155858, best_z=INF, threshold=INF
  %   New best:  x12, Z = 28735399.1558585        
DEBUG EVAL: Testing var 25 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=34, varin=51, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=51, varin=45, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=45, varin=48, theta=0.450000, up=999999999999999983222784.000000
ITER 4: row=8, varin=42, theta=0.545455, up=999999999999999983222784.000000
ITER 5: row=33, varin=34, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 25 = 1 gives z=28767726.041955
  % 	x25 = 1,	Z1 = 28767726.0419547        
DEBUG EVAL: First branch cutoff check: z=28767726.041955, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 25 = 0
ITER 1: row=34, varin=84, theta=1.000000, up=1.000000
ITER 2: row=46, varin=41, theta=1.500000, up=999999999999999983222784.000000
ITER 3: row=49, varin=30, theta=0.333333, up=999999999999999983222784.000000
  % 	x25 = 0,	Z0 = 28735399.1558585        
DEBUG EVAL: Second branch cutoff check: z=28735399.155858, best_z=INF, threshold=INF
  %   New best:  x25, Z = 28735399.1558585        
DEBUG EVAL: Testing var 21 = 1, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
ITER 1: row=16, varin=51, theta=1.000000, up=999999999999999983222784.000000
ITER 2: row=51, varin=45, theta=1.000000, up=999999999999999983222784.000000
ITER 3: row=45, varin=48, theta=0.450000, up=999999999999999983222784.000000
ITER 4: row=8, varin=36, theta=1.000000, up=999999999999999983222784.000000
DEBUG EVAL: Branch var 21 = 1 gives z=28738889.445639
  % 	x21 = 1,	Z1 = 28738889.445639         
DEBUG EVAL: First branch cutoff check: z=28738889.445639, best_z=INF, threshold=INF
DEBUG EVAL: About to test second branch var 21 = 0
ITER 1: row=16, varin=84, theta=1.000000, up=1.000000
ITER 2: row=46, varin=41, theta=1.500000, up=999999999999999983222784.000000
ITER 3: row=49, varin=30, theta=0.333333, up=999999999999999983222784.000000
  % 	x21 = 0,	Z0 = 28735399.1558585        
DEBUG EVAL: Second branch cutoff check: z=28735399.155858, best_z=INF, threshold=INF
  % Best branch is x25, Z0 = 28735399.1558585        , Z1 = 28767726.0419547        

DEBUG CAREFUL: Final result - returning best.var = 25
DEBUG BB: Branching variable chosen: j=25
 % @NC   87   21	x25 = 0	28735399.155858
 % @NC   88   21	x25 = 1	28767726.041955
 %      21    38 28692969.8841               28701379.9928    x1 D     4     3
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=0x55b77e74b490
% @LO 0.07  28.69296988409958615307 99.9000000000
% @LN 0.07  28.70137999281639551441 99.9000000000
% Resuming node 77 at  28.70137999281639551441
DEBUG CONSTRNT: LP rows=51, pool->nlprows=51, pool->npend=0
DEBUG CONSTRNT: Checking 51 LP rows (pool tracks 51, total LP rows 51)
DEBUG CONSTRNT: Checking LP row 0 -> pool row 0
DEBUG CONSTRNT: Pool row 0 has lprow=0, expected 0
DEBUG CONSTRNT: Checking LP row 1 -> pool row 5
DEBUG CONSTRNT: Pool row 5 has lprow=1, expected 1
DEBUG CONSTRNT: Checking LP row 2 -> pool row 74
DEBUG CONSTRNT: Pool row 74 has lprow=2, expected 2
DEBUG CONSTRNT: Checking LP row 3 -> pool row 81
DEBUG CONSTRNT: Pool row 81 has lprow=3, expected 3
DEBUG CONSTRNT: Checking LP row 4 -> pool row 92
DEBUG CONSTRNT: Pool row 92 has lprow=4, expected 4
DEBUG CONSTRNT: Checking LP row 5 -> pool row 96
DEBUG CONSTRNT: Pool row 96 has lprow=5, expected 5
DEBUG CONSTRNT: Checking LP row 6 -> pool row 107
DEBUG CONSTRNT: Pool row 107 has lprow=6, expected 6
DEBUG CONSTRNT: Checking LP row 7 -> pool row 108
DEBUG CONSTRNT: Pool row 108 has lprow=7, expected 7
DEBUG CONSTRNT: Checking LP row 8 -> pool row 109
DEBUG CONSTRNT: Pool row 109 has lprow=8, expected 8
DEBUG CONSTRNT: Checking LP row 9 -> pool row 132
DEBUG CONSTRNT: Pool row 132 has lprow=9, expected 9
DEBUG CONSTRNT: Checking LP row 10 -> pool row 148
DEBUG CONSTRNT: Pool row 148 has lprow=10, expected 10
DEBUG CONSTRNT: Checking LP row 11 -> pool row 46
DEBUG CONSTRNT: Pool row 46 has lprow=11, expected 11
DEBUG CONSTRNT: Checking LP row 12 -> pool row 55
DEBUG CONSTRNT: Pool row 55 has lprow=12, expected 12
DEBUG CONSTRNT: Checking LP row 13 -> pool row 65
DEBUG CONSTRNT: Pool row 65 has lprow=13, expected 13
DEBUG CONSTRNT: Checking LP row 14 -> pool row 154
DEBUG CONSTRNT: Pool row 154 has lprow=14, expected 14
DEBUG CONSTRNT: Checking LP row 15 -> pool row 110
DEBUG CONSTRNT: Pool row 110 has lprow=15, expected 15
DEBUG CONSTRNT: Checking LP row 16 -> pool row 115
DEBUG CONSTRNT: Pool row 115 has lprow=16, expected 16
DEBUG CONSTRNT: Checking LP row 17 -> pool row 17
DEBUG CONSTRNT: Pool row 17 has lprow=17, expected 17
DEBUG CONSTRNT: Checking LP row 18 -> pool row 14
DEBUG CONSTRNT: Pool row 14 has lprow=18, expected 18
DEBUG CONSTRNT: Checking LP row 19 -> pool row 147
DEBUG CONSTRNT: Pool row 147 has lprow=19, expected 19
DEBUG CONSTRNT: Checking LP row 20 -> pool row 101
DEBUG CONSTRNT: Pool row 101 has lprow=20, expected 20
DEBUG CONSTRNT: Checking LP row 21 -> pool row 22
DEBUG CONSTRNT: Pool row 22 has lprow=21, expected 21
DEBUG CONSTRNT: Checking LP row 22 -> pool row 88
DEBUG CONSTRNT: Pool row 88 has lprow=22, expected 22
DEBUG CONSTRNT: Checking LP row 23 -> pool row 125
DEBUG CONSTRNT: Pool row 125 has lprow=23, expected 23
DEBUG CONSTRNT: Checking LP row 24 -> pool row 75
DEBUG CONSTRNT: Pool row 75 has lprow=24, expected 24
DEBUG CONSTRNT: Checking LP row 25 -> pool row 76
DEBUG CONSTRNT: Pool row 76 has lprow=25, expected 25
DEBUG CONSTRNT: Checking LP row 26 -> pool row 97
DEBUG CONSTRNT: Pool row 97 has lprow=26, expected 26
DEBUG CONSTRNT: Checking LP row 27 -> pool row 98
DEBUG CONSTRNT: Pool row 98 has lprow=27, expected 27
DEBUG CONSTRNT: Checking LP row 28 -> pool row 33
DEBUG CONSTRNT: Pool row 33 has lprow=28, expected 28
DEBUG CONSTRNT: Checking LP row 29 -> pool row 36
DEBUG CONSTRNT: Pool row 36 has lprow=29, expected 29
DEBUG CONSTRNT: Checking LP row 30 -> pool row 13
DEBUG CONSTRNT: Pool row 13 has lprow=30, expected 30
DEBUG CONSTRNT: Checking LP row 31 -> pool row 24
DEBUG CONSTRNT: Pool row 24 has lprow=31, expected 31
DEBUG CONSTRNT: Checking LP row 32 -> pool row 32
DEBUG CONSTRNT: Pool row 32 has lprow=32, expected 32
DEBUG CONSTRNT: Checking LP row 33 -> pool row 113
DEBUG CONSTRNT: Pool row 113 has lprow=33, expected 33
DEBUG CONSTRNT: Checking LP row 34 -> pool row 119
DEBUG CONSTRNT: Pool row 119 has lprow=34, expected 34
DEBUG CONSTRNT: Checking LP row 35 -> pool row 120
DEBUG CONSTRNT: Pool row 120 has lprow=35, expected 35
DEBUG CONSTRNT: Checking LP row 36 -> pool row 90
DEBUG CONSTRNT: Pool row 90 has lprow=36, expected 36
DEBUG CONSTRNT: Checking LP row 37 -> pool row 91
DEBUG CONSTRNT: Pool row 91 has lprow=37, expected 37
DEBUG CONSTRNT: Checking LP row 38 -> pool row 19
DEBUG CONSTRNT: Pool row 19 has lprow=38, expected 38
DEBUG CONSTRNT: Checking LP row 39 -> pool row 104
DEBUG CONSTRNT: Pool row 104 has lprow=39, expected 39
DEBUG CONSTRNT: Checking LP row 40 -> pool row 8
DEBUG CONSTRNT: Pool row 8 has lprow=40, expected 40
DEBUG CONSTRNT: Checking LP row 41 -> pool row 31
DEBUG CONSTRNT: Pool row 31 has lprow=41, expected 41
DEBUG CONSTRNT: Checking LP row 42 -> pool row 37
DEBUG CONSTRNT: Pool row 37 has lprow=42, expected 42
DEBUG CONSTRNT: Checking LP row 43 -> pool row 42
DEBUG CONSTRNT: Pool row 42 has lprow=43, expected 43
DEBUG CONSTRNT: Checking LP row 44 -> pool row 93
DEBUG CONSTRNT: Pool row 93 has lprow=44, expected 44
DEBUG CONSTRNT: Checking LP row 45 -> pool row 95
DEBUG CONSTRNT: Pool row 95 has lprow=45, expected 45
DEBUG CONSTRNT: Checking LP row 46 -> pool row 6
DEBUG CONSTRNT: Pool row 6 has lprow=46, expected 46
DEBUG CONSTRNT: Checking LP row 47 -> pool row 12
DEBUG CONSTRNT: Pool row 12 has lprow=47, expected 47
DEBUG CONSTRNT: Checking LP row 48 -> pool row 27
DEBUG CONSTRNT: Pool row 27 has lprow=48, expected 48
DEBUG CONSTRNT: Checking LP row 49 -> pool row 30
DEBUG CONSTRNT: Pool row 30 has lprow=49, expected 49
DEBUG CONSTRNT: Checking LP row 50 -> pool row 149
DEBUG CONSTRNT: Pool row 149 has lprow=50, expected 50
 % @PAP adding 34 rows, 192 nz to LP
DEBUG BB: Processing node 77, calling compute_good_lower_bound
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=6, varin=59, theta=2.000000, up=1.000000
ITER 2: row=6, varin=24, theta=0.500000, up=999999999999999983222784.000000
ITER 3: row=9, varin=59, theta=1.000000, up=1.000000
ITER 4: row=1, varin=15, theta=0.111111, up=999999999999999983222784.000000
ITER 5: row=24, varin=4, theta=1.142857, up=999999999999999983222784.000000
ITER 6: row=34, varin=31, theta=1.142857, up=999999999999999983222784.000000
ITER 7: row=31, varin=37, theta=1.000000, up=1.000000
ITER 8: row=29, varin=10, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=8)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=34)
DEBUG SOLUTION: LP solution array indices: FST[35-74], not_covered[75-94]
DEBUG SOLUTION: lp->best_solution[0] = 28701379.992816
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 34 rows, 60 cols, 252 nonzeros, 2 slack, 32 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 2 rows, 6 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=35, varin=5, theta=0.500000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=36)
DEBUG SOLUTION: LP solution array indices: FST[37-76], not_covered[77-96]
DEBUG SOLUTION: lp->best_solution[0] = 28728375.407203
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 0.500000
DEBUG SOLUTION: lp->best_solution[5] = 0.500000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 1.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 2.000000
DEBUG SOLUTION: lp->best_solution[11] = 0.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 36 rows, 60 cols, 258 nonzeros, 4 slack, 32 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 4 slack rows
  % @PAP adding 2 rows, 12 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=33, varin=69, theta=0.533333, up=1.000000
ITER 2: row=27, varin=71, theta=0.533333, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=34)
DEBUG SOLUTION: LP solution array indices: FST[35-74], not_covered[75-94]
DEBUG SOLUTION: lp->best_solution[0] = 28729828.217337
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 0.933333
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 34 rows, 60 cols, 257 nonzeros, 2 slack, 32 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % @PAP adding 3 rows, 10 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=33, varin=59, theta=0.500000, up=1.000000
ITER 2: row=6, varin=62, theta=0.500000, up=1.000000
LP PHASE: Switching to primal (iter=2)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=35)
DEBUG SOLUTION: LP solution array indices: FST[36-75], not_covered[76-95]
DEBUG SOLUTION: lp->best_solution[0] = 28739840.385278
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 1.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 35 rows, 60 cols, 263 nonzeros, 0 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @PAP adding 4 rows, 17 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=36, varin=2, theta=0.500000, up=999999999999999983222784.000000
ITER 2: row=34, varin=14, theta=0.112676, up=999999999999999983222784.000000
ITER 3: row=35, varin=33, theta=0.111111, up=999999999999999983222784.000000
ITER 4: row=23, varin=46, theta=0.047619, up=1.000000
ITER 5: row=21, varin=88, theta=0.090909, up=1.000000
ITER 6: row=27, varin=20, theta=0.007527, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=6)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=39)
DEBUG SOLUTION: LP solution array indices: FST[40-79], not_covered[80-99]
DEBUG SOLUTION: lp->best_solution[0] = 28748974.288954
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 0.549462
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 1.000000
DEBUG SOLUTION: lp->best_solution[8] = 2.000000
DEBUG SOLUTION: lp->best_solution[9] = 0.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.909677
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 0.909677
  % @PL 39 rows, 60 cols, 280 nonzeros, 7 slack, 32 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 7 slack rows
  % @PAP adding 5 rows, 19 nz to LP
LP PHASE: Starting dual phase (iter=0)
ITER 1: row=33, varin=12, theta=1.000000, up=999999999999999983222784.000000
LP PHASE: Switching to primal (iter=1)
DEBUG SOLUTION: Read 40 FST + 20 not_covered variables from LP solution (lp->rows=37)
DEBUG SOLUTION: LP solution array indices: FST[38-77], not_covered[78-97]
DEBUG SOLUTION: lp->best_solution[0] = 28756773.056953
DEBUG SOLUTION: lp->best_solution[1] = 19.000000
DEBUG SOLUTION: lp->best_solution[2] = 1.000000
DEBUG SOLUTION: lp->best_solution[3] = 1.000000
DEBUG SOLUTION: lp->best_solution[4] = 1.000000
DEBUG SOLUTION: lp->best_solution[5] = 1.000000
DEBUG SOLUTION: lp->best_solution[6] = 1.000000
DEBUG SOLUTION: lp->best_solution[7] = 2.000000
DEBUG SOLUTION: lp->best_solution[8] = 0.000000
DEBUG SOLUTION: lp->best_solution[9] = 1.000000
DEBUG SOLUTION: lp->best_solution[10] = 1.000000
DEBUG SOLUTION: lp->best_solution[11] = 1.000000
DEBUG SOLUTION: lp->best_solution[12] = 0.000000
DEBUG SOLUTION: lp->best_solution[13] = 1.000000
DEBUG SOLUTION: lp->best_solution[14] = 1.000000
  % @PL 37 rows, 60 cols, 279 nonzeros, 2 slack, 35 tight.
DEBUG COPY: Copied 40 FST + 20 not_covered variables to nodep->x
  % @D deleting 2 slack rows
  % Node 77 LP 1 Solution, length = 28756773.056953, 0.01 0
  % DEBUG LP_VARS: Optimal variable values:
  % DEBUG LP_VARS: x[0] = 0.000000 (FST 0)
  % DEBUG LP_VARS: x[1] = 0.000000 (FST 1)
  % DEBUG LP_VARS: x[2] = 1.000000 (FST 2)
  % DEBUG LP_VARS: x[3] = 0.000000 (FST 3)
  % DEBUG LP_VARS: x[4] = 0.000000 (FST 4)
  % DEBUG LP_VARS: x[5] = 0.000000 (FST 5)
  % DEBUG LP_VARS: x[6] = 0.000000 (FST 6)
  % DEBUG LP_VARS: x[7] = 0.000000 (FST 7)
  % DEBUG LP_VARS: x[8] = 0.000000 (FST 8)
  % DEBUG LP_VARS: x[9] = 0.000000 (FST 9)
  % DEBUG LP_VARS: x[10] = 0.000000 (FST 10)
  % DEBUG LP_VARS: x[11] = 0.000000 (FST 11)
  % DEBUG LP_VARS: x[12] = 0.000000 (FST 12)
  % DEBUG LP_VARS: x[13] = 0.000000 (FST 13)
  % DEBUG LP_VARS: x[14] = 0.000000 (FST 14)
  % DEBUG LP_VARS: x[15] = 0.000000 (FST 15)
  % DEBUG LP_VARS: x[16] = 0.000000 (FST 16)
  % DEBUG LP_VARS: x[17] = 0.000000 (FST 17)
  % DEBUG LP_VARS: x[18] = 0.000000 (FST 18)
  % DEBUG LP_VARS: x[19] = 0.000000 (FST 19)
  % DEBUG LP_VARS: x[20] = 0.000000 (FST 20)
  % DEBUG LP_VARS: x[21] = 0.000000 (FST 21)
  % DEBUG LP_VARS: x[22] = 0.000000 (FST 22)
  % DEBUG LP_VARS: x[23] = 0.000000 (FST 23)
  % DEBUG LP_VARS: x[24] = 0.000000 (FST 24)
  % DEBUG LP_VARS: x[25] = 0.000000 (FST 25)
  % DEBUG LP_VARS: x[26] = 0.000000 (FST 26)
  % DEBUG LP_VARS: x[27] = 0.000000 (FST 27)
  % DEBUG LP_VARS: x[28] = 0.000000 (FST 28)
  % DEBUG LP_VARS: x[29] = 0.000000 (FST 29)
  % DEBUG LP_VARS: x[30] = 0.000000 (FST 30)
  % DEBUG LP_VARS: x[31] = 0.000000 (FST 31)
  % DEBUG LP_VARS: x[32] = 0.000000 (FST 32)
  % DEBUG LP_VARS: x[33] = 0.000000 (FST 33)
  % DEBUG LP_VARS: x[34] = 0.000000 (FST 34)
  % DEBUG LP_VARS: x[35] = 0.000000 (FST 35)
  % DEBUG LP_VARS: x[36] = 0.000000 (FST 36)
  % DEBUG LP_VARS: x[37] = 0.000000 (FST 37)
  % DEBUG LP_VARS: x[38] = 0.000000 (FST 38)
  % DEBUG LP_VARS: x[39] = 0.000000 (FST 39)
  % DEBUG LP_VARS: not_covered[0] = 0.000000 (terminal 0)
  % DEBUG LP_VARS: not_covered[1] = 1.000000 (terminal 1)
  % DEBUG LP_VARS: not_covered[2] = 1.000000 (terminal 2)
  % DEBUG LP_VARS: not_covered[3] = 1.000000 (terminal 3)
  % DEBUG LP_VARS: not_covered[4] = 1.000000 (terminal 4)
  % DEBUG LP_VARS: not_covered[5] = 1.000000 (terminal 5)
  % DEBUG LP_VARS: not_covered[6] = 0.000000 (terminal 6)
  % DEBUG LP_VARS: not_covered[7] = 1.000000 (terminal 7)
  % DEBUG LP_VARS: not_covered[8] = 1.000000 (terminal 8)
  % DEBUG LP_VARS: not_covered[9] = 1.000000 (terminal 9)
  % DEBUG LP_VARS: not_covered[10] = 1.000000 (terminal 10)
  % DEBUG LP_VARS: not_covered[11] = 1.000000 (terminal 11)
  % DEBUG LP_VARS: not_covered[12] = 1.000000 (terminal 12)
  % DEBUG LP_VARS: not_covered[13] = 0.000000 (terminal 13)
  % DEBUG LP_VARS: not_covered[14] = 1.000000 (terminal 14)
  % DEBUG LP_VARS: not_covered[15] = 1.000000 (terminal 15)
  % DEBUG LP_VARS: not_covered[16] = 1.000000 (terminal 16)
  % DEBUG LP_VARS: not_covered[17] = 1.000000 (terminal 17)
  % DEBUG LP_VARS: not_covered[18] = 1.000000 (terminal 18)
  % DEBUG LP_VARS: not_covered[19] = 1.000000 (terminal 19)
 % 0 fractional variables
DEBUG CG: LP optimal, z=28756773.056953, best_z=179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000, z>=best_z? NO
DEBUG IFS: Budget mode - accepting integer solution with 1 edges covering 3 vertices
DEBUG CG: integer_feasible_solution returned: TRUE
DEBUG CG: Solution is integer feasible, returning LB_INTEGRAL
DEBUG BB: compute_good_lower_bound returned status=3
DEBUG BB: Node 77 is INTEGRAL (integer solution found)
 %  	=== 37 nodes cut off ===
 % @UO 0.08   3.25677305695297558685 -781.2827756463
 % @UN 0.08   3.25677305695297558685 -781.2827756463
DEBUG BB: Calling heuristic UB for integer solution, current best_z=3256773.056953
DEBUG BB: Heuristic did not improve integer solution
 % *    77     0  3256773.0570  3256773.0570                 x17 D    71    15
DEBUG BB: Starting new iteration, preempt=0
DEBUG BB: Selected node=(nil)
DEBUG BB: No more nodes to process, exiting

 % Certificate of solution:
 % @C	.4767008182741058	.2081993675729823
%%Page: 1 1
BeginPlot
	Plot_Terminals
 % fs2: 13 0 6
	13 T	.4767008182741058	.2081993675729823	S
	.4767008182741058	.2081993675729823	0 T	S
	.4767008182741058	.2081993675729823	6 T	S
  (Euclidean SMT:  20 points,  length = 3.256773056952975,  0.08 seconds)
EndPlot

% @0 Euclidean SMT
% N M Nodes LPs P1CPU P2CPU TotCPU
% @1 20 40 60 109 0.00 0.08 0.08
% Z RootZ %Gap RootLPs RootCPU RedMST
% @2 3.256773056952975 27735063.344511 -751.61179 2 0.00 -4.1576
% InitPRows InitPNZ InitLPRows InitLPNZ
% @3 163 594 135 555
% RootPRows RootPNZ RootLPRows RootLPNZ
% @4 163 594 40 255
% FinalPRows FinalPNZ FinalLPRows FinalLPNZ
% @5 163 594 35 267
% SMTFSTs SMTAvgFSTSz SMTMaxFSTSz #2FSTs #3FSTs ... #10FSTS #>10FSTs
% @6 1 3.000000 3 0 1 0 0 0 0 0 0 0 0
